<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iyheart的博客</title>
  
  <subtitle>分享笔记和学习历程</subtitle>
  <link href="http://iyheart.github.io/atom.xml" rel="self"/>
  
  <link href="http://iyheart.github.io/"/>
  <updated>2025-10-03T16:09:59.946Z</updated>
  <id>http://iyheart.github.io/</id>
  
  <author>
    <name>iyheart</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高等代数-向量与线性空间</title>
    <link href="http://iyheart.github.io/2025/10/03/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/"/>
    <id>http://iyheart.github.io/2025/10/03/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</id>
    <published>2025-10-03T08:29:51.000Z</published>
    <updated>2025-10-03T16:09:59.946Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对于前面的矩阵和行列式的研究，已经研究出了线性方程组如果有唯一解，那么就有$det(\mathbf{A})≠0$。但是这个研究结果并不令人满意。存在一下两点：<ul><li>当$det(\mathbf{A})=0$，那么线性方程组就有两种情况，无解或者有无穷多个解，但是无法分辨出来具体是哪种情况。</li><li>在多数情况下方程组的未知数个数与方程的个数是不一样的，这种情况无法使用行列式判断。</li></ul></li><li>上面这两个问题就使得还需要研究与完善这个规律，就需要从单个方程出发，这里就引入了用一个向量表示一个方程，所以除了高中学的向量的普遍意义之外，向量还用来表示方程的系数。比如下面的线性方程组中$x_1$的系数就可以用一个列向量表示：</li></ul><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n &= b_1 \\a_{21}x_1+a_{22}x_2+...+a_{2n}x_n &= b_2\\~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&~~~~~~\vdots\\a_{s1}x_1+a_{s2}x_2+...+a_{sn}x_n&=b_s\end{cases}\Rightarrow\vec{a}=\begin{pmatrix}a_{11} \\a_{21} \\...    \\a_{s1}\end{pmatrix}</script><h1 id="向量与线性空间"><a href="#向量与线性空间" class="headerlink" title="向量与线性空间"></a>向量与线性空间</h1><blockquote><p><strong>规定向量的运算</strong>：</p><p>取定数域$K$，设n是任意给定的正整数。令$K^{n}={(a_1,a_2,…,a_n)|a_i\in K,i,1,2,…,n}$。</p><ol><li><p>如果$a_1=b_1,a_2=b_2,…,a_n=b_n$，则称$K^{n}$中的两个元素：$(a_1,a_2,…,a_n)$与$(b_1,b_2,…,b_n)$相等</p></li><li><p>在$K^{n}$中加法的运算，$(a_1,a_2,…,a_n)+(b_1,b_2,…,b_n)\stackrel{\mathrm{def}}{=} (a_1+b_1,a_2+b_2,…,a_n+b_n)$</p></li><li>在$K^{n}$中数乘运算，$k(a_1,a_2,…,a_n)\stackrel{\mathrm{def}}{=}(ka_1,ka_2,…,ka_3)$</li></ol><p>由以上三种运算的定义或者由初等行变换可以推导出下面8条运算性质，其中加法有四条，数乘也有四条：</p><ol><li>$\mathbf{\alpha}+\mathbf{\beta}=\mathbf{\beta}+\mathbf{\alpha}$</li><li>$(\mathbf{\alpha}+\mathbf{\beta})+\mathbf{\gamma}=\mathbf{\alpha}+(\mathbf{\beta}+\mathbf{\gamma})$</li><li>把元素<code>(0,0,...,0)</code>记作$\mathbf{0}$称为零向量，它使得：$\mathbf{0}+\mathbf{\alpha}=\mathbf{\alpha}+\mathbf{0}=\mathbf{\alpha}$</li><li>对于$\mathbf{\alpha}=(a_1,a_2,…,a_n)\in K^{n}$令，$-\mathbf{\alpha}\stackrel{\mathrm{def}}=(-a_1,-a_2,…,a_n)\in K^{n}$，则有$\mathbf{\alpha}+(-\mathbf{\alpha})=(-\mathbf{\alpha)}+\mathbf{\alpha}=\mathbf{0}$，称$-\mathbf{\alpha}$是$\alpha$的负元</li><li>$1\mathbf{\alpha}=\mathbf{\alpha}$</li><li>$(kl)\mathbf{\alpha}=k(l\mathbf{\alpha})$</li><li>$(k+l)\mathbf{\alpha}=k\mathbf{\alpha}+l\mathbf{\alpha}$</li><li>$k(\mathbf{\alpha+\beta})=k\mathbf{\alpha}+k\mathbf{\beta}$</li></ol><p>满足这8条运算性质的还有如下：</p><ol><li>平面上以定点O为起点的所有向量组成的集合</li><li>直线上以定点O为起点的所有向量组成的集合</li><li>空间中以定点O为起点的所有向量组成的集合</li></ol><p>数学最基本的两个概念集合和映射。</p><p><strong>集合</strong>：</p><p><strong>映射</strong>：若一个对应法则$f:A\rightarrow B$，有A中的每个元素A，都对应着B中的唯一的一个元素b，则称$f$是A到B的一个映射。</p><p>b被称为a在$f$映射下的像；a被称为b在$f$映射下的<strong>一个原像</strong></p><p>A被称为定义域<code>domain</code>，B被称为陪域<code>codomain</code></p><p>$f$的值域(或者被称为像，像集)，$f(A):={f(a)|a\in A}$，也记作<code>Imf</code></p><p>若$f(A)=B$，则$f$称为一个<strong>满射</strong>,若A中不同元素在$f$上的像不同，则称$f$是单射。</p><p>如果$f$即是单射，又是满射，f称为一个双射（或一一对应）</p><p><strong>运算</strong>：</p><p>$2+3=5$，其实就是有序整数对$(2,3)\rightarrow 5$</p><p>$2*3=6$，其实就是有序整数对$(2,3)\rightarrow 6$</p><p>$S×M:={(a,b)|a\in S,b\in M}$，称为S与M的笛卡尔积。</p><p><strong>运算的定义</strong>：非空集合$S$上的一个<strong>代数运算</strong>，是指$S×S$到$S$的一个映射。</p><p><strong>定义1</strong>：向量、向量空间的定义。</p><p>数域K上所有<code>n</code>元有序数组组成的集合$K^{n}$，连同定义在它上面的加法运算和数量数乘运算，及其满足的8条运算法则一起，称为数域K上的一个<strong>n维向量空间</strong>。$K^{n}$的元素称为<strong>n维向量</strong>，设向量$\alpha=(a_1,a_2,…,a_n)$，称$a_i$是$\alpha$的第<code>i</code>个<strong>分量</strong>。通常用小写的希腊字母$\alpha、\beta、\gamma、…$表示向量。</p><p><strong>定义2</strong>：<strong>线性空间</strong>，将满足上面8条运算的事物抽象出来，建立了线性空间的模型。</p><p>设$V$是一个非空集合，$K$是一个数域，如果$V$上有一个运算，称为加法，即$(\alpha,\beta)\rightarrow\alpha+\beta$；</p><p>$K$与$V$之间的运算，称为<strong>数乘</strong>，即$K×V\rightarrow V:(k,\alpha)\rightarrow k\alpha$</p><p>满足下述8条运算集合，则称为<strong>V</strong>是数域<strong>K</strong>上的一个线性空间</p><ol><li>$\alpha+\beta=\beta+\alpha,\forall \alpha,\beta\in V$，加法交换律</li><li>$(\alpha+\beta)+\gamma=\alpha+(\beta+\gamma),\forall \alpha,\beta,\gamma\in V$，加法结合律</li><li>$V$中有一个元素，记作$\mathbf{0}$，则有下面性质，则把$\mathbf{0}$称为V的零元。$\alpha + 0=\alpha,\forall \alpha \in V$</li><li>对于$\alpha \in V$，有$\beta \in V$，使得$\alpha + \beta = 0$，把$\beta$称为$\alpha$的<strong>负元</strong></li><li>$1\alpha=\alpha,\forall \alpha \in V$</li><li>$(kl)\alpha = k(l\alpha),\forall k,l \in K,\alpha\in V$</li><li>$(k+l)\alpha=k<em>\alpha+l</em>\alpha,\forall k,l\in K,\alpha \in V$</li><li>$k(\alpha+\beta)=k\alpha+k\beta,\forall k\in K,\alpha,\beta \in V$</li></ol><p>所以向量$K^{n}:={(a_1,a_2,…,a_n)|a_i\in K,i=1,2,…,n}$被称为数域<strong>K</strong>上的线性空间，通常称为数域$K$上的n维向量空间。</p><p>实际上<strong>借用几何语言</strong>，线性空间的元素称为一个<strong>向量</strong>，线性空间也可以称为<strong>向量空间</strong></p></blockquote><h1 id="线性空间的性质"><a href="#线性空间的性质" class="headerlink" title="线性空间的性质"></a>线性空间的性质</h1><blockquote><p>点动成线、线动成面、面动成体，所以集合空间中的基本元素是点。但是点与点之间有什么运算呢？所以高中引入了向量，以及向量的坐标。任意选定一个固定点$O$，就可以使用以$O$为起点的向量一一对应，$O$点本身就是零向量。这样其实就给出了几何空间的定义。</p><p><strong>例子1</strong>：几何空间的定义</p><p>以定点$O$为起点的所有向量，构成了几何空间，满足8条运算所以是一个线性空间。</p><p><strong>例子2</strong>：</p><p>$K^{n}:={(a_1,a_2,…,a_n)|a\in K,i=1,2,…,n}$，n维向量也满足8条运算性质</p><p><strong>例子3</strong>：</p><p>非空集合$X$到$\R$的映射，称为函数，集合$X$不要求一定是数。称为$X$上的一个实值函数。记为$\R^{X}:={非空集合X到\R的映射}$</p><p><strong>线性空间的性质</strong>：</p><p>通过这样的例子，抽象出共同点，得到线性空间。现在假定$V$是数域K上的线性空间，则归纳出以下线性空间的性质：</p><ol><li>$V$的零元唯一。</li><li><p>每个$\alpha \in V$的负元唯一，将$\alpha$的负元记作$-\alpha$</p></li><li><p>$0\alpha=\mathbf{0}$</p></li><li><p>$k\mathbf{0}=\mathbf{0}$</p></li><li>若$k\alpha=0$，则$k=0$或$\alpha=\mathbf{0}$</li><li>$(-1)\alpha=-\alpha,\forall \alpha \in V$</li><li>$\alpha-\beta=\alpha+(-\beta)$</li></ol></blockquote><h1 id="线性子空间"><a href="#线性子空间" class="headerlink" title="线性子空间"></a>线性子空间</h1><blockquote><p><strong>定义1</strong>：线性子空间</p><p>设$V$是数域$K$上的线性空间，$U$是$V$的一个非空子集，如果$U$对$V$的加法和数量乘法，也成为数域$K$上的一个线性空间，则称$U$是$V$的一个(线性)子空间。</p><p><strong>定义2</strong>：</p><p>对于定理1中的eg2来说，$W$对于$V$的加法，数量乘法封闭，因此$W$是$V$的子空间，像这样的子空间，称它是<strong>由向量组$\alpha_1,….,\alpha_s$生成的子空间</strong>记作$&lt;\alpha_1,…,\alpha_s&gt;$或$L(\alpha_1,…,\alpha_s)$</p><p><strong>定义3</strong>：线性表出<br>$\beta\in&lt;\alpha_1,…,\alpha_s&gt;\Longleftrightarrow$存在$K$中的一组数$l_1,…,l_s$使得$\beta=l_1\alpha_1+…+l_s\alpha_s$，此时称$\beta$可以由向量$\alpha_1,…,\alpha_s$<strong>线性表出</strong></p><p><strong>定理1：线性子空间的充要条件</strong>：</p><p>$V$的非空子集$U$是子空间：</p><ol><li>若$\alpha,\beta \in U$，则$\alpha+\beta \in U$（U对于V的加法封闭）</li><li>若$\alpha \in U,k\in K$，则$k\alpha \in U$（U对于V的数乘封闭）</li></ol><p>eg1：${0}$是V的子空间</p><p>eg2：向量组$W={k_1\alpha_1+…+k_s\alpha_s|k_1,..,k_s\in K}$称为向量组$\alpha_1,…,\alpha_k$的一个线性组合,也是一个V的子空间。</p></blockquote><h1 id="向量与线性方程组"><a href="#向量与线性方程组" class="headerlink" title="向量与线性方程组"></a>向量与线性方程组</h1><p>通过介绍一些有关于向量的概念，现在就要回到用向量研究线性方程组的解的问题上。现在先来解决用向量如何表示线性方程组的常数和系数。</p><ul><li>如下图所示的个向量的线性方程组，我们可以使用一个列向量来表示方程组中每个方程中相同未知数的系数。</li></ul><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n &= b_1 \\a_{21}x_1+a_{22}x_2+...+a_{2n}x_n &= b_2\\~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&~~~~~~\vdots\\a_{s1}x_1+a_{s2}x_2+...+a_{sn}x_n&=b_s\end{cases}</script><ul><li><p>对于那么对于上面这个方程组，分别使用列向量$\alpha_1,…,\alpha_n$表示相同未知数前面的系数的集合，使用$\beta$表示常数，那么方程组就可以使用向量更简单的表示出来：</p><script type="math/tex; mode=display">\alpha_1=\begin{pmatrix}a_{11} \\a_{21} \\...    \\a_{s1}\end{pmatrix},....,\alpha_n=\begin{pmatrix}a_{1n} \\a_{2n} \\...    \\a_{sn}\end{pmatrix},\beta=\begin{pmatrix}b_{1} \\b_{2} \\...    \\b_{s}\end{pmatrix}\\\\x_1\alpha_1+.....+x_n\alpha_n=\beta</script><ul><li>那么方程组$x_1\alpha_1+…..+x_n\alpha_n=\beta$有解</li><li>$\Longleftrightarrow$有$K$中的一组数$c_1,…,c_n$，使得$c_1\alpha_1+…+c_n\alpha_n=\beta$</li><li>$\Longleftrightarrow\beta$可以由列向量组$\alpha_1,…,\alpha_n$<strong>线性表出</strong></li><li>$\Longleftrightarrow\beta\in&lt;\alpha_1,…,\alpha_n&gt;$</li><li>所以本章任务：<strong>研究线性空间和它的子空间的结构</strong></li></ul></li></ul><blockquote><p><strong>定义1</strong>：线性相关与线性无关</p><p>设$V$是数域$K$上的一个线性空间，$V$中的一个向量$\alpha_1,…,\alpha_s(s≥1)$：</p><p>如果有$K$中不全为0的数$k_1,….,k_s$使得$k_1\alpha_1+…+k_s\alpha_s=\vec{0}$，那么就称向量组$\alpha_1,…,\alpha_s$<strong>线性相关</strong>。</p><p>如果从$k_1\alpha_1+…+k_s\alpha_s=\vec{0}$可以推出$k_1=…=k_s=0$，那么向量组$\alpha_1,…,\alpha_s(s≥1)$称为<strong>线性无关</strong></p><p><strong>定理1</strong>：线性相关与无关和线性方程组的解</p><p>$K^s$中，列向量组$\alpha_1,…,\alpha_n$线性相关</p><p>$\Longleftrightarrow$有$K$个不全为0的数$c_1,…,c_n$使得$c_1\alpha_1+…+c_n\alpha_n=\vec{0}$</p><p>$\Longleftrightarrow$K上n元齐次线性方程组$x_1\alpha_1+…+x_n\alpha_n=\vec{0}$有非零解</p><p>从而$K^s$中，列向量组$\alpha_1,…,\alpha_n$线性无关</p><p>$\Longleftrightarrow$齐次线性方程组$x_1\alpha_1+…+x_n\alpha_n=\vec{0}$只有零解 </p><p>从而得出结论：$K^n$中，列向量组$\alpha_1,…,\alpha_n$线性相关(线性无关)$\Longleftrightarrow$以$\alpha_1,…,\alpha_n$为列向量组的矩阵$A$行列式等于0(不等于0)。行向量组一样。</p><p>注意：$K^n$是数域K上的n维向量，而$\alpha_1,…,\alpha_n$这个向量组的向量个数是<code>n</code>，所以会矩阵A是<code>n×n</code>的数表。</p></blockquote><h1 id="线性相关与线性无关的性质"><a href="#线性相关与线性无关的性质" class="headerlink" title="线性相关与线性无关的性质"></a>线性相关与线性无关的性质</h1><blockquote><p>设$V$是数域$K$上的一个线性空间</p><p><strong>性质1</strong>：</p><p>$\alpha$线性相关$\Longleftrightarrow$有$k≠0$，使得$k\alpha=\vec{0}$$\Longleftrightarrow \alpha=\vec{0}$</p><p>$\alpha$线性无关$\Longleftrightarrow \alpha≠0$</p><p><strong>性质2</strong>：</p><p>向量组$\alpha_1,…,\alpha_s$如果有一个部分组（一部分向量组成的向量组）线性相关，那么$\alpha_1,…,\alpha_s$线性相关。</p><p>从而向量组$\alpha_1,…,\alpha_s$如果线性无关，那么$\alpha_1,…,\alpha_s$的任何一个部分组都线性无关。</p><p><strong>性质3</strong>：</p><p>含有$\vec{0}$的任何一个向量组都线性相关</p><p><strong>性质4</strong>：</p><p>向量组$\alpha_1,…,\alpha_s$线性相关$\Longleftrightarrow$其中至少有一个向量可以由其余向量线性表出。</p><p>从而向量组$\alpha_1,…,\alpha_s$线性无关<script type="math/tex">\Longleftrightarrow</script>其中每一个向量都不能由其余向量线性表出</p><p><strong>命题1</strong>：线性无关的向量组特殊性质一</p><p>设$\beta$可以由向量组$\alpha_1,…,\alpha_s$线性表出，则表出方式唯一。$\Longleftrightarrow$$\alpha_1,…,\alpha_s$线性无关。</p><p><strong>命题2</strong>：线性无关的向量组特殊性质二</p><p>设$\alpha_1,…,\alpha_s$线性无关，如果$\alpha_1,…,\alpha_s,\beta$线性相关，那么$\beta$可以由$\alpha_1,….,\alpha_s$线性表出</p><p><strong>定义1</strong>：极大线性无关组</p><p>向量组$\alpha_1,…,\alpha_s$的一个部分组称为这个向量组的一个极大线性无关组，如果满足：</p><ol><li>这个部分组线性无关</li><li>从向量组的其余向量（如果有的话）中任取一个添进来，得到新的部分组都线性相关。</li></ol></blockquote>]]></content>
    
    
    <summary type="html">前言：无</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA加密Franklin-Reiter攻击</title>
    <link href="http://iyheart.github.io/2025/10/02/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86Franklin-Reiter%E6%94%BB%E5%87%BB/"/>
    <id>http://iyheart.github.io/2025/10/02/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86Franklin-Reiter%E6%94%BB%E5%87%BB/</id>
    <published>2025-10-02T01:53:15.000Z</published>
    <updated>2025-10-03T13:13:52.550Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>参考文章：<a href="https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_coppersmith_attack/#related-message-attack">Coppersmith 相关攻击 - CTF Wiki</a></p></li><li><p>参考文章：<a href="https://blog.csdn.net/XiongSiqi_blog/article/details/130978226">Franklin-Reiter相关消息攻击-CSDN博客</a></p></li><li><p>参考论文：<a href="https://link.springer.com/content/pdf/10.1007/3-540-68339-9_1.pdf">3-540-68339-9_1.pdf</a></p></li><li>参考论文：<a href="https://www.iacr.org/archive/pkc2005/33860001/33860001.pdf">33860001.pdf</a></li></ul><h1 id="前言与介绍"><a href="#前言与介绍" class="headerlink" title="前言与介绍"></a>前言与介绍</h1><p>对于<code>RSA</code>加密相关攻击中，有一个<code>Franklin-Reiter攻击</code>，该攻击也被称为<code>Related Message Attack</code>（即相关消息攻击）。该攻击针对的具体是在<code>RSA</code>加密中什么情况下的一个攻击呢？通过阅读论文，总结了如下几种类型的攻击，从特殊情况到一般情况。</p><p><strong>通过阅读论文</strong>，相关消息攻击一共分为以下几种情况，在这篇论文  <a href="https://link.springer.com/content/pdf/10.1007/3-540-68339-9_1.pdf">3-540-68339-9_1.pdf</a>  从特殊到一般情况研究，给出了一下三种情况，论文中使用：使用$k$，表示消息$m_i$的个数；使用$e$表示RSA加密的公钥$e$；使用$p$表示消息直接满足的多项式，以及使用$\delta$表示该多项式的次数。</p><ul><li><p>先从$k=2,e=3,\delta=1$这种情况来考虑：</p><ul><li>其实也就是两个消息$m_1,m_2$，满足一个一次多项式关系$m_1=p(m_2)=am_2+b$</li><li>并且已知下面式子中的$c_1,c_2,n,e$，以及多项式$p$的系数和常数项</li></ul><script type="math/tex; mode=display">c_1\equiv m_1^{e}~mod(~n)\\c_2\equiv m_2^{e}~mod(~n)</script><ul><li>已知上述情况可以推导出使用$f(x)=x^{e}-c_1~mod(~n)$与$f(p(x))=(ax+b)^{e}-c_2~mod(~n)$有最大公因式$x-m_1$，从而使用求最大公因式的方法可以求出$m_1$</li><li>之后进一步探究了<code>e</code>的一般情况，得出结论：使用更高效的<code>求最大公因式</code>方法，可以使得对于$e$在<code>32bit</code>大小的情况下这个攻击也是能实现的。</li></ul></li><li><p>再从$k=2,e\in Z<em>+,\delta\in Z</em>+$这种情况研究：</p><ul><li>也就是两个消息$m<em>1,m_2$，满足一个$\delta$次的多项式关系$m_2=p(m_1)=c</em>{\delta}m<em>1^{\delta}+c</em>{\delta-1}m_1^{\delta-1}+…+c_0$</li><li>并且已知下面式子中的$c_1,c_2,n,e$，以及多项式$p$的系数和常数项</li></ul><script type="math/tex; mode=display">c_1=m_1^{e}~mod(~n)\\c_2=m_2^{e}~mod(~n)</script><ul><li>已知上述情况可以推导出一般情况$g(x)=gcd(f(x),f(p(x)))$，则$(x-m_1)|g(x)$，特殊情况下$g(x)=x-m_1$，还存在无解的情况，也就是当$p(x)=x^{h}q(x^{e})$，此时$c_1=c_2^{h}(q(c_1))^{e}$</li></ul></li><li><p>之后继续讨论了$k=2,e\in Z<em>+,\delta\in Z</em>+$这种情况，此时多项式并不是类似于上一个显式的多项式，而是隐式多项式。</p><ul><li>也就是两个消息$m_1,m_2$，满足一个的$\delta$次的多项式关系$p(m_1,m_2)=0~mod(~n)$，例如：$p(m1,m2)=am_1^{2}+bm_2^{2}$这样的隐函数。</li><li>并且已知下面式子中的$c_1,c_2,n,e$，以及多项式$p$的系数和常数项</li></ul><script type="math/tex; mode=display">P_1=p(m_1,m_2)=0~mod(~n)\\P_2=m_1^{e}-c_1=0~mod(~n)\\P_3=m_2^{e}-c_2=0~mod(~n)</script><ul><li>这个时候论文为了讨论算法的复杂度，就使用了<code>结式</code>和<code>最大公因式</code>的方法求解（具体求解方法我也没懂）。</li><li>在讨论这种情况的最后论文作者还点名了<code>结式</code>和<code>最大公因式</code>的方法都可以归入<code>Gröbner基</code>这一通用框架中。</li></ul></li><li><p>论文最后讨论$k\in Z<em>+,e\in Z</em>+,\delta\in Z_+$这一情况：</p><ul><li>也就是已知$k$个消息$m_1,m_2,…,m_k$，满足一个$\delta$次的隐式多项式$p(m_1,m_2,…,m_k)$</li><li>并且已知下面式子中的$c_1,c_2,…,c_i,n,e$，以及多项式$p$的系数和常数项</li></ul><script type="math/tex; mode=display">\begin{array}{l}P_0(x_1,....,x_k)=p(x_1,...,x_k)=0~mod(~n)\\P_1(x_1)=x_1^e-c_1=0~mod(~n)\\P_2(x_2)=x_2^{e}-c_2=0~mod(~n)\\....\\P_i(x_i)=x_i^{e}-c_i=0~mod(~n)\\....\\P_k(x_k)=x_k^{e}-c_k=0~mod(~n)\end{array}</script><ul><li>这个时候直接使用<code>Gröbner基</code>一把梭，或者使用<code>结式</code>与<code>gcd</code>结合求解即可。</li></ul></li></ul><p><strong>通过阅读另一篇论文</strong>，也就是这篇论文   <a href="https://www.iacr.org/archive/pkc2005/33860001/33860001.pdf">33860001.pdf</a>   会发现一个另一种情形下的相关消息攻击。</p><p><strong>疑问</strong>：这里其实我还是有个疑问，为什么<code>Franklin-Reiter攻击</code>在<code>CTF Wiki</code>中会被放在<code>Coppersmith相关攻击</code>这篇文章内容里面呢？（先不管这个问题，接下去看看）</p><h1 id="两个消息线性关系"><a href="#两个消息线性关系" class="headerlink" title="两个消息线性关系"></a>两个消息线性关系</h1><ul><li><p>该部分研究的就是第一个论文的第一种情况，即$k=2,\delta=1$而$e\in Z+$这一情况。</p></li><li><p>接下来根据已知的数学条件，就需要来进行推导与分析了。下面先列出一些列的已知条件：</p></li><li><p>首先就是<code>RSA</code>加密，可以得到如下这个条件：</p></li></ul><script type="math/tex; mode=display">c_1\equiv m_1^{e}~mod~(n)\\c_2\equiv m_2^{e}~mod~(n)</script><ul><li>其次两个被加密的消息满足线性关系，则有如下条件，其中<code>a</code>、<code>b</code>是已知的：</li></ul><script type="math/tex; mode=display">\begin{array}{l}m_1 = am_2+b\\m_1 \equiv am_2+b~mod~(n)\end{array}</script><h2 id="e为3的情况"><a href="#e为3的情况" class="headerlink" title="e为3的情况"></a>e为3的情况</h2><ul><li>对于一般的情况现在我们还不清楚，先采用<strong>解剖麻雀</strong>的方法，取一个<code>e=3</code>的情况对这个条件进行研究看看。先将题目已知列出来，从该攻击针对的情况，可以得到这三个基础的式子，其中<code>c1、c2、a、b</code>是已知的，三个方程两个未知数，一般都是可以解出方程的：</li></ul><script type="math/tex; mode=display">\begin{array}{l}c_1 \equiv m_1^{3}~mod~(n)\\c_2 \equiv m_2^{3}~mod~(n)\\m_1 = a*m_2+b\end{array}</script><ul><li><p>那么接下来就来推导一下这个式子，推导式子的过程中有比较灵活的<code>代换</code>以及<code>因式分解</code>，但是要记住一点代换的目的就是为了降幂，与解方程一样：</p><ul><li>首先由$c_1\equiv m_1^{3}~mod~(n)$，可以得到：</li></ul><script type="math/tex; mode=display">\begin{align*}c_1&\equiv (a*m_2+b)^{3}\\&\equiv (am_2)^{3}+3(am_2)^{2}b+3(am_2)b^{2}+b^{3}\\&\equiv (am_2)^{3}-2b^{3}+3b[(am_2)^{2}+(am_2)b+b^{2}]~mod~(n)~~~~~~~~~(1)\end{align*}</script></li></ul><ul><li><p>其次由$c_2\equiv m_2^{3}~mod~(n)$，两边先同时乘上$a^{3}$，再同时减去$b^{3}$可以得到：</p><script type="math/tex; mode=display">a^{3}c_2-b^{3}\equiv (am_2)^{3}-b^{3}\equiv (am_2-b)*[(am_2)^2+am_2b+b^2]~~~~~~~~~(2)</script></li><li><p>使用<code>(1)式-(2)式</code>可以得到一个<code>(3)</code>式：</p><script type="math/tex; mode=display">\begin{align*}c_1-a^{3}c_2+b^{3}&\equiv (am_2)^{3}-2b^{3}+3b[(am_2)^{2}+(am_2)b+b^{2}]-(am_2-b)*[(am_2)^2+am_2b+b^2]\\&\equiv (am_2)^{3}-b^{3} -(am_2-b)*[(am_2)^2+am_2b+b^2]+ 3b[(am_2)^{2}+(am_2)b+b^{2}] - b^{3}\\&\equiv  3b[(am_2)^{2}+(am_2)b+b^{2}] - b^{3}~mod~(n)\end{align*}</script><script type="math/tex; mode=display">\Rightarrow c_1-a^{3}c_2+2b^{3}\equiv3b[(am_2)^{2}+(am_2)b+b^{2}]~mod~(n)~~~~~~~(3)</script></li><li><p>这个时候就要回到<code>(2)</code>式，代换立方差的那一部分公式$[(am_2)^{2}+(am_2)b+b^{2}]$，这样就可以得到：</p><script type="math/tex; mode=display">c_1-a^{3}c_2+2b^{3}\equiv3b\frac{a^{3}c_2-b^{3}}{am_2-b}~mod~(n)</script></li><li><p>最后将$(am_2-b)$移动到左边：</p><script type="math/tex; mode=display">(am_2-b)\equiv3b\frac{a^{3}c_2-b^{3}}{c_1-a^{3}c_2+2b^{3}}~mod~(n)</script></li><li><p>最终就得到：</p><script type="math/tex; mode=display">m_2\equiv3b\frac{a^{3}c_2-b^{3}}{a*(c_1-a^{3}c_2+2b^{3})}+\frac{b}{a}=\frac{b}{a}(\frac{c_1+2a^{3}c_2-b^{3}}{c_1-a^{3}c_2+2b^{2}})~mod~(n)</script></li></ul><h2 id="e为任意的情况"><a href="#e为任意的情况" class="headerlink" title="e为任意的情况"></a>e为任意的情况</h2><ul><li>按照上面的推导方法，最终可以得到一般情况：</li></ul><script type="math/tex; mode=display">m_2 = e*\frac{b}{a}(\frac{a^{e}c_2-b^{e}}{c_1-a^{e}c_2+(e-1)b^{e}}+1)~mod(~n)</script><ul><li><p>现在其实我们可以明确的一点是，如果两个相同的公钥<code>e</code>加密两个明文<code>m1,m2</code>，得到<code>c1,c2</code>，这两个明文其中可以先解出<code>m2</code>，然后根据线性关系，其实还可以解出<code>m1</code>。那这就相当于明文可以被破解了，这种其实属于<strong>代数可解</strong>。</p></li><li><p>既然该式子是<strong>代数可解</strong>，那么为什么不使用公式法直接求<code>m2</code>呢？是因为这样套公式计算确实比较复杂，当<code>e</code>很大的时候可能精度会损失，以及计算效率低。</p></li></ul><h2 id="另辟蹊径之求最大公因式"><a href="#另辟蹊径之求最大公因式" class="headerlink" title="另辟蹊径之求最大公因式"></a>另辟蹊径之求最大公因式</h2><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>此时其实就需要另辟蹊径了。通过研究这个式子就会发现:</p><ul><li><p>多项式$f(x)=x^{e}-c_1~mod(~n)=0$的一个解为$x=m_2$，所以该多项式可以因式分解成$f(x)=(x-m_2)g_1(x)$</p></li><li><p>而另一个多项式$f(p(x))=(ax+b)^{e}~mod(~n)=0$的一个解也为$x=m_2$，所以该多项式可以因式分解成$f(p(x))=(x-m_2)g_2(x)$</p></li><li><p>所以$gcd(f(x),f(p(x)))=(x-m_2)$，此时就将使用公式求解转换成求两个多项式的最大公因式，这样可以避免除法并且可以提高计算效率。</p></li></ul><p>对于编写求解最大公因式的算法，其实用Sagemath是最方便的，所以这里就直接使用Sagemath求解最大公因式。这里给出几个<code>SageMath</code>求解最大公因式的几个代码。以及加快求解最大公因式的方法<code>Half-gcd</code>的代码以及算法推导公式。</p><h3 id="代码1普通多项式gcd"><a href="#代码1——普通多项式gcd" class="headerlink" title="代码1——普通多项式gcd"></a>代码1——普通多项式gcd</h3><ul><li>代码一，使用<code>Sagemath</code>编写多项式<code>gcd</code>算法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n=</span><br><span class="line">a=</span><br><span class="line">c1=</span><br><span class="line">c2=</span><br><span class="line">e = </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Franklin</span>(<span class="params">n,e,a,b,c1,c2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    n: 模数</span></span><br><span class="line"><span class="string">    e: 指数</span></span><br><span class="line"><span class="string">    a: 线性关系中am+b中的a</span></span><br><span class="line"><span class="string">    b: 线性关系中am+b中的b</span></span><br><span class="line"><span class="string">    c1: f = x^e - c1 中的c1,也就是没有被线性变换过的加密密文</span></span><br><span class="line"><span class="string">    c2: 线性变换过的加密密文</span></span><br><span class="line"><span class="string">    return value: int-&gt;m</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="comment"># 首先要设置一个环中的变量,用这个变量来表示多项式</span></span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n)) <span class="comment"># 创建一个模n下的多项式环,环的名称为PR,该环的变量为x</span></span><br><span class="line">    f = x^e - c1 </span><br><span class="line">    g = (a*x+b)^e - c2</span><br><span class="line">    <span class="keyword">while</span> f:</span><br><span class="line">        g,f = f,g % f</span><br><span class="line">    g = g.monic() <span class="comment"># 将g转换为首一多项式,也就是该多项式次数最高次这一项系数为1的多项式</span></span><br><span class="line">    m = g.constant_coefficient()</span><br><span class="line">    <span class="keyword">if</span> m &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(n-m)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(m)</span><br><span class="line">m = Franklin(n,e,a,b,c1,c2)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="代码2多项式half-gcd"><a href="#代码2——多项式Half-gcd" class="headerlink" title="代码2——多项式Half-gcd"></a>代码2——多项式Half-gcd</h3><ul><li>代码二，使用<code>Sagemath</code>和<code>python</code>编写<code>Half-gcd</code>算法，这边也顺便贴一下参考资料与参考论文。</li><li>参考论文：<a href="https://www.researchgate.net/publication/221564865_Half-GCD_and_fast_rational_recovery">(PDF) Half-GCD and fast rational recovery</a></li><li>参考博客：<a href="https://www.cnblogs.com/whx1003/p/16217087.html">多项式 gcd 的正确姿势：Half-GCD 算法 - whx1003 - 博客园</a></li></ul><blockquote><p>进入正题：</p></blockquote><h3 id="代码3sagemath一把梭"><a href="#代码3——Sagemath一把梭" class="headerlink" title="代码3——Sagemath一把梭"></a>代码3——Sagemath一把梭</h3><ul><li>代码三，使用<code>sagemath</code>其实没有快速计算<code>gcd</code>的方法，但是<code>sagemath</code>中有内置的<code>PARI/GP</code>库（也是一个常用于数学的编程语言），所以可以将Sagemath中的<code>PolynomialRing()</code>这个多项式先转换为<code>PARI/GP</code>内置多项式类型。</li><li>之后再使用<code>PARI/GP</code>内置的<code>gcd</code>快速求解两个多项式的最大公因式，而<code>PARI/GP</code>内置的快速求解两个多项式的最大公因式的方法其实就是使用的<code>Half-gcd</code>。代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n)) <span class="comment"># 创建一个模n下的多项式环,环的名称为PR,该环的变量为x</span></span><br><span class="line">f =</span><br><span class="line">g = </span><br><span class="line"><span class="comment"># 下面是关键一步,记为(*)</span></span><br><span class="line">G = PR(f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>))) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤(*),其实拆开来就是如下代码</span></span><br><span class="line">f_pari = f._pari_with_name(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">g_pari = g._pari_with_name(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">G = f_pari.gcd(g_pari)</span><br></pre></td></tr></table></figure><ul><li>完整代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n = </span><br><span class="line">a = </span><br><span class="line">b = </span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line">e = </span><br><span class="line"><span class="comment"># 首先要设置一个环中的变量,用这个变量来表示多项式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Franklin</span>(<span class="params">n,e,a,b,c1,c2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    n: 模数</span></span><br><span class="line"><span class="string">    e: 指数</span></span><br><span class="line"><span class="string">    a: 线性关系中am+b中的a</span></span><br><span class="line"><span class="string">    b: 线性关系中am+b中的b</span></span><br><span class="line"><span class="string">    c1: f = x^e - c1 中的c1,也就是没有被线性变换过的加密密文</span></span><br><span class="line"><span class="string">    c2: 线性变换过的加密密文</span></span><br><span class="line"><span class="string">    return value: int-&gt;m</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n)) <span class="comment"># 创建一个模n下的多项式环,环的名称为PR,该环的变量为x</span></span><br><span class="line">    f = x^e - c1 </span><br><span class="line">    g = (a*x+b)^e - c2</span><br><span class="line">    G = PR(f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>))) <span class="comment"># PR()将求得的公因式转换到PR环上</span></span><br><span class="line">    <span class="built_in">print</span>(G)</span><br><span class="line">    G = G.monic()</span><br><span class="line">    <span class="built_in">print</span>(G)</span><br><span class="line">    m = G.constant_coefficient()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(m)</span><br><span class="line">        </span><br><span class="line">m = Franklin(n,e,a,b,c1,c2)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="built_in">print</span>(n-m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(n-m)))</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><ul><li><p>题目来源：<a href="https://blog.csdn.net/XiongSiqi_blog/article/details/130978226">Franklin-Reiter相关消息攻击-CSDN博客</a></p></li><li><p>题目附件如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(flag)</span><br><span class="line">N = getPrime(<span class="number">512</span>)*getPrime(<span class="number">512</span>)</span><br><span class="line">e = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">c1 = <span class="built_in">pow</span>(m1, e, N)</span><br><span class="line"></span><br><span class="line">a = getRandomNBitInteger(<span class="number">512</span>)</span><br><span class="line">b = getRandomNBitInteger(<span class="number">512</span>)</span><br><span class="line">m2 = a * m1 + b</span><br><span class="line">c2 = <span class="built_in">pow</span>(m2, e, N)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(N, a, b, c1, c2, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n=51296885372346449295388453471330409021784141081351581975478435681552082076338697136130122011636685327781785488670769096434920591920054441921039812310126089859349902066456998315283909435249794317277620588552441456327265553018986591779396701680997794937951231970194353001576159809798153970829987274504038146741</span></span><br><span class="line"><span class="string"> a=13256631249970000274738888132534852767685499642889351632072622194777502848070957827974250425805779856662241409663031192870528911932663995606616763982320967</span></span><br><span class="line"><span class="string"> b=12614470377409090738391280373352373943201882741276992121990944593827605866548572392808272414120477304486154096358852845785437999246453926812759725932442170</span></span><br><span class="line"><span class="string"> c1=18617698095122597355752178584860764221736156139844401400942959000560180868595058572264330257490645079792321778926462300410653970722619332098601515399526245808718518153518824404167374361098424325296872587362792839831578589407441739040578339310283844080111189381106274103089079702496168766831316853664552253142</span></span><br><span class="line"><span class="string"> c2=14091361528414093900688440242152327115109256507133728799758289918462970724109343410464537203689727409590796472177295835710571700501895484300979622506298961999001641059179449655629481072402234965831697915939034769804437452528921599125823412464950939837343822566667533463393026895985173157447434429906021792720</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>此题是一个比较典型的<strong>相关消息攻击</strong>，通过题目附件的代码有如下已知条件：</p><script type="math/tex; mode=display">\begin{array}{l}m_2=am_1+b\\c_1=m_1^{17}~mod(~n)\\c_2=m_2^{17}~mod(~n)\end{array}</script><p>由$m_1、m_2$的线性关系可以带入$c_2=m_2^{17}~mod(~n)$就可以得到如下式子：</p><script type="math/tex; mode=display">c_2=(am_1+b)^{17}~mod(~n)</script><p>由前面的另辟蹊径就能知道，多项式$f(x)=x^{17}-c_1~mod(~n)$与多项式$g(x)=(ax+b)^{17}-c_2~mod(~n)$有公因式$(x-m_1)$。</p><p>从而将问题转变为求解这两个多项式的最大公因式，即可得到原来的明文$m_1$，思路已经有了，现在直接编写exp即可。</p></blockquote><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n=<span class="number">51296885372346449295388453471330409021784141081351581975478435681552082076338697136130122011636685327781785488670769096434920591920054441921039812310126089859349902066456998315283909435249794317277620588552441456327265553018986591779396701680997794937951231970194353001576159809798153970829987274504038146741</span></span><br><span class="line">a=<span class="number">13256631249970000274738888132534852767685499642889351632072622194777502848070957827974250425805779856662241409663031192870528911932663995606616763982320967</span></span><br><span class="line">b=<span class="number">12614470377409090738391280373352373943201882741276992121990944593827605866548572392808272414120477304486154096358852845785437999246453926812759725932442170</span></span><br><span class="line">c1=<span class="number">18617698095122597355752178584860764221736156139844401400942959000560180868595058572264330257490645079792321778926462300410653970722619332098601515399526245808718518153518824404167374361098424325296872587362792839831578589407441739040578339310283844080111189381106274103089079702496168766831316853664552253142</span></span><br><span class="line">c2=<span class="number">14091361528414093900688440242152327115109256507133728799758289918462970724109343410464537203689727409590796472177295835710571700501895484300979622506298961999001641059179449655629481072402234965831697915939034769804437452528921599125823412464950939837343822566667533463393026895985173157447434429906021792720</span></span><br><span class="line">e = <span class="number">17</span></span><br><span class="line"><span class="comment"># 首先要设置一个环中的变量,用这个变量来表示多项式</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n)) <span class="comment"># 创建一个模n下的多项式环,环的名称为PR,该环的变量为x</span></span><br><span class="line">f = x^e - c1 </span><br><span class="line">g = (a*x+b)^e - c2</span><br><span class="line"><span class="keyword">while</span> f:</span><br><span class="line">    g,f = f,g % f   <span class="comment"># 使用辗转相除法求得多项式最大公因式</span></span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line">g = g.monic() <span class="comment"># 将g转换为首一多项式,也就是该多项式次数最高次这一项系数为1的多项式</span></span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"><span class="comment"># 提取该多项式的常数项,但是发现常数项不是负数,所以该数其实并不是真正的m,而n-m才是真正的m</span></span><br><span class="line">m = g.constant_coefficient() </span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(n-m)))</span><br><span class="line"><span class="comment"># b&#x27;flag&#123;a593591a-3749-cc52-0c27-e897fac2c967&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><ul><li><p>接下来稍微修改一下例题1，将<code>e=17</code>，替换成<code>e=65537</code></p></li><li><p>题目附件如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()).encode() + <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">m1 = bytes_to_long(flag)</span><br><span class="line">N = getPrime(<span class="number">512</span>)*getPrime(<span class="number">512</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">c1 = <span class="built_in">pow</span>(m1, e, N)</span><br><span class="line"></span><br><span class="line">a = getRandomNBitInteger(<span class="number">512</span>)</span><br><span class="line">b = getRandomNBitInteger(<span class="number">512</span>)</span><br><span class="line">m2 = a * m1 + b</span><br><span class="line">c2 = <span class="built_in">pow</span>(m2, e, N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b =&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 =&quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 =&quot;</span>,c2)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n = 59861917324226967486215648256894012851495145204497486380891167740615801374063455379673715500954583547144532511038617630076588124328491649811856993314542460125128961468483743038573111414419166480096592264420724034747983484148465064161457578180902917692815465155951262833991421445819783698766048087026362827177</span></span><br><span class="line"><span class="string">a = 8912027245219554871633263198357534861260151492942640613543674312789184411070375687173938678863885846785442731416745232377239461392819384805757821014008997</span></span><br><span class="line"><span class="string">b = 9082019118159490199184118787363903212978739183503144824083405972098784434747374470051472810662991934944899511831981983317873229914591770162089271570548898</span></span><br><span class="line"><span class="string">c1 = 13829716726154552626808370709385622815070337340315816233387666503855034657492722518838631908542319087651252784674601561198457938726403898164944489259977862308799162509306623034533701622307267177872660177001435552253633489217686479650060107252554076305263872524702049994229524235844714514276932861812294412208</span></span><br><span class="line"><span class="string">c2 = 12344340068962283228603202053643543482434797000939385457621435796626275462396259806353278281512262932359248462422732215649437185890052207218476381335849291479672021635844167181113351805907880675672544417067152443404516325590447421944842581421615420605120177863329347579906535387550917852112995890140027254347</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>思路大致是和例题1一样的，但是这题如果使用例题1的exp需要跑很久的。原因：<strong>e太大了，导致多项式次数和系数的比较大，使得计算所花费的时间和算力都非常多</strong></p><p>此时就需要对辗转相除法进行算法上的优化，所以引入了一个新的辗转相除法，也就是<code>Half-gcd</code>算法。下面主要讲解的就是这个算法的具体过程以及算法实现的具体代码。</p><p>这里就贴一个<code>Half-gcd</code>的论文，<code>Half-gcd</code>的详细过程放在代码2那边讲解，那边也贴个论文：<a href="https://www.researchgate.net/publication/221564865_Half-GCD_and_fast_rational_recovery">(PDF) Half-GCD and fast rational recovery</a></p></blockquote><ul><li>这里给出一个<code>Sagemath</code>自带的快速计算两个多项式最大公因式的方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>完整的exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n = <span class="number">59861917324226967486215648256894012851495145204497486380891167740615801374063455379673715500954583547144532511038617630076588124328491649811856993314542460125128961468483743038573111414419166480096592264420724034747983484148465064161457578180902917692815465155951262833991421445819783698766048087026362827177</span></span><br><span class="line">a = <span class="number">8912027245219554871633263198357534861260151492942640613543674312789184411070375687173938678863885846785442731416745232377239461392819384805757821014008997</span></span><br><span class="line">b = <span class="number">9082019118159490199184118787363903212978739183503144824083405972098784434747374470051472810662991934944899511831981983317873229914591770162089271570548898</span></span><br><span class="line">c1 = <span class="number">13829716726154552626808370709385622815070337340315816233387666503855034657492722518838631908542319087651252784674601561198457938726403898164944489259977862308799162509306623034533701622307267177872660177001435552253633489217686479650060107252554076305263872524702049994229524235844714514276932861812294412208</span></span><br><span class="line">c2 = <span class="number">12344340068962283228603202053643543482434797000939385457621435796626275462396259806353278281512262932359248462422732215649437185890052207218476381335849291479672021635844167181113351805907880675672544417067152443404516325590447421944842581421615420605120177863329347579906535387550917852112995890140027254347</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"><span class="comment"># 首先要设置一个环中的变量,用这个变量来表示多项式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Franklin</span>(<span class="params">n,e,a,b,c1,c2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    n: 模数</span></span><br><span class="line"><span class="string">    e: 指数</span></span><br><span class="line"><span class="string">    a: 线性关系中am+b中的a</span></span><br><span class="line"><span class="string">    b: 线性关系中am+b中的b</span></span><br><span class="line"><span class="string">    c1: f = x^e - c1 中的c1,也就是没有被线性变换过的加密密文</span></span><br><span class="line"><span class="string">    c2: 线性变换过的加密密文</span></span><br><span class="line"><span class="string">    return value: int-&gt;m</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n)) <span class="comment"># 创建一个模n下的多项式环,环的名称为PR,该环的变量为x</span></span><br><span class="line">    f = x^e - c1 </span><br><span class="line">    g = (a*x+b)^e - c2</span><br><span class="line">    G = PR(f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>))) <span class="comment"># PR()将求得的公因式转换到PR环上</span></span><br><span class="line">    <span class="built_in">print</span>(G)</span><br><span class="line">    G = G.monic()</span><br><span class="line">    <span class="built_in">print</span>(G)</span><br><span class="line">    m = G.constant_coefficient()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(m)</span><br><span class="line">        </span><br><span class="line">m = Franklin(n,e,a,b,c1,c2)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="built_in">print</span>(n-m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(n-m)))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">59861917324226967486215648256894012851495145204497486380891167740615801374063455379673715500954583547144532511038617630076588124328491649811856993314542460125128961468483743038573111414419166480096592264420668028355190078995842814841648310810119551192062039646311316624372659583573767360517334407327685140012</span></span><br><span class="line"><span class="string">b&#x27;U?\x06\xf5\x0e\xa7\x87zS\xa4\x188l\x80\x11\xb3+\x857v\x00\x1a\xb8\xe6J\x03\x89\x99)Q\x1aA\xf5i\x80@\xe5\xde\xa7I\xcf\x06-K\x08\xca\xb7\xa5\xf4\xd6\xb1mGP\x06\xfd\xbb\xaf\xb7 M\x99\xf0Ir\xefg\xb9\xf9WkA#Y&gt;&quot;\xd6U48h\x1f\x7f\x18~\x84\xff\xc1e\n\x7f\xc3\xf0\xe6n\xfa\x17\xec\xf1\xd5\xdd\x08\xeb9T]x\x1f=\xb7\xb9\xc8\x9e\x1f\x94@=\xd5\xc3\xa4l)_\x81\xdd\xe9\xde,&#x27;</span></span><br><span class="line"><span class="string">56006392793405152622249319809267370783366500753425509639946209618761862246016338248713679698677687165</span></span><br><span class="line"><span class="string">b&#x27;flag&#123;4eebce90-3a9f-4ba4-a75a-a434b915037c&#125;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h3><ul><li><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3></li></ul><p>前面三个例题都是关于直线的线性关系，那么如果是其他线性关系是不是也能这样直接<code>gcd</code>求出结果呢？带着这个疑问来探究探究，如果探究出来了目前就不把题目放在这里了，直接把这题当做题目出出来。（斜眼笑）</p><h1 id="两个消息非线性关系"><a href="#两个消息非线性关系" class="headerlink" title="两个消息非线性关系"></a>两个消息非线性关系</h1><h1 id="多个消息多项式关系"><a href="#多个消息多项式关系" class="headerlink" title="多个消息多项式关系"></a>多个消息多项式关系</h1><h1 id="多个消息多个线性关系"><a href="#多个消息多个线性关系" class="headerlink" title="多个消息多个线性关系"></a>多个消息多个线性关系</h1>]]></content>
    
    
    <summary type="html">前言：e和phi不互素学的有点爽</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="RSA" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/RSA/"/>
    
    
  </entry>
  
  <entry>
    <title>LFSR伪随机数生成器</title>
    <link href="http://iyheart.github.io/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://iyheart.github.io/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2025-09-18T14:01:28.000Z</published>
    <updated>2025-09-18T10:01:56.483Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考博客：<a href="https://learnku.com/docs/cryptography/36-linear-feedback-shift-register-lfsr/9315">3.6 线性反馈移位寄存器（LFSR） | 第三章：序列密码 |《密码学入门》| Python 技术论坛</a></li><li><p>参考博客：<a href="https://zh.wikipedia.org/wiki/线性反馈移位寄存器">线性反馈移位寄存器 - 维基百科，自由的百科全书</a></p></li><li><p>参考博客：<a href="https://www.cnblogs.com/weijianlong/p/11947741.html">线性反馈移位寄存器（LFSR） - 生活的高手 - 博客园</a></p></li><li><p>参考博客：<a href="https://cdcq.github.io/2022/08/28/20220828a/">cdcq的密码学教程四——BM算法 | cdcq</a></p></li><li><p><code>LFSR</code>英文名为<code>Linear feedback shift register</code>，中文翻译过来就是<code>线性反馈移位寄存器</code>，其伪随机数生成的特点已经包含在LFSR的名称中，也就是<strong>线性</strong>、<strong>反馈</strong>这两个词。</p></li><li><p>由于<code>LFSR</code>是非常容易使用硬件实现的，所以在以前很多流密码的密钥都是通过<code>LFSR</code>伪随机数生成算法来实现的，但是该伪随机数生成的算法在密码学体制中是比较不安全的，容易被预测到。但是<code>LFSR</code>组合其实可以得到安全的流密码。</p></li><li><p>本篇文章写于<code>2025.6.16</code>但是写的不怎么好，而在<code>2025.9.11</code>在图书馆随便看看，看到了这本书，从数学原理讲<code>LSFR</code>，于是决定重写博客，重新学习<code>LSFR</code>相关的。</p></li></ul><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250911104035350.png" alt="image-20250911104035350"></p><h1 id="lfsr"><a href="#LFSR" class="headerlink" title="LFSR"></a>LFSR</h1><ul><li><code>LFSR</code>是指给定前一状态的输出，将该输出的线性函数在用作输入的移位寄存器。</li><li>其中<strong>异或运算</strong>是最常见的单比特线性函数，对寄存器的某些位进行异或操作后作为输入，再对寄存器中的各比特进行整体移位。也就是<strong>先进行异或运算再进行位移运算</strong></li></ul><h2 id="lfsr的两种形式"><a href="#LFSR的两种形式" class="headerlink" title="LFSR的两种形式"></a>LFSR的两种形式</h2><ul><li>LFSR其实不止上面介绍的一种方式，其实还有另一种方式。</li><li>对于上面介绍的这种，是比较经典的，将其称为<strong>Fibonacci型</strong>，其实就是指定抽头影响输入位。</li></ul><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250622160519756.png" alt="image-20250622160519756"></p><ul><li>还有一种LFSR类型，该类型为<strong>Galois型</strong>，这种类型是输出位送给输入位后逐位异或，从而影响其他位，得到伪随机。</li></ul><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250622160529128.png" alt="image-20250622160529128"></p><h2 id="lfsr算法描述fibonacci型"><a href="#LFSR算法描述-Fibonacci型" class="headerlink" title="LFSR算法描述(Fibonacci型)"></a>LFSR算法描述(Fibonacci型)</h2><ul><li><p>我们先来给出一张图片，这张图片就简单介绍了<code>LFSR</code>算法。这张图主要做了一下几个事情：</p><ul><li><p>对于初始的状态$a<em>na</em>{n-1}…a<em>{2}a</em>{1}$，经过一个线性函数$f(a_1,a_2,…,a_n)$的运算，其实$f(a_1,a_2,…,a_n)$这个线性函数就是异或操作，即$f(a_1,a_2,…,a_n)=a_1\oplus a_2 \oplus …\oplus a_n$,得到一个结果作为我们后续的输入的<code>bit值</code>，所以这个函数运算结果只有<code>0</code>或者<code>1</code>，先暂时保存这个值</p></li><li><p>之后将$a<em>na</em>{n-1}…a<em>2a_1$经过位移后整体就变成$a</em>{n-1}a_{n-2}…a_1a_0$，此时$a_0$其实就是作为输出值了</p></li><li><p>最后我们再将$f(a<em>1,a_2,…,a_n)$运算得到的结果传递给$a_n$，此时就构成了新的一组$a_na</em>{n-1}…a_2a_1$序列</p></li><li><p>之后像这样不断的线性位移计算，我们就能得到这些二进制序列，我们每线性位移<code>n</code>次取一次序列，这样就得到了<code>n</code>位伪随机数</p></li><li><p>注意：<strong>不一定</strong>所有的<strong>位</strong>都参与线性运算，一般只选择几个位参与线性运算</p></li></ul></li></ul><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250622160603602.png" alt="image-20250622160603602"></p><blockquote><p>有几个<strong>注意点</strong>：</p><ol><li>将参与线性运算$f(a_1,a_2,…,a_n)$的位称为<strong>抽头</strong>，也就是LFSR状态下影响输入的位</li><li>LFSR最右边的位为输出位，同时它始终也是<strong>抽头</strong>。</li><li>抽头是有顺序的异或，然后反馈到最左边的位。</li><li>最右边的位序列称为输出流，如上图所示其实我们的输出流其实是$a_1$先输出出来,然后$a_2$，最后才是$a_n$</li><li>最大长度LFSR产生m序列具有$2^m-1$种状态，寄存器全零状态的时候线性位移后还是全零</li></ol></blockquote><ul><li>接下来我们使用Python实现一下简单的<code>32位LFSR</code>伪随机数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_int32</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFSR</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,seed</span>):</span><br><span class="line">        <span class="comment"># seed作为初始化寄存器的一个种子</span></span><br><span class="line">        <span class="comment"># 规定二进制序列是这样的an an-1 ... a2 a1与上图描述一致</span></span><br><span class="line">        self.seed = _int32(seed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 规定a26 a16 a11 a1都作为抽头</span></span><br><span class="line">        x = <span class="built_in">bin</span>(self.seed)[<span class="number">2</span>:].zfill(<span class="number">32</span>)</span><br><span class="line">        tap = [<span class="number">25</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">0</span>]</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tap:</span><br><span class="line">            tmp ^=<span class="built_in">int</span>(x[i],<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lshift</span>(<span class="params">self,an,reg</span>):</span><br><span class="line">        <span class="comment"># 进行位移运算</span></span><br><span class="line">        <span class="keyword">return</span> _int32((an&lt;&lt;<span class="number">31</span>)|(reg&gt;&gt;<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LSF</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 生成32位的随机数</span></span><br><span class="line">        <span class="comment"># 其实也可以直接LSF一次,而不用32次</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            an = self.xor()</span><br><span class="line">            self.seed=self.lshift(an,self.seed)</span><br><span class="line">        <span class="keyword">return</span> self.seed</span><br><span class="line"></span><br><span class="line">LFSR = LFSR(<span class="number">0xF75a15663499</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(LFSR.LSF())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="lfsr数学表示fibonacci型"><a href="#LFSR数学表示-Fibonacci型" class="headerlink" title="LFSR数学表示(Fibonacci型)"></a>LFSR数学表示(Fibonacci型)</h2><ul><li><p>LFSR有三种数学表示分别是递推公式、多项式表示、矩阵表示，其转换为数学符号，在有的时候更有利于推导公式之类的。</p></li><li><p>首先我们来介绍这张图所有位都参与异或的情况：</p><ul><li>设初始序列为$a<em>{n-1}a</em>{n-2}…a_1a_0$，由于我们每个位都参与运算，所以每个位都影响了最终结果</li><li>所以此时我们就可以写成这样一个<code>模2</code>的方程$a<em>{n+1}=a</em>{n}+a_{n-1}+…+a_2+a_1~mod~2$</li><li>此时我们还可以使用多项式的形式来表示$P(x)=x^{n}+x^{n-1}+…+x^{2}+x+1~mod~2$</li></ul></li><li><p>对于上图我们还可以使用矩阵来表示，我们可以定义<strong>状态向量</strong>$A_n$和<strong>转移矩阵</strong>$B_n$</p></li></ul><script type="math/tex; mode=display">A_n=\begin{bmatrix}a_n\\a_{n-1}\\ \vdots \\ a_2  \\ a_1 \end{bmatrix}\\B_n=\begin{bmatrix}1&&1 && \cdots &&1 &&1\\ 1 && 0 && \cdots && 0 && 0\\ 0 && 1 && \cdots && 0&&0\\ \vdots && \vdots && \ddots && \vdots && \vdots\\ 0 && 0 && \dots &&1&&0 \end{bmatrix}</script><ul><li>最后得到结果</li></ul><script type="math/tex; mode=display">A_{n+1}=B_nA_n=\begin{bmatrix}a_n+a_{n-1}+...+a_2+a_1~mod~2\\a_n\\ \vdots \\ a_3  \\ a_2 \end{bmatrix}</script><ul><li>但是由于在设计<code>LFSR</code>的时候我们并不会每一位都参与异或，此时我们就在$a_i$的前面添加一个系数，如果该位是抽头的话$a_i$前面的系数就为<code>1</code>，该位不是抽头的话$a_i$前面的系数就是0</li><li>例如上面使用Python编写的<code>LFSR</code>，就选用的是$a<em>{26}、a</em>{16}、a<em>{11}、a</em>{1}$作为抽头这样的话，就可以使用数学表达式得到这么一个序列</li></ul><script type="math/tex; mode=display">a_{n+1}=a_{26}+a_{16}+a_{11}+a_1~mod~2\\P(x)=x^{26}+x^{16}+x^{11}+x+1~mod~2</script><ul><li>使用矩阵表示就如下，$B_n$太大写不下：</li></ul><script type="math/tex; mode=display">A_n=\begin{bmatrix}a_{32}\\a_{31}\\ \vdots \\ a_2  \\ a_1 \end{bmatrix}\\</script><ul><li>最后的结果要如下：</li></ul><script type="math/tex; mode=display">A_{n+1}=B_nA_n=\begin{bmatrix}a_{26}+a_{16}+a_{11}+a_1~mod~2\\a_{32}\\ \vdots \\ a_3  \\ a_2 \end{bmatrix}</script><ul><li>所以归纳出输出序列，执行第m次的线性位移操作后的输出值的递推如下：</li></ul><script type="math/tex; mode=display">a_{i+m}=\sum^{m+1}_{j=0}p_j *a_{i+j}~mod~2\\s_i,p_i\in\{0,1\},i=0,1,2,...</script><ul><li>多项式表示为，如果第i位为抽头$p_i$就为1，否则为0：</li><li>这里注意有的多项式表达最高次数位始终为<code>1</code>，但是这里我们是将最低次数位默认为输出位，所以这里多项式始终有个<code>1</code>，具体情况再具体定义这个多项式就行了</li></ul><script type="math/tex; mode=display">P(x) = p_{n-1}x^{n-1}+p_{n-2}x^{n-2}+...+p_{2}x^{2}+p_1x+1~mod~2</script><ul><li>最后矩阵状态转移就不写了，写矩阵太麻烦了。</li></ul><h2 id="lfsr的逻辑图fibonacci型"><a href="#LFSR的逻辑图-Fibonacci型" class="headerlink" title="LFSR的逻辑图(Fibonacci型)"></a>LFSR的逻辑图(Fibonacci型)</h2><ul><li>由于<code>LFSR</code>的特性，其是比较容易在硬件中实现的，逻辑电路图并不复杂。其组成其实就是<strong>n个触发器</strong>，加上<strong>一些异或门</strong>再通过导线连接即可得到一个硬件的LFSR。</li><li>如下图所示：</li></ul><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250622160904448.png" alt="image-20250622160904448"></p><h1 id="lfsr破解"><a href="#LFSR破解" class="headerlink" title="LFSR破解"></a>LFSR破解</h1><ul><li>对于<code>LFSR</code>的破解需要用上一个经典的算法也就是<code>Berlekamp-Massey算法</code>。这里建议先去学习一下<code>Berlekamp-Massey</code>算法，先从它的数学抽象出来的问题入手，在破解LFSR的时候会更有助于理解。<a href="https://oi-wiki.org/math/berlekamp-massey/">Berlekamp–Massey 算法 - OI Wiki</a></li><li>对于<code>Berlekamp-Massey算法</code>，就不在这里详细介绍，这里只介绍<code>Berlekamp-Massey算法</code>在破解LFSR中的应用。</li></ul><h2 id="lfsr深入理解"><a href="#LFSR深入理解" class="headerlink" title="LFSR深入理解"></a>LFSR深入理解</h2><ul><li>接下来要介绍一些相关的定义和定理作为学习<code>Berlekamp-Massey</code>算法的前置知识。</li></ul><blockquote><p><strong>知识点1</strong></p><p>假设一个LFSR长度为<strong>L</strong>，LFSR的<strong>最初状态</strong>其实就等于LFSR所产生的序列的前L位输出。如下图所示，序列$a_0、a_1、…、a_n$其实就是长度为<strong>N</strong>的LFSR的初始状态。</p><p>从第$L+1$位开始的所有输出，完全由LFSR的<strong>反馈结构</strong>和<strong>初始状态决定</strong>，说明了一旦LFSR的<strong>反馈结构</strong>确定并且设置了<strong>初始状态</strong>，那么输出序列就<strong>唯一确定</strong></p><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250622160953542.png" alt="image-20250622160953542"></p><p><strong>知识点2</strong></p><p>当我们要用阶(其实是LFFR的长度)为L的LFSR，来生成长度为$N$的序列其实会出现以下两种情况：</p><ol><li>当<strong>L&gt;=N</strong>时，该LFSR一定能生成长度为$N$的序列，但是并不是最短的一个LFSR</li><li>当<strong>L&lt;N</strong>时，如果该LFSR能生成长度为<script type="math/tex">N</script>的序列，那么从第$L+1$位开始就必须满足递推式$s<em>n=\sum^{L}</em>{i=1}c<em>{i}s</em>{n-i}~mod~2$</li></ol><p><strong>定理1</strong>:</p><p>如果某个长度为L的LFSR能生成长度为N的序列，$s<em>0、s_1、…、s</em>{N-1}$,但是无法生成第$s<em>{N}$项，那么任何一个可以完整生成序列$s_0、s_1、…、s</em>{n}$的LFSR，其长度必须满足$L^{‘}≥N+1-L$，这个其实是<strong>B-M算法的下界定理</strong></p><p><strong>引理</strong>:</p><p>如果一个长度为n的LFSR记为$L<em>{n}(s)$，生成了$s_0,s_1,…,s</em>{N-1}$但是该LFSR并不能生成$s<em>0,s_1,…,s</em>{n-1},s<em>{n}$，那么就有$L</em>{n+1}(s)≥max[L<em>{N}(s),N+1-L</em>{N}(s)]$</p><p><strong>定理2</strong>:</p><p>如果一个长度位N的LFSR</p></blockquote>]]></content>
    
    
    <summary type="html">前言：LFSR线性反馈移位寄存器，之前没写完的打算重写</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="伪随机数" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows高级编程2-窗口程序</title>
    <link href="http://iyheart.github.io/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/"/>
    <id>http://iyheart.github.io/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/</id>
    <published>2025-09-18T09:11:47.000Z</published>
    <updated>2025-09-23T14:08:16.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><h2 id="字符编码方式"><a href="#字符编码方式" class="headerlink" title="字符编码方式"></a>字符编码方式</h2><ul><li>字符编码从上个世纪到现在出现了大致<code>4</code>种编码：<ul><li><code>ASC</code>编码：<code>7</code>位二进制代表一个字符串，这128位字符包含了<code>字母</code>、<code>数字</code>以及一些符号。</li><li><code>ASCII</code>编码：为了在欧洲推广计算机，所以又出现了<code>ASCII</code>编码，<code>8</code>位代表一个字符。并且前<code>128</code>个与前面的<code>ASC</code>编码一样。出现了一个代码页<code>ID</code>，根据代码页<code>ID</code>的不同将后面的<code>128</code>个字符换成对应国家的文字</li><li><code>DBCS</code>编码：主要是适配<code>亚洲</code>的文字编码，单双字节混合编码，英文字母按照<code>1</code>字节编码，象形文字等按照<code>2</code>字节编码</li><li><code>UNICODE</code>编码：被称为万国码，基本上把全世界所有语言都收录了。</li></ul></li><li>这里主要详细说明<code>DBCS</code>和<code>UNICODE</code>编码，其中<code>UNICODE</code>有<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>，如果在<code>Windows</code>下一般是<code>UTF-16</code>，而在<code>Linux</code>下一般是<code>UTF-8</code>：</li></ul><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250916144319067.png" alt="image-20250916144319067"></p><h2 id="宽字节字符"><a href="#宽字节字符" class="headerlink" title="宽字节字符"></a>宽字节字符</h2><p>在<code>windows</code>编程中有一个新的数据类型，该类型为<code>宽字节字符</code>，关键字为<code>wchar_t</code>每个字符占<code>2</code>个字节</p><ul><li><code>char</code>：每个字符占1个字节</li><li><code>wchar_t</code>：实际是<code>unsigned short</code>类型，定义时，需要增加<code>L</code>，通知编译器按照双字节编译字符串，采用<code>UNICODE</code>编码。（无论是英文字母还是汉字都是占用两个字节）</li></ul><p>需要使用支持<code>wchar_t</code>函数操作宽字节字符串。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span>* pwszText = <span class="string">L&quot;Hello wchar&quot;</span>; <span class="comment">// 宽字节字符</span></span><br><span class="line">wprintf(<span class="string">L&quot;%s\n&quot;</span>,pwszText); <span class="comment">// 宽字节字符</span></span><br><span class="line"><span class="comment">// 注意：需要使用专门处理宽字节字符串相关的函数</span></span><br></pre></td></tr></table></figure><h2 id="tchar宏定义"><a href="#TCHAR宏定义" class="headerlink" title="TCHAR宏定义"></a>TCHAR宏定义</h2><ul><li>由于宽字节字符和正常的字节字符有的时候会混淆，所以为了统一微软做了一个<code>TCHAR</code>的宏定义，该宏定义如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果定义了UNICODE这个宏,那么TCHAR就会被宏定义为wchar_t类型</span></span><br><span class="line"><span class="comment">// 如果没有定义UNICODE这个宏,那么TCHAR就会被定义为char类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">wchar_t</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEXT(quote) L## quote</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEXT(quote) quote</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="unicode字符打印"><a href="#UNICODE字符打印" class="headerlink" title="UNICODE字符打印"></a>UNICODE字符打印</h2><p><code>wprintf</code>对<code>UNICODE</code>字符打印支持不完善，在<code>Windows</code>下使用<code>WriteConsole API</code>打印<code>UNICODE</code>字符<code>GetStdHandle</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintUnicode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* pszText = <span class="string">L&quot;阿斯代理商打马赛克代码卢萨卡代码&quot;</span>;</span><br><span class="line">wprintf(<span class="string">L&quot;%s\n&quot;</span>, pszText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">PrintUnicode();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917222510026.png" alt="image-20250917222510026"></p><ul><li>下面就使用<code>WriteConsole()</code>打印中文</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintUnicode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* pszText = <span class="string">L&quot;阿斯代理商打马赛克代码卢萨卡代码&quot;</span>;</span><br><span class="line"><span class="comment">//wprintf(L&quot;%s\n&quot;, pszText);</span></span><br><span class="line"><span class="comment">// Linux有三个标准文件描述符0、1、2，</span></span><br><span class="line"><span class="comment">// 而Windows也有三个标准句柄标准输入句柄、标准输出句柄、标准错误句柄</span></span><br><span class="line"><span class="comment">// 对于Windows标准句柄值是比较大的而且还不确定,需要使用GetStdHandle()这个函数去获取标准句柄</span></span><br><span class="line"><span class="comment">// 该函数只有一个参数,可以是STD_OUTPUT_HANDLE、STD_INPUT_HANDLE、STD_ERROR_HANDLE,返回值就是标准句柄的值</span></span><br><span class="line">HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">WriteConsole(hOut,pszText,wcslen(pszText),<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//C_char();</span></span><br><span class="line"><span class="comment">//W_char();</span></span><br><span class="line"><span class="comment">//T_char();</span></span><br><span class="line">PrintUnicode();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现如下乱码的原因是选用多字节字符，如果使用默认的<code>UTF</code>就能正确输出。</p><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917223326957.png" alt="image-20250917223326957"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>现在约定一下创建一个新项目的基本步骤，先创建一个新的项目，然后将其设置为启动项</li></ul><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917155038576.png" alt="image-20250917155038576"></p><ul><li>修改该项目的属性，选择<code>高级</code>，使用多字节字符集</li></ul><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917154418524.png" alt="image-20250917154418524"></p><p>如果是设置为<code>Unicode</code>编译器会默认有<code>Unicode</code>宏定义，如果使用多字节字符集编译器就不会默认<code>Unicode</code>宏定义，这主要是因为Window是有大量的系统调用函数的参数是<code>TCHAR*</code>、<code>const TCHAR*</code>类型。</p><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917154501016.png" alt="image-20250917154501016"></p><ul><li>例子1——正常的字符处理：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">C_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* pszText = <span class="string">&quot;hello char&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pszText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">C_char();</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917155115719.png" alt="image-20250917155115719"></p><ul><li>例子2——宽字节字符串：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">C_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pszText = <span class="string">&quot;hello char&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pszText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* pszText = <span class="string">L&quot;hello wchar&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = wcslen(pszText);</span><br><span class="line">wprintf(<span class="string">L&quot;%s %d\n&quot;</span>, pszText, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//C_char();</span></span><br><span class="line">W_char();</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wcslen()这个函数求的不是该字符占多少个字节，而是求的该字符有多少个。</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917155451240.png" alt="image-20250917155451240"></p><ul><li>例子3——TCHAR：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">C_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pszText = <span class="string">&quot;hello char&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pszText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* pszText = <span class="string">L&quot;hello wchar&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = wcslen(pszText);</span><br><span class="line">wprintf(<span class="string">L&quot;%s %d\n&quot;</span>, pszText, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> TCHAR * pszText = __TEXT(<span class="string">&quot;hello txt&quot;</span>); </span><br><span class="line"><span class="comment">// 如果没有定义unicode就会根据定义编译为char* pszText = &quot;hello txt&quot;;</span></span><br><span class="line"><span class="comment">// 如果定义了unicode就会根据定义编译为wchar_t * pszText = L&quot;hello wchar&quot;;</span></span><br><span class="line"><span class="comment">// 后面__TEXT(&quot;hello txt&quot;);主要就是根据宏定义#define __TEXT(quote) L## quote，#define __TEXT(quote) quote来判断的</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line">wprintf(<span class="string">L&quot;%s\n&quot;</span>, pszText);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单:%s\n&quot;</span>, pszText);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//C_char();</span></span><br><span class="line"><span class="comment">//W_char();</span></span><br><span class="line">T_char();</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917161824499.png" alt="image-20250917161824499"></p><h1 id="windows窗口程序"><a href="#Windows窗口程序" class="headerlink" title="Windows窗口程序"></a>Windows窗口程序</h1><ul><li>接下来手敲一个Windows窗口程序，完全了解一下Windows窗口程序的创建过程。</li><li>总体概括一下Window窗口程序的创建过程（这个过程会接触到一些比较陌生的名词，之后会详细的说明）：<ul><li>定义WinMain函数</li><li>定义窗口处理函数（自定义，处理消息）</li><li>注册窗口类（向操作系统写入一些数据）</li><li>创建窗口（内存中创建窗口）</li><li>显示窗口（绘制窗口的图像）</li><li>消息循环（获取/翻译/派发消息）</li><li>消息处理</li></ul></li></ul><h2 id="简单创建一个windows程序"><a href="#简单创建一个Windows程序" class="headerlink" title="简单创建一个Windows程序"></a>简单创建一个Windows程序</h2><ul><li>先创建一个<code>Winmain</code>函数，作为入口函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就是创建一个窗口处理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//窗口处理函数(用户自定义，处理消息)</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProce</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM IParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, IParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就是在<code>WinMain</code>函数中注册一个窗口，也就是填写一些关于窗口的数据，并将数据写入到内核里面去。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//窗口处理函数(用户自定义，处理消息)</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProce</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM IParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, IParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注册窗口类(向系统的内核中写入数据)，先创建一个结构体将这个结构体的值都设置好</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;; <span class="comment">//初始化结构体</span></span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>; <span class="comment">//申请缓冲区</span></span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>; <span class="comment">//申请缓冲区</span></span><br><span class="line">    <span class="comment">// 上面是申请两种不同的缓冲区</span></span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">3</span>);<span class="comment">// 注册窗口背景色 + 3是黑色，+1是白色</span></span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;<span class="comment">// 光标,给NULL是默认光标</span></span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;<span class="comment">// 图标,默认图标</span></span><br><span class="line">wc.hInstance = hIns;<span class="comment">// 将WinMain的第一个参数赋值给他</span></span><br><span class="line">wc.lpfnWndProc = WndProce;<span class="comment">// 用上面定义的窗口处理函数的名称赋值</span></span><br><span class="line">wc.lpszClassName = <span class="string">&quot;Main&quot;</span>;<span class="comment">// 窗口类名称随便起一个</span></span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;<span class="comment">// 菜单,NULL是没有菜单</span></span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">// 当窗口水平或者垂直方向发生变化,重新画窗口图画</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个系统调用函数,将这个结构体直接写入到操作系统的内核中去</span></span><br><span class="line">RegisterClass(&amp;wc); <span class="comment">//将以上所有赋值全部写入操作系统</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就是在内存创建窗口，也就是申请一块内存，将窗口的数据放到里面。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//窗口处理函数(用户自定义，处理消息)</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProce</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM IParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, IParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注册窗口类(向系统的内核中写入数据)，先创建一个结构体将这个结构体的值都设置好</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">8</span>);</span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wc.hInstance = hIns;</span><br><span class="line">wc.lpfnWndProc = WndProce;</span><br><span class="line">wc.lpszClassName = <span class="string">&quot;Main&quot;</span>;</span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个系统调用函数,将这个结构体直接写入到操作系统的内核中去</span></span><br><span class="line">RegisterClass(&amp;wc); <span class="comment">//将以上所有赋值全部写入操作系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内存中创建窗口(申请一块内存,将窗口的各种数据存储进去),使用的是CreateWindow()函数</span></span><br><span class="line">    <span class="comment">// 第一个参数就是wc.lpszClassName = &quot;Main&quot;;中所写的&quot;Main&quot;即窗口名称</span></span><br><span class="line">    <span class="comment">// 第二个参数是标题栏的信息,随便写</span></span><br><span class="line">    <span class="comment">// 第三个参数是创建窗口的基本风格</span></span><br><span class="line">    <span class="comment">// 第四个、第五个参数表示窗口的位置,即窗口左上角对应的平屏幕位置</span></span><br><span class="line">    <span class="comment">// 第六个、第七个参数表示窗口的大小,即打开窗口的默认大小</span></span><br><span class="line">HWND hWnd = CreateWindow(<span class="string">&quot;Main&quot;</span>, <span class="string">&quot;window&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就是根据<code>CreateWindow()</code>写入到内存中的数据在电脑屏幕上显示窗口。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//窗口处理函数(用户自定义，处理消息)</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProce</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM IParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, IParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注册窗口类(向系统的内核中写入数据)，先创建一个结构体将这个结构体的值都设置好</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">8</span>);</span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wc.hInstance = hIns;</span><br><span class="line">wc.lpfnWndProc = WndProce;</span><br><span class="line">wc.lpszClassName = <span class="string">&quot;Main&quot;</span>;</span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个系统调用函数,将这个结构体直接写入到操作系统的内核中去</span></span><br><span class="line">RegisterClass(&amp;wc); <span class="comment">//将以上所有赋值全部写入操作系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内存中创建窗口(申请一块内存,将窗口的各种数据存储进去)</span></span><br><span class="line">HWND hWnd = CreateWindow(<span class="string">&quot;Main&quot;</span>, <span class="string">&quot;window&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">500</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示窗口,按照窗口的数据在屏幕上显示窗口ShowWindow()函数</span></span><br><span class="line"><span class="comment">// 借助一个Windows api</span></span><br><span class="line">    <span class="comment">// 第一个参数是CreateWindow()的返回值</span></span><br><span class="line">    <span class="comment">// 第二个参数是以什么方式显示,SW_SHOW是以原样显示</span></span><br><span class="line">ShowWindow(hWnd, SW_SHOW);</span><br><span class="line">    <span class="comment">// 还需要调用UpdateWindow(),其实不用调用也可以,但是微软建议调用</span></span><br><span class="line">    <span class="comment">// UpdateWindow()功能就是刷新窗口</span></span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后就是消息循环，窗口处理完肯定要保持显示状态，像上面那个代码窗口一画完就退出程序，窗口就会消失。</li><li>而正常来说窗口一般都有输入框、点击按钮、鼠标移动到那个图标上，这些都是用户对窗口的一些操作，消息处理基本上就是处理这些。</li><li>在处理消息之前首先需要接收消息，而接收消息肯定要窗口要一直显示用户才能对窗口操作，所以需要使用一个<code>while</code>循环，然窗口一直显示，消息一直在接收和翻译，最后会给用户自定义的窗口处理函数来处理一些用户对窗口的操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//窗口处理函数(用户自定义，处理消息)</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProce</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM IParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, IParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注册窗口类(向系统的内核中写入数据)，先创建一个结构体将这个结构体的值都设置好</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">8</span>);</span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wc.hInstance = hIns;</span><br><span class="line">wc.lpfnWndProc = WndProce;</span><br><span class="line">wc.lpszClassName = <span class="string">&quot;Main&quot;</span>;</span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个系统调用函数,将这个结构体直接写入到操作系统的内核中去</span></span><br><span class="line">RegisterClass(&amp;wc); <span class="comment">//将以上所有赋值全部写入操作系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内存中创建窗口(申请一块内存,将窗口的各种数据存储进去)</span></span><br><span class="line">HWND hWnd = CreateWindow(<span class="string">&quot;Main&quot;</span>, <span class="string">&quot;window&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">500</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示窗口,按照窗口的数据在屏幕上显示窗口</span></span><br><span class="line"><span class="comment">// 借助一个Windows api</span></span><br><span class="line">ShowWindow(hWnd, SW_SHOW);</span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息循环</span></span><br><span class="line">MSG nMsg = &#123; <span class="number">0</span> &#125;; <span class="comment">// MSG这个结构体就是保存GetMessage抓出来的消息</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// nMsg保存Getmessage抓取过来的参数</span></span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;nMsg); <span class="comment">// 翻译消息</span></span><br><span class="line">DispatchMessage(&amp;nMsg);<span class="comment">// 将消息交给窗口处理函数来处理,也就是我们自己定义的消息来处理。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后一步就是消息处理了（最后一步这里不多说），就举个例子比如你对窗口的某个按钮做了点击操作，此时自定义的函数就要做相关的一些操作。或者是点击关闭按钮，表示程序退出，这时需要调用一个窗口退出函数来退出，否则该程序就算你关了窗口，程序也会在后台一直运行。</li><li>最终的效果如下：</li></ul><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250918111643146.png" alt="image-20250918111643146"></p><h2 id="注册窗口类"><a href="#注册窗口类" class="headerlink" title="注册窗口类"></a>注册窗口类</h2>]]></content>
    
    
    <summary type="html">前言：一些crackme和Keygenme都是窗口程序,前来学学</summary>
    
    
    
    <category term="开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Windows开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/Windows%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows高级编程1-应用程序的分类和工具</title>
    <link href="http://iyheart.github.io/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://iyheart.github.io/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2025-09-16T02:08:56.000Z</published>
    <updated>2025-09-17T14:05:22.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>初步学习<code>C</code>语言或者<code>C++</code>语言，再加上一点<code>操作系统</code>的知识就可以初步学习一下<code>Windows高级编程</code>。</li><li>学习Windows高级编程也算是了解一下Windows开发，学到一定程度之后就可以真正能跑去学逆向了。</li></ul><h1 id="visual-studio介绍"><a href="#Visual-Studio介绍" class="headerlink" title="Visual Studio介绍"></a>Visual Studio介绍</h1><ul><li><code>Visual Studio</code>就是Windows应用程序开发的一个IDE。基本上Windows程序的开发使用该IDE是非常方便的。这个IDE算是比较大的一个IDE。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>接下来介绍一下这个软件最基本的使用过程。我们先看视图中<strong>解决方案资源管理器</strong>，我们点击解决方案资源管理器这边，左边就会弹出解决方法资源管理器。</li><li>对于<strong>解决方案资源管理器</strong>，我们只需要知道它最重要的一个就是，它管理着很多项目。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525215415636.png" alt="image-20250525215415636"></p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul><li>项目可以理解就是我们要做的一个程序，它里面是<strong>头文件、C文件</strong>的一些集合，这里我们先来新建一个项目</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220111353.png" alt="image-20250525220111353"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220140511.png" alt="image-20250525220140511"></p><ul><li>此时就会跳转到这个窗口，这边有一个创建新解决方案，选择这个选项和合适的位置，点击创建即可</li><li>如果我们想要自定义这个解决方案的名字我们就可以取消勾选<strong>将解决方案和项目放在同一目录中</strong>（如第二张图片）</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220247928.png" alt="image-20250525220247928"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220853528.png" alt="image-20250525220853528"></p><ul><li>创建好一个项目后我们就会发现，解决方案下面存放着我们新建的项目1</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220450696.png" alt="image-20250525220450696"></p><ul><li>此时我们在该解决方案中再创建一个项目2，发现我们的解决方案中能管理多个项目，之后就是一个头文件</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220639825.png" alt="image-20250525220639825"></p><ul><li>所以我们画一个简单的图表示一下<strong>解决方案、项目、头文件、源文件的关系</strong></li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525221038689.png" alt="image-20250525221038689"></p><ul><li>此时我们在这个对应文件夹中能看到文件项目中的文件目录。</li></ul><p>、<img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525221149138.png" alt="image-20250525221149138"></p><ul><li>如果是不选择<strong>将解决方案和项目放在同一目录中</strong>，我们的项目文件就会出现如下图所示的一堆文件，已经对应的项目文件夹。是俩个图的对比，其中<strong>这俩个图的上一级目录如上图所示</strong>，在本级目录中的一些文件有所不同。</li><li>相同点就是在于都存在<code>.sln</code>文件，这个文件被称为<strong>解决方案文件</strong>，这个文件主要就是存放着各个项目的信息。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525221608241.png" alt="image-20250525221608241"></p><ul><li>我们要创建一个新的项目，还可以直接在解决方案这边右键创建，如下图所示</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525222050718.png" alt="image-20250525222050718"></p><ul><li>在创建项目中，VS给我们提供了很多项目模版，我们在学习Windows核心编程的时候主要就是创建这四种类型的项目文件。</li><li>其它文件在Windows高级编程不是特别重要，也不是经常使用。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525223431481.png" alt="image-20250525223431481"></p><h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><ul><li>当我们写好一个程序时，我们就可以使用这个按钮编译我们写好的程序，并且会自动运行。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224312480.png" alt="image-20250525224312480"></p><ul><li>但是当一个解决方案中有多个项目，我们就会发现，在编译好其中一个项目之后，运行程序时运行的是另一个已经编译好的文件。（其实编译的也不是我们这个项目的文件，其实是编译启动项目的文件）</li><li>比如下图，我们编译的是<code>111</code>，但是运行的<code>hello world</code>，这个主要就是与我们的<strong>启动项目</strong>有关，每个解决方案只能有一个启动项目</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224425121.png" alt="image-20250525224425121"></p><ul><li>我们可以使用如下操作进行启动项目的设置</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224600788.png" alt="image-20250525224600788"></p><ul><li>设置完后再进行编译运行操作就没啥问题了</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224754306.png" alt="image-20250525224754306"></p><h1 id="windows应用程序的分类"><a href="#Windows应用程序的分类" class="headerlink" title="Windows应用程序的分类"></a>Windows应用程序的分类</h1><ul><li><code>Windows</code>应用程序一般就分为三大类：<ol><li>控制台程序<strong>Console</strong>：DOS程序，本身没有窗口，通过<strong>Windows DOS</strong>窗口执行。入口函数：main</li><li>窗口程序：拥有自己的窗口，可以与用户交互。入口函数：WinMain</li><li>库程序：存放代码、数据的程序，执行文件可以从中取出代码执行和获取数据。其中库程序又分为<strong>静态库程序</strong>和<strong>动态库程序</strong><ul><li>静态库程序：扩展名Lib，在编译链接程序时，将代码放入到执行文件中。无入口函数</li><li>动态库程序：扩展名dll，在执行文件执行时从中获取代码。入口函数：DllMain</li></ul></li></ol></li></ul><h2 id="控制台程序"><a href="#控制台程序" class="headerlink" title="控制台程序"></a>控制台程序</h2><ul><li>我们先来创建一个控制台程序</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525223601596.png" alt="image-20250525223601596"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525223618138.png" alt="image-20250525223618138"></p><ul><li>创建好后这个解决方案就会出现一个这个控制台程序的项目。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525223705240.png" alt="image-20250525223705240"></p><ul><li>接下来就是给这个项目添加一些文件，点击项目这边，然后添加，新建项。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525223922240.png" alt="image-20250525223922240"></p><ul><li>操作完上面的此时就会弹出这个窗口，这样就可以选择我们要添加的文件了。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224003654.png" alt="image-20250525224003654"></p><ul><li>我们运行时在终端输出一些信息等，这种程序其实就是控制台程序</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224856718.png" alt="image-20250525224856718"></p><ul><li>当我们编译好后的程序，这里的项目文件就会生成这些文件夹</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525225054348.png" alt="image-20250525225054348"></p><h2 id="窗口程序"><a href="#窗口程序" class="headerlink" title="窗口程序"></a>窗口程序</h2><ul><li>窗口程序是Windows操作系统的一个比较重要的地方，windows区别于Linux就是图形化界面。所以这个是比较核心的一个点。</li><li>我们先来创建一个基于窗口程序的项目。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525225250487.png" alt="image-20250525225250487"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525225408301.png" alt="image-20250525225408301"></p><ul><li>创建好这个项目后我们先来查看一下这个项目的一些相关文件。我们能看到创建完后我们的头文件和源文件一开始就会保护这些文件。</li><li>这里我们要注意一下，我们的控制台程序的主函数是叫<strong>main</strong>函数，而我们的这个应用窗口程序的主函数叫<strong>WinMain</strong>这个函数。这些代码看不懂，没啥关系，之后会慢慢学。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525225517489.png" alt="image-20250525225517489"></p><ul><li>接下来我们选择这个项目为启动项目，编译运行一下这个项目，运行之后我们就会得到如下的窗口。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525225733861.png" alt="image-20250525225733861"></p><h2 id="静态库程序"><a href="#静态库程序" class="headerlink" title="静态库程序"></a>静态库程序</h2><ul><li>不论是静态库程序还是动态库程序，在原理上都是和Linux相同的。只不过在实现上有不同就是了。</li><li>接下来我们就先来添加一个静态库</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005329605.png" alt="image-20250526005329605"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005337520.png" alt="image-20250526005337520"></p><ul><li>新建完之后我们会发现我们新建的这个项目有如下这些文件</li><li>我们会看到这里我们并没有主函数，说明静态库程序并没有主函数。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005429329.png" alt="image-20250526005429329"></p><ul><li>我们编译运行这个程序后会发现该程序会弹出一个报错框，但是这个静态库会被编译好，编译成<code>.lib</code>后缀的文件。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005632048.png" alt="image-20250526005632048"></p><h2 id="动态库程序"><a href="#动态库程序" class="headerlink" title="动态库程序"></a>动态库程序</h2><ul><li>接下来我们查看动态库程序，我们就直接新建一个动态链接库的项目</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005809948.png" alt="image-20250526005809948"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005834764.png" alt="image-20250526005834764"></p><ul><li>创建好后会看到如下代码，查看代码我们会发现一个<code>DllMain</code>这个函数名，这个就是我们这个<code>dll</code>文件的主函数，也就是入口函数。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005922754.png" alt="image-20250526005922754"></p><ul><li>这个时候我们编译运行一下，发现还是弹出一个错误的框</li><li>我们发现这个程序已经被编译成了<code>.dll</code>文件，但是我们还是无法运行这个程序</li><li>这就是动态库的一个比较关键的一个地方，它可以运行，但是它不能独立运行，它是依赖其他程序运行的。这个</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526010059287.png" alt="image-20250526010059287"></p><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><h2 id="编译-链接工具"><a href="#编译、链接工具" class="headerlink" title="编译、链接工具"></a>编译、链接工具</h2><ul><li><strong>VS</strong>这个开发工具会像这样，我们点击按钮，它就会自动将我们的程序编译和链接好。链接的具体过程并没有向我们展示。</li><li>这里就简单介绍一下<strong>VS</strong>编译和链接使用的相关工具。</li><li>编译器这边使用的是<code>CL.exe</code>文件，主要将源代码编译成目标代码<code>.obj</code>文件</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526011417136.png" alt="image-20250526011417136"></p><ul><li>还有链接器<code>LINK.exe</code>，将目标代码、库链接生成最终文件</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526011536220.png" alt="image-20250526011536220"></p><ul><li>还有一个就是资源编译器<code>RC.exe</code>，将<code>.rc</code>资源编译，最终通过链接器存入最终文件。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526011644125.png" alt="image-20250526011644125"></p><h2 id="库文件-头文件"><a href="#库文件、头文件" class="headerlink" title="库文件、头文件"></a>库文件、头文件</h2><ul><li>对于我们一开始学C语言，最经常使用的就是<code>stdio.h</code>这个库文件。而现在我们学习的是<code>windows</code>高级编程，是开发Windows上的一些应用程序。所以我们使用的库就是windows中特有的库。</li><li>windows高级编程中，以下几个Windows库是最经常使用的。<ul><li><code>kernel32.dll</code>提供了核心的API，例如进程、线程、内存管理</li><li><code>user32.dll</code>提供了窗口、消息等API</li><li><code>gdi32.dll</code>绘图相关的API</li><li>它们的路径都在<code>C:\Windows\System32</code>这里</li></ul></li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526012333575.png" alt="image-20250526012333575"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526012429481.png" alt="image-20250526012429481"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526012357396.png" alt="image-20250526012357396"></p><ul><li><p>我们要使用上面的库文件，在使用前必须进行声明，而Windows中的一些头文件已经声明好了。我们此时只要<code>#include</code>就行了。</p></li><li><p>介绍一下Windows中比较重要的头文件</p><ul><li><code>windows.h</code>：所有windows头文件的集合（我们一般就include这个头文件即可）</li><li><code>windef.h</code>：Windows数据类型</li><li><code>winbase.h</code>：kernel32的API</li><li><code>wingdi.h</code>：gdi32的API</li><li><code>winuser.h</code>：user32的API</li><li><code>winnt.h</code>：UNICODE字符集支持</li><li>路径大概就在这里<code>C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um</code></li></ul></li></ul><h2 id="窗口程序基本函数"><a href="#窗口程序基本函数" class="headerlink" title="窗口程序基本函数"></a>窗口程序基本函数</h2><ul><li>在windows开发窗口程序的过程中主要有几个比较常见也比较基本的函数。我们开发的时候是跑不掉的。</li><li>现在我们就先来介绍一下这几个函数，之后我们在开发的时候就会比较熟悉了。剩下的函数看着开发手册学就行了。</li><li>第一个比较基本的函数就是<code>WinMain</code>函数<ul><li><strong>重要概念：句柄</strong>，对于初学我们将句柄理解为用来找到内存的东西，但是句柄并不是指针。</li><li><code>hInstance</code>：当前程序实例句柄，能找到当前进程所占据的内存</li><li><code>hPrevInstance</code>（这个参数已经被废除，只有在16位的时候有用）</li><li><code>LPSTR lpCmdLine</code>：<code>LPSTR</code>就是<code>char *</code>的别名，所以这边我们应该传入一个字符串命令，类似与Main函数中的<code>argv</code>、<code>argc</code></li><li><code>int nCmdShow</code>：只要的作用就是显示窗口，选项有如下图所示，最大化显示、最小化显示、原样窗口显示</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(</span></span><br><span class="line"><span class="params">HINSTANCE hInstance, <span class="comment">// 当前程序的实例句柄</span></span></span><br><span class="line"><span class="params">    HINSTANCE hPrevInstance, <span class="comment">// 当前程序前一个实例句柄</span></span></span><br><span class="line"><span class="params">    LPSTR lpCmdLine, <span class="comment">// 命令行参数字符串</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> nCmdShow <span class="comment">// 窗口的显示方式</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>第二个比较基本的函数就是<code>MessageBox</code>这个弹出消息提示框的函数。<ul><li><code>HWND hWnd</code>：父窗口的句柄，就像下图中我们这个提示框的父窗口就是记事本</li><li><code>LPCTSTR lpText</code>：显示提示框中的文字，相当于下图中的<code>是否要将....</code></li><li><code>LPCTSTR IpCaption</code>：显示在标题栏中的文字，相当于下图中的<code>记事本</code></li><li><code>UINT uType</code>：弹出的框<code>只有确定</code>或者<code>有保存、取消</code>或者<code>有保存、不保存、取消</code>，还有弹窗的一些图标按照一些宏定义和或的型式即可。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MessageBox</span><span class="params">(</span></span><br><span class="line"><span class="params">HWND hWnd,<span class="comment">//父窗口句柄</span></span></span><br><span class="line"><span class="params">    LPCTSTR IpText, <span class="comment">// 显示在消息框中的文字</span></span></span><br><span class="line"><span class="params">    LPCTSTR IpCaption,<span class="comment">// 显示在标题栏中的文字</span></span></span><br><span class="line"><span class="params">    UINT uType<span class="comment">// 消息框中的按钮、图标显示类型</span></span></span><br><span class="line"><span class="params">)</span>;<span class="comment">// 返回点击的按钮ID</span></span><br></pre></td></tr></table></figure><ul><li>提示框的主要效果就是像这样</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526014828491.png" alt="image-20250526014828491"></p><ul><li>接下来编写<code>MessageBox</code>版本的<code>Hello world</code>，编译运行的结果也在下面</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">MessageBox(<span class="number">0</span>, <span class="string">L&quot;Hello World!&quot;</span>, <span class="string">L&quot;Windows高级编程&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526020104717.png" alt="image-20250526020104717"></p>]]></content>
    
    
    <summary type="html">前言：逆向有非常多的WindowsAPI难搞</summary>
    
    
    
    <category term="开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Windows开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/Windows%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>格理论初探</title>
    <link href="http://iyheart.github.io/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/"/>
    <id>http://iyheart.github.io/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/</id>
    <published>2025-09-09T16:19:26.000Z</published>
    <updated>2025-09-23T13:20:22.745Z</updated>
    
    <content type="html"><![CDATA[<ul><li>格理论在密码分析和破解这块是个好工具，而CTF又是偏向解题，在密码学这个方向中其实就是对加密过程和密文以及密钥进行密码分析，发现并破解其中潜在的漏洞。所以对于打CTF来说，格理论是不得不学的一个大方向，使用格能破解一些传统加密。</li><li>格理论除了在密码分析和破解这块起妙用之外，还基于格的几个困难问题设计了一些与格相关的加密（目前我还不知道加密的效率怎么样，有听别人说，但是自己没体会到。）</li><li>其实大二就很想入门格密码学，但是由于时间都花在<code>pwn</code>上，有的时候不仅内耗，还比较浮躁，就导致效率比较低。不过现在大三感觉已经在<code>密码学</code>和<code>pwn</code>这两个方向上已经快突破我的平台期了。大二暑假的时候将初等数论学了个大概（还有指数与原根、连分数、超越数、丢番图，其实原本暑假还打算把抽象代数能学多少就学多少，可惜可惜）。目前有个这么打算<code>高等代数</code>和<code>抽象代数</code>学完，就来学<code>代数数论</code>和<code>解析数论</code>。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>对于格理论、格密码来说，国外的资料是一大堆的，国内的资料是真没多少。而国外资料又是<code>英文</code>看一页都老半天了。所以在学习格之前，我就先做了点信息收集。</p></li><li><p>首先是王小云写的一篇论文：<a href="http://www.jcr.cacrnet.org.cn/CN/10.13868/j.cnki.jcr.000002">格密码学研究</a>，这篇论文并不是学格相关的理论知识，当做看小说一样看一遍下来，对格的整个发展有一个比较清晰的脉络。还有就是该论文中引用比较多的论文，可以看看这些引用的论文。通过看该论文，可以大致了解一些格理论的一些专有名词，比如格的困难问题<code>CVP、SVP</code>等，以及一些定理还有格与机器学习的交叉<code>LWE</code>问题。</p></li><li>目前找到的一本比较系统的写格理论与格密码的书籍了：<code>格理论与密码学 周福才，徐剑编著</code>，这本数是中文的书籍，字还是可以看得比较顺畅的。</li><li>还有一本就是涵盖内容比较多的一本英文教材：<code>《COMPLEXITY OF LATTICE PROBLEMS A Cryptographic Perspective》Daniele Micciancio、Shafi Goldwasser著</code></li><li><p>国外还有一本书：<code>《AnIntroduction to Mathematical Cryptography》Jeffrey Hoffstein、Jill Pipher、Joseph H. Silverman</code></p></li><li><p>接下来就是一些视频了，这个是英文视频：<a href="https://www.bilibili.com/video/BV1bz411v7pS/?spm_id_from=333.1387.upload.video_card.click&amp;vd_source=28578c666061830f05313bc422ef65d5">2012年BIU密码学冬令营-04-Basic Cryptanalysis（中文字幕）_哔哩哔哩_bilibili</a></p></li><li><p>这个是中文的一些教学视频：<a href="https://www.bilibili.com/video/BV1RsFAeWEbF?vd_source=bbdaef564df94fc8991902ba22c6761b">全同态加密理论: 格密码的数学基础</a></p></li><li>这个代数数论的视频也有讲一部分格，在第<code>125</code>个视频中：<a href="https://www.bilibili.com/video/BV1e54y1a7dY?p=125&amp;vd_source=bbdaef564df94fc8991902ba22c6761b">经典代数数论2021</a></li><li><code>《数的几何引论》朱尧辰</code></li><li>参考博客：<a href="https://dexterjie.github.io/2023/07/28/初识格/">初识格 | DexterJie’Blog</a></li></ul><h1 id="格初步认识"><a href="#格初步认识" class="headerlink" title="格初步认识"></a>格初步认识</h1><h2 id="格相关概念"><a href="#格相关概念" class="headerlink" title="格相关概念"></a>格相关概念</h2><ul><li>这一部分主要简述一下通过阅读一些资料对格这个概念的一些初步认识。没啥图片都是文字。</li><li>格密码的发展大体分为两条主线：<ul><li>一是从具有悠久历史的格经典数学问题的研究发展到近30多年来高维格困难问题的求解算法以及其计算复杂性理论研究</li><li>二是从使用格困难问题的求解算法<strong>分析非格公钥密码体制</strong>的安全性发展到基于格困难问题的密码体制的设计。</li></ul></li><li>格的研究源于<code>1611</code>年开普勒提出的如下猜想：在一个容器中堆放等半径的小球所能达到的最大密度为$\frac{\pi}{\sqrt{18}}$。</li><li><code>1840</code>年前后，高斯引入了格的概念并证明了：在三维空间中堆球，如果所有的球心构成一个格，那么堆积密度所能达到知道最大值为$\frac{\pi}{\sqrt{18}}$。</li><li>之后在过去的一个半世纪中，<code>Minkowski</code>、<code>Hermite</code>、<code>Bourgain</code>、<code>Hlawka</code>、<code>Kabatyansky</code>、<code>Levenstein</code>、<code>Lovasz</code>、<code>Mahler</code>、<code>Rogers</code>等著名数学家系统地发展了一般几何体的格堆积与覆盖理论。在这一发展过程中，确定一个几何体的<strong>最大格堆积密度</strong>和<strong>最小格覆盖密度</strong>一直是这一个学科的核心问题。（对与格数学的这个发展过程全部都摘抄自王小云教授）。</li></ul><blockquote><p>首先来了解一下格的定义：格是$\R^m$中一类具有周期性结构的离散点的集合，严格地来说，格是m维欧式空间$\R^m$的$n(m\ge n)$个线性无关向量组$b_1,b_2,…,b_n$的所有整系数线性组合即：</p><script type="math/tex; mode=display">L(\mathbf{B})=\{\sum^{n}_{i=1}x_ib_i:x_i\in Z,i=1,...,n\}</script><p>向量组$\mathbf{b_1},\mathbf{b_2},…,\mathbf{b_n}$称为格的一组基，<strong>同一个格可以用不同的格基表示</strong>，即存在$y_i,\mathbf{c_i}$使得$L(\mathbf{B})=L(\mathbf{C})$，m称为格的维数，n称为格的秩。满足$m=n$的格称为满秩的。通常研究都是研究<strong>满秩的格</strong>也就是<code>m=n</code>这一情况。</p><p><strong>误区</strong>：对于格的定义来说，我们只规定了$x_i$必须为整数，而$\mathbf{b_i}$向量中的数可以不是整数。而格点其实是格中的向量，由于基向量进行加加减减运算后还是一个向量，这个向量其实是可以用坐标表示的。其几何意义就是从<code>(0,0)</code>通过这个向量指向坐标的一个点。所以<strong>格点其实是格向量</strong></p><p>对于格的定义来说，现在感觉还是很抽象，直接上图直接，对于格来说，其几何意义就是平面上、空间上离散而又规律的点。</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191007867.png" alt="image-20250913191007867"></p><p>而在空间中，也是许许多多有规律的点，在高中化学物质结构中的一些晶体是由原子构成的，都是这么画的有固定，规律的原子排布。（这么一想量子计算机也是从原子等微观角度出发，格是从这些散点出发，二者好像似乎有点联系唉？）</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191251506.png" alt="image-20250913191251506"></p><p><strong>这里还需要注意</strong>：不同的格基，可能生成的是相同的格</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191734643.png" alt="image-20250913191734643"></p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191742382.png" alt="image-20250913191742382"></p><p>注解1：从格的定义出发，如果认真学过线性代数就会发现，这个其实就是线性代数中向量空间基的表达方式。如果使用高中教材向量那一部分来说明的话那其实格的表达其实就相当于向量的一组基底表达。线性代数和高中所学的基底$\vec{c}=x\vec{a}+y\vec{b}$，线性代数的表达就不说了（大一线代没好好学都把时间花在学pwn那边了，所以现在回头再看高等代数。），而线代和高中所学的基底<code>x,y</code>的取值范围都是在实数范围之内的，而格这个定义$x_i\in Z$，说明向量前面的系数是整数。所以格才会是空间中离散的具有周期性的点的集合。</p><p>注解2：从格的引入其实可以知道格与几何关系比较密切；从格的定义来说格又是由向量定义的，向量又与矩阵有关，所以格与线性代数、高等代数关系又非常密切；继续从格的定义来说，基底向量的系数都是整数又彻到整数了，那就和初等数论也扯上关系了。（不知道这算不算强行扯关系，按照自己的理解是这样的）。格与以上的数学分支与基础都有关系，那么绝对与抽象代数也很有关系的。</p><p>注解3：既然格与这么多数学分支有联系，那么这些数学分支中的某些定理都可以使用到格上。而从格的定义使用向量定义并且也可以使用矩阵表示，那么其实矩阵、向量、向量空间的一些性质都<strong>可以使用到格上</strong>。<strong>可以毫不客气地说学格之前先把线性代数学好或者高等代数学好</strong>。</p></blockquote><p>通过对格的逐步了解，了解到了研究个一般研究满秩的格，这里还要做一点说明研究格的这一数学分支似乎被称为<strong>几何数论</strong>，<strong>数的几何引论</strong>，在2025.9.11找到了国内的一本书专门讲几何中的格，也就是传统意义上格用来研究的几何体堆叠问题<code>《数的几何引论》朱尧辰</code></p><blockquote><p><strong>格的基本体(基胞)</strong>：</p><p>格的基本体是由格基向量生成、并作为在$\R^n$中代表每个同余类的一个原胞。若格$\mathbf{L}$由线性无关的基向量$\mathbf{b<em>1},\mathbf{b_2},…,\mathbf{b_n}$生成即$L(\mathbf{B})={\sum^{n}</em>{i=1}x_ib_i:x_i\in Z,i=1,…,n}$，那么格的基本体则定义为：</p><script type="math/tex; mode=display">\mathbf{P(B)} =\{\sum_{i=1}^{n}t_i\mathbf{b_i}|0≤t_i<1\}</script><p><strong>误区</strong>：根据基胞的定义，$t_i$是在<code>0~1</code>任意取值的，这就说明，基胞是一个连续的区域，在二维上就是一个平面，在三维上其实就是一个立体图形。而格点或落在平面或者是立体图形的顶点上，并且图形内部是没有格点的。</p><p>如图所示，基胞其实是平行四边形阴影那部分，而格是平行四边形的四个顶点。</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913200242468.png" alt="image-20250913200242468"></p><p>将基胞进行平移整数个单位长度，平行四边形的四个顶点也会被移动到不同的地方，从而构成格。<br><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913200539519.png" alt="image-20250913200539519"></p><p>而到三维或者更高维的立体图形来说，其实可以用化学中物质结构进行类比。晶胞就相当于一个基胞，晶胞顶点上的原子就相当于格点，<strong>相同的基胞构成了晶格</strong>，而<strong>基胞平移会构成格</strong>。</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913200716037.png" alt="image-20250913200716037"></p></blockquote><p>由于研究的一般都是满秩格，而满秩格一般都会有行列式，接下来就需要介绍一下行列式对于格基本体来说的几何意义。</p><blockquote><p><strong>格的行列式的几何意义</strong>：</p><p>格的行列式$del(\mathbf{L})$的值定义为格基本体$\mathbf{P(B)} ={\sum_{i=1}^{n}t_i\mathbf{b_i}|0≤t_i&lt;1}$的有向面积或者说是有向体积。就比如下图，下图中$\mathbf{L} = x_1b_1+x_2b_2,x_1,x_2\in Z$，则$del(\mathbf{L})$的几何意义就是图中平行四边形的面积（但是带有正负号，具体正负要通过右手定则来判断。）</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913201336510.png" alt="image-20250913201336510"></p></blockquote><h2 id="优质基与劣质基"><a href="#优质基与劣质基" class="headerlink" title="优质基与劣质基"></a>优质基与劣质基</h2><ul><li>给定一组基向量，它可以通过整数倍的加加减减，得到一个格。但是这个基有好坏之分的，如何定义这个基的好坏呢？通过研究就有如下评判基的好坏的标准：</li></ul><blockquote><p>一组基如果很容易能表示出格中所有的点，那么这组基就是优质基。</p><p>一组基如果表示出格中所有的点非常困难，那么这组基就是劣质基。</p><p>注解：由于格是由基的整数倍加加减减，而不是实数倍加加减减，这就导致了对于有些基来说，表示一个靠近原点的格点，都需要<code>10000000v+20000000u</code>这么大的一个系数，也就是说有些格点非常难表示出来。</p></blockquote><ul><li>我们此时已经给优质基和劣质基下了一个定义，那么就我们就需要研究这两种基有什么特征（这样才能一看图片或者一把这一组基从图中画出来就能判断它是优质基还是劣质基了）。研究优质基和劣质基得到了如下特点：</li></ul><blockquote><p>劣质基具有的特点：</p><ol><li>长度差异非常大：基向量有的长度非常长、有的长度又非常短</li><li>基向量夹角接近共线：基向量之间的夹角接近共线，可以是非常接近<code>0°</code>，也可以是非常接近<code>180°</code></li></ol><p>优质基具有的特点：</p><ol><li>长度差异非常小：基向量的长度都大概差不多</li><li>基向量夹角接近正交：基向量之间的夹角接近<code>90°</code></li></ol></blockquote><ul><li>给出一个图所示：</li></ul><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914211846300.png" alt="image-20250914211846300"></p><ul><li>优质基生成的格，最典型的优质基其实就是正交向量</li></ul><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914211917982.png" alt="image-20250914211917982"></p><h2 id="格基规约"><a href="#格基规约" class="headerlink" title="格基规约"></a>格基规约</h2><ul><li>格基规约其实又被称为格基减约，它的英文称为<code>Lattice Basis Reduction</code>，这里就先简单了解一下格基规约的一个概念。</li></ul><blockquote><p>格基规约，都出现了<code>格基</code>了，那么肯定是对表示格的基向量做的操作。由于之前已经有说明了，一个格可以使用不同的基表示。而基有优质基和劣质基之分。那么给定一个劣质基表示的格，其实可以通过某种方法将该格使用优质基表示。</p><p>所以<strong>格基规约</strong>做了这么一件事情：将劣质基转换为优质基，并且俩个基表示的仍然是同一个格，这个操作就被称为格基规约。</p></blockquote><ul><li>对于格基规约来说，目前有俩个比较著名的算法即：LLL算法<code>Lenstra–Lenstra–Lovász lattice basis reduction</code>，BKZ算法<code>Block Korkine-Zolotarev lattice reduction</code></li></ul><h2 id="范数距离"><a href="#范数-距离" class="headerlink" title="范数(距离)"></a>范数(距离)</h2><ul><li>范数其实就指的是距离，从初一开始接触绝对值，一直到学了勾股定理之后得到了求平面直角坐标系两点之间的距离的方法。这其实就是最经典的<code>欧几里得距离</code>。<strong>对于后面所说的向量长度、距离等指的一般都是欧几里得距离</strong></li></ul><script type="math/tex; mode=display">AB = \sqrt{(x_A-x_B)^2+(y_A-y_B)^2}</script><ul><li>然后到高中一些奇奇怪怪的题，接触到了曼哈顿距离：</li></ul><script type="math/tex; mode=display">AB = |x_A-x_B|+|y_A-y_B|</script><ul><li>到了大学，在学习线性代数或者高等代数的时候，给距离取了一个新的名称<code>范数</code>英文名称为<code>norm</code>，并且给距离下了一个比较统一的定义：</li></ul><script type="math/tex; mode=display">\|\mathbf{x}\|_p=(\sum_{i=1}^{n}x^{p}_i)^{\frac{1}{p}}</script><ul><li>对于曼哈顿距离，其实就是<code>p=1</code>的情况：</li></ul><script type="math/tex; mode=display">\|\mathbf{x}\|_1=\sum_{i=1}^{n}|x_i|</script><ul><li>对于欧几里得距离<code>欧几里得范数</code>，其实就是<code>p=2</code>的情况：</li></ul><script type="math/tex; mode=display">\|\mathbf{x}\|_2 = \sqrt{<\mathbf{x},\mathbf{x}>}=\sqrt{\sum^{n}_{i=1}x_i^{2}}</script><ul><li>还有一种极限的情况如公式如下所示：</li></ul><script type="math/tex; mode=display">\|\mathbf{x}\|_{\infty}=\lim_{p \to \infty}\|\mathbf{x}\|_p=\max^{n}_{i=1}|x_i|</script><h1 id="格的基本问题"><a href="#格的基本问题" class="headerlink" title="格的基本问题"></a>格的基本问题</h1><h2 id="最短向量问题svp"><a href="#最短向量问题-SVP" class="headerlink" title="最短向量问题(SVP)"></a>最短向量问题(SVP)</h2><blockquote><p>最短向量问题<code>Short Vector Problem,SVP</code>：给定格$\mathbf{L}$，找一个非零格向量$\mathbf{v}$，满足对任意非零向量$\mathbf{u}\in \mathbf{L}$，有$||\mathbf{v}||≤||\mathbf{u}||$。</p><p>注解1：是给定一个格找它的最短向量，而不是给定一组基向量找它的最短向量，只不过我们使用一组基向量来描述整个格。</p><p>注解2：最短向量问题所描述的找一个<code>非零格向量</code>，这个向量有特地说明是<code>格向量</code>（格向量其实就是用基表示出来的，在图中其实就是格点）。也就是说，我们需要寻找的就是给定格中的一个点（也就是格向量），使得对于其他格$\mathbf{L}$的向量来说满足$||\mathbf{v}||≤||\mathbf{u}||$。</p><p>注解3：有时候<strong>最短向量不唯一</strong>，可能有多个。但是最短向量是<strong>成对出现的</strong>，因为如果找到了一个最短向量，那么它的相反向量其实也是一个最短向量。</p><p>注解4：对于一组优质基，该基向量中的其中一个向量很可能就是一个最短向量。对于一组劣质基，该基向量中的一个向量大概率都不是最短向量</p><p><strong>几何理解</strong>：这里直接给出二维的平面图来说明，SVP在二维上可以使用几何来理解。其实就是找到一个格点，以该格点与原点的距离为半径，以原点为圆心，画出一个圆。这个圆满足如下两个条件：</p><ol><li>该圆的内部除了原点外，不能有其他格点</li><li>格点要么在该圆的圆外，要么在该圆的圆上，而在圆上的点其实就是我们要找的最短向量。</li></ol><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914203603318.png" alt="image-20250914203603318"></p><p>有的时候一个格的最短向量并不唯一</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914204048964.png" alt="image-20250914204048964"></p><ul><li>下面这个是劣质基寻找最短向量的一个例图</li></ul><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914205647979.png" alt="image-20250914205647979"></p></blockquote><p>类比：个人感觉找最短向量问题有点和寻找模意义下的指数有点像。（好像更准确的来说是寻找模意义下给定一个底数，求这个底数的模幂运算的阶？）</p><h2 id="r-近似最短向量问题r-svp"><a href="#r-近似最短向量问题-r-SVP" class="headerlink" title="r-近似最短向量问题(r-SVP)"></a>r-近似最短向量问题(r-SVP)</h2><p>&gt;<br>&gt;<br>&gt;</p><h2 id="逐次最小长度问题smp"><a href="#逐次最小长度问题-SMP" class="headerlink" title="逐次最小长度问题(SMP)"></a>逐次最小长度问题(SMP)</h2><h2 id="最短线性无关向量问题sivp"><a href="#最短线性无关向量问题-SIVP" class="headerlink" title="最短线性无关向量问题(SIVP)"></a>最短线性无关向量问题(SIVP)</h2><h2 id="唯一最短向量问题usvp-r"><a href="#唯一最短向量问题-uSVP-r" class="headerlink" title="唯一最短向量问题(uSVP-r)"></a>唯一最短向量问题(uSVP-r)</h2><h2 id="最近向量问题cvp"><a href="#最近向量问题-CVP" class="headerlink" title="最近向量问题(CVP)"></a>最近向量问题(CVP)</h2><h2 id="有界距离解码问题bdd-r"><a href="#有界距离解码问题-BDD-r" class="headerlink" title="有界距离解码问题(BDD-r)"></a>有界距离解码问题(BDD-r)</h2><h2 id="判断版本r-近似最短问题gapsvp-r"><a href="#判断版本r-近似最短问题-GapSVP-r" class="headerlink" title="判断版本r-近似最短问题(GapSVP-r)"></a>判断版本r-近似最短问题(GapSVP-r)</h2><h1 id="格相关算法"><a href="#格相关算法" class="headerlink" title="格相关算法"></a>格相关算法</h1><h1 id="格密码相关问题"><a href="#格密码相关问题" class="headerlink" title="格密码相关问题"></a>格密码相关问题</h1><h2 id="小整数解问题sis问题"><a href="#小整数解问题-SIS问题" class="headerlink" title="小整数解问题(SIS问题)"></a>小整数解问题(SIS问题)</h2><h3 id="隐藏子集问题hssp"><a href="#隐藏子集问题-HSSP" class="headerlink" title="隐藏子集问题(HSSP)"></a>隐藏子集问题(HSSP)</h3><h2 id="容错学习lwe问题"><a href="#容错学习-LWE问题" class="headerlink" title="容错学习(LWE问题)"></a>容错学习(LWE问题)</h2><h3 id="rlwe问题"><a href="#RLWE问题" class="headerlink" title="RLWE问题"></a>RLWE问题</h3><h3 id="mlwe问题"><a href="#MLWE问题" class="headerlink" title="MLWE问题"></a>MLWE问题</h3><h2 id="隐藏数问题hnp"><a href="#隐藏数问题-HNP" class="headerlink" title="隐藏数问题(HNP)"></a>隐藏数问题(HNP)</h2><h2 id="ntru问题"><a href="#NTRU问题" class="headerlink" title="NTRU问题"></a>NTRU问题</h2><h2 id="agcd问题"><a href="#AGCD问题" class="headerlink" title="AGCD问题"></a>AGCD问题</h2>]]></content>
    
    
    <summary type="html">前言：非常想入门格</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="格密码理论" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%A0%BC%E5%AF%86%E7%A0%81%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>高等代数-行列式</title>
    <link href="http://iyheart.github.io/2025/09/09/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <id>http://iyheart.github.io/2025/09/09/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/</id>
    <published>2025-09-09T04:52:15.000Z</published>
    <updated>2025-09-09T08:08:47.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行列式的引入"><a href="#行列式的引入" class="headerlink" title="行列式的引入"></a>行列式的引入</h1><ul><li>前面阶梯形矩阵提供了判断方程组的解的办法，但是求出一个矩阵的阶梯形矩阵几乎都已经将方程解出来了，那还要判断方程组的解干嘛。</li><li>所以<strong>为了更容易的得出一个方程组解的情况</strong>，这个时候就需要先利用矩阵去研究了。先来研究二元一次方程组，该方程组如下，其中$a<em>{11}、a</em>{21}$不全为0,那不妨设$a_{11}\not=0$。</li></ul><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2&=b_1\\a_{21}x_1+a_{22}x_2&=b_2\\\end{cases}</script><ul><li>将它化成增广矩阵后就如下图所示：</li></ul><script type="math/tex; mode=display">\begin{bmatrix}a_{11}&a_{12}&b_1\\a_{21}&a_{22}&b_2\end{bmatrix}</script><ul><li>​    使用初等行变换就转化成了阶梯形矩阵，通分一下，就会出现两种情况：</li></ul><script type="math/tex; mode=display">\begin{bmatrix}a_{11} & a_{12} & b_1\\0&a_{22}-\frac{a_{21}}{a_{11}}a_{12}&b_2-\frac{a_{21}}{a_{11}}b_1\end{bmatrix}\\\Rightarrow\begin{bmatrix}a_{11} & a_{12} & b_1\\0&\frac{a_{11}a_{22}-a_{21}a_{12}}{a_11}&b_2-\frac{a_{21}}{a_{11}}b_1\end{bmatrix}</script><ul><li>情况1：$a<em>{11}a</em>{22}-a<em>{12}a</em>{21}\not=0$，此时根据上一章方程组解的情况就可以得到该方程有唯一解：</li></ul><script type="math/tex; mode=display">(\frac{b_1a_{22}-b_2a_{12}}{a_{11}a_{22}-a_{12}a_{21}},\frac{a_{11}b_2-a_{21}b_1}{a_{11}a_{22}-a_{12}a_{21}})</script><ul><li>情况2：$a<em>{11}a</em>{22}-a<em>{12}a</em>{21}=0$，此时原方程组无解或者有无穷多个解。</li></ul><blockquote><p><strong>行列式</strong>：</p><p>此时对于$a<em>{11}a</em>{22}-a<em>{12}a</em>{21}$就使用如下的一个记号，矩阵2级矩阵$\mathbf{A}$的行列式，记作$|A|$或者$det\mathbf{A}$：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11} & a_{12} \\a_{21} & a_{22}\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}</script><p>注解：行列式是一个数</p><p><strong>命题1</strong>：</p><p>两个方程的二元一次方程组有唯一解的充分必要条件是：它的系数矩阵$\mathbf{A}$的行列式(简称为<strong>系数行列式</strong>)$|A|\not=0$，此时它的唯一解是：</p><script type="math/tex; mode=display">(\frac{b_1a_{22}-b_2a_{12}}{a_{11}a_{22}-a_{12}a_{21}},\frac{a_{11}b_2-a_{21}b_1}{a_{11}a_{22}-a_{12}a_{21}})'</script></blockquote><h1 id="n元排列"><a href="#n元排列" class="headerlink" title="n元排列"></a>n元排列</h1><blockquote><p><strong>定义1</strong>：</p><p><code>1,2,...,n</code>的一个全排列称为一个n元排列（或n个不同正整数的全排列称为一个n元排列），而<code>1,2,...,n</code>形成的n元排列有<code>n!</code>个，例如：<code>3</code>元排列有<code>123,132,213,231,312,321</code></p><p><strong>定义2</strong>：</p><p>对于一个四元排列<code>2431</code>，从左到右数，顺序（从小到大）的数对有：<code>24</code>、<code>23</code>。从左到右数，逆序（从大到小）的数对有：<code>21,43,41,31</code>。像这样在一个<code>n</code>元排列中<strong>逆序的数对的数目称为逆序数</strong>，记作$\tau(2431)=4$</p><p><strong>定义3</strong>：</p><p>逆序数是偶数的排列称为<strong>偶排列</strong>。</p><p>逆序数是奇数的排列称为<strong>奇排列</strong>。</p><p><strong>定义4</strong>：</p><p>将<code>2431</code>的<code>4</code>和<code>1</code>交换位置，使其变成<code>2134</code>的这个操作称为<strong>对换</strong>，记作$(4,1)$。</p><p><strong>定理1</strong>：</p><p>对换改变n元排列的奇偶性</p><p><strong>定理2</strong>：</p><p>任一n元排列与排列<code>123...n</code>可以经过一系列对换互变，并且所作对换的次数与这个n元排列有相同的奇偶性。</p></blockquote><h1 id="n阶行列式"><a href="#n阶行列式" class="headerlink" title="n阶行列式"></a>n阶行列式</h1><blockquote><p><strong>定义1</strong>：</p><p>n阶行列式$\begin{vmatrix}a<em>{11}&amp;a</em>{12}&amp;…&amp;a<em>{1n}\ a</em>{21}&amp;a<em>{22}&amp;…&amp;a</em>{2n} \…&amp;…&amp;…&amp;…\ a<em>{n1}&amp;a</em>{n2}&amp;…&amp;a_{nn}\end{vmatrix}$是<code>n!</code>项的代数和，其中每一项是不同行，不同列的n个元素的乘积，每一项按行指标成自然序排好位置，当列指标形成的排列是偶排列时，该项带正号，当列指标形成的排列是奇排列，该项带负号。</p><p>$\begin{vmatrix}a<em>{11}&amp;a</em>{12}&amp;…&amp;a<em>{1n}\ a</em>{21}&amp;a<em>{22}&amp;…&amp;a</em>{2n}\…&amp;…&amp;…&amp;…\ a<em>{n1}&amp;a</em>{n2}&amp;…&amp;a<em>{nn}\end{vmatrix}=\sum</em>{j<em>1j_2…j_n}(-1)^{\tau(j_1j_2…j_n)}a</em>{1j<em>1}a</em>{2j<em>2}…a</em>{nj_n}$。行列式其实是右边这个求和表达式的一个简洁记号。</p><p><strong>定义2</strong>：</p><p>n阶行列式$\begin{vmatrix}a<em>{11}&amp;a</em>{12}&amp;…&amp;a<em>{1n}\ a</em>{21}&amp;a<em>{22}&amp;…&amp;a</em>{2n} \…&amp;…&amp;…&amp;…\ a<em>{n1}&amp;a</em>{n2}&amp;…&amp;a<em>{nn}\end{vmatrix}$也称为n阶矩阵$\mathbf{A}=\begin{bmatrix}a</em>{11}&amp;a<em>{12}&amp;…&amp;a</em>{1n}\a<em>{21}&amp;a</em>{22}&amp;…&amp;a<em>{2n}\…&amp;…&amp;…&amp;…\a</em>{n1}&amp;a<em>{n2}&amp;…&amp;a</em>{nn}\end{bmatrix}$的行列式，记作$|\mathbf{A}|$，$det\mathbf{A}$，简记成$\mathbf{A}=(a<em>{ij})$其中$a</em>{ij}$为A的$(i,j)$元</p><p><strong>定义3</strong>：上三角形行列式</p><p>主对角线下方元素全为0的n阶行列式称为上三角形行列式。（下三角形行列式：主对角线上方的元素全为0的n阶行列式）</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}&...&a_{1,n-1}&a_{1,n}\\0&a_{22}&...&a_{2,n-1}&a_{2,n}\\0&0&a_{33}&...&a_{3,n}\\...&...&...&...&...\\0&0&...&a_{n-1,n-1}&a_{n-1,n}\\0&0&...&0&a_{n,n}\end{vmatrix}</script><p>一些行列式的计算：</p><p><strong>一阶行列式</strong>：</p><p>$|a|=a$</p><p><strong>二阶行列式</strong>：</p><p>$\begin{vmatrix}a<em>{11}&amp;a</em>{12}\ a<em>{21}&amp;a</em>{22}\end{vmatrix}=a<em>{11}a</em>{22}-a<em>{12}a</em>{21}$</p><p><strong>三阶行列式</strong>：</p><p>三元排列偶排列：<code>123,231,312</code></p><p>三元排列奇排列：<code>132,213,321</code></p><p>$\begin{vmatrix}a<em>{11}&amp;a</em>{12}&amp;a<em>{13}\ a</em>{21}&amp;a<em>{22}&amp;a</em>{23}\ a<em>{31}&amp;a</em>{32}&amp;a<em>{33}\end{vmatrix}=a</em>{11}a<em>{22}a</em>{33}+a<em>{12}a</em>{23}a<em>{31}+a</em>{13}a<em>{21}a</em>{32}-a<em>{11}a</em>{23}a<em>{32}-a</em>{12}a<em>{21}a</em>{33}-a<em>{13}a</em>{22}a_{31}$</p><p><strong>上三角形行列式</strong>：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}&...&a_{1,n-1}&a_{1,n}\\0&a_{22}&...&a_{2,n-1}&a_{2,n}\\0&0&a_{33}&...&a_{3,n}\\...&...&...&...&...\\0&0&...&a_{n-1,n-1}&a_{n-1,n}\\0&0&...&0&a_{n,n}\end{vmatrix}=a_{11}a_{22}...a_{nn}</script><p>命题1：上三角形行列式的值等于它的主对角线上n个元素的乘积。</p></blockquote><h1 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h1><blockquote><p><strong>定义1</strong>：矩阵的转置</p><p>设n阶矩阵$\mathbf{A}=(a<em>{i,j})=\begin{bmatrix}a</em>{11}&amp;a<em>{12}&amp;…&amp;a</em>{1n}\ a<em>{21}&amp;a</em>{22}&amp;…&amp;a<em>{2n}\…&amp;…&amp;…&amp;…\ a</em>{n1}&amp;a<em>{n2}&amp;…&amp;a</em>{nn}\end{bmatrix}$把行列互换得到的矩阵$\begin{bmatrix}a<em>{11}&amp;a</em>{21}&amp;…&amp;a<em>{n1}\a</em>{12}&amp;a<em>{22}&amp;…&amp;a</em>{n2}\…&amp;…&amp;…&amp;…\a<em>{1n}&amp;a</em>{2n}&amp;…&amp;a_{nn}\end{bmatrix}$称为A的转置，记作$A’$或$A^{T}$或$A^{t}$</p><p><strong>行列式的性质</strong>：</p><p><strong>性质1</strong>：转置的行列式与原先行列式值相等，即：$|A’|=|A|$</p><p><strong>性质2</strong>：行列式一行的公因子可以提出去，即（k=0也成立）：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\\vdots&\vdots&&\vdots\\ka_{i1}&ka_{i2}&...&ka_{in}\\\vdots&\vdots&&\vdots\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix}=k\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\\vdots&\vdots&&\vdots\\a_{i1}&a_{i2}&...&a_{in}\\\vdots&\vdots&&\vdots\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix}</script><p><strong>性质3</strong>：</p><p>行列式中若某一行是两组数的和，则此行列式等于两个行列式的和，这两个行列式的这一行分别是第一组数和第二组数，而其余各行与原来行列式的相应各行相同，即：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\\vdots&\vdots&&\vdots\\b_1+c_1&b_2+c_2&...&b_n+c_n\\\vdots&\vdots&&\vdots\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix}=\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\\vdots&\vdots&&\vdots\\b_1&b_2&...&b_{n}\\\vdots&\vdots&&\vdots\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix}+\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\\vdots&\vdots&&\vdots\\c_1&c_2&...&c_{n}\\\vdots&\vdots&&\vdots\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix}</script><p><strong>性质4</strong>：</p><p>两行互换，行列式反号，即：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\\vdots&\vdots&&\vdots\\a_{i1}&a_{i2}&...&a_{in}\\\vdots&\vdots&&\vdots\\a_{k1}&a_{k2}&...&a_{kn}\\\vdots&\vdots&&\vdots\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix}=-\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\\vdots&\vdots&&\vdots\\a_{k1}&a_{k2}&...&a_{kn}\\\vdots&\vdots&&\vdots\\a_{i1}&a_{i2}&...&a_{in}\\\vdots&\vdots&&\vdots\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix}</script><p><strong>性质5</strong>：</p><p>两行相同，行列式的值为0，即：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\\vdots&\vdots&&\vdots\\a_{i1}&a_{i2}&...&a_{in}\\\vdots&\vdots&&\vdots\\a_{i1}&a_{i2}&...&a_{in}\\\vdots&\vdots&&\vdots\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix}=0</script><p><strong>性质6</strong>：</p><p>两行成比例，行列式的值为0，即：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\\vdots&\vdots&&\vdots\\a_{i1}&a_{i2}&...&a_{in}\\\vdots&\vdots&&\vdots\\la_{i1}&la_{i2}&...&la_{in}\\\vdots&\vdots&&\vdots\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix}=0</script><p><strong>性质7</strong>：</p><p>把一行的倍数加到另一行上，行列式的值不变，即：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\\vdots&\vdots&&\vdots\\a_{i1}&a_{i2}&...&a_{in}\\\vdots&\vdots&&\vdots\\a_{k1}+la_{i1}&a_{k2}+la_{i2}&...&a_{kn}+la_{in}\\\vdots&\vdots&&\vdots\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix}=\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\\vdots&\vdots&&\vdots\\a_{i1}&a_{i2}&...&a_{in}\\\vdots&\vdots&&\vdots\\a_{k1}&a_{k2}&...&a_{kn}\\\vdots&\vdots&&\vdots\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix}</script></blockquote><h1 id="行列式按行列展开"><a href="#行列式按行-列-展开" class="headerlink" title="行列式按行(列)展开"></a>行列式按行(列)展开</h1><ul><li>行列式按行（列）展开的本质其实就是对行列式的展开做变形。</li></ul><blockquote><p>$|\mathbf{A}|=\begin{vmatrix}a<em>{11}&amp;a</em>{12}&amp;a<em>{13}\a</em>{21}&amp;a<em>{22}&amp;a</em>{23}\a<em>{31}&amp;a</em>{32}&amp;a<em>{33}\end{vmatrix}=(a</em>{11}a<em>{22}a</em>{33}-a<em>{11}a</em>{23}a<em>{32})+(a</em>{12}a<em>{23}a</em>{31}-a<em>{12}a</em>{21}a<em>{33})+(a</em>{13}a<em>{21}a</em>{32}-a<em>{13}a</em>{22}a_{31})$</p><p>$|\mathbf{A}|=a<em>{11}\begin{vmatrix}a</em>{22}&amp;a<em>{23}\a</em>{32}&amp;a<em>{33}\end{vmatrix}-a</em>{12}\begin{vmatrix}a<em>{21}&amp;a</em>{23}\a<em>{31}&amp;a</em>{33}\end{vmatrix}+a<em>{13}\begin{vmatrix}a</em>{21}&amp;a<em>{22}\a</em>{31}&amp;a_{32}\end{vmatrix}$</p><p><strong>定义1</strong>：</p><p>n级矩阵$\mathbf{A}$中，划去第i行和第j列，剩下的元素按照原来的次序组成<code>n-1</code>级矩阵的行列式称为矩阵$\mathbf{A}$的<code>(i,j)</code>元的<strong>余子式</strong>，记作$M<em>{ij}$。令$A</em>{ij}=(-1)^{i+j}M<em>{ij}$，则$A</em>{ij}$是$\mathbf{A}$的<code>(i,j)</code>元的代数余子式。</p></blockquote><ul><li>从行列式的按行展开推导出了如下几个定理：</li></ul><blockquote><p><strong>定理1</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$等于它的第i行元素与自己的代数余子式的乘积之和。$|\mathbf{A}|=a<em>{i1}A</em>{i1}+a<em>{i2}A</em>{i2}+…+a<em>{in}A</em>{in}=\sum<em>{j=1}^{n}a</em>{ij}A_{ij}$其中$i\in{1,2,…,n}$，该式子被陈伟n阶行列式的第i行的展开式</p><p><strong>定理2</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$等于它的第j列元素与自己的代数余子式的乘积之和，即：$|\mathbf{A}|=a<em>{1j}A</em>{1j}+a<em>{2j}A</em>{2j}+…+a<em>{nj}A</em>{nj}=\sum<em>{l=1}^{n}a</em>{lj}A_{lj}$</p><p><strong>定理3</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$的第i行元素与第k行($k≠i$)相应元素的代数余子式的乘积之和为0，即：$a<em>{i1}A</em>{k1}+a<em>{i2}A</em>{k2}+…+a<em>{in}A</em>{kn}=0$，当$k≠i$</p><p><strong>定理4</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$的第j列元素与第l列($l≠j$)相应元素的代数余子式的乘积之和为0，即：$a<em>{1j}A</em>{1l}+a<em>{2j}A</em>{2l}+…+a<em>{nj}A</em>{nl}=0$，当$l≠j$</p></blockquote><ul><li>特殊的行列式——范德蒙行列式</li></ul><p>&gt;<br>&gt;<br>&gt;</p><h1 id="克拉默cramer法则"><a href="#克拉默-Cramer-法则" class="headerlink" title="克拉默(Cramer)法则"></a>克拉默(Cramer)法则</h1><blockquote><p><strong>定理1</strong>：</p><p>数域$\mathbf{K}$上的n个方程的n元线性方程组有唯一解的充分必要条件是它的系数行列式（即系数矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$）不等于0。即<code>n级矩阵的初等行变换不改变它们的行列式的非零性质</code></p><p><strong>推论1</strong>：</p><p>数域$\mathbf{K}$上的n个方程的n元齐次线性方程组只有零解的充分必要条件是它的系数行列式不等于0，从而它有非零解的充分必要条件是它的系数行列式等于0。</p><p><strong>定理2</strong>：</p><p>记矩阵$\mathbf{B}<em>j,j=1,2,3…,n$即，$\mathbf{B_j=\begin{bmatrix}a</em>{11} &amp;…&amp;a<em>{1,j-1}&amp;b_1&amp;a</em>{1,j+1}&amp;…&amp;a<em>{1n}\ a</em>{21}&amp;…&amp;a<em>{2,j-1}&amp;b_2&amp;a</em>{2,j+1}&amp;…&amp;a<em>{2n}\ \vdots&amp;&amp;\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\ a</em>{n1}&amp;…&amp;a<em>{n,j-1}&amp;b_n&amp;a</em>{2,j+1}&amp;…&amp;a_{nn}\end{bmatrix}}$。那么就有n个方程的n元线性方程组的系数</p><p>行列式$|\mathbf{A}|≠0$时，它的唯一解是：$(\frac{|B_1|}{|A|},\frac{|B_2|}{|A|},…,\frac{|B_n|}{|A|})$</p></blockquote><h1 id="行列式按k行列展开"><a href="#行列式按k行-列-展开" class="headerlink" title="行列式按k行(列)展开"></a>行列式按k行(列)展开</h1><blockquote><p><strong>定义1</strong>：</p><p>n级矩阵$\mathbf{A}$中任意取定k行，k列$1\le k &lt; n$，位于这些行和列的交叉处的$k^2$个元素按原来的排法组成的<code>k</code>级矩阵的行列式称为$\mathbf{A}$的一个k阶子式。取定$\mathbf{A}$的第$i_1,i_2,…,i_k$行（$i_1&lt;i_2&lt;…&lt;i_k$），第$j_1,j_2,…,j_k$列（$j_1&lt;j_2&lt;….&lt;j_k$），所得到的k阶子式记作$\mathbf{A}\begin{bmatrix}i_1,i_2,…,i_k\ j_1,j_2,…,j_k\end{bmatrix}$。</p><p>划去这个k阶子式所在的行和列，剩下的元素原来的排法组成的<code>(n-k)</code>级矩阵的行列式称为<strong>余子式</strong>，它前面乘以$(-1)^{(i_1+i_2+…+i_k)+(j_1+j_2+…+j_k)}$则称为子式的<strong>代数余子式</strong>。</p><p>令${i’<em>1,i’_2,…,i’</em>{n-k}}={1,2,…,n}/{i<em>1,i_2,…,i_k}$，${j’_1,j’_2,…,j’</em>{n-k}}={1,2,3..,n}/{i<em>1,i_2,…,i_k}$，并且$i_1’&lt;i_2’&lt;…&lt;i’</em>{n-k},j’<em>1&lt;j’_2&lt;…&lt;j’</em>{n-k}$，则子式的余子式为$A\begin{bmatrix}i’_1,i’_2,…,i’_n\ j’_1,j’_2,…,j’_n\end{bmatrix}$</p><p><strong>定理1</strong>(Laplace定理，即拉普拉斯定理)：</p><p>在n级矩阵$|\mathbf{A}|$中，取定第$i<em>1,i_2,…,i_k$行（$i_1&lt;i_2&lt;…&lt;i_k$），则这k行元素形成的所有k阶子式与它们自己的代数余子式的乘积之和等于$|\mathbf{A}|$，即$|\mathbf{A}|=\sum</em>{1\le j_1&lt;j_2&lt;…&lt;j_k\le n}\mathbf{A}\begin{bmatrix}i_1,i_2,…,i_k\ j_1,j_2,…,j_k\end{bmatrix}(-1)^{(i_1+…+i_k)+(j_1+…+j_k)}A\begin{bmatrix}i’_1,i’_2,…,i’_n\ j’_1,j’_2,…,j’_n\end{bmatrix}$</p></blockquote>]]></content>
    
    
    <summary type="html">前言：继续</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN-trick-exit函数利用</title>
    <link href="http://iyheart.github.io/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/"/>
    <id>http://iyheart.github.io/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/</id>
    <published>2025-09-07T06:05:08.000Z</published>
    <updated>2025-09-10T23:54:39.809Z</updated>
    
    <content type="html"><![CDATA[<ul><li>碎碎念：之前看到打exit的题目都有点不太像去看，这周尝试去看了一题打exit的，虽然没打出来但是在牢题目的时候大致了解了<code>exit</code>的大致流程，也知道了哪些地方可以进行利用。并且还了解了<code>exit</code>函数，在系统调用<code>exit</code>之前会进行一个<code>IO_FILE</code>的刷新流。所以类似于<code>house of apple</code>这种堆利用基本上也快可以理解了。</li><li>在打exit的时候也尝试去劫持<code>vtable</code>，虽然也没利用成功，但是也理解了<code>FSOP</code>的相关利用方式，感觉堆的<code>30</code>种类型应该这个学期就能结束了。（结束了就开内核了，有点单线程，在堆没结束前不太想碰其他的pwn题。）</li><li>参考博客：<a href="https://www.anquanke.com/post/id/243196">exit（）分析与利用-安全KER - 安全资讯平台</a></li></ul><h1 id="exit函数执行流程结束时"><a href="#exit函数执行流程-结束时" class="headerlink" title="exit函数执行流程(结束时)"></a>exit函数执行流程(结束时)</h1><ul><li><p><code>exit()</code>函数的源码位于<code>glibc-2.35\stdlib\exit.c</code>，在<code>exit()</code>函数调用的还会用到<code>exit.h</code>、</p></li><li><p>由于低版本的堆由于<code>hook</code>函数，利用还是比较容易的，所以这个<code>exit()</code>函数，就使用<code>glibc2.35</code>版本的源码进行调试（刚好本地Ubuntu的libc版本其实也是<code>glibc2.35</code>），本地就有现成环境。</p></li><li><p>首先总体介绍一下<code>exit()</code>函数的调用流程，注意<code>glibc中的exit()</code>和<code>exit系统调用</code>需要区分开来：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>()-&gt;</span><br><span class="line">__run_exit_handlers()-&gt;</span><br><span class="line">    __call_tls_dtors()</span><br><span class="line">    __libc_atexit()</span><br><span class="line">_exit() <span class="comment">// 执行exit系统调用</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250909180658225.png" alt="image-20250909180658225"></p><h2 id="exit函数两个重要结构体"><a href="#exit函数两个重要结构体" class="headerlink" title="exit函数两个重要结构体"></a>exit函数两个重要结构体</h2><ul><li>在介绍<code>exit</code>函数执行流程之前，需要介绍两个结构体，以便于理解<code>exit()</code>函数的执行过程。</li><li>结构体1：<code>exit_function</code>结构体，这里其实是一个注册函数的结构体。</li><li>程序在启动的时候会注册许多函数，这些函数在程序运行结束的时候调用<code>exit()</code>的时候就会被<code>exit()</code>函数一个一个的执行过去，主要目的是在退出程序的时候可以自动执行一些清理操作，从而达到自动释放资源的目的。</li><li><code>exit_function</code>结构体主要就两个东西：<ul><li><code>flavor</code>变量：用于表示是否有注册函数，<code>flavor=0</code>时表示没有注册函数，<code>flavor=1</code>的时候表示存在注册函数，该函数没有参数传递进去。<code>flavor=2</code>的时候表示存在注册函数，该函数调用时带有参数。<code>flavor=3</code>的时候表示存在注册函数，该函数是<code>C++</code>的析构函数。</li><li><code>析构函数</code>：C++在使用类模版创建了一个实例对象之后，程序结束后需要调用该析构函数释放这个实例对象。</li><li><code>func</code>这个联合体：存储着函数指针，需要传递的参数，以及析构函数的<code>void *dso_handle;</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="type">void</span> (*at) (<span class="type">void</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">  &#125; on;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">void</span> *dso_handle;</span><br><span class="line">  &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>结构体2：<code>exit_function_list</code>，用于管理注册函数的链表，是单向链表，其结构体如图所示。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250909183535553.png" alt="image-20250909183535553"></p><ul><li>程序在执行main函数之前调用了<code>glibc</code>中的某些函数来注册函数，而<code>glibc</code>也向用户提供了<code>atexit()、on_exit()、__cxa_atexit()</code>这三个注册函数，使得我们在<code>Linux</code>编写<code>C</code>程序的时候也能注册属于自己的一些函数。注意：注册的函数按照栈结构进行调用，也就是<strong>后面注册的函数，会先被执行</strong><ul><li><code>atexit()</code>函数注册的是无参函数</li><li><code>on_exit()</code>函数注册的是带参数的函数</li><li><code>__cxa_atexit()</code>函数注册的是析构函数</li></ul></li><li>先注册一个无参函数并调试看看</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个无参函数,该函数会在程序执行结束后执行</span></span><br><span class="line"><span class="comment">// int atexit(void (*func)(void))</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_atexit1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is my_atexit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (atexit(my_atexit1) !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;atexit() error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program is over\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910192635113.png" alt="image-20250910192635113"></p><p>在调用<code>atexit</code>之前进行查看<code>initial</code>这个结构体，该结构体就是libc中存储注册函数的结构体，也就是这个结构体<code>exit_function_list</code></p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910192940226.png" alt="image-20250910192940226"></p><p>调用<code>atexit</code>后，该结构体的<code>fns</code>就会多出来一个结构体，并且<code>idx</code>也会变成<code>2</code>，还会发现<code>at</code>这个函数指针并不是真实的函数地址是被加密过的函数地址。</p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910193208482.png" alt="image-20250910193208482"></p><ul><li>接下来再注册一个带参数的函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int on_exit(void (* function) (int void*), void *arg);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_atexit2</span><span class="params">(<span class="type">int</span> status,<span class="type">void</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bye~ %s\n&quot;</span>,(<span class="type">char</span>*)s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *msg = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (on_exit(my_atexit2,msg) !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;atexit() error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program is over\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910194011806.png" alt="image-20250910194011806"></p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910194054142.png" alt="image-20250910194054142"></p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910194112657.png" alt="image-20250910194112657"></p><ul><li>第三个就不举例了，接下来还需要看看，如果函数注册满了<code>32</code>个之后，还有函数需要注册那么这些函数会放在哪里呢？下面这个程序探究一下这个。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_atexit1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is my_atexit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">35</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (atexit(my_atexit1) !=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;atexit() error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program is over\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调试情况如下，当超过<code>32</code>个的时候，再进行函数的注册就会申请堆块用做后续的注册。</li></ul><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910195402776.png" alt="image-20250910195402776"></p><ul><li>而这个堆块的<code>next</code>指针，指向的是<code>initial</code>这个结构体，也就是位于<code>glibc</code>中的<code>exit_function_list</code>。所以从某种程度上说明了后注册的函数先被调用。当只有<code>initial</code>这个结构体存在，还是后被注册的函数先被执行。</li></ul><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910195639862.png" alt="image-20250910195639862"></p><h2 id="exit函数源码"><a href="#exit函数源码" class="headerlink" title="exit函数源码"></a>exit函数源码</h2><ul><li>源码如下：首先是一个简单的封装<code>exit()</code>函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure><ul><li>接下来就是<code>__run_exit_handlers()</code>函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">     <span class="type">bool</span> run_list_atexit, <span class="type">bool</span> run_dtors)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (run_dtors)</span><br><span class="line">      __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Exit processing complete.  We will not allow any more</span></span><br><span class="line"><span class="comment">     atexit/on_exit registrations.  */</span></span><br><span class="line">  __exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">      <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">      <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">      <span class="type">void</span> *arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ef_free:</span><br><span class="line">    <span class="keyword">case</span> ef_us:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_on:</span><br><span class="line">      onfct = f-&gt;func.on.fn;</span><br><span class="line">      arg = f-&gt;func.on.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      onfct (status, arg);</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_at:</span><br><span class="line">      atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      atfct ();</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_cxa:</span><br><span class="line">      <span class="comment">/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span></span><br><span class="line"><span class="comment"> we must mark this function as ef_free.  */</span></span><br><span class="line">      f-&gt;flavor = ef_free;</span><br><span class="line">      cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">      arg = f-&gt;func.cxa.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      cxafct (arg, status);</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))</span><br><span class="line">    <span class="comment">/* The last exit function, or another thread, has registered</span></span><br><span class="line"><span class="comment">       more exit functions.  Start the loop over.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      *listp = cur-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">   allocate element.  */</span></span><br><span class="line"><span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">    RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">  _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="__call_tls_dtors"><a href="#call-tls-dtors" class="headerlink" title="__call_tls_dtors"></a>__call_tls_dtors</h3><ul><li>首先会调用一个比较关键的函数<code>__call_tls_dtors ()</code>，该函数与<strong>线程局部存储</strong>有关。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先调用TLS析构函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (run_dtors)</span><br><span class="line">      __call_tls_dtors ();</span><br></pre></td></tr></table></figure><h3 id="调用注册函数"><a href="#调用注册函数" class="headerlink" title="调用注册函数"></a>调用注册函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">        <span class="type">const</span> <span class="type">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">            <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">            <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">            <span class="type">void</span> *arg;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ef_free:</span><br><span class="line">            <span class="keyword">case</span> ef_us:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ef_on:</span><br><span class="line">              onfct = f-&gt;func.on.fn;</span><br><span class="line">              arg = f-&gt;func.on.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">              PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">              onfct (status, arg);</span><br><span class="line">              __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">case</span> ef_at:</span><br><span class="line">              atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">              PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">              atfct ();</span><br><span class="line">              __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> ef_cxa:</span><br><span class="line">              f-&gt;flavor = ef_free;</span><br><span class="line">              cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">              arg = f-&gt;func.cxa.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">              PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">              cxafct (arg, status);</span><br><span class="line">              __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    *listp = cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">free</span> (cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷新io缓冲区"><a href="#刷新IO缓冲区" class="headerlink" title="刷新IO缓冲区"></a>刷新IO缓冲区</h3><ul><li>最后在<code>_exit(status)</code>执行之间还会有<code>RUN_HOOK (__libc_atexit, ());</code>，我们会在<code>/libio/genops.c</code>中找到<code>__libc_atexit</code>这个函数。这里还出现了<code>_IO_cleanup</code>以及<code>text_set_element</code>宏定义</li><li>而<code>__libc_atexit</code>其实是位于libc中的一个段（即一块内存空间，该空间名为<code>__libc_atexit</code>）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text_set_element(__libc_atexit, _IO_cleanup);</span><br></pre></td></tr></table></figure><ul><li>而这个宏定义出现在<code>glibc-2.35\glibc-2.35\include\libc-symbols.h</code></li><li>这个宏定义其实就是将<code>_IO_cleanup</code>，写入到<code>__libc_atexit</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make SYMBOL, which is in the text segment, an element of SET.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> text_set_element(set, symbol)_elf_set_element(set, symbol)</span></span><br></pre></td></tr></table></figure><ul><li>最后在回到<code>RUN_HOOK (__libc_atexit, ());</code>这个位置其实就很好理解了。这个代码其实执行的就是<code>_IO_cleanup</code>。</li><li>而<code>_IO_cleanup</code>会调用<code>_IO_flush_all_lockp (0);</code>是刷新已经打开的流，并在需要的时候上一个锁机制。还会调用<code>_IO_unbuffer_all ();</code>用于将所有打开的流的缓冲模式变成无缓冲模式，然后将缓冲区进行释放。</li><li><code>_IO_unbuffer_all ()、_IO_flush_all_lockp (0)</code>这两个函数都是<code>IO</code>函数，在调试<code>exit()</code>的时候就不需要仔细调试，可以放在调试<code>IO</code>的时候仔细调试。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面这个是<code>_IO_flush_all_lockp</code>的代码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">        run_fp = fp;</span><br><span class="line">        <span class="keyword">if</span> (do_lock)</span><br><span class="line">            _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">        || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">        )</span><br><span class="line">        &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (do_lock)</span><br><span class="line">            _IO_funlockfile (fp);</span><br><span class="line">        run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">    _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面这个就是<code>_IO_unbuffer_all ();</code>的源码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> legacy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (_IO_vtable_offset (fp) != <span class="number">0</span>))</span><br><span class="line">        legacy = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">        &amp;&amp; (legacy || fp-&gt;_mode != <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">            <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (! legacy &amp;&amp; ! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">            &#123;</span><br><span class="line">                fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">                fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">                freeres_list = fp;</span><br><span class="line">                fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (! legacy &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">            _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">            _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (! legacy)</span><br><span class="line">fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">    _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exit函数调试"><a href="#exit函数调试" class="headerlink" title="exit函数调试"></a>exit函数调试</h2><h1 id="exit函数执行流程开始时"><a href="#exit函数执行流程-开始时" class="headerlink" title="exit函数执行流程(开始时)"></a>exit函数执行流程(开始时)</h1><ul><li>exit函数在开始的时候并没有执行，而是进行动态链接，将<code>exit()</code>函数的地址绑定到起来。但是这一绑定的过程其实是比较容易利用的。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>对于<code>exit</code>函数的利用其实就是好几个：</p><ul><li>利用<code>__call_tls_dtors</code>这个TLS析构函数，该函数会触发一个函数指针。</li><li>利用注册函数，但是这个函数通常会被<code>fs:0x30</code>加密，如果想要修改注册函数，就必须先泄露<code>fs:0x30</code>或者先修改<code>fs:0x30</code>。</li><li><code>IO</code>函数刷新缓冲区，这个其实就是<code>_IO_FILE</code>的利用，<code>house of apple</code>就与这个相关了，进行这个利用其实是最经常用的了。</li><li>劫持<code>rtdl_fini()</code>中的函数指针，劫持<code>l_info伪造fini_array节</code>，使用<code>fini_array</code>进行ROP，以及<code>劫持fini</code></li></ul></li><li><p>为了加深对<code>exit()</code>函数的执行过程，其实对应<code>IO</code>利用的<code>exit()</code>函数这里暂时不拿例题。只拿<code>exit()</code>函数其他两个利用的例题。</p></li></ul><h1 id="题目1"><a href="#题目1——" class="headerlink" title="题目1——"></a>题目1——</h1>]]></content>
    
    
    <summary type="html">前言：暑假看exit函数流程不太明白，最近牢的一题对exit有比较清晰了。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>GPNCTF2025复现</title>
    <link href="http://iyheart.github.io/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/"/>
    <id>http://iyheart.github.io/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/</id>
    <published>2025-09-05T14:35:04.000Z</published>
    <updated>2025-09-05T15:55:26.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p><strong>对于写WP个人的见解</strong>：</p><p>对于一些比赛，虽然有写wp，但是其实本人是想着一个方向或者多个方向复现完再发的，但是这比较困难，因为每个比赛的每个方向题目都是有简单、有困难的。简单的题目还好，可能一下子就复现完了，但是剩下的比较困难的题目就很难受了可能会因为知识储备不足而无法自己独立做出。虽然说是有wp可以看，但是看wp的目的是能学到东西，而不是利用脚本一把梭一下。</p><p>所以在复现比赛题目的时候往往对自己要求比较高，而遇到难的短时间复现不了，时间一长好像就把题目鸽了<code>(老毛病了)QAQ</code>。这就导致我写的wp感觉还是比较少的。并且一些比赛题目是用AI一把梭的（AI一把梭的根本学不到东西），对于这种情况我是更希望复现完了再发wp的。</p><p><strong>对于CTF中使用AI的一些碎碎念</strong>：</p><p>高中物理老师说过，考试是考试，考试要有考试的技巧；平时刷题就要踏踏实实的刷题；考试过后对于试卷的题目也是需要踏踏实实的。</p><p>而CTF比赛其实某种程度上也相当于考试吧，而大部分CTF比赛都允许使用AI的，这就导致在比赛中使用AI就相当于一个考试的技巧，黑猫白猫抓到老鼠的都是好猫——能解出题目的AI就是好AI（哈哈哈哈）。这就导致了大部分人遇到题目就会直接把题目附件之类的直接丢给AI一把梭（包括我自己）。</p><p>所以这个暑假就期间就已经开始反思了，就觉得AI一把梭是真学不到东西，赛后也是一鸽再鸽，所以干脆在平时的CTF比赛中减少AI一把梭的次数，并且拿到题目附件的时候并不是第一时间丢给AI，而是认认真真的看懂代码，对于代码中不明白的部分再去询问AI（这样总比直接复制粘贴丢给AI能学到东西），只有实在没思路的题目还是需要AI一把梭的（毕竟CTF是个竞赛，还是个团队协作的比赛，都能用AI一把梭的但是你不会，也只能先使用AI一把梭把flag梭出来再说了）。</p><h1 id="crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="hinting"><a href="#hinting" class="headerlink" title="hinting"></a>hinting</h2><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">FLAG = <span class="string">b&quot;There was an actual flag here once&quot;</span></span><br><span class="line">FLAG = sys.argv[<span class="number">1</span>].encode() <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> FLAG</span><br><span class="line">BS = <span class="number">1024</span></span><br><span class="line">FLAG = bytes_to_long(FLAG)</span><br><span class="line">set_random_seed(secrets.randbelow(<span class="built_in">int</span>(<span class="number">2</span>**<span class="number">64</span>)))</span><br><span class="line">p, q = random_prime(<span class="number">2</span> ** (BS), <span class="number">2</span> ** (BS - <span class="number">1</span>)), random_prime(<span class="number">2</span>**BS, <span class="number">2</span> ** (BS - <span class="number">1</span>))</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="built_in">pow</span>(FLAG, e, n) <span class="comment"># RSA加密</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123;n:x&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;e = <span class="subst">&#123;e:x&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123;<span class="built_in">int</span>(c):x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">pp, qq = (</span><br><span class="line">    p.digits(base=<span class="number">7</span>, padto=<span class="built_in">int</span>(log(<span class="number">2</span> ** (BS + <span class="number">1</span>), <span class="number">7</span>)) + <span class="number">2</span>), </span><br><span class="line">    q.digits(base=<span class="number">7</span>, padto=<span class="built_in">int</span>(log(<span class="number">2</span> ** (BS + <span class="number">1</span>), <span class="number">7</span>)) + <span class="number">2</span>),</span><br><span class="line">) <span class="comment">#pp,qq分别为p、q的7进制位,小索引号对应的是低位</span></span><br><span class="line">V = vector([(pp[i] + qq[i]) % <span class="number">7</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pp))]) <span class="comment"># 相同位相加然后模7</span></span><br><span class="line"><span class="built_in">print</span>(V)<span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n = 2666fab0a6dae7095642f0cb67602776badc8ede2629a54866017fc3840394f8157f0cc38e9f02b48733f1dbae4514d3d808d9a824b2933170e153dfcfedb0148f8a89311575df58c2c12ee11fae2510073956221ec472ae3f1bbd685011c350955502a2b0b1160e1fa299a050c0ee89c161c0fa55e32fb3806f2970287702f7d566e155fac71a4202c8b15d27c0dac2a566ad955d0ef7df73af86dc4e8f7e0048ccdb6ea551477c99bd6545b7dda2886c86796f20cbba8f2ddd173e2ab93bb00e5993c8adac5921d8586553b7a6086f7ff8c43f571d251bf5931ebb858bd64366cd92efa2fa7d9c4ea6a91049696454066046ef6dd4e6d9516439bcbadc266b</span></span><br><span class="line"><span class="string">e = 10001</span></span><br><span class="line"><span class="string">c = 230e6605e4a59cda037ec9d08830137e93bcec65af7ca9d93c17fccc45b7e7908909134e9f6410ab9b76b53c2402455e6b7cc0b1e7ee2c0921b2ebc5c6407b323fef3b905197ef4224886d2ba0b98b277f2cf267fbefae9e2067e2c8a4be0915b2665d53c1cf725b4f50ff4e7b66743656f36bee57b93fa07bd3d5fcaf7b596d48e876b26499b436c703581d10d85de024a803710f188733766c3be06dd6eeb7a0acff37a4656cb9d4c0053a96b2c61480b6da6792095d47d3a7e7e0beb00acba38d5f430228e54f691dce6e63a936500acede51afbba16ea8b0b7042373787667dfc5694d4ed048a9127565ca2050986997cd312a54616d63611d56ab4dbbf0</span></span><br><span class="line"><span class="string">(1, 0, 3, 4, 1, 1, 1, 1, 5, 6, 0, 1, 3, 2, 0, 5, 6, 2, 4, 6, 0, 6, 4, 2, 3, 1, 6, 5, 1, 6, 0, 2, 2, 2, 2, 6, 0, 5, 6, 2, 5, 0, 6, 5, 2, 5, 5, 0, 0, 2, 3, 2, 5, 2, 0, 4, 2, 2, 1, 0, 6, 2, 3, 5, 3, 6, 5, 5, 3, 6, 1, 4, 4, 2, 2, 6, 6, 3, 5, 6, 3, 6, 6, 5, 6, 1, 1, 6, 5, 4, 4, 2, 1, 3, 0, 5, 4, 4, 0, 6, 3, 2, 1, 0, 1, 2, 0, 6, 3, 5, 4, 2, 2, 1, 5, 3, 0, 1, 3, 5, 2, 2, 3, 6, 5, 5, 2, 0, 6, 0, 6, 1, 0, 2, 2, 4, 0, 3, 1, 4, 1, 4, 6, 5, 4, 6, 3, 3, 1, 3, 0, 3, 4, 5, 0, 0, 0, 4, 1, 6, 5, 3, 0, 0, 1, 4, 3, 4, 0, 3, 4, 1, 6, 3, 6, 0, 0, 3, 6, 2, 2, 3, 4, 4, 1, 5, 4, 5, 1, 5, 3, 2, 0, 0, 1, 4, 3, 0, 4, 2, 1, 3, 0, 2, 6, 1, 5, 6, 3, 4, 1, 3, 2, 5, 3, 5, 5, 5, 1, 5, 2, 2, 1, 2, 6, 6, 3, 1, 2, 5, 6, 5, 2, 3, 4, 2, 3, 4, 2, 6, 6, 0, 6, 1, 5, 3, 1, 4, 5, 0, 4, 3, 1, 0, 1, 1, 1, 0, 4, 6, 0, 4, 2, 0, 0, 2, 0, 4, 3, 2, 3, 0, 4, 5, 6, 2, 4, 6, 6, 0, 0, 4, 1, 1, 3, 3, 6, 1, 6, 2, 4, 4, 3, 5, 3, 2, 4, 3, 4, 1, 4, 1, 6, 6, 1, 0, 4, 2, 3, 6, 3, 5, 4, 2, 6, 2, 2, 1, 6, 2, 1, 2, 4, 4, 0, 0, 4, 5, 2, 3, 1, 4, 1, 1, 5, 6, 0, 0, 5, 0, 4, 6, 1, 5, 2, 0, 0, 4, 6, 2, 3, 3, 2, 2, 5, 2, 0, 1, 2, 1, 0, 5, 6, 2, 3, 0, 0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>这题其实也是类似于<code>p异或q</code>的题型，都是通过剪枝搜索，但是应该如何搜索，应该从多项式乘法入手。目前已知<code>p</code>、<code>q</code>的七进制位，将它们俩个用多项式表示如下：</li></ul><script type="math/tex; mode=display">p = a_n*7^{n} + a_{n-1}*7^{n-1} + ...+a_{1}*7^{1}+a_0*7^{0}\\q = b_n*7^{n} + b_{n-1}*7^{n-1} + ...+b_{1}*7^{1}+b_0*7^{0}\\p*q=a_0*q+a_1*7^{1}*q+.....+a_n*7^{n}*q</script><ul><li>这时展开来可以发现：</li></ul><script type="math/tex; mode=display">p*q=a_0*b_0+a_0b_1*7^1+a_1b_0*7^{1}+........</script><ul><li>此时我们可以发现，由<code>a_0*b_0</code>其实就可以确定n的最低<code>1</code>位，而已知<code>a_0、b_0、a_1、b_1</code>就可以已知最低的<code>2</code>位,以此类推知道多少位就能已知多少位一直到最高位。这其实就类似于<code>p^q</code>的低位搜索，只不过将二进制换成了七进制。所以正常<code>DFS</code>剪枝搜索即可。(猜想：可能可以从高位和低位进行中间相遇)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">n = <span class="number">0x2666fab0a6dae7095642f0cb67602776badc8ede2629a54866017fc3840394f8157f0cc38e9f02b48733f1dbae4514d3d808d9a824b2933170e153dfcfedb0148f8a89311575df58c2c12ee11fae2510073956221ec472ae3f1bbd685011c350955502a2b0b1160e1fa299a050c0ee89c161c0fa55e32fb3806f2970287702f7d566e155fac71a4202c8b15d27c0dac2a566ad955d0ef7df73af86dc4e8f7e0048ccdb6ea551477c99bd6545b7dda2886c86796f20cbba8f2ddd173e2ab93bb00e5993c8adac5921d8586553b7a6086f7ff8c43f571d251bf5931ebb858bd64366cd92efa2fa7d9c4ea6a91049696454066046ef6dd4e6d9516439bcbadc266b</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="number">0x230e6605e4a59cda037ec9d08830137e93bcec65af7ca9d93c17fccc45b7e7908909134e9f6410ab9b76b53c2402455e6b7cc0b1e7ee2c0921b2ebc5c6407b323fef3b905197ef4224886d2ba0b98b277f2cf267fbefae9e2067e2c8a4be0915b2665d53c1cf725b4f50ff4e7b66743656f36bee57b93fa07bd3d5fcaf7b596d48e876b26499b436c703581d10d85de024a803710f188733766c3be06dd6eeb7a0acff37a4656cb9d4c0053a96b2c61480b6da6792095d47d3a7e7e0beb00acba38d5f430228e54f691dce6e63a936500acede51afbba16ea8b0b7042373787667dfc5694d4ed048a9127565ca2050986997cd312a54616d63611d56ab4dbbf0</span></span><br><span class="line">hint = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">x0 = &#123;<span class="number">0</span>:<span class="number">0</span>,<span class="number">1</span>:<span class="number">6</span>,<span class="number">2</span>:<span class="number">5</span>,<span class="number">3</span>:<span class="number">4</span>,<span class="number">4</span>:<span class="number">3</span>,<span class="number">5</span>:<span class="number">2</span>,<span class="number">6</span>:<span class="number">1</span>&#125;</span><br><span class="line">x1 = &#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">1</span>:<span class="number">0</span>,<span class="number">2</span>:<span class="number">6</span>,<span class="number">3</span>:<span class="number">5</span>,<span class="number">4</span>:<span class="number">4</span>,<span class="number">5</span>:<span class="number">3</span>,<span class="number">6</span>:<span class="number">2</span>&#125;</span><br><span class="line">x2 = &#123;<span class="number">0</span>:<span class="number">2</span>,<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">0</span>,<span class="number">3</span>:<span class="number">6</span>,<span class="number">4</span>:<span class="number">5</span>,<span class="number">5</span>:<span class="number">4</span>,<span class="number">6</span>:<span class="number">3</span>&#125;</span><br><span class="line">x3 = &#123;<span class="number">0</span>:<span class="number">3</span>,<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">1</span>,<span class="number">3</span>:<span class="number">0</span>,<span class="number">4</span>:<span class="number">6</span>,<span class="number">5</span>:<span class="number">5</span>,<span class="number">6</span>:<span class="number">4</span>&#125;</span><br><span class="line">x4 = &#123;<span class="number">0</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">3</span>,<span class="number">2</span>:<span class="number">2</span>,<span class="number">3</span>:<span class="number">1</span>,<span class="number">4</span>:<span class="number">0</span>,<span class="number">5</span>:<span class="number">6</span>,<span class="number">6</span>:<span class="number">5</span>&#125;</span><br><span class="line">x5 = &#123;<span class="number">0</span>:<span class="number">5</span>,<span class="number">1</span>:<span class="number">4</span>,<span class="number">2</span>:<span class="number">3</span>,<span class="number">3</span>:<span class="number">2</span>,<span class="number">4</span>:<span class="number">1</span>,<span class="number">5</span>:<span class="number">0</span>,<span class="number">6</span>:<span class="number">6</span>&#125;</span><br><span class="line">x6 = &#123;<span class="number">0</span>:<span class="number">6</span>,<span class="number">1</span>:<span class="number">5</span>,<span class="number">2</span>:<span class="number">4</span>,<span class="number">3</span>:<span class="number">3</span>,<span class="number">4</span>:<span class="number">2</span>,<span class="number">5</span>:<span class="number">1</span>,<span class="number">6</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(x0))</span><br><span class="line">search = &#123;<span class="number">0</span>:x0,<span class="number">1</span>:x1,<span class="number">2</span>:x2,<span class="number">3</span>:x3,<span class="number">4</span>:x4,<span class="number">5</span>:x5,<span class="number">6</span>:x6&#125;</span><br><span class="line">n_list = n.digits(base=<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(n_list)</span><br><span class="line">candidate = []</span><br><span class="line"><span class="comment"># 1*7^0 + 0*7^1 + ... + </span></span><br><span class="line"><span class="comment">#print(bit)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">p,q</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(p)</span><br><span class="line">    <span class="keyword">if</span> l &lt; <span class="built_in">len</span>(hint):</span><br><span class="line">        count = hint[l]</span><br><span class="line">    p_ = <span class="built_in">int</span>(p,<span class="number">7</span>)</span><br><span class="line">    q_ = <span class="built_in">int</span>(q,<span class="number">7</span>)</span><br><span class="line">    n_ = p_*q_</span><br><span class="line">    nn_list = n_list[<span class="number">0</span>:l]</span><br><span class="line">    <span class="keyword">if</span> n_==n:</span><br><span class="line">        candidate.append(p_)</span><br><span class="line">    <span class="comment">#print(&#x27;--------&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span>  Integer(n_).digits(base=<span class="number">7</span>)[<span class="number">0</span>:l] == nn_list:</span><br><span class="line">        <span class="keyword">if</span> l&gt;= <span class="built_in">len</span>(hint):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        h = hint[l]</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">print</span>(Integer(n_).digits(base=<span class="number">7</span>))</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">0</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">1</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">2</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)                </span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">3</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">4</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">5</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)                </span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">6</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)                   </span><br><span class="line"><span class="comment"># 0+1 = 1</span></span><br><span class="line"><span class="comment"># 1+0 = 1</span></span><br><span class="line"><span class="comment"># 6+2  5+3 4+4 3+5 2+6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    find(<span class="built_in">str</span>(i),<span class="built_in">str</span>(x1[i]))</span><br><span class="line"><span class="built_in">print</span>(candidate)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> candidate:</span><br><span class="line">    q = n//i</span><br><span class="line">    phi = (i-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    d = inverse_mod(e,phi)</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;GPNCTF&#123;wOw_faCTORING_wi7H_H1NT5_15_FUn&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716093455090.png" alt="image-20250716093455090"></p><h2 id="restricted-oracle"><a href="#restricted-oracle" class="headerlink" title="restricted oracle"></a>restricted oracle</h2><ul><li>从这题了解到了<code>CBC</code>块加密模式有一个攻击为<code>padding Oracle</code>攻击，稍微改了一下这题的代码，使得爆破次数没有限制，从而学习了一下<code>padding Oracle</code>攻击。基本版的<code>padding Oracle</code>攻击的学习过程写在了这篇博客中：<a href="https://iyheart.github.io/2025/06/18/CTFblog/CRYPTO系列blog/对称加密/块加密/块加密模式/">块加密工作模式 | iyheart的博客</a> </li><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha512</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">MAX_TRIES = <span class="keyword">lambda</span> x: <span class="built_in">len</span>(x)*<span class="number">40</span>  <span class="comment"># 严格限制了爆破的次数</span></span><br><span class="line">TEXT_FILE = <span class="string">&quot;text.txt&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getText</span>(<span class="params">n=<span class="number">10</span></span>)-&gt;<span class="built_in">str</span>:</span><br><span class="line">    lines = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(TEXT_FILE, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="comment">#print(len(lines), &quot;lines loaded from text file.&quot;)</span></span><br><span class="line">    out = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        line =secrets.choice(lines)</span><br><span class="line">        line =line.split(<span class="string">&quot; &quot;</span>,<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">        out += line.strip()</span><br><span class="line">    <span class="comment">#out = &quot;abc&quot;*100 + &quot;bcd&quot;*100+&quot;A&quot;  # 题目给出了密文的形式,应该就是用于减少爆破次数的.</span></span><br><span class="line">    out = <span class="string">&quot;&quot;</span>.join(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x <span class="keyword">in</span> string.ascii_letters,out))</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PadServer</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,text</span>):</span><br><span class="line">        self.queries = [<span class="number">0</span>]</span><br><span class="line">        self.key =  os.urandom(<span class="number">16</span>)</span><br><span class="line">        self.cipher = AES.new(self.key, AES.MODE_CBC)</span><br><span class="line">        self.chall = text.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(random.randint(<span class="number">0</span>,<span class="number">4</span>)):</span><br><span class="line">                self.chall += <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)+(os.urandom(<span class="number">1</span>)[<span class="number">0</span>] % <span class="number">26</span>)).encode()<span class="comment"># 明文 = getText(n) 的输出（仅包含英文字母）+ 0~4 个随机大写字母（来自 &#x27;A&#x27;-&#x27;Z&#x27;）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.iv = os.urandom(<span class="number">16</span>)</span><br><span class="line">        <span class="comment">#print(f&quot;Padding is : &#123;self.pad(self.chall).hex()&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cutq</span>(<span class="params">self</span>):</span><br><span class="line">        self.queries+=[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_chall</span>(<span class="params">self</span>):</span><br><span class="line">        aes = AES.new(self.key, AES.MODE_CBC, self.iv)</span><br><span class="line">        <span class="keyword">return</span> self.iv+aes.encrypt(self.pad(self.chall))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">self, s</span>):</span><br><span class="line">        padbit = <span class="number">16</span> - <span class="built_in">len</span>(s) % <span class="number">16</span></span><br><span class="line">        padding = <span class="built_in">bytes</span>([padbit] * padbit)</span><br><span class="line">        <span class="keyword">return</span> s + padding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unpad</span>(<span class="params">self, s</span>):</span><br><span class="line">        padbit = s[-<span class="number">1</span>]</span><br><span class="line">        padding = s[-padbit:]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">set</span>(padding) == &#123;padbit&#125;:</span><br><span class="line">            <span class="keyword">return</span> s[:-s[-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, ciphertext</span>):</span><br><span class="line">        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)</span><br><span class="line">        plaintext = cipher.decrypt(ciphertext)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oracle</span>(<span class="params">self, ciphertext</span>):</span><br><span class="line">        self.queries[-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        plaintext = self.decrypt(ciphertext)</span><br><span class="line">        <span class="comment">#print(&quot;oracle request decrypts to &quot;, plaintext.hex())</span></span><br><span class="line">        <span class="keyword">if</span> self.unpad(plaintext) == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFlag</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read().strip()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">a:<span class="built_in">bytes</span>,b:<span class="built_in">bytes</span></span>)-&gt;<span class="built_in">bytes</span>:</span><br><span class="line"></span><br><span class="line">    ml  = <span class="built_in">max</span>(<span class="built_in">len</span>(a),<span class="built_in">len</span>(b))</span><br><span class="line">    a = a.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    b = b.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome to the Pad Server!&quot;</span>)</span><br><span class="line">    FLAG =getFlag()</span><br><span class="line">    text =getText()</span><br><span class="line">    oracle =PadServer(text)</span><br><span class="line">    MAX_TRIES = MAX_TRIES(text)</span><br><span class="line">    tries = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(xor(sha512(text[:-<span class="number">3</span>].encode(<span class="string">&quot;utf-8&quot;</span>)).digest(),FLAG.encode()).<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(oracle.get_chall().<span class="built_in">hex</span>())</span><br><span class="line">    <span class="keyword">while</span> tries &lt; MAX_TRIES:</span><br><span class="line">        ciph = <span class="built_in">bytes</span>.fromhex(<span class="built_in">input</span>(<span class="string">&quot;speak to the oracle: &quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ciph) % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Ciphertext must be a multiple of 16 bytes.&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Oracle says: &quot;</span>, oracle.oracle(ciph))</span><br><span class="line">        tries+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先需要接收消息，并从消息中分离数<code>vi</code>和<code>密文</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_bytes</span>(<span class="params">block</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(block))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(block)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>.fromhex(block)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">padding</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([padding] * padding)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p =  remote(<span class="string">&quot;newford-of-charged-unity.gpn23.ctf.kitctf.de&quot;</span>, <span class="string">&quot;443&quot;</span>, ssl=<span class="literal">True</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Welcome to the Pad Server!\n&#x27;</span>)</span><br><span class="line">c1 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line">iv_c2 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line"><span class="built_in">print</span>(iv_c2)</span><br><span class="line">iv = iv_c2[:<span class="number">32</span>]</span><br><span class="line">c2 = iv_c2[<span class="number">32</span>:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c2=&#x27;</span>,c2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iv=&#x27;</span>,iv)</span><br><span class="line">l = <span class="built_in">len</span>(c2)</span><br><span class="line">ll = l//<span class="number">32</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="built_in">print</span>(l//<span class="number">32</span>)</span><br><span class="line">c_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ll):</span><br><span class="line">    c_list.append(c2[i*<span class="number">32</span>:i*<span class="number">32</span>+<span class="number">32</span>])</span><br><span class="line"><span class="built_in">print</span>(c_list)</span><br><span class="line"><span class="built_in">print</span>(my_bytes(c_list[-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><ul><li>之后就是爆破出<code>padding</code>的个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">padding = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    block1 = my_bytes(c_list[-<span class="number">2</span>])</span><br><span class="line">    block2 = my_bytes(c_list[-<span class="number">1</span>])</span><br><span class="line">    payload = (block1[:i]+xor(block1[i],<span class="string">b&#x27;\x10&#x27;</span>)+block1[i+<span class="number">1</span>:]+block2).<span class="built_in">hex</span>().encode()</span><br><span class="line">    <span class="built_in">print</span>(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">    rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="built_in">print</span>(rec)</span><br><span class="line">    <span class="keyword">if</span> rec==<span class="string">&#x27;False&#x27;</span>:</span><br><span class="line">        padding=<span class="number">0x10</span>-i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;padding----&gt;&quot;</span>,padding)</span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716100001976.png" alt="image-20250716100001976"></p><ul><li>尝试爆破最后一块剩余没有被<code>padding</code>填充的部分，会发现爆破出来的，字母目前只有大写字母和小写字母。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 破解尾块的数据</span></span><br><span class="line">text = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(padding,<span class="number">16</span>,<span class="number">1</span>):</span><br><span class="line">    t = j-padding</span><br><span class="line">    padd = pad(padding)</span><br><span class="line">    padd2 = pad(j + <span class="number">1</span>)[:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(padd2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;------------第<span class="subst">&#123;<span class="number">15</span>-j&#125;</span>位爆破--------------&quot;</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">255</span>):</span><br><span class="line">        payload = (block1[:<span class="number">15</span>-j]+xor(block1[<span class="number">15</span>-j],i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>))+xor(xor(block1[<span class="number">16</span>-j:],text.encode()+padd),padd2)+block2).<span class="built_in">hex</span>().encode()</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">        rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">        <span class="built_in">print</span>(rec)</span><br><span class="line">        <span class="keyword">if</span> rec==<span class="string">&#x27;True&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;find---&gt;&quot;</span>,xor(i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>),j+<span class="number">1</span>))</span><br><span class="line">            text = xor(i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>),j+<span class="number">1</span>).decode() + text</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;text---&gt;&quot;</span>,text)</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment">#out = &quot;abc&quot;*100 + &quot;bcd&quot;*100+&quot;A&quot;  # 题目给出了密文的形式,应该就是用于减少爆破次数的.</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716095632989.png" alt="image-20250716095632989"></p><ul><li>但是由于有限制次数，而题目中又给了<code>key</code>是大小写字母，所以我们可以构造如下列表，用于减少爆破次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个列表,用于爆破使用,爆破只选择对应对应索引与字母的异或值,从而减少爆破次数</span></span><br><span class="line">latter = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">17</span>):</span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> latter:</span><br><span class="line">        <span class="built_in">print</span>(j)</span><br><span class="line">        x.append(i^(<span class="built_in">ord</span>(j)))</span><br><span class="line">        <span class="comment">#print(x)</span></span><br><span class="line">    a.append(x)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>减少次数后就可以在有限次数绕过爆破出<code>key</code>，在爆破的时候还需要考虑一下时间问题，明文非常长，但是靶机只有<code>30</code>分钟的限制。但是在爆破的过程中会发现明文是德国新闻的一些句子。</li></ul><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716143239889.png" alt="image-20250716143239889"></p><ul><li>这就需要对单词进行词频分析，从而减少爆破的时间，并且还发现，每次连接发送过来的块长度不一样，有的块长度到达了<code>60</code>多，有的才<code>30</code>多或者<code>40</code>多，所以我们应该选择<code>40</code>多、<code>30</code>多块的来进行爆破，这样也能节省时间。这样能使得平均每块爆破时间降低到<code>38.07秒</code></li></ul><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716144442590.png" alt="image-20250716144442590"></p><ul><li>爆破出来<code>text</code>后再去掉最后的大写字母，即可得到结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">a:<span class="built_in">bytes</span>,b:<span class="built_in">bytes</span></span>)-&gt;<span class="built_in">bytes</span>:</span><br><span class="line">    ml  = <span class="built_in">max</span>(<span class="built_in">len</span>(a),<span class="built_in">len</span>(b))</span><br><span class="line">    a = a.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    b = b.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(x ^^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b))</span><br><span class="line">    </span><br><span class="line">c1 = <span class="string">&#x27;wiederumhatbereitsweitereEntlassungenbeiWallStreetBankenundanderenFinanzinstitutionenzurFolgeEinwandererausDeutschlandsetzenflschlicherweiseeineLehremitdemgesellschaftlichenAbstieggleichHPIncwirdesdiesenMarktauchweiterhinadressierenerklrtderBritewarumausMcLarenSichtvielfreinMotorenUpdateinSpielbergsprichtkuriertderMinistereinenBeinbruchausundGtzeuernsichnichtBildNchstesBildDiesesBildmachtedasaustralischeMerinoschafChrisweltweitbekanntSeptemberseienalleDetailszuderAbschaltsoftwareoffengelegtwordenvergrernBildinfoausblendenBildWaserwartenSieindieserPhasevonIhrenSpielernWosinddennjetztallehindienochvoreinpaarJahren&#x27;</span></span><br><span class="line">c2 = <span class="string">&#x27;d620ed061b06427d260bda1af508da1517a84b5d93a9c466a65ca608a671bdffd941e829a0c923b69c9187dba50ffcdf81351c7f117503ba78b664b72643e626&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>.fromhex(c2))</span><br><span class="line"><span class="built_in">print</span>(xor(hashlib.sha512(c1[:-<span class="number">3</span>].encode(<span class="string">&quot;utf-8&quot;</span>)).digest(),<span class="built_in">bytes</span>.fromhex(c2)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(c1)//<span class="number">16</span>)</span><br><span class="line"><span class="string">b&#x27;GPNCTF&#123;nic3_Gu3SS1Ng_p4DdInG_iS_FuN&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="number">38</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716161430730.png" alt="image-20250716161430730"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment"># 建立一个列表,用于爆破使用,爆破只选择对应对应索引与字母的异或值,从而减少爆破次数</span></span><br><span class="line"><span class="comment"># 高频次出现的字母放在前面减少爆破次数和时间</span></span><br><span class="line">latter = <span class="string">&#x27;enisratdhulcgmobwfkzvpjyxqSDMBNAFEKLGHTWRZIUPCJVOYXQ&#x27;</span> </span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">17</span>):</span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> latter:</span><br><span class="line">        <span class="built_in">print</span>(j)</span><br><span class="line">        x.append(i^(<span class="built_in">ord</span>(j)))</span><br><span class="line">        <span class="comment">#print(x)</span></span><br><span class="line">    a.append(x)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">text = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_bytes</span>(<span class="params">block</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(block))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(block)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>.fromhex(block)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">padding</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([padding] * padding)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack_other_block</span>(<span class="params">pre_list,lat_list</span>):</span><br><span class="line">    <span class="keyword">global</span> text</span><br><span class="line">    block1 = my_bytes(pre_list)</span><br><span class="line">    block2 = my_bytes(lat_list)</span><br><span class="line">    text1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a[<span class="number">1</span>]:</span><br><span class="line">        payload = block1[:<span class="number">15</span>]</span><br><span class="line">        payload += xor(block1[<span class="number">15</span>], i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">        payload += block2</span><br><span class="line">        payload = payload.<span class="built_in">hex</span>().encode()  <span class="comment"># 转换为16进制字符形式,再转换为字节形式发送</span></span><br><span class="line">        <span class="comment">#print(len(payload))</span></span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">        rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">        <span class="comment">#print(rec)</span></span><br><span class="line">        <span class="keyword">if</span> rec == <span class="string">&#x27;True&#x27;</span>:  <span class="comment"># 判断是否能得到True的应答</span></span><br><span class="line">            <span class="comment">#print(&quot;find---&gt;&quot;, xor(i.to_bytes(1, &#x27;big&#x27;), 1))  # 爆破到明文</span></span><br><span class="line">            text = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), <span class="number">1</span>).decode() + text  <span class="comment"># 这里应该需要修改为异或1</span></span><br><span class="line">            <span class="comment">#print(&quot;text---&gt;&quot;, text)</span></span><br><span class="line">            text1 = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), <span class="number">1</span>).decode() + text1</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">16</span>, <span class="number">1</span>):</span><br><span class="line">        padd2 = pad(j + <span class="number">1</span>)[:-<span class="number">1</span>]  <span class="comment"># 再计算j+1的pad</span></span><br><span class="line">        <span class="comment">#print(padd2)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;------------第<span class="subst">&#123;<span class="number">15</span> - j&#125;</span>位爆破--------------&quot;</span>)</span><br><span class="line">        <span class="comment">#print(&quot;text1---&gt;&quot;, text1)</span></span><br><span class="line">        t = xor(block1[<span class="number">16</span> - j:], text1.encode())  <span class="comment"># 先计算C_i-1[j]^P_n[j], 相比于前面这里去掉了padd</span></span><br><span class="line">        t2 = xor(t, padd2)  <span class="comment"># 最终计算得到C_i-1[j]^P_n[j]^(L+1)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a[j+<span class="number">1</span>]:</span><br><span class="line">            payload = block1[:<span class="number">15</span> - j]  <span class="comment"># C_i-1[15-L]前面的数据不要动</span></span><br><span class="line">            payload += xor(block1[<span class="number">15</span> - j], i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>)) + t2  <span class="comment"># 组合成第C_i-1密文块</span></span><br><span class="line">            payload += block2  <span class="comment"># 加上尾块</span></span><br><span class="line">            payload = payload.<span class="built_in">hex</span>().encode()  <span class="comment"># 转换为16进制字符形式,再转换为字节形式发送</span></span><br><span class="line">            <span class="comment">#print(len(payload))</span></span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>, payload)</span><br><span class="line">            p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">            rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">            <span class="comment">#print(rec)</span></span><br><span class="line">            <span class="keyword">if</span> rec == <span class="string">&#x27;True&#x27;</span>:  <span class="comment"># 判断是否能得到True的应答</span></span><br><span class="line">                <span class="comment">#print(&quot;find---&gt;&quot;, xor(i.to_bytes(1, &#x27;big&#x27;), j + 1))  # 爆破到明文</span></span><br><span class="line">                text = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), j + <span class="number">1</span>).decode() + text  <span class="comment"># 添加到text中</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;text---&gt;&quot;</span>, text)</span><br><span class="line">                text1 = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), j + <span class="number">1</span>).decode() + text1</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;text--&gt;&#x27;</span>,text)</span><br><span class="line">    <span class="keyword">return</span> text1</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;grandforge-of-face-melting-tschunk.gpn23.ctf.kitctf.de&quot;</span>, <span class="string">&quot;443&quot;</span>, ssl=<span class="literal">True</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Welcome to the Pad Server!\n&#x27;</span>)</span><br><span class="line">    c1 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c1 = &#x27;</span>,c1)</span><br><span class="line">    iv_c2 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="built_in">print</span>(iv_c2)</span><br><span class="line">    iv = iv_c2[:<span class="number">32</span>]</span><br><span class="line">    c2 = iv_c2[<span class="number">32</span>:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c2=&#x27;</span>,c2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;iv=&#x27;</span>,iv)</span><br><span class="line">    l = <span class="built_in">len</span>(c2)</span><br><span class="line">    ll = l//<span class="number">32</span></span><br><span class="line">    <span class="built_in">print</span>(l)</span><br><span class="line">    <span class="built_in">print</span>(l//<span class="number">32</span>)</span><br><span class="line">    c_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ll):</span><br><span class="line">        c_list.append(c2[i*<span class="number">32</span>:i*<span class="number">32</span>+<span class="number">32</span>])</span><br><span class="line">    <span class="built_in">print</span>(c_list)</span><br><span class="line">    <span class="built_in">print</span>(my_bytes(c_list[-<span class="number">1</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;block_length---&gt;&#x27;</span>,<span class="built_in">len</span>(c_list))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(c_list)&lt;=<span class="number">40</span>: <span class="comment"># 选择块总数＜=40的消息进行爆破,从而减少时间</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    p.close()</span><br><span class="line">    <span class="comment"># 确定padding长度</span></span><br><span class="line"></span><br><span class="line">padding = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    block1 = my_bytes(c_list[-<span class="number">2</span>])</span><br><span class="line">    block2 = my_bytes(c_list[-<span class="number">1</span>])</span><br><span class="line">    payload = (block1[:i]+xor(block1[i],<span class="string">b&#x27;\x10&#x27;</span>)+block1[i+<span class="number">1</span>:]+block2).<span class="built_in">hex</span>().encode()</span><br><span class="line">    <span class="comment">#print(payload)</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">    rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="comment">#print(rec)</span></span><br><span class="line">    <span class="keyword">if</span> rec==<span class="string">&#x27;False&#x27;</span>:</span><br><span class="line">        padding=<span class="number">0x10</span>-i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">#print(&quot;padding----&gt;&quot;,padding)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 破解尾块的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(padding,<span class="number">16</span>,<span class="number">1</span>):</span><br><span class="line">    padd = pad(padding) <span class="comment"># 先计算原始padd</span></span><br><span class="line">    padd2 = pad(j + <span class="number">1</span>)[:-<span class="number">1</span>] <span class="comment"># 再计算j+1的pad</span></span><br><span class="line">    <span class="comment">#print(padd2)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;------------第<span class="subst">&#123;<span class="number">15</span>-j&#125;</span>位爆破--------------&quot;</span>)</span><br><span class="line">    t = xor(block1[<span class="number">16</span>-j:],text.encode()+padd) <span class="comment"># 先计算C_i-1[j]^P_n[j]</span></span><br><span class="line">    t2 = xor(t,padd2) <span class="comment"># 最终计算得到C_i-1[j]^P_n[j]^(L+1)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a[j+<span class="number">1</span>]:</span><br><span class="line">        payload = block1[:<span class="number">15</span>-j]  <span class="comment"># C_i-1[15-L]前面的数据不要动</span></span><br><span class="line">        payload +=xor(block1[<span class="number">15</span>-j],i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>))+t2 <span class="comment"># 组合成第C_i-1密文块</span></span><br><span class="line">        payload +=block2    <span class="comment">#加上尾块</span></span><br><span class="line">        payload = payload.<span class="built_in">hex</span>().encode() <span class="comment"># 转换为16进制字符形式,再转换为字节形式发送</span></span><br><span class="line">        <span class="comment">#print(len(payload))</span></span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">        rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">        <span class="comment">#print(rec)</span></span><br><span class="line">        <span class="keyword">if</span> rec==<span class="string">&#x27;True&#x27;</span>: <span class="comment"># 判断是否能得到True的应答</span></span><br><span class="line">            <span class="comment">#print(&quot;find---&gt;&quot;,xor(i.to_bytes(1,&#x27;big&#x27;),j+1)) # 爆破到明文</span></span><br><span class="line">            text = xor(i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>),j+<span class="number">1</span>).decode() + text <span class="comment"># 添加到text中</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;text---&gt;&quot;</span>,text)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(c_list)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>),leave=<span class="string">&#x27;true&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;block<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> i&gt;=<span class="number">1</span>:</span><br><span class="line">        attack_other_block(c_list[i-<span class="number">1</span>],c_list[i])</span><br><span class="line">    <span class="keyword">elif</span> i==<span class="number">0</span>:</span><br><span class="line">        attack_other_block(iv,c_list[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;text:&#x27;</span>,text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;encrypt_flag:&#x27;</span>,c1)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：暑假复现了两题，感觉太少了没发（有碎碎念）</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-flask框架开发</title>
    <link href="http://iyheart.github.io/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/"/>
    <id>http://iyheart.github.io/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/</id>
    <published>2025-09-02T00:47:37.000Z</published>
    <updated>2025-09-03T07:55:24.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flask开发规范"><a href="#flask开发规范" class="headerlink" title="flask开发规范"></a>flask开发规范</h1><h2 id="hello_world"><a href="#Hello-world" class="headerlink" title="Hello_world"></a>Hello_world</h2><p>对于flask框架的开发，一般都是遵循着如下格式模版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902223748762.png" alt="image-20250902223748762"></p><h2 id="路由规范"><a href="#路由规范" class="headerlink" title="路由规范"></a>路由规范</h2><ol><li>路由定义的路径名称应尽量与其绑定的函数名称应该<strong>尽量相同</strong></li></ol><h2 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h2><ul><li>对于一个比较复杂的项目结构，该结构的目录如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">my_flask_app/</span><br><span class="line">│</span><br><span class="line">├── app/ </span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── routes/  <span class="comment"># 路由逻辑</span></span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── main.py</span><br><span class="line">│   │   └── auth.py</span><br><span class="line">│   ├── models/    <span class="comment"># 数据库模型</span></span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   └── user.py</span><br><span class="line">│   ├── templates/<span class="comment"># 前端展示相关</span></span><br><span class="line">│   │   ├── layout.html</span><br><span class="line">│   │   └── home.html</span><br><span class="line">│   └── static/<span class="comment"># 前端展示相关</span></span><br><span class="line">│       ├── css/</span><br><span class="line">│       └── js/</span><br><span class="line">│</span><br><span class="line">├── config.py<span class="comment"># 配置</span></span><br><span class="line">├── requirements.txt<span class="comment"># 项目依赖</span></span><br><span class="line">├── migrations/<span class="comment"># 数据库版本管理</span></span><br><span class="line">│   └── ...</span><br><span class="line">└── run.py<span class="comment"># 程序启动文件</span></span><br></pre></td></tr></table></figure><h1 id="flask路由"><a href="#flask路由" class="headerlink" title="flask路由"></a>flask路由</h1><ul><li>在flask中路由并不是指网络层的那些东西，而是web应用将<code>URL映射</code>到<code>python</code>函数的机制。flask路由是flask应用的核心部分，用于处理不同的<code>URL</code>的请求，并将请求的处理委托给相应的视图函数。</li><li>下面是关于Flask路由的详细说明：<ul><li>定义路由：<code>@app.route(&quot;/path&quot;)</code>装饰器定义URL和视图函数的映射。</li><li>路由参数：通过动态部分在<code>URL</code>中传递参数</li><li>路由规则：使用类型转换器指定URL参数传递的类型，字符串、整数、浮点数、路径。</li><li>请求方法：指定允许的HTTP请求方法。</li><li>路由函数返回：视图函数可以返回不同的类型响应。</li><li>静态文件和模版：管理静态文件和动态渲染HTML模版。</li><li>路由优先级：确保路由顺序正确，以避免意外匹配结果。</li></ul></li></ul><h2 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h2><p>路由的定义其实就是如下两步：</p><ul><li>第一步先在一行中写上<code>@app.route(&quot;/path&quot;)</code>。</li><li>第二步紧接着定义一个函数，这个函数被称为<strong>视图函数</strong>，例子就用<code>hello_world</code>的这个例子</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><h2 id="参数接收"><a href="#参数接收" class="headerlink" title="参数接收"></a>参数接收</h2><ul><li>在定义路由的时候定义这样的形式：<code>@app.route(&#39;/say/&lt;name&gt;&#39;)</code>，这就是表示将<code>URL</code>请求的一些路径参数传递给函数，这个<code>name</code>其实是一个变量名称。</li><li>当使用<code>URL</code>访问<code>/say/xxx</code>，此时<code>name=xxx</code>就会作为参数传递给其绑定的函数，所以路由绑定的函数就会存在<code>name</code>这个参数，而这个<code>xxx</code>是被用户决定的。</li><li>例子：对于如下代码，当我们访问<code>/say/aaa</code>，<code>name=&#39;aaa&#39;</code>，此时就会返回<code>hello aaa</code>；如果访问<code>/say/bbb</code>，此时就会返回<code>hello bbb</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/say/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;hello <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225006459.png" alt="image-20250902225006459"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225103185.png" alt="image-20250902225103185"></p><h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><ul><li>对于参数的接收可以指定一个规则，使得接收的参数为整型会绑定一个函数，接收的参数为字符串类型会绑定另一个函数。这个规则的定义如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/type/&lt;int:number&gt;&quot;</span></span>) </span><span class="comment"># &lt;数据类型:变量名&gt;</span></span><br></pre></td></tr></table></figure><ul><li>例子如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/type/&lt;int:number&gt;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">type1</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;int,<span class="subst">&#123;number&#125;</span>&quot;</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/type/&lt;string:strs&gt;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">type2</span>(<span class="params">strs</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;str,<span class="subst">&#123;strs&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225722918.png" alt="image-20250902225722918"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225735722.png" alt="image-20250902225735722"></p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ul><li><p>这里的请求方法指的是<code>http</code>协议的请求方法，常见的<code>http</code>协议的请求方法有：<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>。这里指简单介绍<code>GET</code>请求和<code>POST</code>请求。</p></li><li><p>定义的形式如下：选定传入的参数为<code>methods</code>，<code>methods</code>为一个列表类型，它需要指定为接收的方法类型，比如只处理get请求，就只写<code>[&#39;GET&#39;]</code>；如果需要处理get、post请求，就需要写<code>[&#39;GET&#39;,&#39;POST&#39;]</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/get&quot;</span>,methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br></pre></td></tr></table></figure><ul><li>例子如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/get&quot;</span>,methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;这是一个get请求&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/post&quot;</span>,methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;这是一个post请求&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902230653213.png" alt="image-20250902230653213"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902231047893.png" alt="image-20250902231047893"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902232053306.png" alt="image-20250902232053306"></p><h2 id="视图函数返回"><a href="#视图函数返回" class="headerlink" title="视图函数返回"></a>视图函数返回</h2><p>视图函数的返回可以返回<code>字符串、html、标签、json文件、自定义请求响应</code>，这里直接从例子入手。</p><ul><li>例子1：返回<code>json</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/json&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">json_func</span>():</span><br><span class="line">    dicts=<span class="built_in">dict</span>()</span><br><span class="line">    dicts[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;tome&quot;</span></span><br><span class="line">    dicts[<span class="string">&quot;age&quot;</span>] = <span class="number">19</span></span><br><span class="line">    <span class="keyword">return</span> flask.jsonify(dicts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902233706687.png" alt="image-20250902233706687"></p><ul><li>例子2：返回<code>字符串</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/str&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;strs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902233815127.png" alt="image-20250902233815127"></p><ul><li>例子3：返回<code>html</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/html&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">html_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;html&lt;/h1&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902233914436.png" alt="image-20250902233914436"></p><ul><li>例子4：返回自定义请求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/response&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">response_func</span>():</span><br><span class="line">    response=flask.Response(<span class="string">&quot;defi response&quot;</span>,status=<span class="number">200</span>)</span><br><span class="line">    response.headers[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;definiresponse&quot;</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902234501110.png" alt="image-20250902234501110"></p><h2 id="静态文件与模版"><a href="#静态文件与模版" class="headerlink" title="静态文件与模版"></a>静态文件与模版</h2><ul><li><p>静态文件和模版：管理静态文件和动态渲染HTML模版。例如：<code>.html、.png、.jpg</code>文件</p></li><li><p>这个其实也是路由函数的一种返回类型，是直接返回文件。需要使用<code>flask</code>中的<code>flask.render_template()</code>函数，使用<code>flask.render_template()</code>，该函数会从当前目录下的一个名为<code>templates</code>的目录作为根目录去寻找对应的文件。</p></li></ul><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902235026791.png" alt="image-20250902235026791"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/return_html&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_html_func</span>():</span><br><span class="line">    <span class="keyword">return</span> flask.render_template(<span class="string">&#x27;./example.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902235038747.png" alt="image-20250902235038747"></p><h2 id="路由优先级"><a href="#路由优先级" class="headerlink" title="路由优先级"></a>路由优先级</h2><ul><li>当存在两个相同的路由时，使用<code>URL</code>访问路由函数时，到底是先调用哪个路由函数，这个就需要使用路由优先级确定。</li><li>路由优先级原则：哪个路由函数先被定义，先被定义的路由函数优先级就会更高。访问该路径的时候，使用的路由函数始终是<code>func1</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/my_route&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Func1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/my_route&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Func2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902235353791.png" alt="image-20250902235353791"></p><h1 id="flask视图函数"><a href="#flask视图函数" class="headerlink" title="flask视图函数"></a>flask视图函数</h1><ul><li>视图函数其实就是与<code>flask</code>路由绑定起来的函数，该函数被称为视图函数。视图函数一般最经常用来处理前端发送过来的请求，后端的逻辑一般都在<code>flask</code>视图函数中编写。</li><li>对于<code>flask</code>视图函数，主要就是前后端交互的处理，一般就是接收和处理前端发送过来的数据，然后将处理结果返回给前端，从而达到前后端交互目的。</li></ul><h2 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h2><h2 id="返回响应"><a href="#返回响应" class="headerlink" title="返回响应"></a>返回响应</h2><h2 id="处理请求相应"><a href="#处理请求相应" class="headerlink" title="处理请求相应"></a>处理请求相应</h2><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><h2 id="视图函数装饰器"><a href="#视图函数装饰器" class="headerlink" title="视图函数装饰器"></a>视图函数装饰器</h2><ul><li><p>函数装饰器是<code>python</code>的一个特性，而<code>flask</code>框架有一些定义好的函数装饰器，接下来就是要学习<code>flask</code>框架的视图函数装饰器。</p></li><li><p>对于视图函数修饰器，效果有点类似于<code>@app.route</code>这个功能，<code>route</code>是对视图函数将URL进行绑定。而视图函数修饰器也类似于用来绑定函数的。接下来介绍几个修饰器的关键字，用户还可以<strong>自定义视图函数修饰器</strong>：</p><ul><li>路由相关：<ul><li><code>@app.get(&#39;/path&#39;)</code>：相当于<code>@app.route(&#39;/path&#39;, methods=[&#39;GET&#39;])</code>，只响应<code>GET</code>请求</li><li><code>@app.post(&#39;/path&#39;)</code>：相当于<code>@app.route(&#39;/path&#39;, methods=[&#39;POST&#39;])</code>，只响应<code>post</code>请求</li><li><code>@app.put(&#39;/path&#39;)</code> 、<code>@app.delete(&#39;/path&#39;)</code> 、 <code>@app.patch(&#39;/path&#39;)</code>：<br> 分别对应 PUT、DELETE、PATCH 请求。</li><li><code>@app.route(&#39;/path&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;])</code>：可以处理多个请求。</li></ul></li><li>请求钩子：<ul><li><code>@app.before_request</code>：在每个请求之前运行的函数。</li><li><code>@app.after_request</code>：在每个请求处理之后的函数</li><li><code>@app.teardown_request</code>：在请求结束之后运行的函数，用于清理工作</li></ul></li><li>错误处理修饰器：<ul><li><code>@app.errorhandler(404)</code>：捕获404错误，返回自定义页面</li><li><code>@app.errorhandler(Exception)</code>：捕获所有异常，可返回统一的错误信息</li></ul></li><li>蓝图相关修饰器：<ul><li><code>@bp.route(&#39;/path&#39;)</code>：类似于<code>@app.route(&#39;/path&#39;)</code>，但是只作用于蓝图</li><li><code>@bp.before_app_request</code>：只作用于蓝图的钩子函数。</li></ul></li></ul></li></ul><h1 id="flask模版渲染"><a href="#flask模版渲染" class="headerlink" title="flask模版渲染"></a>flask模版渲染</h1><ul><li>在web开发中，模版一般是指带有占位符的<code>HTML</code>文件，这样其实就能根据一些用户信息或者用户的请求在前端显示不同的信息。</li></ul><h1 id="项目1登录界面"><a href="#项目1—登录界面" class="headerlink" title="项目1—登录界面"></a>项目1—登录界面</h1><h2 id="阶段1"><a href="#阶段1" class="headerlink" title="阶段1"></a>阶段1</h2><h2 id="阶段2"><a href="#阶段2" class="headerlink" title="阶段2"></a>阶段2</h2><h2 id="阶段3"><a href="#阶段3" class="headerlink" title="阶段3"></a>阶段3</h2>]]></content>
    
    
    <summary type="html">前言：5天时间内要完成一个课设，还是赶紧学吧。</summary>
    
    
    
    <category term="开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="后端" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/%E5%90%8E%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>伪随机数生成器MT19937</title>
    <link href="http://iyheart.github.io/2025/09/02/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/MT19937%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://iyheart.github.io/2025/09/02/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/MT19937%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2025-09-02T00:04:49.000Z</published>
    <updated>2025-09-02T00:42:10.409Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>做到相关的题目就直接来先学习一下。</p></li><li><p>参考博客：<a href="https://seandictionary.top/mt19937/">https://seandictionary.top/mt19937/</a></p></li><li>参考文章：<a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister - Wikipedia</a></li><li>参考博客：<a href="https://hasegawaazusa.github.io/mersenne-twister-note.html">https://hasegawaazusa.github.io/mersenne-twister-note.html</a></li><li>参考博客：<a href="https://huangx607087.online/2021/07/10/Explore-MT19937/">https://huangx607087.online/2021/07/10/Explore-MT19937/</a></li><li>参考博客：<a href="https://xenny.wiki/posts/crypto/PRNG/MT19937.html">MT19937 分析 | Xenny 的博客</a>，<code>Xenny</code>老师这篇将如何逆向MT19937讲的挺好的。</li></ul><h1 id="mt19937"><a href="#MT19937" class="headerlink" title="MT19937"></a>MT19937</h1><ul><li>对于<code>MT19937</code>的介绍，已经在前面的一篇文章中介绍过了，接下来就具体学习一下<code>MT19937</code>具体的算法过程。</li><li>对于<code>MT19937</code>的应用，其实很多语言的<code>random</code>这个库都使用的是<code>MT19937</code>这个算法，比如<code>python</code>、<code>PHP</code>和<code>Matlab</code>，并且从<code>C++11</code>开始，<code>C++</code>也可以使用梅森旋转算法（MT19937）,对应的命名空间为<code>std::mt19937_64</code>。</li><li><code>MT19937</code>这个伪随机数生成器，目前被视为最好的随机数算法。</li><li>做个统一：以下文章中的内容都以<code>MT19937</code>来表示该算法。</li></ul><h2 id="mt19937原始版本"><a href="#MT19937原始版本" class="headerlink" title="MT19937原始版本"></a>MT19937原始版本</h2><ul><li><p>该版本其实就是使用<code>32</code>位的整数作为该算法的种子。之后的<code>64</code>位是后来的一个变种版本，初学的时候一开始只要学原始版本即可。</p></li><li><p>接下来我们一步一步介绍一下<code>MT19937</code>的具体过程，采用的是该博客的方式：<a href="https://hasegawaazusa.github.io/mersenne-twister-note.html，先分布介绍，最后再将算法有个整体概念。">https://hasegawaazusa.github.io/mersenne-twister-note.html，先分布介绍，最后再将算法有个整体概念。</a></p></li><li><p>代码采用的是这篇博客的代码，实现的比较简洁：<a href="https://huangx607087.online/2021/07/10/Explore-MT19937/">https://huangx607087.online/2021/07/10/Explore-MT19937/</a></p></li><li><p>这个算法其实总的来说有三个部分，分别就是<code>初始化操作</code>、<code>获得伪随机数(提取伪随机数)</code>、<code>梅森旋转操作</code></p></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于Python中支持无限长度的整型,所以我们需要定义一个函数来实现32位整型的提取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_int32</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span> &amp; x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个MT19937的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,seed</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先对数据进行初始化操作,并且定义一些固定的值以及用户传进来的值</span></span><br><span class="line"><span class="string">        1.mt:表示624个初始状态的寄存器,这里使用长度为624的列表表示</span></span><br><span class="line"><span class="string">        2.seed:表示用户传入的随机数种子,并将该种子赋值给mt[0],即第一个寄存器</span></span><br><span class="line"><span class="string">        3.mtinit: 是用于初始化的一个常数,该数可以用于提高初始种子的扩散效果</span></span><br><span class="line"><span class="string">        4.mti:这里先设定一个初值0,在初始化的时候用不到</span></span><br><span class="line"><span class="string">        5.最后进行623次的for循环,通过递推的方式为每一个初始状态寄存器都进行初始化</span></span><br><span class="line"><span class="string">        (也就是说初始状态寄存器的值与seed关联性是比较强的)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.mt = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">        self.mt[<span class="number">0</span>] = seed</span><br><span class="line">        self.mti=<span class="number">0</span></span><br><span class="line">        self.mtinit = <span class="number">0x6c078965</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">624</span>):</span><br><span class="line">            self.mt[i] = _int32(self.mtinit * (self.mt[i-<span class="number">1</span>] ^ self.mt[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>) + i)</span><br></pre></td></tr></table></figure><ul><li>这里主要就是利用用户传入的种子，对该<code>MT19937</code>中的初始状态寄存器做一个初始化操作，使得<code>624</code>个初始化状态寄存器都有对应的值。</li></ul><h3 id="提取伪随机数"><a href="#提取伪随机数" class="headerlink" title="提取伪随机数"></a>提取伪随机数</h3><ul><li>代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getbits</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1.这个步骤就是利用之前生成的624个初始状态寄存器的值,通过梅森旋转以及位运算</span></span><br><span class="line"><span class="string">      从而计算出这一次触发时我们得到的伪随机数的值</span></span><br><span class="line"><span class="string">    2.mti其实这里就是记录用户获取随机数的此时,以624为一个周期,每获取一个周期后就会触发梅森旋转(也被称为回火策略)</span></span><br><span class="line"><span class="string">    3.一开始mti为0的时候就会先触发一次梅森旋转</span></span><br><span class="line"><span class="string">    4. 2636928640(即0x9D2C5680)和4022730752(即0xEFC60000)都是常量。前者混合中位，掩盖模式特征;后者混合高位，增强熵</span></span><br><span class="line"><span class="string">    5. 这些常数保证了输出的质量和周期长度,并不能随意修改</span></span><br><span class="line"><span class="string">    :return: 返回值就是一个32位的整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.mti==<span class="number">0</span>:</span><br><span class="line">        self.twist()</span><br><span class="line">    y = self.mt[self.mti]</span><br><span class="line">    y = y ^ y &gt;&gt; <span class="number">11</span> <span class="comment"># 先左移后异或,位移运算优先级高于异或</span></span><br><span class="line">    y = y ^ y &gt;&gt; <span class="number">7</span> &amp; <span class="number">2636928640</span> <span class="comment"># 先左移,再进行与操作,最后再异或</span></span><br><span class="line">    y = y ^ y &lt;&lt; <span class="number">15</span> &amp; <span class="number">4022730752</span></span><br><span class="line">    y = y ^ y &gt;&gt; <span class="number">18</span></span><br><span class="line">    self.mti = (self.mti + <span class="number">1</span>) % <span class="number">624</span></span><br><span class="line">    <span class="keyword">return</span> _int32(y)</span><br></pre></td></tr></table></figure><h3 id="梅森旋转操作"><a href="#梅森旋转操作" class="headerlink" title="梅森旋转操作"></a>梅森旋转操作</h3><ul><li>代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twist</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    直接将624个初始状态寄存器进行一个梅森旋转操作，</span></span><br><span class="line"><span class="string">    旋转过程涉及位运算以及与当前初始状态寄存器i以及第i+397个寄存器的状态有关</span></span><br><span class="line"><span class="string">    :return: 无返回值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">624</span>):</span><br><span class="line">        <span class="comment"># 主要就是与一个固定的0x80000000 和 0x7fffffff</span></span><br><span class="line">        <span class="comment"># 这里就表示用第i个初始状态寄存器的最高位 + 第i+1个初始状态寄存器的第1-31位</span></span><br><span class="line">        y = _int32((self.mt[i]) &amp; <span class="number">0x80000000</span>) + (self.mt[(i + <span class="number">1</span>) % <span class="number">624</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">        <span class="comment"># 之后就是更新当前初始状态寄存器的的值</span></span><br><span class="line">        self.mt[i] = (y &gt;&gt; <span class="number">1</span>) ^ self.mt[(i+<span class="number">397</span>) % <span class="number">624</span>]</span><br><span class="line">        <span class="keyword">if</span> y % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            self.mt[i] = self.mt[i] ^ <span class="number">0x9908b0df</span></span><br></pre></td></tr></table></figure><h3 id="总体代码"><a href="#总体代码" class="headerlink" title="总体代码"></a>总体代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于Python中支持无限长度的整型,所以我们需要定义一个函数来实现32位整型的提取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_int32</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span> &amp; x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个MT19937的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,seed</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先对数据进行初始化操作,并且定义一些固定的值以及用户传进来的值</span></span><br><span class="line"><span class="string">        1.mt:表示624个初始状态的寄存器,这里使用长度为624的列表表示</span></span><br><span class="line"><span class="string">        2.seed:表示用户传入的随机数种子,并将该种子赋值给mt[0],即第一个寄存器</span></span><br><span class="line"><span class="string">        3.mtinit: 是用于初始化的一个常数,该数可以用于提高初始种子的扩散效果</span></span><br><span class="line"><span class="string">        4.mti:这里先设定一个初值0,在初始化的时候用不到,</span></span><br><span class="line"><span class="string">        5.最后进行623次的for循环,通过递推的方式为每一个初始状态寄存器都进行初始化</span></span><br><span class="line"><span class="string">        (也就是说初始状态寄存器的值与seed关联性是比较强的)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.mt = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">        self.mt[<span class="number">0</span>] = seed</span><br><span class="line">        self.mti=<span class="number">0</span></span><br><span class="line">        self.mtinit = <span class="number">0x6c078965</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">624</span>):</span><br><span class="line">            self.mt[i] = _int32(self.mtinit * (self.mt[i-<span class="number">1</span>] ^ self.mt[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>) + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getbits</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1.这个步骤就是利用之前生成的624个初始状态寄存器的值,通过梅森旋转以及位运算</span></span><br><span class="line"><span class="string">          从而计算出这一次触发时我们得到的伪随机数的值</span></span><br><span class="line"><span class="string">        2.mti其实这里就是记录用户获取随机数的此时,以624为一个周期,每获取一个周期后就会触发梅森旋转(也被称为回火策略)</span></span><br><span class="line"><span class="string">        3.一开始mti为0的时候就会先触发一次梅森旋转</span></span><br><span class="line"><span class="string">        4. 2636928640(即0x9D2C5680)和4022730752(即0xEFC60000)都是常量。前者混合中位，掩盖模式特征;后者混合高位，增强熵</span></span><br><span class="line"><span class="string">        5. 这些常数保证了输出的质量和周期长度,并不能随意修改</span></span><br><span class="line"><span class="string">        :return: 返回值就是一个32位的整数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.mti==<span class="number">0</span>:</span><br><span class="line">            self.twist()</span><br><span class="line">        y = self.mt[self.mti]</span><br><span class="line">        y = y ^ y &gt;&gt; <span class="number">11</span> <span class="comment"># 先左移后异或,位移运算优先级高于异或</span></span><br><span class="line">        y = y ^ y &gt;&gt; <span class="number">7</span> &amp; <span class="number">2636928640</span> <span class="comment"># 先左移,再进行与操作,最后再异或</span></span><br><span class="line">        y = y ^ y &lt;&lt; <span class="number">15</span> &amp; <span class="number">4022730752</span></span><br><span class="line">        y = y ^ y &gt;&gt; <span class="number">18</span></span><br><span class="line">        self.mti = (self.mti + <span class="number">1</span>) % <span class="number">624</span></span><br><span class="line">        <span class="keyword">return</span> _int32(y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twist</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        直接将624个初始状态寄存器进行一个梅森旋转操作，</span></span><br><span class="line"><span class="string">        旋转过程涉及位运算以及与当前初始状态寄存器i以及第i+397个寄存器的状态有关</span></span><br><span class="line"><span class="string">        :return: 无返回值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">624</span>):</span><br><span class="line">            <span class="comment"># 主要就是与一个固定的0x80000000 和 0x7fffffff</span></span><br><span class="line">            <span class="comment"># 这里就表示用第i个初始状态寄存器的最高位 + 第i+1个初始状态寄存器的第1-31位</span></span><br><span class="line">            y = _int32((self.mt[i]) &amp; <span class="number">0x80000000</span>) + (self.mt[(i + <span class="number">1</span>) % <span class="number">624</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">            <span class="comment"># 之后就是更新当前初始状态寄存器的的值</span></span><br><span class="line">            self.mt[i] = (y &gt;&gt; <span class="number">1</span>) ^ self.mt[(i+<span class="number">397</span>) % <span class="number">624</span>]</span><br><span class="line">            <span class="keyword">if</span> y % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                self.mt[i] = self.mt[i] ^ <span class="number">0x9908b0df</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="mt19937-64版本"><a href="#MT19937-64版本" class="headerlink" title="MT19937-64版本"></a>MT19937-64版本</h2><h1 id="mt19937破解"><a href="#MT19937破解" class="headerlink" title="MT19937破解"></a>MT19937破解</h1><ul><li>这一部分是参考：<a href="https://hasegawaazusa.github.io/mersenne-twister-note.html">Mersenne Twister 梅森旋转算法笔记 | 独奏の小屋</a></li></ul><h2 id="状态破解"><a href="#状态破解" class="headerlink" title="状态破解"></a>状态破解</h2><h2 id="矩阵状态破解"><a href="#矩阵状态破解" class="headerlink" title="矩阵状态破解"></a>矩阵状态破解</h2><h2 id="旋转破解"><a href="#旋转破解" class="headerlink" title="旋转破解"></a>旋转破解</h2><h1 id="mt19937常见题型"><a href="#MT19937常见题型" class="headerlink" title="MT19937常见题型"></a>MT19937常见题型</h1><ul><li>这一部分主要是参考：<a href="https://huangx607087.online/2021/07/10/Explore-MT19937/">https://huangx607087.online/2021/07/10/Explore-MT19937/</a></li><li>由于初始状态寄存器一共有<code>624*32=19968个bit位</code>，所以要恢复、预测等需要<code>19968</code>个bit位，所以在<code>MT19937</code>的题型都是围绕着已知<code>bit</code>位来实现的。</li></ul><h2 id="题型1_预测随机数"><a href="#题型1-预测随机数" class="headerlink" title="题型1_预测随机数"></a>题型1_预测随机数</h2><ul><li>给了足够多的数据后其实可以预测随机数的，并且有在Python中其实有现成的库可以使用，当然其实也可以自己逆向以下<code>MT19937</code>的算法，自己预测破解。</li></ul><h3 id="题目1_xyctf2025_division"><a href="#题目1-XYCTF2025-Division" class="headerlink" title="题目1_XYCTF2025_Division"></a>题目1_XYCTF2025_Division</h3><h3 id="题目2_"><a href="#题目2" class="headerlink" title="题目2_"></a>题目2_</h3><h2 id="题型2_恢复随机数"><a href="#题型2-恢复随机数" class="headerlink" title="题型2_恢复随机数"></a>题型2_恢复随机数</h2><ul><li>这类题型其实就是选用一开始生成的随机数对<code>flag</code>等密文进行加密，之后给你后续一大堆随机数，让你恢复出随机数种子和初始状态寄存器</li><li>恢复出随机数种子和初始状态寄存器，从而可以得到一开始生成的随机数值，从而获得密钥，对<code>flag</code>的密文进行解密操作。</li></ul><h3 id="题目1_xyctf2025_choice"><a href="#题目1-XYCTF2025-choice" class="headerlink" title="题目1_XYCTF2025_choice"></a>题目1_XYCTF2025_choice</h3><h2 id="题型3_给一定量任意的bit"><a href="#题型3-给一定量任意的bit" class="headerlink" title="题型3_给一定量任意的bit"></a>题型3_给一定量任意的bit</h2><ul><li>这种情况是题目给你一定量<code>任意的伪随机数的bit</code>，从而让你恢复这个伪随机数。这种情况其实就是要进行一定量的操作了。</li><li>有些情况他会给你足够的<code>bit</code>也就是<code>19968</code>个<code>bit</code>或者超过<code>19968个</code>bit，此时还是比较好恢复初始状态寄存器的。</li><li>但是有些情况题目不会给你足够数量的<code>bit</code>位，此时可能就需要对<code>MT19937</code>的旋转过程或者其他过程进行破解。从而恢复初始状态寄存器。</li></ul><h3 id="题目1_random-game"><a href="#题目1-Random-game" class="headerlink" title="题目1_Random game"></a>题目1_Random game</h3><h3 id="题目2_never-enough"><a href="#题目2-never-enough" class="headerlink" title="题目2_never enough"></a>题目2_never enough</h3><h1 id="相关库分析"><a href="#相关库分析" class="headerlink" title="相关库分析"></a>相关库分析</h1><h2 id="python中random库"><a href="#python中random库" class="headerlink" title="python中random库"></a>python中random库</h2><h2 id="c中stdmt19937_64"><a href="#C-中std-mt19937-64" class="headerlink" title="C++中std::mt19937_64"></a>C++中std::mt19937_64</h2>]]></content>
    
    
    <summary type="html">前言：学习一下比较常用的MT19937</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="伪随机数" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>一次性签名-WOTS</title>
    <link href="http://iyheart.github.io/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/"/>
    <id>http://iyheart.github.io/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/</id>
    <published>2025-08-31T08:06:07.000Z</published>
    <updated>2025-09-01T14:59:56.250Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考文章：<a href="https://mp.weixin.qq.com/s/9ik2fPXH3OP1q7SrH-wLZw">https://mp.weixin.qq.com/s/9ik2fPXH3OP1q7SrH-wLZw</a></li></ul><h1 id="wots介绍"><a href="#WOTS介绍" class="headerlink" title="WOTS介绍"></a>WOTS介绍</h1><ul><li><code>WOTS</code>全称为<code>Winternitz one-time signature scheme</code>，翻译过来就被叫做<code>Winternitz 一次性签名方案</code>，该数字签名为<code>Robert Winternitz</code>提出的。</li><li><code>WOTS</code>这个数字签名是<strong>基于哈希的签名算法</strong>，该签名是<code>Lamport</code>签名的改进算法，通过时间换空间的思路，减少了签名的体积。</li><li>应用场景：<ul><li>作为<code>XMSS</code>、<code>SPHINCS</code>等现代化哈希签名体系的核心组件。</li><li>适合在抗练字密码学中作为安全的签名方案</li><li>由于<code>WOTS</code>是一次性签名，通常配合<code>Merkle</code>树扩展成多次使用的签名体系。</li></ul></li></ul><h1 id="wots算法过程"><a href="#WOTS算法过程" class="headerlink" title="WOTS算法过程"></a>WOTS算法过程</h1><ul><li>对于这个算法来说，主要包括的还是密钥生成、签名、数字签名的验证三个算法，所以<code>WOTS</code>算法过程主要就是分为<code>密钥生成</code>、<code>签名</code>、<code>数字签名的验证</code>三个过程</li><li>注意：这个数字签名算法需要多看几遍才能看明白，而且第一次看的时候会有点懵，需要从整体把握这样才能明白每一步为什么要这样选取数据。</li></ul><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p><strong>确定同时签名的位数</strong>：首先需要先选取一个$\omega\ge2$，$\omega$表示要<strong>同时签名的位数</strong>，并且还控制着公钥的<strong>哈希次数</strong>。</p><ul><li>这里例举一个例子帮助理解：比如：要签名<code>a-&gt;01100001</code>，如果选取$w=2$，那么签名的时候对于<code>a-&gt;01100001</code>就会将它的二进制位，按照俩个一组进行组合，将组合后的数据进行哈希计算<code>h(01)、h(10)、h(00)、h(01)</code>。</li><li>注意：一般来说$\omega=8$，因为<code>8</code>位是一个字节刚好可以一个字节同时进行数字签名。</li></ul><p><strong>选取一个哈希函数</strong>：确定哈希函数的消息摘要长度是<code>256</code>位，还是<code>128</code>位将会影响后续公钥和私钥的长度。这边选取目前最常用的<code>sha2-256</code>。即哈希摘要长度为<code>256</code>位，转换为字节数就是<code>32</code>字节。</p><p><strong>私钥的选取</strong>：要确定私钥的个数，私钥的大小。</p><ul><li><p>私钥的个数由俩个部分组成：</p><ul><li><p>第一个部分$t_1$：由同时签名的位数$\omega$与哈希函数的消息摘要长度决定，即哈希摘要的位数$256/\omega$，这里$t_1=32$</p></li><li><p>第二个部分$t_2$：由同时签名的位数$\omega$与后面校验和的长度决定，根据下面的校验和长度，选择$t_2=2$</p></li></ul></li><li><p>私钥的生成的大小其实就是在$x_i\in[0,2^{256}),i=1,2,..,t-1$这个范围内，而这个<code>256</code>其实就是选取哈希函数消息摘要的位数。这样就形成了一个私钥。</p></li></ul><script type="math/tex; mode=display">Sk=(x_{t-1},...,x_1,x_0),t=t_1+t_2</script><p><strong>公钥的计算</strong>：公钥的计算其实比较简单，就是将私钥进行一定次数的哈希计算，形成哈希链。而哈希的次数是由$\omega$决定的。</p><script type="math/tex; mode=display">y_i=h^{2^{\omega}-1}(x_i)=h^{256}(x_i),0\le i \le t-1\\Pk=(y_{t-1},...,y_1,y_0)</script><ul><li>由于$\omega=8$，哈希的次数为<code>255</code>，哈希的次数比较合适（太多会导致运算时间太高，太少导致容易被破解）。</li></ul><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><ul><li>假设消息是<code>m</code>，首先需要通过一次哈希，将消息<code>m</code>映射到固定的长度，这里选取<code>sha2-256</code>，所以消息<code>m</code>会被映射成<code>256</code>位。接下来就需要对这个<code>256</code>位的哈希值进行分组操作，将这个<code>256</code>位的哈希值分成$\omega$位一组，这里也就是<code>8</code>位一组。</li></ul><script type="math/tex; mode=display">h(m) = b_{t_1-1}||...||b_0</script><ul><li>接下来需要对分组的$b_i$计算一个校验和，具体的计算方式如下：</li></ul><script type="math/tex; mode=display">c = \sum_{i=0}^{t_1-1}(2^{\omega}-b_i)</script><ul><li>求得校验和<code>c</code>后，需要将<code>c</code>转换为比特串，将转换成的比特串继续按照$\omega$位一组进行分组，一共可以分得$t_2$组，而这个$t_2$就是前面私钥的个数$t=t_1+t_2$中的$t_2$，而通过计算这里的$t_2=2$</li></ul><script type="math/tex; mode=display">c=b_{t_2-1}||...||b_0</script><ul><li>这里将<code>h(m)</code>和<code>c</code>组合起来得到<code>d</code>：</li></ul><script type="math/tex; mode=display">d=c||h(m)=d_{t-1}||...||d_{t-t_2-1}||....d_0</script><ul><li>最终就需要对消息的哈希值与校验和进行签名得到最终的签名<code>V</code>，最坏的情况需要执行$2^{\omega-1}$次的哈希函数运算：</li></ul><script type="math/tex; mode=display">v_i =h^{d_i}(sk_i),i=0,1,...,t-1\\V = (v_{t-1},...,t_1,t_0)</script><h2 id="验签算法"><a href="#验签算法" class="headerlink" title="验签算法"></a>验签算法</h2><ul><li>验证签名的运算其实就是将哈希链的计算次数达到<code>255</code>次并判断是否与公钥相等。也就是先进行哈希函数的运算：</li></ul><script type="math/tex; mode=display">v'_i = h^{255-d_i}(v_i)\\V'=(v'_{t-1},...,v'_{1},v'_0)</script><ul><li>最后判断$pk_i$是否与$v’_i$相等，如果存在有一个数据不相等就说明签名验证不成功，说明消息或者某些数据被更改了。</li></ul><p>注意：这是一次性数字签名方案，说明如果重复使用同一个私钥对不同消息进行数字签名，很可能就能伪造数字签名了。所以一次性数字签名在可能会存在<strong>重复使用私钥的情况</strong>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li>实现的代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 使用sha2-256进行哈希链的计算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_chain</span>(<span class="params">m,x</span>):</span><br><span class="line">    t = m</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x):</span><br><span class="line">        t = sha256(t).digest()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建公钥和私钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">key_gen</span>():</span><br><span class="line">    omega,t1,t2 = <span class="number">8</span>, <span class="number">32</span>, <span class="number">2</span></span><br><span class="line">    sk = [random.randint(<span class="number">0</span>,<span class="number">2</span>**(omega * <span class="number">32</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t1+t2)] <span class="comment"># 生成私钥</span></span><br><span class="line">    pk = [hash_chain(long_to_bytes(m),<span class="number">255</span>) <span class="keyword">for</span> m <span class="keyword">in</span> sk] <span class="comment"># 生成公钥</span></span><br><span class="line">    <span class="keyword">return</span> sk,pk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行签名操作m表示需要签名的消息,sk表示用于签名的私钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">m,sk</span>):</span><br><span class="line">    <span class="comment"># 计算消息的哈希值</span></span><br><span class="line">    m_ = sha256(m).digest()</span><br><span class="line">    <span class="comment"># V用于存储签名的结果</span></span><br><span class="line">    V = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 签名消息</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(m_):</span><br><span class="line">        V.append(hash_chain(long_to_bytes(sk[index]),item))</span><br><span class="line">    sigma = long_to_bytes(<span class="built_in">sum</span>(<span class="built_in">list</span>(m_)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 签名校验和</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(sigma):</span><br><span class="line">        V.append(hash_chain(long_to_bytes(sk[index+<span class="number">32</span>]),item))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行数字签名的验证</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">m,V,pk</span>):</span><br><span class="line">    m_ = sha256(m).digest()</span><br><span class="line">    V_ = []</span><br><span class="line">    <span class="comment"># 计算剩余的哈希链</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(m_):</span><br><span class="line">        V_.append(hash_chain(V[index],<span class="number">255</span>-item))</span><br><span class="line"></span><br><span class="line">    c = long_to_bytes(<span class="built_in">sum</span>(<span class="built_in">list</span>(m_)))</span><br><span class="line">    <span class="comment"># 计算校验和部分的剩余哈希链</span></span><br><span class="line">    <span class="keyword">for</span> index,item <span class="keyword">in</span> <span class="built_in">enumerate</span>(c):</span><br><span class="line">        V_.append(hash_chain(V[index+<span class="number">32</span>],<span class="number">255</span>-item))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断计算出来的哈希链是否与公钥pk相等</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(V_)):</span><br><span class="line">        <span class="keyword">if</span> pk[i] != V_[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sk, pk = key_gen()</span><br><span class="line">    m = <span class="string">b&#x27;AAAA&#x27;</span></span><br><span class="line">    V = sign(m,sk)</span><br><span class="line">    <span class="comment"># 当 m 没被修改时进行认证</span></span><br><span class="line">    result = verify(m,V,pk)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;m没被修改=<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 当 m 被修改过时进行认证</span></span><br><span class="line">    result2 = verify(<span class="string">b&#x27;AAA&#x27;</span>,V,pk)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;m被修改过进行认证=<span class="subst">&#123;result2&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="例题-nepctf2025_nepsign"><a href="#例题-nepctf2025-nepsign" class="headerlink" title="例题-nepctf2025_nepsign"></a>例题-nepctf2025_nepsign</h1><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"><span class="keyword">from</span> ast <span class="keyword">import</span> literal_eval</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">flag = os.environ[<span class="string">&quot;FLAG&quot;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  </span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="comment"># SM3和SM3_n是一块的,实现的就是哈希值计算,所以此题使用的就是SM3作为哈希函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nepsign</span>():</span><br><span class="line">    <span class="comment"># 构造方法, 初始化n = 256 , hex_symbols = &#x27;012....&#x27; ,调用keygen函数</span></span><br><span class="line">    <span class="comment"># 从sign()函数中可以看出,omega = 8</span></span><br><span class="line">    <span class="comment"># 从公钥的生成可以看出哈希链也是哈希了255次</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): </span><br><span class="line">        self.n = <span class="number">256</span></span><br><span class="line">        self.hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">        self.keygen()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 密钥生成方式类似于WOTS(Winternitz one-time signature scheme)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keygen</span>(<span class="params">self</span>): </span><br><span class="line">        rng = SystemRandom()   </span><br><span class="line">        self.sk = [rng.randbytes(<span class="number">32</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)]   <span class="comment"># 生成私钥sk,生成48组</span></span><br><span class="line">        self.pk = [SM3_n(self.sk[_], <span class="number">255</span>, self.n) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)] <span class="comment"># 生成公钥pk,生成48组</span></span><br><span class="line">        <span class="keyword">return</span> self.sk, self.pk <span class="comment"># 返回数据及其哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self, msg, sk=<span class="literal">None</span></span>): <span class="comment"># 签名操作</span></span><br><span class="line">        sk = sk <span class="keyword">if</span> sk <span class="keyword">else</span> self.sk  <span class="comment"># 获取私钥</span></span><br><span class="line">        m = SM3(msg) <span class="comment"># 计算消息msg的哈希值,结果为m</span></span><br><span class="line">        m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>) <span class="comment"># 将哈希值转换为二进制比特填充,填充到256位</span></span><br><span class="line">        a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n // <span class="number">8</span>)] <span class="comment"># 8位一组,8位一组的取出来</span></span><br><span class="line">        step = [<span class="number">0</span>] * <span class="number">48</span> <span class="comment"># 初始化,保存a数组的值</span></span><br><span class="line">        qq = [<span class="number">0</span>] * <span class="number">48</span> <span class="comment"># 初始化,保存hash值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):<span class="comment"># 计算哈希链,哈希次数为step[i],哈希的数据为sk[i]</span></span><br><span class="line">            step[i] = a[i]</span><br><span class="line">            qq[i] = SM3_n(sk[i], step[i]) </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这里相当于自定义了一个校验和,这个校验和是统计m消息的哈希值的16进制字符表示中0~f的索引和</span></span><br><span class="line">        <span class="comment"># 比如m[0]=&#x27;0&#x27;,m[16]=&#x27;0&#x27;,那么sum[0] = 0 + 16</span></span><br><span class="line">        <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">                <span class="keyword">if</span> m[j - <span class="number">1</span>] == self.hex_symbols[i]: </span><br><span class="line">                    <span class="built_in">sum</span>[i] += j     </span><br><span class="line">            step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span>  <span class="comment"># 将sum[i]模上255</span></span><br><span class="line">            qq[i + <span class="number">32</span>] = SM3_n(sk[i + <span class="number">32</span>], step[i + <span class="number">32</span>]) <span class="comment"># 计算校验和部分的哈希链</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> qq] <span class="comment"># 相当于返回qq列表,qq列表长度为</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, msg, qq, pk=<span class="literal">None</span></span>): <span class="comment"># 验证过程</span></span><br><span class="line">        qq = [<span class="built_in">bytes</span>.fromhex(i) <span class="keyword">for</span> i <span class="keyword">in</span> qq] <span class="comment">#</span></span><br><span class="line">        pk = pk <span class="keyword">if</span> pk <span class="keyword">else</span> self.pk</span><br><span class="line">        m = SM3(msg)</span><br><span class="line">        m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">        a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n // <span class="number">8</span>)]</span><br><span class="line">        step = [<span class="number">0</span>] * <span class="number">48</span></span><br><span class="line">        pk_ = [<span class="number">0</span>] * <span class="number">48</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            step[i] = a[i]</span><br><span class="line">            pk_[i] = SM3_n(qq[i], <span class="number">255</span> - step[i]) <span class="comment"># 关键点一共会进行255次哈希,抓住这一点去伪造qq</span></span><br><span class="line">        <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">                <span class="keyword">if</span> m[j - <span class="number">1</span>] == self.hex_symbols[i]:</span><br><span class="line">                    <span class="built_in">sum</span>[i] += j</span><br><span class="line">            step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">            pk_[i + <span class="number">32</span>] = SM3_n(qq[i + <span class="number">32</span>], <span class="number">255</span> - step[i + <span class="number">32</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> pk_ == pk <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;initializing...&#x27;</span>)</span><br><span class="line">Sign = Nepsign()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">match</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)): <span class="comment"># 提供俩个选项</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment"># 选项1是输入消息,消息不等于happy for NepCTF 2025就会对输入的消息进行签名,但是这里存在一个私钥复用的漏洞点,通过特殊构造其实就可以得到qq列表</span></span><br><span class="line">            msg = <span class="built_in">bytes</span>.fromhex(<span class="built_in">input</span>(<span class="string">&#x27;msg: &#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> msg != <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(Sign.sign(msg))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t do that&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            qq = literal_eval(<span class="built_in">input</span>(<span class="string">&#x27;give me a qq: &#x27;</span>)) <span class="comment"># 输入qq使得使得qq满足对happy for NepCTF 2025这个消息的签名</span></span><br><span class="line">            <span class="keyword">if</span> Sign.verify(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>, qq):</span><br><span class="line">                <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>通过解读代码其实就发现本题其实可以得到，最关键的利用点就是要想办法获取消息<code>b&#39;happy for NepCTF 2025&#39;</code>，签名过后的<code>qq</code>数组。</li><li>其实使用题目中现成的函数，可以得到消息<code>b&#39;happy for NepCTF 2025&#39;</code>的哈希值以及校验和的具体值,也就是上面代码中的<code>step</code>的值，而<code>step</code>的值代表着私钥哈希的次数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  <span class="comment"># 应该是计算一个hash值</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 首先计算出对消息b&#x27;happy for NepCTF 2025&#x27;来说,它的step的状态</span></span><br><span class="line">msg = <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_step</span>(<span class="params">msg</span>):</span><br><span class="line">    m = SM3_n(msg)</span><br><span class="line">    m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">    step = [<span class="number">0</span>]*<span class="number">48</span></span><br><span class="line">    a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span> // <span class="number">8</span>)]</span><br><span class="line">    hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        step[i] = a[i]</span><br><span class="line">    <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">            <span class="keyword">if</span> m[j - <span class="number">1</span>] == hex_symbols[i]:  <span class="comment"># 如果消息的哈希值对应索引符合hex_symbols中的某一个</span></span><br><span class="line">                <span class="built_in">sum</span>[i] += j  <span class="comment"># sum就会加上索引</span></span><br><span class="line">        step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">step_des = c_step(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(step_des)</span><br></pre></td></tr></table></figure><p><img src="/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/image-20250901222946617.png" alt="image-20250901222946617"></p><ul><li><p>通过观察代码就会发现，每次使用选择<code>1</code>的签名操作时，都使用的是同一个私钥进行签名，由于消息<code>b&#39;happy for NepCTF 2025&#39;</code>的<code>step</code>值是已知的。所以我们只要发送特殊的消息，使得该消息的<code>step1[i]&lt;=step[i]</code></p><ul><li>当<code>step1[i]&lt;step[i]</code>的时候，其实可以使用返回的<code>qq1[i]</code>，继续哈希<code>step[i]-step1[i]</code>次就能得到消息<code>b&#39;happy for NepCTF 2025&#39;</code>对应的<code>qq[i]</code>的值</li><li>当<code>step1[i]=step[i]</code>的时候，<code>qq1[i]==qq[i]</code></li><li>这样通过有限次的对不同的特殊消息进行签名，就可以得到<code>pp</code>这个列表的值。</li></ul></li><li><p>接下来使用下面这一串代码可以生成符合要求的消息，也就是满足<code>step1[i]&lt;=step[i]</code>的消息。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  <span class="comment"># 应该是计算一个hash值</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先计算出对消息b&#x27;happy for NepCTF 2025&#x27;来说,它的step的状态</span></span><br><span class="line">msg = <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_step</span>(<span class="params">msg</span>):</span><br><span class="line">    m = SM3_n(msg)</span><br><span class="line">    m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">    step = [<span class="number">0</span>]*<span class="number">48</span></span><br><span class="line">    a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span> // <span class="number">8</span>)]</span><br><span class="line">    hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        step[i] = a[i]</span><br><span class="line">    <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">            <span class="keyword">if</span> m[j - <span class="number">1</span>] == hex_symbols[i]:  <span class="comment"># 如果消息的哈希值对应索引符合hex_symbols中的某一个</span></span><br><span class="line">                <span class="built_in">sum</span>[i] += j  <span class="comment"># sum就会加上索引</span></span><br><span class="line">        step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">step_des = c_step(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(step_des)</span><br><span class="line">candidate = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = os.urandom(<span class="number">5</span>)</span><br><span class="line">        step = c_step(x)</span><br><span class="line">        <span class="keyword">if</span> step[i] &lt;= step_des[i]:</span><br><span class="line">            candidate.append(x.<span class="built_in">hex</span>())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(candidate)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">candate = [&#x27;e528ac746f&#x27;, &#x27;ad694be518&#x27;, &#x27;12e5f725da&#x27;, &#x27;f38b0675a8&#x27;, &#x27;d126dd5379&#x27;, &#x27;e1bcffc062&#x27;, &#x27;f54fb14599&#x27;, &#x27;9e4ce2c549&#x27;, &#x27;42bb777a69&#x27;, &#x27;37773f0771&#x27;, &#x27;605fc06b20&#x27;, &#x27;3dd0ba0a5b&#x27;, &#x27;f01e1de8f1&#x27;, &#x27;651d6251d5&#x27;, &#x27;07e90c3714&#x27;, &#x27;2e70224c66&#x27;, &#x27;cd73d66284&#x27;, &#x27;dd270bb39b&#x27;, &#x27;0afbbf91bb&#x27;, &#x27;21954ad626&#x27;, &#x27;53c6e4b606&#x27;, &#x27;cb6632070b&#x27;, &#x27;25e43397f6&#x27;, &#x27;d6f54113c6&#x27;, &#x27;0f1dbf213f&#x27;, &#x27;8a71fbbcef&#x27;, &#x27;1e484654d5&#x27;, &#x27;c0cce89280&#x27;, &#x27;720c8fde3a&#x27;, &#x27;b42e82218b&#x27;, &#x27;8fb6002d72&#x27;, &#x27;fa4804f1af&#x27;, &#x27;ff05854709&#x27;, &#x27;0e83a61727&#x27;, &#x27;d087fccce3&#x27;, &#x27;08958c158a&#x27;, &#x27;5bc77069ea&#x27;, &#x27;b1173ddd72&#x27;, &#x27;f0bf6f2b4f&#x27;, &#x27;b144583404&#x27;, &#x27;8ebc7c5eb8&#x27;, &#x27;dd82f6435d&#x27;, &#x27;903377a152&#x27;, &#x27;f31923e8d1&#x27;, &#x27;58ab6aac57&#x27;, &#x27;6bc744f37c&#x27;, &#x27;4ca8b192b1&#x27;, &#x27;9f22cebc5f&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>最后使用<code>candidate</code>中的消息泄露消息<code>b&#39;happy for NepCTF 2025&#39;</code>的<code>qq</code>数组的值，最后再使用选项<code>2</code>认证即可。最终exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  <span class="comment"># 应该是计算一个hash值</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先计算出对消息b&#x27;happy for NepCTF 2025&#x27;来说,它的step的状态</span></span><br><span class="line">msg = <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_step</span>(<span class="params">msg</span>):</span><br><span class="line">    m = SM3_n(msg)</span><br><span class="line">    m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">    step = [<span class="number">0</span>]*<span class="number">48</span></span><br><span class="line">    a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span> // <span class="number">8</span>)]</span><br><span class="line">    hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        step[i] = a[i]</span><br><span class="line">    <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">            <span class="keyword">if</span> m[j - <span class="number">1</span>] == hex_symbols[i]:  <span class="comment"># 如果消息的哈希值对应索引符合hex_symbols中的某一个</span></span><br><span class="line">                <span class="built_in">sum</span>[i] += j  <span class="comment"># sum就会加上索引</span></span><br><span class="line">        step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">step_des = c_step(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(step_des)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">candate = []</span></span><br><span class="line"><span class="string">for i in range(48):</span></span><br><span class="line"><span class="string">    while True:</span></span><br><span class="line"><span class="string">        x = os.urandom(5)</span></span><br><span class="line"><span class="string">        step = c_step(x)</span></span><br><span class="line"><span class="string">        if step[i] &lt;= step_des[i]:</span></span><br><span class="line"><span class="string">            candate.append(x.hex())</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">print(candate)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">candate = [<span class="string">&#x27;e528ac746f&#x27;</span>, <span class="string">&#x27;ad694be518&#x27;</span>, <span class="string">&#x27;12e5f725da&#x27;</span>, <span class="string">&#x27;f38b0675a8&#x27;</span>, <span class="string">&#x27;d126dd5379&#x27;</span>, <span class="string">&#x27;e1bcffc062&#x27;</span>, <span class="string">&#x27;f54fb14599&#x27;</span>, <span class="string">&#x27;9e4ce2c549&#x27;</span>, <span class="string">&#x27;42bb777a69&#x27;</span>, <span class="string">&#x27;37773f0771&#x27;</span>, <span class="string">&#x27;605fc06b20&#x27;</span>, <span class="string">&#x27;3dd0ba0a5b&#x27;</span>, <span class="string">&#x27;f01e1de8f1&#x27;</span>, <span class="string">&#x27;651d6251d5&#x27;</span>, <span class="string">&#x27;07e90c3714&#x27;</span>, <span class="string">&#x27;2e70224c66&#x27;</span>, <span class="string">&#x27;cd73d66284&#x27;</span>, <span class="string">&#x27;dd270bb39b&#x27;</span>, <span class="string">&#x27;0afbbf91bb&#x27;</span>, <span class="string">&#x27;21954ad626&#x27;</span>, <span class="string">&#x27;53c6e4b606&#x27;</span>, <span class="string">&#x27;cb6632070b&#x27;</span>, <span class="string">&#x27;25e43397f6&#x27;</span>, <span class="string">&#x27;d6f54113c6&#x27;</span>, <span class="string">&#x27;0f1dbf213f&#x27;</span>, <span class="string">&#x27;8a71fbbcef&#x27;</span>, <span class="string">&#x27;1e484654d5&#x27;</span>, <span class="string">&#x27;c0cce89280&#x27;</span>, <span class="string">&#x27;720c8fde3a&#x27;</span>, <span class="string">&#x27;b42e82218b&#x27;</span>, <span class="string">&#x27;8fb6002d72&#x27;</span>, <span class="string">&#x27;fa4804f1af&#x27;</span>, <span class="string">&#x27;ff05854709&#x27;</span>, <span class="string">&#x27;0e83a61727&#x27;</span>, <span class="string">&#x27;d087fccce3&#x27;</span>, <span class="string">&#x27;08958c158a&#x27;</span>, <span class="string">&#x27;5bc77069ea&#x27;</span>, <span class="string">&#x27;b1173ddd72&#x27;</span>, <span class="string">&#x27;f0bf6f2b4f&#x27;</span>, <span class="string">&#x27;b144583404&#x27;</span>, <span class="string">&#x27;8ebc7c5eb8&#x27;</span>, <span class="string">&#x27;dd82f6435d&#x27;</span>, <span class="string">&#x27;903377a152&#x27;</span>, <span class="string">&#x27;f31923e8d1&#x27;</span>, <span class="string">&#x27;58ab6aac57&#x27;</span>, <span class="string">&#x27;6bc744f37c&#x27;</span>, <span class="string">&#x27;4ca8b192b1&#x27;</span>, <span class="string">&#x27;9f22cebc5f&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#host = &quot;nepctf30-tjtu-vam0-ewpd-crfw4njdv208.nepctf.com&quot;</span></span><br><span class="line"><span class="comment">#port = &#x27;443&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(host, port, ssl=True, sni=host)</span></span><br><span class="line">p = process([<span class="string">&#x27;python3.10&#x27;</span>,<span class="string">&#x27;server.py&#x27;</span>])</span><br><span class="line">hash_list = []</span><br><span class="line">qq = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(candate)):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;msg&#x27;</span>,candate[i].encode())</span><br><span class="line">    <span class="built_in">hash</span> = p.recvuntil(<span class="string">b&#x27;]&#x27;</span>).decode()[<span class="number">3</span>:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">hash</span> = <span class="built_in">hash</span>.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    hash_ = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">hash</span>)):</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">            hash_.append(<span class="built_in">hash</span>[j][<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hash_.append(<span class="built_in">hash</span>[j][<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line">    step = c_step(<span class="built_in">bytes</span>.fromhex(candate[i]))</span><br><span class="line">    t = step_des[i] - step[i]</span><br><span class="line">    <span class="comment">#print(hash_)</span></span><br><span class="line">    qq.append(SM3_n(<span class="built_in">bytes</span>.fromhex(hash_[i]),t))</span><br><span class="line">    <span class="comment">#print(qq)</span></span><br><span class="line"><span class="built_in">print</span>(qq)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;give me a qq:&#x27;</span>,<span class="built_in">str</span>(qq).encode())</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/image-20250901225954934.png" alt="image-20250901225954934"></p>]]></content>
    
    
    <summary type="html">前言：newctf2025出现了这个签名，学习一下</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="数字签名" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>高等代数-线性方程组</title>
    <link href="http://iyheart.github.io/2025/08/26/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <id>http://iyheart.github.io/2025/08/26/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</id>
    <published>2025-08-26T09:00:37.000Z</published>
    <updated>2025-10-02T09:33:31.768Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>参考教材：<code>邱维声—高等代数大学高等代数课程创新教材</code></p></li><li><p>参考视频：<a href="https://www.bilibili.com/video/BV1jR4y1M78W?vd_source=bbdaef564df94fc8991902ba22c6761b">北大丘维声教授清华高等代数课程1080P高清修复版(全151集)</a></p></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>在学习高等代数之前，先对高等代数有一定的了解。高等代数研究的核心其实是其实是<code>解方程</code>，解多元一次方程以及解一元多次方程，再拓展到n元n次方程。这就是高等代数主要研究的内容。</li><li>书中前言这张图片对高等代数的概括非常好，研究的方向就是这两大线<ul><li>研究解多元一次方程的问题引入了<code>矩阵</code>、<code>向量</code>、<code>线性空间</code>等线性代数相关的内容，在线性代数中最关键的其实是<code>线性空间</code>、<code>线性映射</code></li><li>研究解一元多次方程的问题引入了<code>群</code>、<code>环</code>、<code>域</code>，最终形成了<code>抽象代数</code>这一门学科，而抽象代数的核心定理其实是<code>伽罗瓦大定理</code></li></ul></li></ul><p><img src="/2025/08/26/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/image-20250814172045086.png" alt="image-20250814172045086"></p><ul><li><code>邱维声</code>老先生的这本书的主线其实是：研究线性空间和多项式环的结构及其态射（线性映射，多项式环的通用性质），所以高等代数更多的是<strong>研究线性代数</strong>以及<strong>多项式环</strong>，而群和域这边是在抽象代数去研究。</li></ul><h1 id="线性方程组矩阵消元法"><a href="#线性方程组矩阵消元法" class="headerlink" title="线性方程组矩阵消元法"></a>线性方程组矩阵消元法</h1><h2 id="线性方程组与矩阵"><a href="#线性方程组与矩阵" class="headerlink" title="线性方程组与矩阵"></a>线性方程组与矩阵</h2><blockquote><p><strong>线性方程</strong>：</p><p>像$a_{1}x_1+a_2x_2+…+a_nx_n=b_1$这样，左端都是未知量$x_1,x_2,…,x_n$的一个齐次式，右端是常数被称为<strong>线性方程</strong>。</p><ul><li>系数：每个未知量前面的数称为<strong>系数</strong></li><li>常数项：右端的项被称为<strong>常数项</strong></li></ul><p><strong>线性方程组</strong>：</p><p>两个及以上的线性方程组合，就被称为<strong>线性方程组</strong>，含<code>n</code>个未知量的线性方程组被称为<code>n</code>元线性方程组，它的一般形式如下：</p><ul><li>$a<em>{11},a</em>{12},…,a_{sn}$是<strong>系数</strong></li><li>$b_1,b_2,…,b_n$是<strong>常数项</strong>，一般写在等号右边</li><li>方程个数为s与未知量个数n可以<code>相等</code>，也可以是<code>s&lt;n</code>或者<code>s&gt;n</code>的关系</li><li>将$x_1,x_2,…,x_n$代入$c_1,c_2,…,c_n$后，每个方程都变成恒等式，那么这n元有序数组$(c_1,c_2,…,c_n)$是线性方程组的<strong>一组解</strong>，方程组的所有解组成的几何称为这个方程组的解集。</li></ul><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n &= b_1 \\a_{21}x_1+a_{22}x_2+...+a_{2n}x_n &= b_2\\~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&~~~~~~\vdots\\a_{s1}x_1+a_{s2}x_2+...+a_{sn}x_n&=b_s\end{cases}</script><p><strong>矩阵</strong>：由于解方程都是对系数和常数项操作并没有改变未知数，所以为了方便就引入了<strong>一个数表</strong>即<strong>矩阵</strong>，将方程组的未知数前面的系数和常数项提取出来。写成如下形式：</p><script type="math/tex; mode=display">\begin{bmatrix}a_{11} & a_{12} & \dots & a_{1n} & b_{1} \\a_{21} & a_{22} & \dots & a_{2n} & b_{2} \\\vdots & \vdots & \ddots& \vdots & \vdots \\a_{s1} & a_{s2} & \dots & a_{sn} & b_{s}\end{bmatrix}</script><p><strong>系数矩阵</strong>：只提取方程组的系数做为一个矩阵，这样的矩阵叫做<strong>系数矩阵</strong></p><script type="math/tex; mode=display">\begin{bmatrix}a_{11} & a_{12} & \dots & a_{1n}  \\a_{21} & a_{22} & \dots & a_{2n}  \\\vdots & \vdots & \ddots& \vdots  \\a_{s1} & a_{s2} & \dots & a_{sn} \end{bmatrix}</script><p><strong>增广矩阵</strong>：提取方程组的系数和常数项做为一个矩阵，这样的矩阵叫做<strong>增广矩阵</strong></p><script type="math/tex; mode=display">\begin{bmatrix}a_{11} & a_{12} & \dots & a_{1n} & b_{1} \\a_{21} & a_{22} & \dots & a_{2n} & b_{2} \\\vdots & \vdots & \ddots& \vdots & \vdots \\a_{s1} & a_{s2} & \dots & a_{sn} & b_{s}\end{bmatrix}</script><p><strong>矩阵的定义</strong>：</p><p>由<code>s·m</code>个数排成<code>s</code>行、<code>m</code>列的一张表称为一个<code>s×m</code>矩阵，其中的每一个数称为这个矩阵的<strong>一个元素</strong>，第<code>i</code>行与第<code>j</code>列交叉位置的元素称为矩阵的<code>(s,j)</code>元。</p><p>注解1：矩阵通常用大写英文字母$\mathbf{A,B,C,…}$表示。一个<code>s×m</code>矩阵可以简单地记作$\mathbf{A}<em>{s×m}$，它的<code>(i,j)</code>元记作$\mathbf{A}(i;j)$，如果矩阵$\mathbf{A}$的<code>(i,j)</code>元是$a</em>{ij}$，那么可以记作$\mathbf{A}=(a_{ij})$</p><p>注解2：元素全为0的矩阵称为<strong>零矩阵</strong>，简记作$\mathbf{0}$。s行m列的零矩阵可以记成$\mathbf{0}_{s×m}$</p><p>注解3：如果一个矩阵$\mathbf{A}$的行数与列数相等，则称它为<strong>方阵</strong>。m行n列的方阵也称为<strong>m级矩阵</strong></p><p>注解4：对于两个矩阵$\mathbf{A,B}$，如果它们的行数相等，都等于<code>s</code>；列数相等，都等于<code>m</code>；并且$\mathbf{A}(i;j)=\mathbf{B}(i;j),i=1,2,…,s,~~~j=1,2,…,m$，那么称矩阵$\mathbf{A,B}$相等，记作$\mathbf{A=B}$</p><p>例题1：解方程组</p><script type="math/tex; mode=display">\begin{cases}x_1+3x_2+x_3&=2\\3x_1+4x_2+2x_3&=9\\-x_1-5x_2+4x_4&=10\\2x_1+7x_2+x_3&=10\end{cases}</script></blockquote><ol><li><p>先使用<code>2式+1式·(-3)</code>、<code>3式+1式</code>、<code>4式+1式·(-2)</code>，消去<code>2、3、4式</code>的$x_1$，然后交换<code>2式和4式</code>的位置</p></li><li><p>再使用<code>3式+2式·2</code>、<code>4式+2式·5</code>，以及<code>4式+3式·2</code>得到了一个<strong>阶梯型方程组</strong></p></li></ol><script type="math/tex; mode=display">\begin{cases}x_1+3x_2+x_3&=2\\~~~~~~~~~~~x_2-x_3&=-3\\~~~~~~~~~~~~~~~~~~~~x_3&=6\\~~~~~~~~~~~~~~~~~~~~~0&=0\end{cases}</script><ol><li>最后使用$3式·\frac{1}3{}$、<code>1式+3式·(-1)</code>、<code>2式+3式</code>、<code>1式+2式·(-3)</code>就可以得到<strong>简化阶梯形方程组</strong>，并且可以看出该方程组的解为$(3,-1,2)’$</li></ol><script type="math/tex; mode=display">\begin{cases}x_1~~~~&=3\\~~~~~~x_2&=1\\~~~~~~~~~~~~~x_3&=2\\~~~~~~~~~~~~~~0&=0\end{cases}</script><h2 id="线性方程组求解与矩阵化简"><a href="#线性方程组求解与矩阵化简" class="headerlink" title="线性方程组求解与矩阵化简"></a>线性方程组求解与矩阵化简</h2><blockquote><p><strong>线性方程组的初等变换</strong>：</p><ol><li>把一个方程的倍数加到另一个方程上</li><li>互换两个方程的位置</li><li>用一个非零数称某一个方程</li></ol><p>注解：通过线性方程组初等变换后的方程组的解与原方程组相同，所以使用有限次数的线性方程组的初等变换就可以求出n元线性方程组的解。</p><p><strong>矩阵的初等行变换</strong>：</p><p>由于矩阵是线性方程组抽象出来的，所以线性方程组的初等变换运用到矩阵就是矩阵的初等行变换</p><ol><li>把一行的倍数加到另一行上</li><li>互换两行的位置</li><li>用一个非零数乘某一行</li></ol><p><strong>矩阵的行阶梯</strong>：</p><p>阶梯型方程组转换成矩阵形式，就变成了<strong>矩阵的行阶梯</strong>，有以下几个特征：</p><ol><li>元素全为<code>0</code>的行（称为<strong>零行</strong>）在下方(如果有零行)；</li><li>元素不全为<code>0</code>的行（称为<strong>非零行</strong>），从左边数起第一个不为0的元素称为<strong>主元</strong>，它们的列指标随着行指标的递增而<strong>严格增大</strong>。即行指标增大<code>1</code>，列指标也需要增大<code>1</code>而不是增大<code>2</code></li></ol><script type="math/tex; mode=display">\begin{bmatrix}1&3&1&2\\0&1&-1&-3\\0&0&3&6\\0&0&0&0\end{bmatrix}</script><p><strong>简化行阶梯形矩阵</strong>：</p><p>简化阶梯形方程组抽象成矩阵形式就变成了简化行阶梯形矩阵，特点如下：</p><ol><li>它阶梯形矩阵</li><li>每个非零行的主元都是1</li><li>每个主元所在的列的其余元素都是0</li></ol><script type="math/tex; mode=display">\begin{bmatrix}1&0&0&3\\0&1&0&-1\\0&0&1&2\\0&0&0&0\end{bmatrix}</script><p><strong>定理1</strong>：</p><p>任意一个矩阵都可以经过一系列初等行变换化成<strong>阶梯型矩阵</strong></p><p><strong>推理1</strong>：</p><p>任意一个矩阵都可以经过一系列初等行变换化成<strong>简化行阶梯形矩阵</strong></p><p><strong>矩阵解线性方程组</strong>：</p><p>将方程组转换为增广矩阵后，通过初等行变换化成<strong>阶梯型矩阵</strong>，再化成<strong>简化行阶梯形矩阵</strong>就是解线性方程组。</p><p>例题2：使用矩阵解方程组</p><script type="math/tex; mode=display">\begin{cases}x_1+3x_2+x_3&=2\\3x_1+4x_2+2x_3&=9\\-x_1-5x_2+4x_4&=10\\2x_1+7x_2+x_3&=10\end{cases}</script></blockquote><p><img src="/2025/08/26/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/image-20250825144013357.png" alt="image-20250825144013357"></p><h1 id="线性方程组解的情况与判别"><a href="#线性方程组解的情况与判别" class="headerlink" title="线性方程组解的情况与判别"></a>线性方程组解的情况与判别</h1><blockquote><p><strong>线性方程组解的情况</strong>：</p><p>系数和常数项为有理数（或实数，或复数）的n元线性方程组的解的情况有且只有三种可能：无解，有唯一解，有无穷多个解。</p><p>注解：如果一个线性方程组有解，那么称它是<strong>相容的</strong>；否则，称它是<strong>不相容的</strong></p><p><strong>线性方程组解的判别</strong>：</p><p>把n元线性方程组的增广矩阵经过初等行变换化成阶梯形矩阵，如果相应的阶梯型方程组出现<code>0=d(其中d是非零数)</code>，这种方程，那么原方程无解；否则，有解。</p><p>当有解的时候，如果阶梯形矩阵的非零行数目<code>r</code>等于未知量数目<code>n</code>，那么原方程组有唯一解，如果<code>r&lt;n</code>那么原方程有无穷多个解。</p><p>注解：当原方程有无穷多个解的时候，简化的行阶梯形矩阵就会出现如下形式</p><script type="math/tex; mode=display">\begin{bmatrix}1&-1&0&2\\0&0&1&-1\\0&0&0&0\end{bmatrix}</script><p>转换成线性方程组后就如下：</p><script type="math/tex; mode=display">\begin{cases}x_1-x_2&=2\\x_3&=1\\0&=0\end{cases}</script><p>之后化简就如下,下面表达式其实就是原线性方程组的<strong>一般解</strong>，其中行阶梯矩阵对应的主元为系数的未知量$x_1,x_3$称为<strong>主变量</strong>，其余未知量$x_2$称为<strong>自由未知量</strong>：</p><script type="math/tex; mode=display">\begin{cases}x_1&=x_2+2\\x_3&=1\\0&=0\end{cases}</script><p><strong>齐次线性方程组</strong>：</p><p>常数项全为0的线性方程组称为<strong>齐次线性方程组</strong>。<code>(0,0,...,0)</code>是齐次线性方程组的一个解，称为<strong>零解</strong>。其余的解（如果有）称为<strong>非零解</strong>。该方程如下图所示，由于常数项全为<code>0</code>，所以在将其转换为矩阵的求解时，只需要使用<strong>系数矩阵</strong>即可：</p><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n &= 0 \\a_{21}x_1+a_{22}x_2+...+a_{2n}x_n &= 0\\~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&~~~~~~\vdots\\a_{s1}x_1+a_{s2}x_2+...+a_{sn}x_n&=0\end{cases}</script><p><strong>推论1</strong>：n元齐次线性方程组有非零解的充分必要条件是：它的系数矩阵经过初等行变换化成的阶梯形矩阵中，非零行的数目<code>r&lt;n</code></p><p><strong>推论2</strong>：n元齐次线性方程组，如果方程组的数目s小于未知量的数目n，那么它一定有非零解。</p><p><strong>高斯-若尔当算法</strong>：</p><p><img src="/2025/08/26/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/image-20250826131015073.png" alt="image-20250826131015073"></p></blockquote><h1 id="数域"><a href="#数域" class="headerlink" title="数域"></a>数域</h1><blockquote><p><strong>定义1</strong>：</p><p>复数集的一个子集K如果满足，那么就称K是一个<strong>数域</strong>，有理数集<code>Q</code>，实数集<code>R</code>，复数集<code>C</code>都是数域：</p><ol><li>$0,1\in K$</li><li>$a,b\in K \Rightarrow a\pm b,ab\in K$，$a,b\in K,b\not=0 \Rightarrow \frac{a}{b}\in K$</li></ol><p>注解1：复数域是最大的数域。在讨论线性方程组有没有解时，都是在一个给定的数域K里讨论，称<code>数域K上的线性方程组</code>，即它的系数和常数项都属于K，且它的解（若存在）是K中的数组成的有序数组。</p><p>注解2：讨论矩阵问题时，也是在一个给定的数域K里进行，称<code>数域K上的矩阵</code>。</p><p><strong>命题1</strong>：</p><p>任一数域都包含有理数域</p></blockquote>]]></content>
    
    
    <summary type="html">前言：高等代数</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>算法数论-素性检验算法</title>
    <link href="http://iyheart.github.io/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://iyheart.github.io/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/</id>
    <published>2025-08-21T12:23:16.000Z</published>
    <updated>2025-08-22T10:28:51.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些算法概念"><a href="#一些算法概念" class="headerlink" title="一些算法概念"></a>一些算法概念</h1><p><code>判定问题</code>：只回答<code>是</code>或者<code>否</code>的问题，也就是算法的返回值只有<code>True</code>或者<code>False</code></p><p><code>随机算法</code>：使用了随机数的算法</p><p><code>判定问题偏是(Yes-biased)Monte-Carlo算法</code>：算法给出<code>是</code>的回答总是正确的，给出<code>否</code>的回答也许不正确。如果对应该为<code>是</code>的输入至多以$\varepsilon$的概率给出<code>否</code>的答案则说该算法具有<strong>错误概率$\varepsilon$</strong></p><p><code>判定问题偏否(No-biased)Monte-Carlo算法</code>：算法给出<code>否</code>的回答总是正确的，给出<code>是</code>的回答也许不正确。如果对应该为<code>否</code>的输入至多以$\varepsilon$的概率给出<code>是</code>的答案则说该算法具有<strong>错误概率$\varepsilon$</strong></p><h1 id="素性检验介绍"><a href="#素性检验介绍" class="headerlink" title="素性检验介绍"></a>素性检验介绍</h1><ul><li>在公钥密码学中经常都是要生成一个大素数，而大素数是没办法直接生成的，需要随机生成一个大数，在判断该数是否为素数。</li><li><p>由于生成的是一个大数，程序没办法遍历2到该数的平方根发现该数是否有因子，这种方法对大数并不高效，所以就需要设计一个算法判断一个大数是否为素数。判断一个数是否为素数这个行为就是<strong>素性检验</strong></p></li><li><p>具体介绍一下<strong>生成随机素数的一般方法</strong>：</p><ul><li>生成随机整数<code>n</code></li><li>判断<code>n</code>是否为素数，有两种判断方法，即<code>确定性算法</code>、<code>随机算法</code>：<ol><li>确定性算法：以概率1确定n是否为素数，2002年三位印度计算机科学家发现了第一个多项式时间的算法，称为<strong>AKS素性检测</strong>，计算复杂度为$O(log^{12}(n))$</li><li>随机算法：如果n通过某些素数判定准则，则n可能为素数，如果不通过则n肯定为合数。如：<code>Fermat素性检测</code>、<code>Miller-Rabin素性检测</code>、<code>Solovay-Strassen素性检测</code>、<code>Lucas素性检测</code></li></ol></li></ul></li><li>这里先对成功概率进行分析：在<code>1~N</code>之间随机选取一个数，其为素数的概率约为$\frac{1}{lnN}$，这个其实就是素数的密度。</li><li>在RSA加密算法中，大素数<code>p、q</code>选取为<code>512bit</code>的素数，其成功概率为$\frac{1}{ln2^{512}}\approx\frac{1}{355}$，即可以在随机选取的<code>355</code>个数中以高概率找到一个素数的。</li></ul><h1 id="fermat素性检验"><a href="#Fermat素性检验" class="headerlink" title="Fermat素性检验"></a>Fermat素性检验</h1><ul><li><p><code>Fermat</code>素性检验是一个<code>判定问题偏否(No-biased)Monte-Carlo算法</code>，该检验算法是随机算法，目前该素性检验方法已经过时了。</p></li><li><p>应用：PGP（邮件加密软件）使用<code>Fermat</code>素性检测算法，在PGP中，通过测试的数为<code>Carmichael</code>数的概率小于$\frac{1}{10^{50}}$</p></li><li><p><code>Fermat</code>素性检验算法原理其实就是费马小定理：若p是素数，则$a^{p-1}=a~mod(~p)$，或者$a^{p-1}\equiv1~mod(~p)$。</p></li><li>算法的具体过程：</li><li>该算法的代码实现：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Fermat_test</span>():</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li><code>Fermat</code>素性检验存在的缺陷：存在这样的合数<code>n</code>，使得$0&lt;a&lt;n,gcd(a,n)=1,a^{n-1}\equiv1~mod(~n)$，这样的合数称为<code>Carmichael</code>数，如<code>561</code>是一个<code>Carmichael</code>数。</li></ul><h1 id="miller-rabin素性检验"><a href="#Miller-Rabin素性检验" class="headerlink" title="Miller-Rabin素性检验"></a>Miller-Rabin素性检验</h1><ul><li><p><code>Miller-Rabin</code>算法对于合数问题是一个<code>偏是的Monte Carlo</code>算法。</p></li><li><p><code>Miller-Rabin</code>素性检验，也被称为强伪素数检验，是对<code>Fermat</code>检测的改进。该算法目前为止很常用。</p></li><li><p><code>Miller-Rabin</code>素性检验的原理：</p><ul><li>当n为素数的时候，对于二次同余方程$x^{2}\equiv 1~(mod~n)\Leftrightarrow x\equiv \pm1~mod(~n)$</li><li>设$n-1=2^{k}m$，其中m是奇数，若$(a,n)=1$，则可以由费马小定理得到：<ul><li>$a^{n-1}=a^{2^{k}m}\equiv1~(mod~n)\Leftrightarrow a^{2^{k-1}m}\equiv \pm1~(mod~n)$</li><li>如果$a^{2^{k-1}m}\equiv1~(mod~n)\Leftrightarrow a^{2^{k-2}m}\equiv \pm1~(mod~n)$</li><li>如果$a^{2^{k-2}m}\equiv1~(mod~n)\Leftrightarrow a^{2^{k-3}m}\equiv \pm1~(mod~n)$</li><li>…………</li><li>如果$a^{2m}\equiv1~(mod~n)\Leftrightarrow a^{m}\equiv \pm1~(mod~n)$</li></ul></li><li>这样对于序列$a^{m},a^{2m},…,a^{2^{k-1}m},a^{2^{k}m}~(mod~n)$就会得到这样的一个序列：$(1,1,….,1)$或者$(<em>,</em>,…,*,-1,1,…,1)$。</li><li>对于一个随机数，按照上述方法计算，如果<code>p</code>是素数，就会得到序列$(1,1,….,1)$或者$(<em>,</em>,…,*,-1,1,…,1)$，如果<code>p</code>不是素数，就不会得到该序列</li></ul></li><li><p>算法具体过程：</p><ul><li><p>第一步：先把$n-1$写成$2^km$的形式，其中m是一个奇数</p></li><li><p>第二步：使用随机数生成器，生成一个整数$a\in[1,n-1]$</p></li><li><p>第三步：</p><ul><li>$b\leftarrow a^m~(mod~n)$。这里直接先从$a^{m}$开始检查</li><li>$if~b\equiv 1~(mod~n)$，<code>return &quot;n is prime&quot;</code>。先检查形式是否为<code>(1,1,...,1)</code>。</li></ul></li><li><p>第四步：</p><ul><li><p><code>for i&lt;- 0 to k-1</code></p></li><li><p><code>do</code>：</p><p>$if~b\equiv-1(mod~n)$，<code>return &quot;n is prime&quot;</code>此时判断形式是否为<code>(*,...,*,-1,1,...)</code>）</p><p>$else~b\leftarrow b^2 ~(mod~n)$</p></li><li><p><code>return &quot;n is composite&quot;</code></p></li></ul></li></ul></li><li><p>代码实现如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Miller_Rabin_test</span>():</span><br></pre></td></tr></table></figure><ul><li>错误概率分析：<ul><li>如果黎曼猜想为真，<code>Miller-Rabin</code>素性检验可以转为确定性算法。当目前算法的确定性与否还不知道。</li><li>如果<code>n</code>是奇合数，则在${1,…,n-1}$范围内至多有$\frac{n-1}{4}$个a能让<code>n</code>通过<code>Miller-Rabin</code>检测</li><li>这说明奇合数只有至多$\frac{1}{4}$的概率通过一次<code>Miller-Rabin</code>检测，则奇合数通过<code>k</code>次的<code>Miller-Rabin</code>检测的概率至多为$\frac{1}{4^{k}}$（但是这并不是错误概率）</li><li>错误概率：<code>n</code>通过了素性检测，但<code>n</code>是合数的概率。（该问题是一个条件概率的问题）。先定义两个随机变量也就是，定义<code>a: 一个特定长度的随机奇整数n是合数</code>，定义<code>b: 算法连续回答了m次&quot;n是一个素数&quot;</code>，则求错误概率其实就是求条件概率$P(a\mid b)$，也就是当事件<code>b</code>发生时，事件<code>a</code>发生的概率。<ul><li>可以很容易知道<code>奇整数n为素数的概率</code>：$P(\bar{a})\approx \frac{2}{ln~n}$，因为素数在整数的分布为$\frac{1}{ln~n}$，而在奇整数的概率就翻倍了。这样就可以得到$P(a)\approx 1 - \frac{2}{ln~n}$</li><li>还可以知道<code>在已知n为奇素数条件下,事件b是必然发生</code>即：$P(b\mid \bar{a})= 1$，由条件概率$P(b\mid\bar{a})=\frac{P(\bar{a}b)}{P(\bar{a})}$</li><li>由上面可以知道<code>在已知n为奇合数条件下,算法m次回答&quot;n是一个素数&quot;的概率</code>：$P(b\mid a)≤\frac{1}{4^{m}}$由条件概率可以知道，$P(b\mid a)=\frac{P(ab)}{P(a)}$</li><li>那么由条件概率和全概率的公式就可以得到：$P(a\mid b)=\frac{P(ab)}{P(b)}=\frac{P(b\mid a)P(a)}{P(b\mid a)P(a)+P(b\mid \bar{a})P(\bar{a})}≤\frac{\frac{1}{4^m}<em>(1-\frac{2}{ln~n})}{\frac{1}{4^{m}}</em>(1-\frac{2}{ln~n})+\frac{2}{ln~n}}=\frac{ln~n-2}{ln~n-2+2^{2m+1}}$</li></ul></li><li>从错误概率的推导可以看出，随着检测次数的增加，错误概率是逐渐降低的。</li></ul></li><li>下图给出错误概率的一张表：</li></ul><p><img src="/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/image-20250822004159274.png" alt="image-20250822004159274"></p><h1 id="solovay-strassen素性检验"><a href="#Solovay-Strassen素性检验" class="headerlink" title="Solovay-Strassen素性检验"></a>Solovay-Strassen素性检验</h1><h1 id="lucas素性检验"><a href="#Lucas素性检验" class="headerlink" title="Lucas素性检验"></a>Lucas素性检验</h1><h1 id="python-cryptoutilnumber源码"><a href="#Python-Crypto-Util-number源码" class="headerlink" title="Python-Crypto.Util.number源码"></a>Python-Crypto.Util.number源码</h1><ul><li>对于Python中的<code>Crypto.Util.number</code>应该都不陌生，经常都在用，这里主要分析三个函数的源码，即<code>getPrime</code>、<code>isPrime</code>、<code>_rabinMillerTest</code>这三个函数，其中<code>getPrime</code>中有使用<code>isPrime</code>函数，而<code>isPrime</code>中有使用的就是<code>_rabinMillerTest</code>函数作为素性检测算法</li><li>一般来说都是使用<code>pycharm</code>作为<code>python</code>的开发环境，所以这里就说明一下<code>pycharm</code>中如何找到该源码(没下载的要先下载)，首先打开<code>venv-&gt;Lib-&gt;</code>这个目录</li></ul><p><img src="/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/image-20250821211916677.png" alt="image-20250821211916677"></p><ul><li>然后找到<code>Crypto</code>这个包，再找到<code>Crypto</code>中<code>Util</code>这个子包</li></ul><p><img src="/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/image-20250821212050368.png" alt="image-20250821212050368"></p><ul><li>最后找到<code>number.py</code>这个文件即可</li></ul><p><img src="/2025/08/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA-%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95/image-20250821212141364.png" alt="image-20250821212141364"></p><h2 id="getprime"><a href="#getPrime" class="headerlink" title="getPrime"></a>getPrime</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getPrime</span>(<span class="params">N, randfunc=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回一个N位的素数.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    N必须是一个大于1的整数N must be an integer larger than 1.</span></span><br><span class="line"><span class="string">    如果没有提供randfunc,则使用Random.get_random_bytes这个函数.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置随机数生成器</span></span><br><span class="line">    <span class="keyword">if</span> randfunc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        randfunc = Random.get_random_bytes</span><br><span class="line"><span class="comment"># 检查N是否大于2</span></span><br><span class="line">    <span class="keyword">if</span> N &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;N must be larger than 1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机生成一个数,并判断该数是否为素数,调用isPrime判断 </span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        number = getRandomNBitInteger(N, randfunc) | <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(number, randfunc=randfunc):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure><h2 id="isprime"><a href="#isPrime" class="headerlink" title="isPrime"></a>isPrime</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isPrime</span>(<span class="params">N, false_positive_prob=<span class="number">1e-6</span>, randfunc=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">r&quot;&quot;&quot;判断整数N是不是一个素数.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        false_positive_prob (float):</span></span><br><span class="line"><span class="string">          结果不是素数的统计概率,默认值为10^&#123;-6&#125;.</span></span><br><span class="line"><span class="string">          注意，实际出现误判的概率远小于这个值</span></span><br><span class="line"><span class="string">          这里只是数学上可以严格证明.</span></span><br><span class="line"><span class="string">        randfunc (callable):</span></span><br><span class="line"><span class="string">          一个随机数生成函数,它接收参数N,并返回一个长度为N的随机字节串</span></span><br><span class="line"><span class="string">          如果没有提供该函数默认使用的是Crypto.Random.get_random_bytes这个函数,作为随机数生成算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">    如果输入的N是素数,则返回True</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用默认的随机数生成算法</span></span><br><span class="line">    <span class="keyword">if</span> randfunc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        randfunc = Random.get_random_bytes</span><br><span class="line"><span class="comment"># 当_fastmath这个库被调用的时候,就使用_fastmath库中的isPrime进行判断以提高效率</span></span><br><span class="line">    <span class="keyword">if</span> _fastmath <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> _fastmath.isPrime(long(N), false_positive_prob, randfunc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先判断N的是否为特殊的素数2</span></span><br><span class="line">    <span class="keyword">if</span> N &lt; <span class="number">3</span> <span class="keyword">or</span> N &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">2</span></span><br><span class="line">    <span class="comment"># 再判断p是否被sieve_base中的元素整除,或者是sieve_base中的元素</span></span><br><span class="line">    <span class="comment"># sieve_base存放的元素是2~104729之间所有的素数,包括2和104729</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> sieve_base:</span><br><span class="line">        <span class="keyword">if</span> N == p:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> N % p == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 最后先确定_rabinMillerTest检测的次数rounds,该检测的次数rounds为-ln(false_positive_prob)/ln(4)向上取整</span></span><br><span class="line">    rounds = <span class="built_in">int</span>(math.ceil(-math.log(false_positive_prob)/math.log(<span class="number">4</span>)))</span><br><span class="line">    <span class="comment"># 最后使用_rabinMillerTest进行检测,并且_rabinMillerTest中才是调用randfunc算法的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bool</span>(_rabinMillerTest(N, rounds, randfunc))</span><br></pre></td></tr></table></figure><h2 id="_rabinmillertest"><a href="#rabinMillerTest" class="headerlink" title="_rabinMillerTest"></a>_rabinMillerTest</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_rabinMillerTest</span>(<span class="params">n, rounds, randfunc=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;_rabinMillerTest(n:long, rounds:int, randfunc:callable):int</span></span><br><span class="line"><span class="string">    测试n是否为素数</span></span><br><span class="line"><span class="string">    返回值为0:n肯定是合数</span></span><br><span class="line"><span class="string">    返回值为1:n很可能是素数</span></span><br><span class="line"><span class="string">    返回值为2:n肯定是素数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    如果未提供randfunc,则使用Random.new.read</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    这个函数仅供内部使用,未来可能会被重命名或删除</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 检测特殊的情况(n==2, n even, n &lt; 2)</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> <span class="keyword">or</span> (n &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">2</span></span><br><span class="line">    <span class="comment"># n可能是一个非常大的数,所以先计算n-1应该会更好</span></span><br><span class="line">    n_1 = n - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 这一步就是将n-1转换为2**b * m的形式,b需要最大,m是奇数</span></span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    m = n_1</span><br><span class="line">    <span class="keyword">while</span> (m &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">        m &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    tested = [] <span class="comment"># 存储被测试过的随机数,以免之后随机数再次生成到被测试过的数</span></span><br><span class="line">    <span class="comment"># 做最多n-2次判断</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> iter_range (<span class="built_in">min</span> (rounds, n-<span class="number">2</span>)):</span><br><span class="line">        <span class="comment"># 随机选择一个小于n的数a,确保它之前没有被测试过</span></span><br><span class="line">        a = getRandomRange (<span class="number">2</span>, n, randfunc)</span><br><span class="line">        <span class="keyword">while</span> a <span class="keyword">in</span> tested:</span><br><span class="line">            a = getRandomRange (<span class="number">2</span>, n, randfunc)</span><br><span class="line">        tested.append (a)</span><br><span class="line">        <span class="comment"># 接下来就是进行rabin-miller素性检验</span></span><br><span class="line">        z = <span class="built_in">pow</span> (a, m, n) <span class="comment"># (a**m) % n</span></span><br><span class="line">        <span class="keyword">if</span> z == <span class="number">1</span> <span class="keyword">or</span> z == n_1:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        composite = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> iter_range(b):</span><br><span class="line">            z = (z * z) % n</span><br><span class="line">            <span class="keyword">if</span> z == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> z == n_1:</span><br><span class="line">                composite = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> composite:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：做到一题素性检测的题目，学学素性检测</summary>
    
    
    
    <category term="算法" scheme="http://iyheart.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法数论" scheme="http://iyheart.github.io/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>椭圆曲线数字签名相关攻击</title>
    <link href="http://iyheart.github.io/2025/08/13/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/Elliptic_Curve/ECDSA-Attack/"/>
    <id>http://iyheart.github.io/2025/08/13/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/Elliptic_Curve/ECDSA-Attack/</id>
    <published>2025-08-12T16:37:23.000Z</published>
    <updated>2025-08-12T18:00:19.896Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对于<code>ECDSA</code>的攻击最核心的部分就是随机数<code>k</code>和私钥<code>d</code>，一般都是在这俩个数据做文章，结合近期比赛上遇到的<code>ECDSA</code>相关的密码题目，<strong>更经常的是在随机数<code>k</code>这边做文章</strong>。难度加大一点就是对<code>k、d</code>二者都做点事情。</li><li>对数据签名攻击的最终目的是为了伪造数字签名数据对即<code>(s,r)</code>这俩个数据对，而这两个数据对与<code>k、d</code>是相关的，对于<code>ECDSA</code>攻击的核心点基本上都是在<code>k、d</code>这两点上。</li></ul><h1 id="题型1随机数k的复用"><a href="#题型1—随机数k的复用" class="headerlink" title="题型1—随机数k的复用"></a>题型1—随机数k的复用</h1><h2 id="题型1推导"><a href="#题型1推导" class="headerlink" title="题型1推导"></a>题型1推导</h2><ul><li>在<code>ECDSA</code>数字签名的时候， 如果随机数<code>k</code>复用就会导致私钥的泄露，首先回顾一下<code>ECDSA</code>数字签名的过程。主要就是下面这俩个式子</li></ul><script type="math/tex; mode=display">r = x~mod(~n)\\s = k^{-1}(h+r*d)~mod(~n)</script><ul><li>对于俩次不同的签名，有如下的式子</li></ul><script type="math/tex; mode=display">r_1 = x_1~mod(~n)\\s_1 = k_1^{-1}(h_1+r_1*d)~mod(~n)\\\\r_2 = x_2~mod(~n)\\s_2 = k_2^{-1}(h_2+r_2*d)~mod(~n)\\</script><ul><li>当随机数k重复使用就会出现$k_1=k_2=k$这一情况，由于$x = (k*G).x()$，这就导致了$r_1=r_2=r$上面的式子就可以写成这样：</li></ul><script type="math/tex; mode=display">r = x~mod(~n)\\s_1 = k^{-1}(h_1+r*d)~mod(~n)\\\\r = x~mod(~n)\\s_2 = k^{-1}(h_2+r*d)~mod(~n)\\</script><ul><li>所以就有：</li></ul><script type="math/tex; mode=display">s_1-s_2=\frac{h1+r*d-h2-r*d}{k}~mod(~n)\\s_1-s_2=\frac{h1-h2}{k}~mod(n)\\\therefore k = (h_1-h_2)*(s_1-s_2)^{-1}~mod(~n)\\\therefore d = (s_1*k-h_1)*r^{-1}~mod(n)</script><h2 id="题型1例题"><a href="#题型1例题" class="headerlink" title="题型1例题"></a>题型1例题</h2><ul><li>接下来给出一个例题：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">p = <span class="number">104013039882501274693449938443150870046676177290878392003647959897761590749237</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">55</span></span><br><span class="line">E = EllipticCurve(GF(p),[a,b]) <span class="comment"># 创建一个椭圆曲线</span></span><br><span class="line">O = E.order()                  <span class="comment"># 计算该椭圆曲线的阶</span></span><br><span class="line">G = E.gen(<span class="number">0</span>)                   <span class="comment"># 获取该椭圆曲线的一个生成元</span></span><br><span class="line">d = random.randint(<span class="number">1</span>,O-<span class="number">1</span>)      <span class="comment"># 生成一个私钥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">message</span>):                <span class="comment"># 计算消息的哈希值</span></span><br><span class="line">    t = sha256(message.encode(<span class="string">&#x27;utf-8&#x27;</span>)).digest()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(t,<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ecdsa</span>(<span class="params">k,G,d,h_,O</span>):             <span class="comment"># 进行椭圆曲线数字签名</span></span><br><span class="line">    K = k*G</span><br><span class="line">    x = <span class="built_in">int</span>(K.x())</span><br><span class="line">    r = x % O</span><br><span class="line">    k_ = inverse_mod(k,O)</span><br><span class="line">    s = k_ * (h_ + r * d) % O</span><br><span class="line">    <span class="keyword">return</span> (r,s)</span><br><span class="line">    </span><br><span class="line">message = [<span class="string">&quot;Hello_world&quot;</span>,<span class="string">&quot;this_is_a_meesage&quot;</span>]</span><br><span class="line">h1 = h(message[<span class="number">0</span>])</span><br><span class="line">h2 = h(message[<span class="number">1</span>])</span><br><span class="line">k = random.randint(<span class="number">1</span>,O-<span class="number">1</span>)</span><br><span class="line">sig1 = ecdsa(k,G,d,h1,O)</span><br><span class="line">sig2 = ecdsa(k,G,d,h2,O) <span class="comment"># k的复用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;(r1,s1) = <span class="subst">&#123;sig1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;(r2,s2) = <span class="subst">&#123;sig2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#print(f&quot;flag=flag&#123;&#123;&#123;str(d)&#125;&#125;&#125;&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(r1,s1) = (40006709387573641419946125303569413158469101955768758583457507808179101337206, 1585768849918578394723965791955160503009311951479720516547647283934983942200)</span></span><br><span class="line"><span class="string">(r2,s2) = (40006709387573641419946125303569413158469101955768758583457507808179101337206, 85267507776229139224293234455627206003745480460349166116613720730622564486718)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>对随机数k的复用推导就像上面那样，这里给出exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">p = <span class="number">104013039882501274693449938443150870046676177290878392003647959897761590749237</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">55</span></span><br><span class="line">E = EllipticCurve(GF(p),[a,b]) <span class="comment"># 创建一个椭圆曲线</span></span><br><span class="line">O = E.order()                  <span class="comment"># 计算该椭圆曲线的阶</span></span><br><span class="line">G = E.gen(<span class="number">0</span>)                   <span class="comment"># 获取该椭圆曲线的一个生成元</span></span><br><span class="line">d = random.randint(<span class="number">1</span>,O-<span class="number">1</span>)      <span class="comment"># 生成一个私钥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">message</span>):                <span class="comment"># 计算消息的哈希值</span></span><br><span class="line">    t = sha256(message.encode(<span class="string">&#x27;utf-8&#x27;</span>)).digest()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(t,<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">(r1,s1) = (<span class="number">40006709387573641419946125303569413158469101955768758583457507808179101337206</span>, <span class="number">1585768849918578394723965791955160503009311951479720516547647283934983942200</span>)</span><br><span class="line">(r2,s2) = (<span class="number">40006709387573641419946125303569413158469101955768758583457507808179101337206</span>, <span class="number">85267507776229139224293234455627206003745480460349166116613720730622564486718</span>)</span><br><span class="line">message = [<span class="string">&quot;Hello_world&quot;</span>,<span class="string">&quot;this_is_a_meesage&quot;</span>]</span><br><span class="line">s1_s2 = s1 - s2 </span><br><span class="line">h1 = h(message[<span class="number">0</span>])</span><br><span class="line">h2 = h(message[<span class="number">1</span>])</span><br><span class="line">h1_h2 = h1-h2</span><br><span class="line">s1_s2_ = inverse_mod(s1_s2,O)</span><br><span class="line">k = h1_h2 * s1_s2_ % O</span><br><span class="line">r1_ = inverse_mod(r1,O)</span><br><span class="line">d = (s1*k - h1)*r1_ % O</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;flag&#123;&#123;<span class="subst">&#123;d&#125;</span>&#125;&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># flag&#123;39293969871044977010378459455218809487719269197611508380642557837535793765188&#125;</span></span><br></pre></td></tr></table></figure><h1 id="题型2随机数k1与k2有关系"><a href="#题型2—随机数k1与k2有关系" class="headerlink" title="题型2—随机数k1与k2有关系"></a>题型2—随机数k1与k2有关系</h1><h2 id="题型2综述"><a href="#题型2综述" class="headerlink" title="题型2综述"></a>题型2综述</h2><ul><li>对于这种题型，其实主要考察的重点其实并不是<code>ECDSA</code>这个数字签名的过程，而是伪随机数生成器了。这个就需要对一些伪随机数生成的机制有一定的了解。</li><li>简单一点的伪随机数生成考点就是<code>LCG</code>的基础题型了，难度上来就变种的<code>LCG</code>或者其他的伪随机数生成器了。主要还是积累伪随机数生成器的相关算法和对应的破解方法吧。</li></ul><h2 id="题型2例题"><a href="#题型2例题" class="headerlink" title="题型2例题"></a>题型2例题</h2><h1 id="题型3结合其他加密方式"><a href="#题型3—结合其他加密方式" class="headerlink" title="题型3—结合其他加密方式"></a>题型3—结合其他加密方式</h1><h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><h2 id="题目12025年春秋杯夏季赛_eccccc"><a href="#题目1—2025年春秋杯夏季赛-eccccc" class="headerlink" title="题目1—2025年春秋杯夏季赛_eccccc"></a>题目1—2025年春秋杯夏季赛_eccccc</h2><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">b&#x27;flag&#123;&#x27;</span>) <span class="keyword">and</span> flag.endswith(<span class="string">b&#x27;&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ECDSA</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, E=<span class="literal">None</span>, G=<span class="literal">None</span>, n=<span class="literal">None</span></span>):</span><br><span class="line">        p = <span class="number">115792089237316195423570985008687907853269984665640564039457584007908834671663</span> <span class="comment"># 定义模数</span></span><br><span class="line">        a = <span class="number">0</span>; b = <span class="number">7</span></span><br><span class="line">        self.E = E <span class="keyword">if</span> E <span class="keyword">else</span> EllipticCurve(GF(p), [a, b]) <span class="comment"># 定义椭圆曲线y^2 = x^3 + 7 mod p</span></span><br><span class="line">        self.G = G <span class="keyword">if</span> G <span class="keyword">else</span> self.E.gen(<span class="number">0</span>) <span class="comment"># 获得椭圆曲线的基点</span></span><br><span class="line">        self.n = n <span class="keyword">if</span> n <span class="keyword">else</span> self.E.order() <span class="comment"># 获得椭圆曲线的阶</span></span><br><span class="line">        self.d = randint(<span class="number">1</span>, self.n - <span class="number">1</span>)    <span class="comment"># 随机选取一个数d</span></span><br><span class="line">        self.Q = self.d * self.G           <span class="comment"># 计算 d*G 椭圆曲线点运算</span></span><br><span class="line">        self.k = randint(<span class="number">1</span>, self.n - <span class="number">1</span>) % self.n <span class="comment"># 计算k = 随机数 % n (即椭圆曲线的阶)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self, m:<span class="built_in">bytes</span></span>): <span class="comment"># 签名操作</span></span><br><span class="line">        self.k = (<span class="number">7</span> * self.k ** <span class="number">2</span> + <span class="number">3</span> * self.k + <span class="number">11</span>) % self.n  <span class="comment"># 另 k = (7*k^2 + 3*k +11 ) % n</span></span><br><span class="line">        R = self.k * self.G                                    <span class="comment"># R = k*G</span></span><br><span class="line">        r = ZZ(R.x()) % self.n                                 <span class="comment"># r = R_x % n 取点R的橫坐标%n</span></span><br><span class="line">        h = <span class="built_in">int</span>.from_bytes(sha256(m).digest(), <span class="string">&#x27;big&#x27;</span>)          <span class="comment"># h = 消息的哈希值</span></span><br><span class="line">        s = self.k**(-<span class="number">1</span>) * (h + self.d * r) % self.n           <span class="comment"># 签名结果: s = k^(-1) * (h + d*r) % n</span></span><br><span class="line">        <span class="keyword">return</span> (r, s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, m:<span class="built_in">bytes</span>, r:<span class="built_in">int</span>, s:<span class="built_in">int</span></span>):  <span class="comment"># 验证过程</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt; r &lt; self.n <span class="keyword">and</span> <span class="number">0</span> &lt; s &lt; self.n): <span class="comment"># 判断 0 &lt; r,s &lt; n and</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        w = <span class="built_in">pow</span>(s, -<span class="number">1</span>, self.n)          <span class="comment"># 计算 w = s^(-1) mod n</span></span><br><span class="line">        h = <span class="built_in">int</span>.from_bytes(sha256(m).digest(), <span class="string">&#x27;big&#x27;</span>) <span class="comment"># 计算消息的哈希值</span></span><br><span class="line">        u1 = (h * w) % self.n           <span class="comment"># 计算u1 = (h*w) %n</span></span><br><span class="line">        u2 = (r * w) % self.n           <span class="comment"># 计算u2 = (r*w) %n</span></span><br><span class="line">        R = u1 * self.G + u2 * self.Q   <span class="comment"># 计算点R = u1*G + u2*Q</span></span><br><span class="line">        <span class="keyword">return</span> ZZ(R.x()) % self.n == r  <span class="comment"># 验证R_x == r</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = ECDSA()</span><br><span class="line"><span class="built_in">print</span>(AES.new(key=sha256(<span class="built_in">str</span>(e.d).encode()).digest(), mode=AES.MODE_ECB).encrypt(pad(flag, <span class="number">16</span>))) <span class="comment"># 用随机数d作为密钥将flag进行加密,输出密文</span></span><br><span class="line"><span class="built_in">print</span>(e.sign(<span class="string">b&#x27;32748923ur8934u893ygf893h34t3453453&#x27;</span>))   <span class="comment"># 使用e对该消息进行签名</span></span><br><span class="line"><span class="built_in">print</span>(e.sign(<span class="string">b&#x27;ehfw9h8r039u82678ifjewf9024r2323423&#x27;</span>))   <span class="comment"># 使用e对该消息进行签名</span></span><br><span class="line"><span class="comment"># 对下一次签名的随机数k2与前一次签名的随机数k1满足一个二次模的关系</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;\xa7\x13\xd5j\x10*\xc9\x04\xda\x8b\xaaf\xde\xae\xdc\xdb\xb7T\xcd\x8b\xc9K\xf4\xb4^p\x8da\x1bS\xef\x92\xaf\x03\xe9\xc2\x0c\x8c\x83\x83\xf9\xc6\xc7\t\xf9\x9cp\x9d&#x27;</span></span><br><span class="line"><span class="string">(18507930132802310344248699822628576170242868593944128167302942018134209256936, 23965013559564325260453725916491832279556345092147805659950905735422363429946)</span></span><br><span class="line"><span class="string">(61645219796227967861807301237829197706412124807702206247291322591426944615554, 84283844402102709520391794221564573160907887711307574424747605446691209453247)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>exp如下，具体过程这里就不说明了，放在<code>wp</code>那边说明：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ECCCCC</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">p = <span class="number">115792089237316195423570985008687907853269984665640564039457584007908834671663</span> <span class="comment"># 定义模数</span></span><br><span class="line">a = <span class="number">0</span> </span><br><span class="line">b = <span class="number">7</span></span><br><span class="line">e = EllipticCurve(GF(p),[a,b])</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line">G = e.gen(<span class="number">0</span>)</span><br><span class="line">n = e.order()</span><br><span class="line">c = <span class="string">b&#x27;\xa7\x13\xd5j\x10*\xc9\x04\xda\x8b\xaaf\xde\xae\xdc\xdb\xb7T\xcd\x8b\xc9K\xf4\xb4^p\x8da\x1bS\xef\x92\xaf\x03\xe9\xc2\x0c\x8c\x83\x83\xf9\xc6\xc7\t\xf9\x9cp\x9d&#x27;</span></span><br><span class="line">m1 = <span class="string">b&#x27;32748923ur8934u893ygf893h34t3453453&#x27;</span></span><br><span class="line">m2 = <span class="string">b&#x27;ehfw9h8r039u82678ifjewf9024r2323423&#x27;</span></span><br><span class="line">h1 = <span class="built_in">int</span>.from_bytes(sha256(m1).digest(), <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">h2 = <span class="built_in">int</span>.from_bytes(sha256(m2).digest(), <span class="string">&#x27;big&#x27;</span>)   </span><br><span class="line">r1,s1 = (<span class="number">18507930132802310344248699822628576170242868593944128167302942018134209256936</span>, <span class="number">23965013559564325260453725916491832279556345092147805659950905735422363429946</span>)</span><br><span class="line">r2,s2 = (<span class="number">61645219796227967861807301237829197706412124807702206247291322591426944615554</span>, <span class="number">84283844402102709520391794221564573160907887711307574424747605446691209453247</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;基点G=&quot;</span>,G)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;阶n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(r1,r2)</span><br><span class="line"><span class="built_in">print</span>(s1,s2)</span><br><span class="line"><span class="built_in">print</span>(h1,h2)</span><br><span class="line">r1_ = inverse_mod(r1,n)</span><br><span class="line">r2_ = inverse_mod(r2,n)</span><br><span class="line">x = h1*r1_ - h2*r2_ % n</span><br><span class="line">y1 = s1*r1_ </span><br><span class="line">y2 = s2*r2_</span><br><span class="line">k = var(<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">P = PolynomialRing(Zmod(n), <span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">k = P.gen()</span><br><span class="line">f = y1*k - y2*(<span class="number">7</span>*k^<span class="number">2</span> + <span class="number">3</span>*k + <span class="number">11</span>) - x </span><br><span class="line">roots = f.roots() <span class="comment"># 在mod n 下求一个关于未知数k的二次剩余,得到俩个解其中一个解就是key</span></span><br><span class="line"><span class="built_in">print</span>(roots)</span><br><span class="line">k1 = roots[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">d = (s1*k1-h1)*r1_ % n</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="built_in">print</span>(AES.new(key=sha256(<span class="built_in">str</span>(d).encode()).digest(), mode=AES.MODE_ECB).decrypt(c))</span><br><span class="line"><span class="comment"># b&#x27;flag&#123;14537d3b-2567-4f1a-a011-2df9635dad20&#125;\x06\x06\x06\x06\x06\x06&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="题目2l3hctf_ecdsa"><a href="#题目2—L3HCTF-ECDSA" class="headerlink" title="题目2—L3HCTF_ECDSA"></a>题目2—L3HCTF_ECDSA</h2><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> NIST256p, SigningKey</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlawedNonceGenerator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.n = n</span><br><span class="line">        self.a = random.randrange(<span class="number">1</span>, n)</span><br><span class="line">        self.b = random.randrange(<span class="number">1</span>, n)</span><br><span class="line">        self.c = random.randrange(<span class="number">1</span>, n)</span><br><span class="line">        self.last_k = random.randrange(<span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_nonce</span>(<span class="params">self</span>):</span><br><span class="line">        current_k = self.last_k</span><br><span class="line">        next_k = (self.a * current_k**<span class="number">2</span> + self.b * current_k + self.c) % self.n</span><br><span class="line">        self.last_k = next_k</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> current_k</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curve = NIST256p</span><br><span class="line">n = curve.order</span><br><span class="line">G = curve.generator</span><br><span class="line"><span class="comment">#print(curve.curve)</span></span><br><span class="line"><span class="built_in">print</span>(G.x())</span><br><span class="line"><span class="built_in">print</span>(G.y())</span><br><span class="line"><span class="comment">#print(n)</span></span><br><span class="line">private_key = SigningKey.from_secret_exponent(random.randrange(<span class="number">1</span>, n), curve=curve)</span><br><span class="line">d = private_key.privkey.secret_multiplier</span><br><span class="line">public_key = private_key.get_verifying_key()</span><br><span class="line"></span><br><span class="line">messages = [</span><br><span class="line">    <span class="string">b&quot;Hello player, welcome to L3HCTF 2025!&quot;</span>,</span><br><span class="line">    <span class="string">b&quot;This is a crypto challenge, as you can probably tell.&quot;</span>,</span><br><span class="line">    <span class="string">b&quot;It&#x27;s about ECDSA, a very... robust algorithm.&quot;</span>,</span><br><span class="line">    <span class="string">b&quot;I&#x27;m sure there are no implementation flaws whatsoever.&quot;</span>,</span><br><span class="line">    <span class="string">b&quot;Anyway, here are your signatures. Good luck!&quot;</span>,</span><br><span class="line">    <span class="string">f&quot;Oh, and the flag is L3HCTF&#123;&#123;<span class="subst">&#123;d&#125;</span>&#125;&#125;. Don&#x27;t tell anyone!&quot;</span>.encode(),</span><br><span class="line">]</span><br><span class="line">nonce_generator = FlawedNonceGenerator(n)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;signatures.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    k = nonce_generator.generate_nonce()</span><br><span class="line">    message = messages[i]</span><br><span class="line">    h = <span class="built_in">int</span>.from_bytes(hashlib.sha256(message).digest(), <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    R = k * curve.generator <span class="comment"># 计算R</span></span><br><span class="line">    r = R.x() % n <span class="comment"># 取Rx % n 为r</span></span><br><span class="line">    s_inv = <span class="built_in">pow</span>(k, -<span class="number">1</span>, n) <span class="comment"># k^(-1) mod n</span></span><br><span class="line">    s = (s_inv * (h + d * r)) % n <span class="comment">#s = k^(-1) * (h+d*r)</span></span><br><span class="line">    <span class="comment"># ki = a*k_i-1 **2 + b*k_i-1 + c % n</span></span><br><span class="line">    f.write(<span class="string">f&quot;h: <span class="subst">&#123;h&#125;</span>, r: <span class="subst">&#123;r&#125;</span>, s: <span class="subst">&#123;s&#125;</span>\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Oh, and the flag is L3HCTF&#123;&#123;<span class="subst">&#123;d&#125;</span>&#125;&#125;. Don&#x27;t tell anyone!&quot;</span>.encode())</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：睡不着，感觉最近学密码有点上瘾了....</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="椭圆曲线" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>PE逆向定位main函数</title>
    <link href="http://iyheart.github.io/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/"/>
    <id>http://iyheart.github.io/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/</id>
    <published>2025-08-10T15:37:33.000Z</published>
    <updated>2025-08-13T02:57:04.893Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一般而言，逆向一般分为静态分析和动态调试，现在先来说说静态分析。</li><li>参考：逆向工程核心原理第二章</li><li><a href="https://bbs.kanxue.com/thread-224500.htm">[原创]逆向技术之寻找Main入口点-软件逆向-看雪-安全社区|安全招聘|kanxue.com</a></li><li><a href="https://www.bilibili.com/video/BV1UY4y1r7bA?vd_source=bbdaef564df94fc8991902ba22c6761b">逆向分析-快速定位main函数</a></li></ul><h1 id="查看程序信息"><a href="#查看程序信息" class="headerlink" title="查看程序信息"></a>查看程序信息</h1><ul><li>对于静态分析而言，拿到一个程序，并不要着急去使用<code>IDA pro</code>将这个可执行文件或者<code>dll</code>文件逆向出来。而是先要收集程序的一些相关的信息，一般而言要收集的程序信息有如下：<ul><li><strong>查看程序的架构</strong>，这个程序是在什么架构下的，不同架构下的程序其二进制指令是不同的即对于的汇编指令是不同的。例如：<code>x86</code>架构、<code>x86_64</code>架构、<code>mips</code>架构、<code>arm</code>架构等</li><li><strong>查看程序的文件结构</strong>，对于<code>Windows</code>系统、<code>Linux</code>系统、<code>MAC</code>系统，其对应的可执行文件的格式都不一样的，如果是<code>windows</code>系统的可执行文件那就不能在其他系统上直接运行。如果在动态调试的时候就需要选择对应的系统了。</li><li><strong>查看程序的编译环境</strong>，对于相同的代码来说，不同编译器或者编译环境编译成的可执行文件，在<code>main</code>函数执行前以及在<code>main</code>函数结束后所执行的东西是不同的。（这个文章后面会详细说明）</li><li><strong>查看程序的壳</strong>，有些程序并不想那么轻易的被反汇编，反编译，这个时候程序就会被加一个壳，这样在对程序进行逆向分析的时候就只能逆向出来程序的壳。而不能逆向出程序的正确代码。而<strong>壳</strong>这个称呼其实就是有保护程序的意思和自然界一些壳的功能非常相似。</li><li><strong>查看程序的动态链接库</strong>，一般而言如果不是静态编译的程序都会有一个动态链接库，而在逆向的目标程序中会保存着动态链接库的信息，已经一些用到的<code>函数接口</code>。从而使得我们在逆向的时候能查找资料或者能很快的反应过来这个函数的作用和功能。</li><li><strong>查看程序编写的语言</strong>，在逆向的时候目标程序不都是<code>C</code>语言编写的，可能还有<code>rust</code>、<code>C++</code>、<code>golang</code>以及一些比较古老和小众的语言。获取程序是使用哪种语言编写的这有助于我们了解到该程序会使用哪些标准库，以及一些语言特性。</li></ul></li><li>上面简单解释了一下收集程序信息的一些作用，接下来介绍一下怎么收集、使用什么工具收集。这里选用的工具是<code>die</code>，<code>die</code>的全称为<code>Detect It Easy</code>，它是一个开源的可执行文件分析工具，用来检测上面所说的程序信息。它的下载方式在这里：<a href="https://github.com/horsicq/Detect-It-Easy">horsicq/Detect-It-Easy：用于确定 Windows、Linux 和 MacOS 文件类型的程序。</a></li><li>这里做一个示范，随便找一个<code>.exe</code>的可执行文件，在拿到一个<code>.exe</code>可执行文件时，不要先急着使用<code>IDA</code>反汇编它，而是先打开<code>DIE</code>。</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811134310354.png" alt="image-20250811134310354"></p><ul><li>这样在没有开启高级选项其信息是这样的</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811134427490.png" alt="image-20250811134427490"></p><ul><li>在开启高级选项后会出现一大串东西，但是其实这一大串东西目前不知道有没有用。但是下图画红框的地方是需要注意的：它标识了<code>程序基地址</code>以及<code>程序入口点</code>，对于程序入口点（<strong>EnteryPoint</strong>）并不是<code>main</code>函数，这里放后面会详细说明，这里先知道有<code>EnteryPoint</code>这个东西</li><li>在下图中其实我们就能收集到上面所说的层序相关信息，有助于我们逆向分析程序。</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811134550977.png" alt="image-20250811134550977"></p><h1 id="程序入口点entrypoint"><a href="#程序入口点-EntryPoint" class="headerlink" title="程序入口点(EntryPoint)"></a>程序入口点(EntryPoint)</h1><ul><li>在学<code>PE</code>文件结构的时候在<code>NT选项头</code>的这个结构体即<code>_IMAGE_OPTIONAL_HEADER</code>这个结构体中，会发现有这么一个成员，这个成员其实就是<code>EntryPoint</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span>&#123;</span></span><br><span class="line">    .....</span><br><span class="line">    DWORD AddressOfEntryPoint;<span class="comment">// 程序入口点地址,简称EP(当前入口点)。OEP(原始入口点),在加壳的时候这么称呼</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果没学过<code>PE</code>文件格式其实也不大，这里具体介绍一下<code>EntryPoint</code>这个概念：</li></ul><blockquote><p>EP(EntryPoint)入口点：</p><p>EP是Windows可执行文件的代码入口点，是执行应用程序时最先执行的代码的起始位置，它依赖于CPU。</p><p>注解：从EP的概念中其实就可以知道，我们点击一个<code>exe</code>文件，它就是从这个入口点保存的地址开始运行的，即<code>EIP、RIP</code>一开始的值为<code>EP</code></p></blockquote><ul><li>在学习<code>C</code>语言的时候，我们写的代码都是从<code>main</code>函数开始执行的，但是程序并不是一开始就执行<code>main</code>函数，而是从<code>EP</code>开始执行。</li></ul><h1 id="定位main函数"><a href="#定位main函数" class="headerlink" title="定位main函数"></a>定位main函数</h1><ul><li>在收集完信息后，如果有壳就脱壳，没壳就可以直接使用<code>IDA</code>进行逆向分析了。如果有做过几题逆向题就会发现，逆向题一开始都是先去寻找<code>main</code>函数，找到<code>main</code>函数后才开始对程序进行逆向分析。其实我们编写一个程序也是从<code>main</code>函数开始。</li><li>但是在逆向分析中有的时候<code>main</code>函数可并不是那么好找的。接下来就使用一个例子来说明为什么有的时候<code>main</code>函数不好找</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>使用<code>vs2022</code>编写如下程序，编译后找到对应的可执行文件</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811140349517.png" alt="image-20250811140349517"></p><ul><li>下面是对应的可执行文件，在这里除了有<code>Realme.exe</code>文件外，其实还有<code>Realme.pdb</code>文件，这个<code>.pdb</code>文件是什么呢？<code>pdb</code>的全称其实是<code>Program Database</code>（程序数据库），它包含了调试信息，包括变量名、函数名、行号等信息。</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811140606696.png" alt="image-20250811140606696"></p><ul><li>这时我们使用<code>Ida</code>对<code>Realme.exe</code>文件进行逆向，在逆向的时候我们会出现一个这样的提示，其实就是<code>Realme.exe</code>文件连接了一个调试信息和符号表在<code>Realme.pdb</code>中，我们是否要加载这个符号表，这里我们先选择<code>Yes</code></li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811140915727.png" alt="image-20250811140915727"></p><ul><li>等<code>Ida</code>反编译完后直接在<code>Functions</code>那一栏搜索<code>main</code>，操作下来会很快的确定到<code>main</code>函数，这相当的轻松。</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811141219078.png" alt="image-20250811141219078"></p><ul><li>此时我们关掉这个<code>ida</code>界面，对该程序重新逆向，遇到这个选项的时候选择<code>No</code></li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811141317418.png" alt="image-20250811141317418"></p><ul><li><code>Ida</code>反编译好该文件后继续搜索<code>main</code>函数，发现并没有搜索到<code>main</code>函数</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811141415646.png" alt="image-20250811141415646"></p><ul><li>这时因为程序没有加载<code>.pdb</code>文件，所以<code>IDA</code>在逆向的时候没有对应的符号表，而在真实的环境中，程序都是又多、又没有符号表。在这种情况下就需要先定位到<code>main</code>函数才能开始逆向分析。对于找到<code>main</code>函数，其实我们就需要从<code>EP程序入口点</code>入手。</li><li>程序入口点在收集程序信息的时候就已经知道了，并且<code>IDA</code>中对程序入口点的函数都会使用<code>start</code>名称，搜索一下函数名称就可以看到（可以多试几个程序，看看这些程序的<code>start</code>函数）</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811141909123.png" alt="image-20250811141909123"></p><ul><li>接下来就以<code>vs2022</code>编译的<code>x64 debug</code>的这个<code>realme.exe</code>文件在有符号表的情况下进行分析，看看这个程序从<code>start</code>到<code>main</code>会执行哪些步骤。</li><li>首先可以查壳看看该程序的的<code>EP</code></li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811143755880.png" alt="image-20250811143755880"></p><ul><li>接下来在<code>IDA</code>中找到<code>EP</code>也就是对应的<code>start</code>函数，此时发现这个<code>start</code>函数会<code>jmp</code>到<code>mainCRTStartup</code>这个函数中去，这个函数的全称为<code>main CRT Startup</code>，<code>CRT C Runtime Library</code></li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811143706011.png" alt="image-20250811143706011"></p><ul><li>这时跟进这个函数看看，发现这个函数中会<code>call</code>一个函数，一个名为<code>__scrt_common_main</code>这个函数，接下来继续跟进</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144020190.png" alt="image-20250811144020190"></p><ul><li>发现<code>__scrt_common_main</code>会<code>call</code>俩个函数，这时会注意到第二个函数与<code>main</code>函数有关系，所以跟进到<code>__scrt_common_main_seh</code>这个函数中，进行分析。</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144204988.png" alt="image-20250811144204988"></p><ul><li>进入到<code>__scrt_common_main_seh</code>会发现这是一个比较复杂的函数</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144558042.png" alt="image-20250811144558042"></p><ul><li>这个时候定位到函数块结束前面一点的位置，会看到这个函数会调用<code>invoke_main</code>跟进到这个函数中去</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144632550.png" alt="image-20250811144632550"></p><ul><li>进入到这个函数中去就会发现有一个<code>j_main</code>，跟进<code>j_main</code></li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144728913.png" alt="image-20250811144728913"></p><ul><li>发现<code>j_main</code>这个函数会执行<code>jmp main</code>，而<code>jmp main</code>中<code>jmp</code>到的位置其实就是<code>main</code>函数的位置</li></ul><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144748447.png" alt="image-20250811144748447"></p><p><img src="/2025/08/10/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E9%80%86%E5%90%91%E5%AE%9A%E4%BD%8Dmain%E5%87%BD%E6%95%B0/image-20250811144852445.png" alt="image-20250811144852445"></p><ul><li>所以在<code>start</code>到<code>main</code>之间<code>vs2022</code>编译的<code>x64</code>程序执行的流程是这样的：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">-&gt;mainCRTStartup</span><br><span class="line">-&gt;_scrt_common_main</span><br><span class="line">-&gt;__scrt_common_main_seh</span><br><span class="line">.....</span><br><span class="line">-&gt;invoke_main</span><br><span class="line">    .....</span><br><span class="line">-&gt;j_main</span><br><span class="line">-&gt;main</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h2 id="windbg调试"><a href="#windbg调试" class="headerlink" title="windbg调试"></a>windbg调试</h2><h2 id="定位main函数的方法"><a href="#定位main函数的方法" class="headerlink" title="定位main函数的方法"></a>定位main函数的方法</h2><ul><li><p>通过上面的分享，这时如果遇到一个<code>vs2022</code>编译的<code>x64</code>版本的<code>exe</code>程序尽管它没有符号表，我们也能比较快速的找到<code>main</code>函数。但是其他开发环境编译的程序<code>start-&gt;main</code>是否也是这样的流程呢？答案是其他开发环境编译的程序可能并不是这样的流程，主要有以下几点：</p><ul><li>不同编译器，编译后的<code>exe</code>程序<code>start-&gt;main</code>函数之间执行的程序是不同的。</li><li>相同编译器但是版本不同，编译后的<code>exe</code>程序<code>start-&gt;main</code>函数之间执行的程序也是不同的。</li></ul></li><li><p>因为编译器的原因<code>start-&gt;main</code>之间执行的程序逻辑并不相同，这样我们并不能学习一个<code>vs2022 x64</code>编译的程序<code>start-&gt;main</code>之间的过程就一劳永逸，还需要一些其他的方法来确定main函数的地址，这里介绍几个方法。</p><ul><li>方法一：收集到逆向的目标程序编译环境（包括开发环境、编译器版本等）信息后，在本地配置一个相同或者差不多的环境（比如都使用<code>vs2022</code>）使用该开发环境编写一个简单的程序并带有符号表编译，通过调试这个简单的程序熟悉<code>start-&gt;main</code>之间的程序流程，这样逆向目标程序就很容易找到<code>main</code>函数了。</li><li>方法二：字符串搜索法</li><li>方法三：动态调试，调试call到相应函数时程序会触发一些行为，或者在调试器中看到一些字符串即可确定函数。</li><li>方法四：API检索法在调用代码中设置断点、在API代码中设置断点。</li><li>方法五：寻找<code>exit</code>函数，寻找exit函数的参数从哪里来，一般来说exit函数的参数是main的返回值。</li></ul></li><li>对于方法一，一种就是现学，另一种就是平时的积累，没什么好说的，在文章后面会对各个编译器和开发环境下编译的<code>exe</code>文件从<code>start-&gt;main</code>的这一过程进行分析并积累起来。接下来重点介绍一下方法<code>二、三、四</code></li></ul><p>注意：对于方法<code>二、三、四</code>其实也适用于定位其他关键函数。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><h1 id="visual_studio2022_start分析"><a href="#Visual-studio2022-start分析" class="headerlink" title="Visual_studio2022_start分析"></a>Visual_studio2022_start分析</h1><h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><h2 id="x32"><a href="#x32" class="headerlink" title="x32"></a>x32</h2>]]></content>
    
    
    <summary type="html">怎么感觉逆向入门要比PWN难???</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="REVERSE" scheme="http://iyheart.github.io/categories/CTF/REVERSE/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA加密之e和phi不互素</title>
    <link href="http://iyheart.github.io/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/"/>
    <id>http://iyheart.github.io/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/</id>
    <published>2025-08-08T15:44:47.000Z</published>
    <updated>2025-08-12T14:11:32.401Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考博客：<a href="https://www.cnblogs.com/SevensNight/p/18764988">e与(p-1)或(q-1)均不互素 - sevensnight - 博客园</a></li><li>参考视频：<a href="https://www.bilibili.com/video/BV11B421k7Jh?vd_source=bbdaef564df94fc8991902ba22c6761b">b站视频DoraHacks_e_phi不互素</a></li><li><p>由于该题型涉及到<code>AMM</code>算法所以还是比较迟才整理的。虽然网上有现成的代码，但是为了做题而抄代码这学不到东西（赛后也会因为缺少数论基础而不会去理解算法原理）。</p></li><li><p>这样下面这一张图是本篇文章的主要脉络：</p></li></ul><p><img src="/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/image-20250809124458151.png" alt="image-20250809124458151"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>对于之前做过的一些<code>RSA</code>加密，求出$\phi(N)$后就离解出密文非常近了，最关键一步其实就是求私钥$d$也就是$d \equiv e^{-1}~mod~(\phi(n))$，也就是求e在模$\phi(n)$下的逆元。但是回顾一下数论知识就会发现在求e的逆元时首先逆元需要存在才能求得密文，而密文存在的条件是$gcd(\phi(n),e)=1$，即二者互素。</li><li>当$gcd(\phi(n),e)≠1$，也就是二者不互素的情况下，就不能使用求逆元的方法求得私钥$d$，这就导致没办法正常的解密，此时就需要使用其他的方法进行处理，核心的方法是<code>AMM</code>算法。当然有些时候$gcd(\phi(n),e)$比较小的时候会有更好的解决方法。</li></ul><h1 id="情况1gcdephi比较小"><a href="#情况1—gcd-e-phi-比较小" class="headerlink" title="情况1—gcd(e,phi)比较小"></a>情况1—gcd(e,phi)比较小</h1><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><ul><li><p>对于$gcd(e,\phi(n))$比较小的情况，这里有个疑问，到底怎么样才算是比较小呢？总需要有一个界限吧。这个先不急着知道，看完该情况处理方式的推导过程之后，其实就会明白了（当然到文章后面我也会说明）。</p></li><li><p>对于$gcd(e,\phi(n))$比较小的情况，不妨设$gcd(e,\phi(n))=t$，则有$e’=e//t$。那么就有如下推导：</p></li></ul><script type="math/tex; mode=display">\begin{array}{l}c \equiv m^e \equiv m^{e't}~mod(~n)\\d' = e'^{-1}~mod(~\phi(n))\\\Rightarrow c^{d'} \equiv m^{te'd'}~mod(~\phi(n))\\\Rightarrow    c^{d'} \equiv m^{t*1}~mod(~\phi(n))\\\Rightarrow c^{d'} \equiv m^t ~mod(~\phi(n))\end{array}</script><ul><li>通过如上推导其实就相当于对$m^e$进行了一个降幂的操作，将$m^e$降成了$m^t$。虽然这样求的并不是明文的原始数据，但是当$m^t &lt; n$的时候，这其实就有$c^{d’}~mod(~n) =     m^t$，因为$m^t$的实际值是小于n的，这样就可以得到真正的$m^t$的值，这样直接开根号就可以求得$m$即明文</li><li>所以上面所说的<strong>比较小</strong>的这个界限，其实就是根据$m^t$与<strong>n</strong>的大小相比较的情况。</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ul><li>题目来源：NSSCTF忘记具体哪题了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">flag = <span class="string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span></span><br><span class="line"> </span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"> </span><br><span class="line">e = <span class="number">65537</span>*<span class="number">2</span></span><br><span class="line">n = p*q </span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;p = <span class="subst">&#123;p&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;q = <span class="subst">&#123;q&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e = <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">p = 9927950299160071928293508814174740578824022211226572614475267385787727188317224760986347883270504573953862618573051241506246884352854313099453586586022059</span></span><br><span class="line"><span class="string">q = 9606476151905841036013578452822151891782938033700390347379468858357928877640534612459734825681004415976431665670102068256547092636766287603818164456689343</span></span><br><span class="line"><span class="string">e = 131074</span></span><br><span class="line"><span class="string">c = 68145285629092005589126591120307889109483909395989426479108244531402455690717006058397784318664114589567149811644664654952286387794458474073250495807456996723468838094551501146672038892183058042546944692051403972876692350946611736455784779361761930869993818138259781995078436790236277196516800834433299672560</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>解析如下：</p><ul><li>这题其实<code>p、q、n、e、c</code>都给了，先直接按照常规解密流程走走看，发现代码运行到<code>d = gmpy2.invert(e,phi)</code>会报错，报错内容是逆元不存在。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><ul><li>既然逆元不存在的话，那其实就是<code>gcd(e,phi)!=1</code>。那就先来看看<code>e和phi的最大公因素</code>，发现最大公因素是<code>2</code>，算是比较小的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(gmpy2.gcd(e,phi))</span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure><ul><li>这时已经知道了<code>gcd(e,phi)=2</code>，那我们就尝试一下直接开方是否能解出<code>flag</code>。通过推导的过程得到$m^2$后直接开方，发现可以直接求得<code>flag</code>，那这题就算是完成了。exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">e = <span class="number">131074</span></span><br><span class="line">c = </span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">t = gmpy2.gcd(e,phi)</span><br><span class="line">e_ = e//t</span><br><span class="line">d_ = gmpy2.invert(e_,phi)</span><br><span class="line">m_ = <span class="built_in">pow</span>(c,d_,n)</span><br><span class="line">m,x = gmpy2.iroot(m_,t)</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;NSSCTF&#123;inverse_and_root&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="情况2e和p-1或q-1互素"><a href="#情况2—e和-p-1-或-q-1-互素" class="headerlink" title="情况2—e和(p-1)或(q-1)互素"></a>情况2—e和(p-1)或(q-1)互素</h1><h2 id="推导"><a href="#推导-1" class="headerlink" title="推导"></a>推导</h2><ul><li>这种情况是<code>e</code>和$phi(n)$并不互素，但是<code>e</code>和<code>p-1或q-1</code>其中一个互素，这种情况也不需要使用<code>AMM</code>算法来求解。这里我们可以根据数论同余定理：若$m=p_1*p_2$，且$a\equiv b(~mod~m)$，则有$a\equiv b~(mod ~p_1)$和$a\equiv b~(mod~p_2)$</li><li><p>由于情况2是<code>e和(p-1)、(q-1)其一互素</code>，那就不妨设$gcd(e,p-1)=1$，也就是$e^{-1}~mod~(\phi(p))$存在</p></li><li><p>这时对于情况2，就有如下推导：</p></li></ul><script type="math/tex; mode=display">\begin{array}{l}n=p*q,c\equiv m^e~(mod~n)\\\Rightarrow c\equiv m^e~(mod~p)\\gcd(e,p-1)=1 \\\Rightarrow d'\equiv e~mod(~\phi(p))\\\Rightarrow m \equiv m^{e*d'}~mod(~p)\end{array}</script><ul><li><p>通过以上推导其实可以比较轻松的求出明文<code>m</code>。注意：这种条件下也有一个限制条件就是明文<code>m</code>必须小于<code>p</code>，或者不能远大于<code>p</code>，否则在计算$m \equiv m^{e*d’}~mod(~p)$时，没有办法还原出真正的<code>m</code>。</p></li><li><p>所以情况2本质上是转换为这种形式的<code>RSA</code>加密从而去解密：</p></li></ul><script type="math/tex; mode=display">m^e \equiv c(~mod~p)\\m^e \equiv c(~mod~q)</script><h2 id="例题"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">e = <span class="number">65537</span> * <span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">9</span></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()).encode() + <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">n = p*q</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line">t = gmpy2.gcd(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">assert</span> m**t &gt; n</span><br><span class="line"><span class="keyword">assert</span> gmpy2.gcd(e,p-<span class="number">1</span>) == <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p =&quot;</span>,p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q =&quot;</span>,q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e =&quot;</span>,e)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">c = 3337182590619332891367579450095260017621948297658608474765927585747734506999354328509683568925377515619204064576076990658487700251069936667303178625246768854069321364684053609635568733663779323983023955186264359508474160621887429553760676977134496070475993741436565049779300934693925938183415460792275981347122871322148183170843853299782459185390522709695133592628923912979653573313450679119054746286193009565269774894288416510194737513999402051586939745106744803143145962870026162701796980802087523932796322787192289532828027946970149619523331107916885023397981791618926415589540736035561888254541222060699696856314</span></span><br><span class="line"><span class="string">p = 159938356510922739007311592848401509267166900696359028060364191269434588150823128062554654793663223011556473183265872894887579647809204570681388595087731937155662030332723972658713288321275408537705376086753101569069606146533249314025914677902624686308192979454352019032737737659516168971489486159303628756323</span></span><br><span class="line"><span class="string">q = 96430824217229072069182669895140083481416631653486517954264036040832169030441397642841245167011632195729479683858486548460196751092827654037479770105468583618722386613888439003723062136646644840030371564874711263303175809941599945731077671059902934814813625011920226998576747817059406799637645523370079620639</span></span><br><span class="line"><span class="string">e = 61932465</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>这题代码<code>assert gmpy2.gcd(e,p-1) == 1</code>已经告诉我们是<code>e与p-1互素</code>，并且此题也断言了<code>m**t &gt; n</code>，这就导致我们并不能使用情况1的解法。就需要使用情况2推导的方法，exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">c = </span><br><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">e = <span class="number">61932465</span></span><br><span class="line">c = c % p</span><br><span class="line">phi = p-<span class="number">1</span></span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,p)</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;flag&#123;1858c133-a706-4110-af96-9639b25a3d5f&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="情况3p-1或q-1是e的倍数"><a href="#情况3—-p-1-或-q-1-是e的倍数" class="headerlink" title="情况3—(p-1)或(q-1)是e的倍数"></a>情况3—(p-1)或(q-1)是e的倍数</h1><ul><li><p>情况3的解法会比前俩种情况复杂的多，这种情况一般是<code>gcd(e,phi)=e</code>或者是<code>gcd(e,phi)=k*e</code>，在解决此情况的时候需要使用到一个算法，这个算法为<code>AMM</code>算法，也就是</p></li><li><p>在学习<code>AMM</code>算法之前需要先掌握几个定理和概念：</p><ul><li>二次剩余与二次非剩余</li><li>欧拉判别法</li><li>勒让德符号</li></ul></li></ul><h2 id="amm算法"><a href="#AMM算法" class="headerlink" title="AMM算法"></a>AMM算法</h2><ul><li><code>AMM</code>算法全称是<strong>AMM(全称为Adleman-Mander-Miller Method)</strong>，<code>AMM</code>算法与<code>Tonelli-Shanks</code>算法本质上是一样的，只不过乘积的时候顺序不同。</li><li>首先提出<code>AMM</code>算法是在<code>1977</code>年，由<code>Adleman, Manders, Miller</code>发表于<code>IEEE FOCS</code>会议的一篇名为<code>On taking roots in finite fields</code></li><li><p>但是真正让<code>AMM</code>算法被重视的其实是在<code>2011</code>年，由<code>Zhengjun Cao, Qian Sha, Xiao Fan</code>发表的名为<code>Adleman–Manders–Miller Root Extraction Method Revisited</code>这篇论文，所以学习AMM算法主要参考的就是这篇论文，论文地址：<a href="https://arxiv.org/pdf/1111.4877">1111.4877v1.pdf</a></p></li><li><p>在论文中有介绍三种<code>AMM</code>算法：分别是<code>二次同余方程</code>的AMM算法，以及扩域后的<code>二次同余方程</code>的AMM算法，最后就是<code>r次同余方程</code>的AMM算法。这边我只学习<code>二次同余方程</code>的AMM算法和<code>r次同余方程</code>的AMM算法。</p></li><li><p><code>AMM</code>算法的作用其实是快速求解同余方程$x^2\equiv a~(~mod~p)$，其中<code>p</code>是素数。</p></li></ul><p><strong>问题</strong>：</p><p>求解二次同余方程$x^2 \equiv \delta~(mod~p)$，其中<code>p</code>是奇素数。</p><p><strong>算法推导</strong>：</p><ul><li>首先我们先将<code>p-1</code>（也就是奇素数p的欧拉函数），写成$2^t*s$的形式，其中需要满足<code>s</code>是一个奇数。这样对于一个模p下的二次剩余$\delta$和模p下的二次非剩余$\rho$来说有如下的式子$(\delta^s)^{2^{t}}~mod(~p)$和式子$(\rho^{s})^{2^{t}}~mod~(p)$由欧拉判别可以得到：</li></ul><script type="math/tex; mode=display">(\delta^s)^{2^{t-1}}\equiv 1~mod(~p),(\rho^{s})^{2^{t-1}}\equiv -1~mod~(p)</script><ul><li>当$t=1$的时候其实就有下式，即由上式左边的同余式同余号两边同乘$\delta$即可得到：</li></ul><script type="math/tex; mode=display">(\delta^{\frac{s+1}{2}})^2 \equiv \delta~mod(~p)</script><ul><li>当$t≥2$的时候，就会有$(\delta^s)^{2^{t-2}}~mod(~p)\in{1,-1}$，此时就可以找到一个$k_1=0 ~or~1$使得：</li></ul><script type="math/tex; mode=display">(\delta^s)^{2^{t-2}}*(\rho^s)^{2^{t-1}*k_1}\equiv1~mod(~p)</script><ul><li>对于$(\delta^s)^{2^{t-3}}$也有$(\delta^s)^{2^{t-3}}~mod(~p)\in{1,-1}$，此时也可以找到一个$k_2=0~or~1$使得：</li></ul><script type="math/tex; mode=display">(\delta^s)^{2^{t-3}}*(\rho^s)^{2^{t-1}*k_2}\equiv1~mod(~p)</script><ul><li>这样就可以找到$k<em>1,k_2,…,k</em>{t-1}\in{0,1}$，使得：</li></ul><script type="math/tex; mode=display">(\delta^s)(\rho^s)^{2*k_1+2^2*k_2+...+2^{t-1}*k_{t-1}}\equiv1~(mod~p)</script><ul><li>最终我们就可以找到同余方程$x^2 \equiv \delta~(mod~p)$的根即：</li></ul><script type="math/tex; mode=display">(\delta^{\frac{s+1}{2}})^2((\rho^s)^{k_1+2*k_2+...+2^{t-2}*k_{t-1}})^2 \equiv \delta~(mod~p)</script><ul><li><p>而这个程序运行的时间复杂度为$O(log^3p+t^2log^2p)$。</p></li><li><p>下面这张图片就是<code>AMM</code>算法在有限域$F_p$下的求平方根的伪代码：</p></li></ul><p><img src="/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/image-20250809180442472.png" alt="image-20250809180442472"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose_one</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rho = random.randint(<span class="number">1</span>,p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(rho,(p-<span class="number">1</span>)//<span class="number">2</span>,p) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> rho</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">AMM</span>(<span class="params">delta,p</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param delta: 同余结果a</span></span><br><span class="line"><span class="string">    :param p: 模数p</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> delta % p == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(delta,(p-<span class="number">1</span>)//<span class="number">2</span>,p) != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 在[1,p)中选择一个模p的二次非剩余</span></span><br><span class="line">        rho = choose_one(p)</span><br><span class="line">        <span class="keyword">if</span> rho // p !=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    t = <span class="number">0</span> <span class="comment"># 计算t、s</span></span><br><span class="line">    phi = p-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> phi % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        phi = phi//<span class="number">2</span></span><br><span class="line">    s = (p-<span class="number">1</span>)//(<span class="number">2</span>**t)</span><br><span class="line">    <span class="keyword">assert</span>(s % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接下来就是最关键的一步,也就是我们花最多时间推导的部分</span></span><br><span class="line">    a = <span class="built_in">pow</span>(rho,s,p)</span><br><span class="line">    b = <span class="built_in">pow</span>(delta,s,p)</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t):</span><br><span class="line">        d = <span class="built_in">pow</span>(b,<span class="built_in">pow</span>(<span class="number">2</span>,t-<span class="number">1</span>-i),p)</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">        b = b * <span class="built_in">pow</span>(a,<span class="number">2</span>*k,p) % p</span><br><span class="line">        h = h * <span class="built_in">pow</span>(a,k,p) % p</span><br><span class="line">        a = <span class="built_in">pow</span>(a,<span class="number">2</span>,p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(delta,(s+<span class="number">1</span>)//<span class="number">2</span>,p)*h) % p</span><br></pre></td></tr></table></figure><ul><li>使用<code>AMM</code>算法解二次同余方程，可以解出一个解<code>x1</code>，而二次同余方程是有俩个解的，而第二个解其实就可以用<code>(p-x1)%p</code>这样其实就可以解得二次同余方程的所有解了。可以做一题算法题尝试一下：<a href="https://www.luogu.com.cn/problem/P5491">P5491 【模板】二次剩余 - 洛谷</a></li></ul><h2 id="拓展amm算法"><a href="#拓展AMM算法" class="headerlink" title="拓展AMM算法"></a>拓展AMM算法</h2><ul><li><code>AMM</code>算法是快速求解<code>二次同余方程</code>，而<code>拓展AMM</code>算法其实就是快速求解高次同余方程，即形如$x^r\equiv a~(mod~p)$，其中<code>p</code>是素数，对于这种形式的同余方程需要与离散对数这个同余方程的形式区别开来，离散对数的同余方程是这样的$a^x\equiv r~(mod~p)$。其实这俩式子容易混淆就和高一那时候<code>幂函数</code>与<code>指数函数</code>容易混淆是差不多的。</li></ul><p><strong>问题</strong>：</p><p>求解高次同余方程$x^{r}\equiv \delta~(mod~p)$，其中p为奇素数。</p><p><strong>算法推导</strong>：</p><ul><li>对于该高次同余方程，其实有两种情况：<ul><li>第一种其实就是RSA加密中求解私钥d的运算，也就是当$gcd(r,\phi(p))=1$的情况下，就直接开根$x \equiv \delta^{r^{-1}}$，这种情况已经算是相当的熟悉了</li><li>第二种其实就是<code>AMM</code>算法的这种情况，也就是$r\mid p-1$这种情况</li></ul></li><li>当满足条件$r\mid p-1$这个情况时，此时$p-1$就可以被表示成$r^t*s$这种形式，这与前面AMM算法是类似的。此时还应该需要满足条件$(s,r)=1$。</li><li>此时已知的是一个n次剩余$\delta$，那么由r次剩余的判别就可以得到$(\delta^{s})^{r^{t-1}}\equiv \delta^{p-1} \equiv 1~(mod~p)$。（对于r次剩余的判别可以问AI了解一下）</li><li>因为$(s,r)=1$，这样会很容易找到一个非负整数$\alpha$使得$s\mid r\alpha -1$，那其实就有$r\alpha-1=ks$，这样就有如下式子：</li></ul><script type="math/tex; mode=display">(\delta^{r\alpha-1})^{r^{t-1}}=(\delta^{ks})^{r^{t-1}}=((\delta^{s})^{r^{t-1}})^k\equiv1~mod(~p)</script><ul><li>当<code>t=1</code>的时候，$\delta^{\alpha}$其实就是该同余方程的一个根。</li><li>当<code>t≥2</code>的时候，这时随机生成一个r次方非剩余，$\rho\in(0,p)$，这时就有如下式子：</li></ul><script type="math/tex; mode=display">(\rho^{s})^{i*r^{t-1}} \not= (\rho^{s})^{j*r^{t-1}},~i\not=j, i,j\in\{0,1,...,r-1\}</script><ul><li><p>由于取遍${0,1,…,r-1}$，$(\rho^{s})^{i<em>r^{t-1}}$的结果都没有相同的情况，这样就不妨设$K_i=(\rho^{s})^{i</em>r^{t-1}} and~K={K<em>0,K_1,…,K</em>{r-1}}$</p></li><li><p>这样其实就很容易找到一个$K_i$（任意取一个i好像都可以）满足式子$X^r\equiv1~mod(~p)$，该式子推导需要用上费马小定理：</p></li></ul><script type="math/tex; mode=display">K_i^r=(\rho^s)^{i*r^t}=(\rho^{s*r^{t}})^{i}=(\rho^{p-1})^{i}\equiv1~mod(~p)</script><ul><li>而根据r次剩余的判别就有：</li></ul><script type="math/tex; mode=display">((\delta^{r\alpha-1})^{r^{t-2}})^{r} \equiv 1~mod(~p)</script><ul><li>联立上面俩个式子其实，并且存在唯一的$j_1\in{0,1,…,r-1}$满足：</li></ul><script type="math/tex; mode=display">(\delta^{r\alpha-1})^{r^{t-2}}\equiv K_{i-j_1}~(mod~p)</script><ul><li>此时取$K_i=K_0$就有，但是对于下面的这个式子，如果要求得$j_1$就逃不开解离散对数：</li></ul><script type="math/tex; mode=display">(\delta^{r\alpha-1})^{r^{t-2}}\equiv K_{-j_1}~(mod~p)\\\Rightarrow (\delta^{r\alpha-1})^{r^{t-2}}K_j \equiv 1~(mod~p)\\\Rightarrow (\delta^{r\alpha-1})^{r^{t-2}}(\rho^{s})^{j_1*r^{t-1}} \equiv 1~(mod~p)</script><ul><li>以此类推，可以找到唯一的$j_2\in{0,1,…,r-1}$使得：</li></ul><script type="math/tex; mode=display">(\delta^{r\alpha-1})^{r^{t-3}}(\rho^{s})^{j_1*r^{t-1}}(\rho^{s})^{j_2*r^{t-2}}\equiv 1~(mod~p)</script><ul><li>这样就可以得到$j<em>1,j_2,…,j</em>{t-1}$满足如下式子：</li></ul><script type="math/tex; mode=display">\begin{array}{l}(\delta^{r\alpha-1})(\rho^{s})^{j_1*r}(\rho^{s})^{j_2*r^{2}}...(\rho^{s})^{j_{t-1}*r^{t-1}}\equiv 1~(mod~p)\\\Rightarrow (\delta^{r\alpha-1})(\rho^{s})^{j_1*r}(\rho^{s})^{j_2*r^{2}}...(\rho^{s})^{j_{t-1}*r^{t-1}}*\delta\equiv \delta~(mod~p)\\\Rightarrow(\delta^{r\alpha})((\rho^{s})^{j_1+j_2*r+...+j_{t-1}*r^{t-2}})^r\equiv \delta~(mod~p)\\\Rightarrow(\delta^{\alpha})^{r}((\rho^{s})^{j_1+j_2*r+...+j_{t-1}*r^{t-2}})^r\equiv \delta~(mod~p)\end{array}</script><ul><li><p>这样就得到了一个解：$x\equiv(\delta^{\alpha})((\rho^{s})^{j<em>1+j_2*r+…+j</em>{t-1}*r^{t-2}})~(mod~p)$</p></li><li><p>下面这张图片是描述拓展AMM算法的伪代码：</p></li></ul><p><img src="/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/image-20250809230550800.png" alt="image-20250809230550800"></p><ul><li>Python编写的拓展AMM算法代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose_one</span>(<span class="params">r,p</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rho = random.randint(<span class="number">1</span>,p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(rho,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span>  rho</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exAMM</span>(<span class="params">delta,r,p</span>):</span><br><span class="line">    <span class="keyword">if</span> (p-<span class="number">1</span>) % r != <span class="number">0</span>: <span class="comment"># 检测整除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(delta,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>: <span class="comment"># 检测N次剩余</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一步、第二步: 先生成一个r次非剩余</span></span><br><span class="line">    rho = choose_one(r,p)</span><br><span class="line">    <span class="comment"># 第三步(1): 求t,s</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    phi = p-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> phi % r == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        phi = phi//r</span><br><span class="line">    s = (p-<span class="number">1</span>)//(r**t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(2): 计算最小的alpha,使得满足 s|r*alpha - 1</span></span><br><span class="line">    <span class="keyword">if</span> math.gcd(s,r) != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (s*k+<span class="number">1</span>) % r != <span class="number">0</span>:</span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line">    alpha = (s*k+<span class="number">1</span>)//r</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(3): 初始化一些值,为循环做准备</span></span><br><span class="line">    a = <span class="built_in">pow</span>(rho,<span class="built_in">pow</span>(r,t-<span class="number">1</span>)*s,p)</span><br><span class="line">    b = <span class="built_in">pow</span>(delta,r*alpha-<span class="number">1</span>,p)</span><br><span class="line">    c = <span class="built_in">pow</span>(rho,s,p)</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t):</span><br><span class="line">        d = <span class="built_in">pow</span>(b,<span class="built_in">pow</span>(r,t-<span class="number">1</span>-i),p)</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = -math.log(d,a) % r <span class="comment"># 这里可能还有点问题,但好像不影响可以跑出结果</span></span><br><span class="line">        b = b*<span class="built_in">pow</span>(c,r*j,p) % p</span><br><span class="line">        h = h*<span class="built_in">pow</span>(c,j) % p</span><br><span class="line">        c = <span class="built_in">pow</span>(c,r,p)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(delta,alpha,p) * h % p</span><br></pre></td></tr></table></figure><ul><li>得到一组解后先别急，根据代数学基本定理：记重根的情况下，解的个数与方程最高次数相关，在模意义下也是这样的。所以使用<code>AMM</code>算法所求得的这个解不一定是<code>m</code></li><li>那应该如何求得其他解呢？已知一个解求其他解是比较容易的（这部分涉及到指数与原根）</li><li>在模方程下有：$X^r\equiv a~(mod~p)$，其中$x_0$是该方程的一个解，那么所有解的形式是：$x=x_0<em>g^{k</em>\frac{p-1}{r}}~mod(~p),k=0,1,…,r-1$，而这个<code>g</code>其实是一个生成元，满足$g^r\equiv1~(mod~p)$</li><li>所以得到一个解后，先要寻找一个满足条件的g，这样就可以求出全部的根了。但是当<code>p</code>太大的时候，找到生成元的时间复杂度太高了，所以就需要使用其他方式求得全部的解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种find_g的方式时间复杂度太高了</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_g</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="keyword">for</span> g <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,p):</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,p-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (p-<span class="number">1</span>) % d == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">pow</span>(g,d,p)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> d != p-<span class="number">1</span>:</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_all_root</span>(<span class="params">x0,r,p,g</span>):</span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,r):</span><br><span class="line">        roots.append(x0 * <span class="built_in">pow</span>(g,k*((p-<span class="number">1</span>)//r),p) % p)</span><br><span class="line">    <span class="keyword">return</span> roots</span><br></pre></td></tr></table></figure><ul><li>这里参考博客：<a href="https://www.cnblogs.com/SevensNight/p/18766178，其实就不直接去求`g`，而是利用随机数直接去求$g^{k*\frac{p-1}{r}}$所构成的集合">https://www.cnblogs.com/SevensNight/p/18766178，其实就不直接去求`g`，而是利用随机数直接去求$g^{k*\frac{p-1}{r}}$所构成的集合</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到所有的ri，即(ri*mp)^e%p = 1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ALL_ROOT2</span>(<span class="params">r, q</span>):  <span class="comment"># use function set() and .add() ensure that the generated elements are not repeated</span></span><br><span class="line">    li = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">len</span>(li) &lt; r):</span><br><span class="line">        p = powmod(random.randint(<span class="number">1</span>, q-<span class="number">1</span>), (q-<span class="number">1</span>)//r, q)</span><br><span class="line">        li.add(p)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_all_root</span>(<span class="params">x0,p,li</span>):</span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">        root = (x0*i) % p</span><br><span class="line">        roots.append(root)</span><br><span class="line">    <span class="keyword">return</span>  roots</span><br></pre></td></tr></table></figure><h2 id="推导"><a href="#推导-2" class="headerlink" title="推导"></a>推导</h2><ul><li>对应这个类型的题目，本质上是求解如下形式的高次同余方程。因为此时的e、phi不互素指数找不到逆元，正常的RSA解密方法就失效了。</li></ul><p><img src="/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/image-20250810091234312.png" alt="image-20250810091234312"></p><ul><li>首先要先进行如下的转化：</li></ul><script type="math/tex; mode=display">\begin{array}{l}n=p*q\\m^e\equiv c~mod~(n)\\\Rightarrow m^e \equiv c ~mod(~p),m^e\equiv c~mod(~q)\end{array}</script><ul><li><p>然后使用AMM算法分别求得这俩个方程的一个解，求得一个解后再求生成元就很容易得到全部解，记$m^e \equiv c ~mod(~p)$的解为$m<em>{1i}$，记$m^e\equiv c~mod(~q)$的解为$m</em>{2j}$</p></li><li><p>最后再遍历$m<em>{1i}、m</em>{2j}$，对他们使用<code>CRT</code>求解，总能求得一个解为<code>m</code></p></li></ul><script type="math/tex; mode=display">\begin{cases}x\equiv m_{1i} ~(mod~p)~i=1,2,...,e\\x\equiv m_{2j} ~(mod~q)~j=1,2,...,e\\\end{cases}</script><h2 id="例题"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><ul><li>题目来源：NSSCTF，不知道是哪题</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMyPrime</span>(<span class="params">nbits</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="number">2</span>*<span class="number">1009</span>*getPrime(nbits//<span class="number">2</span>)*getPrime(nbits//<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> is_prime(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> n+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">p = getMyPrime(<span class="number">700</span>)</span><br><span class="line">q = getMyPrime(<span class="number">700</span>)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line">e = <span class="number">1009</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + os.urandom(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"><span class="keyword">assert</span> m.bit_length() &lt; n.bit_length()</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;p = <span class="subst">&#123;p&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;q = <span class="subst">&#123;q&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = 38041020633815871156456469733983765765506895617311762629687651104582466286930269704125415948922860928755218376007606985275046819516740493733602776653724917044661666016759231716059415706703608364873041098478331738686843910748962386378250780017056206432910543374411668835255040201640020726710967482627384460424737495938659004753604600674521079949545966815918391090355556787926276553281009472950401599151788863393804355849499551329</span></span><br><span class="line"><span class="string">c = 2252456587771662978440183865248648532442503596913181525329434089345680311102588580009450289493044848004270703980243056178363045412903946651952904162045861994915982599488021388197891419171012611795147125799759947942753772847866647801312816514803861011346523945623870123406891646751226481676463538137263366023714001998348605629756519894600802504515051642140147685496526829541501501664072723281466792594858474882239889529245732945</span></span><br><span class="line"><span class="string">p = 5220649501756432310453173296020153841505609640978826669340282938895377093244978215488158231209243571089268416199675077647719021740691293187913372884975853901554910056350739745148711689601574920977808625399309470283   </span></span><br><span class="line"><span class="string">q = 7286645200183879820325990521698389973072307061827784645416472106180161656047009812712987400850001340478084529480635891468153462119149259083604029658605921695587836792877281924620444742434168448594010024363257554563</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>首先素数的生成满足一定的规律即：<code>p-1</code>的因子一定包含<code>e=1009</code>，所以<code>e</code>与<code>p-1和q-1</code>都不互素。这就需要使用AMM算法进行求根操作</li><li>这题其实就是先使用AMM算法求出一个根，然后利用这个根求出所有解，最后遍历使用CRT操作，具体其实就看推导和AMM算法的内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose_one</span>(<span class="params">r,p</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rho = random.randint(<span class="number">1</span>,p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(rho,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span>  rho</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exAMM</span>(<span class="params">delta,r,p</span>):</span><br><span class="line">    <span class="keyword">if</span> (p-<span class="number">1</span>) % r != <span class="number">0</span>: <span class="comment"># 检测整除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(delta,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>: <span class="comment"># 检测N次剩余</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一步、第二步: 先生成一个r次非剩余</span></span><br><span class="line">    rho = choose_one(r,p)</span><br><span class="line">    <span class="comment"># 第三步(1): 求t,s</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    phi = p-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> phi % r == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        phi = (phi-<span class="number">1</span>)//r</span><br><span class="line">    s = (p-<span class="number">1</span>)//(r**t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(2): 计算最小的alpha,使得满足 s|r*alpha - 1</span></span><br><span class="line">    <span class="keyword">if</span> math.gcd(s,r) != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (s*k+<span class="number">1</span>) % r != <span class="number">0</span>:</span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line">    alpha = (s*k+<span class="number">1</span>)//r</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(3): 初始化一些值,为循环做准备</span></span><br><span class="line">    a = <span class="built_in">pow</span>(rho,<span class="built_in">pow</span>(r,t-<span class="number">1</span>)*s,p)</span><br><span class="line">    b = <span class="built_in">pow</span>(delta,r*alpha-<span class="number">1</span>,p)</span><br><span class="line">    c = <span class="built_in">pow</span>(rho,s,p)</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t):</span><br><span class="line">        d = <span class="built_in">pow</span>(b,<span class="built_in">pow</span>(r,t-<span class="number">1</span>-i),p)</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = -math.log(d,a) % r</span><br><span class="line">        b = b*<span class="built_in">pow</span>(c,r*j,p) % p</span><br><span class="line">        h = h*<span class="built_in">pow</span>(c,j) % p</span><br><span class="line">        c = <span class="built_in">pow</span>(c,r,p)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(delta,alpha,p) * h % p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ALL_ROOT2</span>(<span class="params">r, q</span>):  <span class="comment"># use function set() and .add() ensure that the generated elements are not repeated</span></span><br><span class="line">    li = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">len</span>(li) &lt; r):</span><br><span class="line">        p = <span class="built_in">pow</span>(random.randint(<span class="number">1</span>, q-<span class="number">1</span>), (q-<span class="number">1</span>)//r, q)</span><br><span class="line">        li.add(p)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_all_root</span>(<span class="params">x0,p,li</span>):</span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">        root = (x0*i) % p</span><br><span class="line">        roots.append(root)</span><br><span class="line">    <span class="keyword">return</span>  roots</span><br><span class="line">c = <span class="number">2252456587771662978440183865248648532442503596913181525329434089345680311102588580009450289493044848004270703980243056178363045412903946651952904162045861994915982599488021388197891419171012611795147125799759947942753772847866647801312816514803861011346523945623870123406891646751226481676463538137263366023714001998348605629756519894600802504515051642140147685496526829541501501664072723281466792594858474882239889529245732945</span></span><br><span class="line">p = <span class="number">5220649501756432310453173296020153841505609640978826669340282938895377093244978215488158231209243571089268416199675077647719021740691293187913372884975853901554910056350739745148711689601574920977808625399309470283</span></span><br><span class="line">q = <span class="number">7286645200183879820325990521698389973072307061827784645416472106180161656047009812712987400850001340478084529480635891468153462119149259083604029658605921695587836792877281924620444742434168448594010024363257554563</span></span><br><span class="line">r = <span class="number">1009</span></span><br><span class="line">delta1 = c % p</span><br><span class="line">x0 = exAMM(delta1,r,p)</span><br><span class="line">li1 = ALL_ROOT2(r,p)</span><br><span class="line">roots1 = find_all_root(x0,p,li1)</span><br><span class="line">delta2 = c % q</span><br><span class="line">x1 = exAMM(delta2,r,q)</span><br><span class="line">li2 = ALL_ROOT2(r,q)</span><br><span class="line">roots2 = find_all_root(x1,q,li2)</span><br><span class="line"><span class="built_in">print</span>(roots1)</span><br><span class="line"><span class="built_in">print</span>(roots2)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(roots1)),leave=<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(roots2)):</span><br><span class="line">        <span class="comment"># 除数p、q</span></span><br><span class="line">        M = p*q</span><br><span class="line">        m1 = q</span><br><span class="line">        m2 = p</span><br><span class="line">        m1_ = gmpy2.invert(m1,p)</span><br><span class="line">        m2_ = gmpy2.invert(m2,q)</span><br><span class="line">        m = (m1*m1_*roots1[i] + m2*m2_*roots2[j]) % M</span><br><span class="line">        flag = long_to_bytes(m)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;NSSCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;NSSCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># b&quot;NSSCTF&#123;ee5cb1a5-9d62-257a-9ef5-48b06ff0651a&#125;\xbc\xbaw\xfe\xb8\x04A\x8es\xdct#\x1a\x91\x82\xbd\x0f\xfc&lt;\xc4\xb0$\x01\xd0\xc8/\xd9d#\x9baf=\xf1\xfd\xde&#x27;\x0e=\xcfX\xd1\xdbM\x9f\xba\xaf\x8a\xb9\xf0\xd7\xaa&#123;\xbf`:DY\xf5|\x11_R\x92\xa1\x9d\xc81\x12\xe9`\x17\xe3\n@K\\\xa5\x1f\xa7?\xdb\xf7p\x8aH\xba(\x02\xad\xf8n\xbe\xea\xcdTu\xac\xc4\xa1&quot;</span></span><br></pre></td></tr></table></figure><ul><li>sagemath版本：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line">c = <span class="number">2252456587771662978440183865248648532442503596913181525329434089345680311102588580009450289493044848004270703980243056178363045412903946651952904162045861994915982599488021388197891419171012611795147125799759947942753772847866647801312816514803861011346523945623870123406891646751226481676463538137263366023714001998348605629756519894600802504515051642140147685496526829541501501664072723281466792594858474882239889529245732945</span></span><br><span class="line">p = <span class="number">5220649501756432310453173296020153841505609640978826669340282938895377093244978215488158231209243571089268416199675077647719021740691293187913372884975853901554910056350739745148711689601574920977808625399309470283</span>   </span><br><span class="line">q = <span class="number">7286645200183879820325990521698389973072307061827784645416472106180161656047009812712987400850001340478084529480635891468153462119149259083604029658605921695587836792877281924620444742434168448594010024363257554563</span></span><br><span class="line">r = <span class="number">1009</span></span><br><span class="line">c1 = c % p</span><br><span class="line">c2 = c % q</span><br><span class="line">Zmn = Zmod(p) <span class="comment"># 创建一个模p的整数环</span></span><br><span class="line">Zmn2 = Zmod(q)</span><br><span class="line"><span class="comment"># 在模p的整数环下求 x^r = c 的根，也就是x^p = c mod(p)满足该式子的未知数x</span></span><br><span class="line"><span class="comment"># all = True表示要求出所有解，而all = false则表示不需要求出所有解</span></span><br><span class="line">x_list = Zmn(c1).nth_root(r,<span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line">y_list = Zmn2(c2).nth_root(r,<span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#print(y_list)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(x_list)),leave = <span class="string">&#x27;True&#x27;</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_list)):</span><br><span class="line">        m_ = [x_list[i],y_list[j]]</span><br><span class="line">        p_ = [p,q]</span><br><span class="line">        result = CRT(m_,p_)</span><br><span class="line">        flag = long_to_bytes(result)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;NSSCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;NSSCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="情况4p-1和q-1与e均不互素"><a href="#情况4—-p-1-和-q-1-与e均不互素" class="headerlink" title="情况4—(p-1)和(q-1)与e均不互素"></a>情况4—(p-1)和(q-1)与e均不互素</h1><ul><li>对于<code>e</code>与<code>phi</code>不互素来说通解其实都是有限域开根，但是对于这种情况，<code>e</code>与<code>p-1和q-1</code>均不互素并且<code>p-1和q-1</code>都不是<code>r</code>的倍数，那AMM算法适用的条件就失效了。</li><li>但是思路还是有限域开根，这里直接使用<code>sagemath</code>一把梭，对于sagemath有限元两种开根方式，看sagemath一把梭部分。</li></ul><h2 id="例题"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><ul><li>题目来源：<a href="https://www.cnblogs.com/SevensNight/p/18764988">e与(p-1)或(q-1)均不互素 - sevensnight - 博客园</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"> </span><br><span class="line">e = <span class="number">0x14</span></span><br><span class="line">p = <span class="number">733089589724903586073820965792963746076789390539824437962807679954808310072656817423828613938510684864567664345751164944269489647964227519307980688068059059377123391499328155025962198363435968318689113750910755244276996554328840879221120846257832190569086861774466785101694608744384540722995426474322431441</span></span><br><span class="line">q = <span class="number">771182695213910447650732428220054698293987458796864628535794956332865106301119308051373568460701145677164052375651484670636989109023957702790185901445649197004100341656188532246838220216919835415376078688888076677350412398198442910825884505318258393640994788407100699355386681624118606588957344077387058721</span></span><br><span class="line">n = p*q</span><br><span class="line"> </span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#406314720119562590605554101860453913891646775958515375190169046313074168423687276987576196367702523895650602252851191274766072774312855212771035294337840170341052016067631007495713764510925931612800335613551752201920460877432379214684677593342046715833439574705829048358675771542989832566579493199671622475225225451781214904100440695928239014046619329247750637911015313431804069312072581674845078940868349474663382442540424342613429896445329365750444298236684237769335405534090013035238333534521759502103604033307768304224154383880727399879024077733935062478113298538634071453067782212909271392163928445051705642</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p = <span class="number">733089589724903586073820965792963746076789390539824437962807679954808310072656817423828613938510684864567664345751164944269489647964227519307980688068059059377123391499328155025962198363435968318689113750910755244276996554328840879221120846257832190569086861774466785101694608744384540722995426474322431441</span></span><br><span class="line">q = <span class="number">771182695213910447650732428220054698293987458796864628535794956332865106301119308051373568460701145677164052375651484670636989109023957702790185901445649197004100341656188532246838220216919835415376078688888076677350412398198442910825884505318258393640994788407100699355386681624118606588957344077387058721</span></span><br><span class="line">n = p*q</span><br><span class="line">c = <span class="number">406314720119562590605554101860453913891646775958515375190169046313074168423687276987576196367702523895650602252851191274766072774312855212771035294337840170341052016067631007495713764510925931612800335613551752201920460877432379214684677593342046715833439574705829048358675771542989832566579493199671622475225225451781214904100440695928239014046619329247750637911015313431804069312072581674845078940868349474663382442540424342613429896445329365750444298236684237769335405534090013035238333534521759502103604033307768304224154383880727399879024077733935062478113298538634071453067782212909271392163928445051705642</span></span><br><span class="line">e = <span class="number">0x14</span></span><br><span class="line">Zmn = Zmod(p) <span class="comment"># 创建一个模p的整数环</span></span><br><span class="line">Zmn2 = Zmod(q)</span><br><span class="line"><span class="comment"># 在模p的整数环下求 x^r = c 的根，也就是x^p = c mod(p)满足该式子的未知数x</span></span><br><span class="line"><span class="comment"># all = True表示要求出所有解，而all = false则表示不需要求出所有解</span></span><br><span class="line">x_list = Zmn(c).nth_root(e,<span class="built_in">all</span> = <span class="literal">True</span>)</span><br><span class="line">y_list = Zmn2(c).nth_root(e,<span class="built_in">all</span> = <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#print(x_list)</span></span><br><span class="line"><span class="comment">#print(y_list)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(x_list)),leave=<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_list)):</span><br><span class="line">        c_ = [<span class="built_in">int</span>(x_list[i]),<span class="built_in">int</span>(y_list[j])]</span><br><span class="line">        m = [p,q]</span><br><span class="line">        x = CRT(c_,m)</span><br><span class="line">        f = long_to_bytes(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;flag&#x27;</span> <span class="keyword">in</span> f:</span><br><span class="line">            <span class="built_in">print</span>(f)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;flag&#x27;</span> <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># b&#x27;flag&#123;r54__d34l1n6_w17h_3v3n_3 _&amp;_f1nd1n6_n-7h_r0075~~&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="情况5nprq的情况"><a href="#情况5—n-p-r-q的情况" class="headerlink" title="情况5—n=p^r*q的情况"></a>情况5—n=p^r*q的情况</h1><ul><li>对于这种情况来说处理方式还是一样的去求根。</li></ul><h2 id="例题"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><ul><li>题目来源：<code>2023年香山杯-list</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">s,l</span>):</span><br><span class="line">    <span class="keyword">return</span> s + os.urandom(l - <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    g = getPrime(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = g * random.getrandbits(<span class="number">138</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        q = g * random.getrandbits(<span class="number">138</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(q):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    N = p ** <span class="number">5</span> * q</span><br><span class="line">    phi = p ** <span class="number">4</span> * (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    d = random.getrandbits(<span class="number">256</span>)</span><br><span class="line">    e = inverse(d, phi)</span><br><span class="line">    E = e * g</span><br><span class="line">    hint = gmpy2.gcd(E, phi)</span><br><span class="line">    <span class="keyword">return</span> N, E, hint</span><br><span class="line"></span><br><span class="line">flag = pad(flag,<span class="number">64</span>)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">n,e,hint = gen()</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;hint = <span class="subst">&#123;hint&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;e = <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># hint = 251</span></span><br><span class="line"><span class="comment"># n = 108960799213330048807537253155955524262938083957673388027650083719597357215238547761557943499634403020900601643719960988288543702833581456488410418793239589934165142850195998163833962875355916819854378922306890883033496525502067124670576471251882548376530637034077</span></span><br><span class="line"><span class="comment"># e = 3359917755894163258174451768521610910491402727660720673898848239095553816126131162471035843306464197912997253011899806560624938869918893182751614520610693643690087988363775343761651198776860913310798127832036941524620284804884136983215497742441302140070096928109039</span></span><br><span class="line"><span class="comment"># c = 72201537621260682675988549650349973570539366370497258107694937619698999052787116039080427209958662949131892284799148484018421298241124372816425123784602508705232247879799611203283114123802597553853842227351228626180079209388772101105198454904371772564490263034162</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="通解"><a href="#通解" class="headerlink" title="通解"></a>通解</h2><ul><li>对于情况1和情况2，这两种情况太特殊不具有一般性。在很多情况下不能使用情况1和情况2的方法。</li><li>对于<code>e</code>和<code>phi</code>不互素的情形以及以后遇到的各种变形情况，需要牢牢抓住有限域开根与CRT配合这条思路，基本上这类题型换汤不换药。</li><li>还有就是这类问题本质上就是使用<strong>算法的方式</strong>求第一类的高次同余式，如下图所示：</li></ul><p><img src="/2025/08/08/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86%E4%B9%8Be%E5%92%8Cphi%E4%B8%8D%E4%BA%92%E7%B4%A0/image-20250809235317052.png" alt="image-20250809235317052"></p><ul><li>转化到<code>RSA</code>加密中其实就是去解如下高次同余方程：</li></ul><script type="math/tex; mode=display">x^r\equiv \delta~mod(~p) \Rightarrow m^e\equiv c~(mod~p)</script><h2 id="amm板子"><a href="#AMM板子" class="headerlink" title="AMM板子"></a>AMM板子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose_one</span>(<span class="params">r,p</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rho = random.randint(<span class="number">1</span>,p)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(rho,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span>  rho</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exAMM</span>(<span class="params">delta,r,p</span>):</span><br><span class="line">    <span class="keyword">if</span> (p-<span class="number">1</span>) % r != <span class="number">0</span>: <span class="comment"># 检测整除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(delta,(p-<span class="number">1</span>)//r,p) != <span class="number">1</span>: <span class="comment"># 检测N次剩余</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一步、第二步: 先生成一个r次非剩余</span></span><br><span class="line">    rho = choose_one(r,p)</span><br><span class="line">    <span class="comment"># 第三步(1): 求t,s</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    phi = p-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> phi % r == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        phi = (phi-<span class="number">1</span>)//r</span><br><span class="line">    s = (p-<span class="number">1</span>)//(r**t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(2): 计算最小的alpha,使得满足 s|r*alpha - 1</span></span><br><span class="line">    <span class="keyword">if</span> math.gcd(s,r) != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (s*k+<span class="number">1</span>) % r != <span class="number">0</span>:</span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line">    alpha = (s*k+<span class="number">1</span>)//r</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步(3): 初始化一些值,为循环做准备</span></span><br><span class="line">    a = <span class="built_in">pow</span>(rho,<span class="built_in">pow</span>(r,t-<span class="number">1</span>)*s,p)</span><br><span class="line">    b = <span class="built_in">pow</span>(delta,r*alpha-<span class="number">1</span>,p)</span><br><span class="line">    c = <span class="built_in">pow</span>(rho,s,p)</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t):</span><br><span class="line">        d = <span class="built_in">pow</span>(b,<span class="built_in">pow</span>(r,t-<span class="number">1</span>-i),p)</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = -math.log(d,a) % r</span><br><span class="line">        b = b*<span class="built_in">pow</span>(c,r*j,p) % p</span><br><span class="line">        h = h*<span class="built_in">pow</span>(c,j) % p</span><br><span class="line">        c = <span class="built_in">pow</span>(c,r,p)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(delta,alpha,p) * h % p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ALL_ROOT2</span>(<span class="params">r, q</span>):  <span class="comment"># use function set() and .add() ensure that the generated elements are not repeated</span></span><br><span class="line">    li = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">len</span>(li) &lt; r):</span><br><span class="line">        p = powmod(random.randint(<span class="number">1</span>, q-<span class="number">1</span>), (q-<span class="number">1</span>)//r, q)</span><br><span class="line">        li.add(p)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_all_root</span>(<span class="params">x0,p,li</span>):</span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">        root = (x0*i) % p</span><br><span class="line">        roots.append(root)</span><br><span class="line">    <span class="keyword">return</span>  roots</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_nth_root</span>(<span class="params">c,e,p</span>):</span><br><span class="line">    x0 = exAMM(c,e,p)</span><br><span class="line">    li = ALL_ROOT2(e,p)</span><br><span class="line">    roots = find_all_root(x0,p,li)</span><br><span class="line">    <span class="keyword">return</span> roots</span><br></pre></td></tr></table></figure><h2 id="sagemath一把梭"><a href="#sagemath一把梭" class="headerlink" title="sagemath一把梭"></a>sagemath一把梭</h2><ul><li>对于有限域开根，其实sagemath已经有对应的函数与方法了，其实还不止一种。接下来主要介绍sagemath中有限域开根的两中方式。所谓有限域开根其实在数论中就是求高次同余式$x^r= a~(mod~p)$的根，而在其他代数结构可能就不是指模意义下的求根了。</li><li>有了sagemath一把梭之后就不用<code>AMM</code>算法了，可以纯脚本小子哈哈哈，但是建议还是学一下AMM算法，都牢密码了，如果不是比赛的话认真学还是不错的。</li><li>方式一：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">41</span></span><br><span class="line">r = <span class="number">8</span></span><br><span class="line">c = <span class="number">10</span></span><br><span class="line">Zmn = Zmod(p) <span class="comment"># 创建一个模p的整数环</span></span><br><span class="line"><span class="comment"># 在模p的整数环下求 x^r = c 的根，也就是x^p = c mod(p)满足该式子的未知数x</span></span><br><span class="line"><span class="comment"># all = True表示要求出所有解，而all = false则表示不需要求出所有解</span></span><br><span class="line">x_list = Zmn(c).nth_root(r,<span class="built_in">all</span> = <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(x_list)</span><br></pre></td></tr></table></figure><ul><li>方式二：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">41</span></span><br><span class="line">r = <span class="number">8</span></span><br><span class="line">c = <span class="number">10</span></span><br><span class="line">F = GF(p) <span class="comment"># 创建一个有限域F_p</span></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(F) <span class="comment"># 在F上定义一个多项式环,其变量为x </span></span><br><span class="line">f = x^r - c <span class="comment"># 构造同余方程多项式</span></span><br><span class="line">f = f.monic() <span class="comment"># 转化为首一多项式</span></span><br><span class="line">x_list = f.roots() <span class="comment"># 有限域开方</span></span><br><span class="line"><span class="built_in">print</span>(x_list)</span><br></pre></td></tr></table></figure><p>注意：实际上求根其实只需要求一个根，之后使用如下定理在模方程下有：$X^r\equiv a~(mod~p)$，其中$x_0$是该方程的一个解，那么所有解的形式是：$x=x_0<em>g^{k</em>\frac{p-1}{r}}~mod(~p),k=0,1,…,r-1$，而这个<code>g</code>其实是一个生成元，满足$g^r\equiv1~(mod~p)$即可快速求出。这个其实在拓展<code>AMM</code>算法中有详细讲解。</p><h1 id="rabin加密算法"><a href="#Rabin加密算法" class="headerlink" title="Rabin加密算法"></a>Rabin加密算法</h1><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><ul><li>参考博客：<a href="https://blog.csdn.net/vivid117/article/details/124784493">密码学之公钥密码体系（4）：Rabin公钥密码方案_rabin密码体制-CSDN博客</a></li><li><code>RSA</code>加密算法在<code>1977</code>年就已经出现了，但是<code>Rabin</code>加密算法其实是在<code>1979</code>年被提出。该加密算法是基于平方根计算难度的公钥密码体系，而<code>RSA</code>是基于大整数分解的公钥密码体系，这俩点需要区别开来。</li><li><p>但是为什么会在<code>RSA</code>加密中讲解<code>Rabin</code>加密算法呢？这是因为<code>Rabin</code>加密算法其实可以被看做是一个特殊的RSA加密算法，正常来说RSA加密的<code>e</code>一般都是选取<code>65537</code>，而<code>Rabin</code>加密算法基于平方根计算难度的公钥密码体系，所以<code>e</code>一般是选取<code>2</code>。</p></li><li><p>接下来就介绍一下<code>Rabin</code>加密算法：</p><ul><li>首先先生成两个大素数<code>p</code>、<code>q</code>，这俩个大素数最好都满足$p\equiv3~mod(~4),q\equiv3~(mod~4)$，这样会简化求平方根的计算（后面会提到）</li><li>然后计算模数<code>n=p*q</code></li><li>选取公钥<code>pk=n</code></li><li>选取私钥<code>sk=(p,q)</code></li></ul></li><li><p>加密过程：对消息<code>m</code>进行模平方运算，也就是$c\equiv m^2~(mod~n)$</p></li><li><p>解密过程如下（其实解密过程就是上面求解高次同余式方程的过程）：</p><ul><li>将$c\equiv m^2~(mod~n)$拆分成$m^2\equiv c~mod(~p),m^2\equiv c~(mod~q)$</li><li>求解同余方程的根$x^2\equiv c~mod(~p),x^2\equiv c~(mod~q)$，这里有一个问题<code>p、q</code>越大二次同余方程的这个根就越难找到。</li><li>所以在前面生成<code>p、q</code>有要求$p\equiv3~mod(~4),q\equiv3~(mod~4)$，这个其实就是用来化简求二次同余方程的这个过程。</li><li>如果满足$p\equiv3~mod(~4),q\equiv3~(mod~4)$，此时$x_1\equiv c^{\frac{p+1}{4}}mod~p,y_1\equiv c^{\frac{q+1}{4}}~mod(~q)$，这样求可以快速求出两个式子的一个平方根但是这俩个平方根不一定是真的<code>m</code></li><li>所以分别求得这俩个同余式的平方根后，由根的对称性原理其实就很容易求得$x_2\equiv p-x_1~(mod~p),y_2\equiv q-y_1~(mod~p)$</li><li>分别求得俩组解后，使用<code>CRT</code>最终求得密文。</li></ul></li><li>接下来使用代码演示一下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_p_q</span>(<span class="params">p_bit,q_bit</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = getPrime(p_bit)</span><br><span class="line">        q = getPrime(q_bit)</span><br><span class="line">        <span class="keyword">if</span> p % <span class="number">4</span> == <span class="number">3</span> <span class="keyword">and</span> q % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> p,q</span><br><span class="line">message = <span class="string">b&#x27;this_is_message&#x27;</span></span><br><span class="line">m = bytes_to_long(message)</span><br><span class="line">e = <span class="number">2</span></span><br><span class="line">p,q = my_p_q(<span class="number">512</span>,<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;加密参数如下:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p =&quot;</span>,p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q =&quot;</span>,q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e =&quot;</span>,e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;m =&quot;</span>,m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>,c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来是解密过程,先解二次同余方程,再求解令一个根,最后使用CRT</span></span><br><span class="line">x1 = <span class="built_in">pow</span>(c,(p+<span class="number">1</span>)//<span class="number">4</span>,p)</span><br><span class="line">y1 = <span class="built_in">pow</span>(c,(q+<span class="number">1</span>)//<span class="number">4</span>,q)</span><br><span class="line"></span><br><span class="line">x2 = (p-x1) % p</span><br><span class="line">y2 = (q-y1) % q</span><br><span class="line"></span><br><span class="line">c1 = [x1,x2]</span><br><span class="line">c2 = [y1,y2]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> c2:</span><br><span class="line">        M = p*q</span><br><span class="line">        m1 = q</span><br><span class="line">        m2 = p</span><br><span class="line">        m1_ = gmpy2.invert(m1,p)</span><br><span class="line">        m2_ = gmpy2.invert(m2,q)</span><br><span class="line">        x = (m1*m1_*i + m2*m2_*j) % M</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(x))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b&#x27;this_is_message&#x27;</span></span><br><span class="line"><span class="string">b&quot;?\xbb\xfc&lt;\x89/*`x\xc7V&#x27;y\xa7?\xf3#.T\x06R\xf2\x8b\x90\x16\xe5L\xc3\x82\x8a\xdfSS\x1e\x89-F\x8b\x1b\\\x12\t\xa3\xc79\xe9\x04\xe4\xe3\xa78E\x80A\xc8\xdf\xc7\xfc\xb84;P\xb8\x9b\xb6\xde^v\xd4&amp;\xe3i\x91\xf6\x86\xdch\xf3\xd5\xb1\x93\xd7\xe8&gt;0\x17\xf8Z\xfb\xc0\xe7\xb5-%\xaf\xa0t\xa6\xa9\x80\xfe\xa0*u\x96\xa0\xe2\x89\xf0&amp;=\xb9\x88\xb6\x06\x07\x85,\x07\xb8\xa6\xba\xb3\xd7$M\xb0\xd6&quot;</span></span><br><span class="line"><span class="string">b&#x27;V\x85\x1cR\xd1\xc5\xb8r\xcenk\xba\x91\x17\xcdQ\xbd\xdc\x96\xc5MJ\x16\xa23|\xe0&lt;=PZ\xec\xd8\x9d\x14*51f\x97\x19\x87/\x91&amp;\xae\xee&#125;\x1b\x1c\x9e\xa8\xb6VC,S\xfb\xfd\x8eh\xc5\x88\xea\xcb\xac\xcf \x85!\xdc\x04\xec\xdfz\x82\x0b\xa4\xe8\x97\xa9\x84\x9d\xea\xbb\xadF*\x89f8\xcc\xb9\xd2\xeb\xae&quot;\x0b\x01\xb1\xbe\xd0K\xf2yC\x15+\xd4Z;\xe3\xa1y\x1e&lt;\x019&#123;\x13\xcc\x8c2\xe4\x9awfk&#x27;</span></span><br><span class="line"><span class="string">b&quot;\x96A\x18\x8fZ\xf4\xe2\xd3G5\xc1\xe2\n\xbf\rD\xe1\n\xea\xcb\xa0&lt;\xa22Jb,\xff\xbf\xdb:@+\xbb\x9dW&#123;\xbc\x81\xf3+\x90\xd3X`\x97\xf3a\xfe\xc3\xd6\xee6\x98\x0c\x0c\x1b\xf8\xb5\xc2\xa4\x16A\x86\x82\x8b-\x97YH\xbfn~\xd6\x01^t\x98\xbeI=\\\x86(\xeb\xc5&gt;\x85\x85&#x27; \x81\xe6\xf8\x9bN\x96\xb1\xab2\xbdpvh\x0f\xe3\xf7\xb5\xc4\x80y\x9d)\xba\xbb\xda\x13\x06\x19Y\x13\xd9\x81HKc\xaf\xdc&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h2><ul><li>题目来源：<code>VNCTF2025</code></li><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line">flag=bytes_to_long(flag)</span><br><span class="line">l=flag.bit_length()//<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">n=[]</span><br><span class="line">N=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(n) &lt; <span class="number">3</span>:</span><br><span class="line">    p = <span class="number">4</span>*getPrime(l)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> isPrime(p):</span><br><span class="line">        n.append(p)</span><br><span class="line">        N *= p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c=<span class="subst">&#123;flag*flag%N&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># flag**2 % N</span></span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> symbols, expand</span><br><span class="line">x = symbols(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">polynomial = expand((x - n[<span class="number">0</span>]) * (x - n[<span class="number">1</span>]) * (x - n[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;polynomial=&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># c=24884251313604275189259571459005374365204772270250725590014651519125317134307160341658199551661333326703566996431067426138627332156507267671028553934664652787411834581708944</span></span><br><span class="line"><span class="comment"># polynomial=x**3 - 15264966144147258587171776703005926730518438603688487721465*x**2 + 76513250180666948190254989703768338299723386154619468700730085586057638716434556720233473454400881002065319569292923*x - 125440939526343949494022113552414275560444252378483072729156599143746741258532431664938677330319449789665352104352620658550544887807433866999963624320909981994018431526620619</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>非常典型的<code>Rabin</code>加密算法，其实还有不同的就是这个程序是三个素数的<code>Rabin</code>加密算法，而且题目没有正常的将<code>n、p、q、r</code>告诉我们而是给了一个多项式。</li><li>其实直接那多项式的系数进行分解就行，这边<code>sage</code>可以支持分解多项式，那就用<code>sage</code>分解。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a3 = <span class="number">1</span></span><br><span class="line">a2 = -<span class="number">15264966144147258587171776703005926730518438603688487721465</span></span><br><span class="line">a1 = <span class="number">76513250180666948190254989703768338299723386154619468700730085586057638716434556720233473454400881002065319569292923</span></span><br><span class="line">a0 = -<span class="number">125440939526343949494022113552414275560444252378483072729156599143746741258532431664938677330319449789665352104352620658550544887807433866999963624320909981994018431526620619</span></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(QQ)</span><br><span class="line">f = x^<span class="number">3</span> + a2*x^<span class="number">2</span> + a1*x + a0</span><br><span class="line">result = f.factor()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(x - 5908636118089697338533572785710162817248001570348495067227) * (x - 5487564316951417093934647798659941512646442958127439071827) * (x - 3868765709106144154703556118635822400623994075212553582411)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>接下来其实就是正常的<code>Rabin</code>算法的界面，只不过要解三个二次同余式，<code>CRT</code>的次数也比较多，exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(x - 5908636118089697338533572785710162817248001570348495067227) * (x - 5487564316951417093934647798659941512646442958127439071827) * (x - 3868765709106144154703556118635822400623994075212553582411)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p = <span class="number">5908636118089697338533572785710162817248001570348495067227</span></span><br><span class="line">q = <span class="number">5487564316951417093934647798659941512646442958127439071827</span></span><br><span class="line">r = <span class="number">3868765709106144154703556118635822400623994075212553582411</span></span><br><span class="line">n = p*q*r</span><br><span class="line">c = <span class="number">24884251313604275189259571459005374365204772270250725590014651519125317134307160341658199551661333326703566996431067426138627332156507267671028553934664652787411834581708944</span></span><br><span class="line">x1 = <span class="built_in">pow</span>(c,(p+<span class="number">1</span>)//<span class="number">4</span>,p)</span><br><span class="line">y1 = <span class="built_in">pow</span>(c,(q+<span class="number">1</span>)//<span class="number">4</span>,q)</span><br><span class="line">z1 = <span class="built_in">pow</span>(c,(r+<span class="number">1</span>)//<span class="number">4</span>,r)</span><br><span class="line">x2 = (p-x1) % p</span><br><span class="line">y2 = (q-y1) % q</span><br><span class="line">z2 = (r-z1) % r</span><br><span class="line">c1 = [x1,x2]</span><br><span class="line">c2 = [y1,y2]</span><br><span class="line">c3 = [z1,z2]</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line"><span class="built_in">print</span>(c2)</span><br><span class="line"><span class="built_in">print</span>(c3)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> c2:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> c3:</span><br><span class="line">            M = n</span><br><span class="line">            m1 = n//p</span><br><span class="line">            m2 = n//q</span><br><span class="line">            m3 = n//r</span><br><span class="line">            m1_ = gmpy2.invert(m1,p)</span><br><span class="line">            m2_ = gmpy2.invert(m2,q)</span><br><span class="line">            m3_ = gmpy2.invert(m3,r)</span><br><span class="line">            X = (m1*m1_*i + m2*m2_*j + m3*m3_*k) % M</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(X))</span><br><span class="line"><span class="comment"># b&#x27;VNCTF&#123;90dcfb2dfb21a21e0c8715cbf3643f4a47d3e2e4b3f7b7975954e6d9701d9648&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：学习密码学</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="RSA" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/RSA/"/>
    
    
  </entry>
  
  <entry>
    <title>PE文件结构</title>
    <link href="http://iyheart.github.io/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://iyheart.github.io/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2025-08-08T04:10:50.000Z</published>
    <updated>2025-08-10T15:38:16.472Z</updated>
    
    <content type="html"><![CDATA[<ul><li>推荐查看<code>PE</code>文件格式的工具：<code>010editor</code>、<code>CFF</code>、<code>winhex</code>。</li><li>其中<code>010editor</code>可以在之后逆向作为工具使用（其有PE模版，PE不同头的部分会有不同颜色的高亮），CFF可以具体查看PE文件结构体的具体值，<code>winhex</code>二进制查看器（用于学习）。</li><li>CFF汉化版：<a href="https://bbs.kanxue.com/thread-138015.htm">[分享][汉化]CFF Explorer 7.9 官方版（支持中文）-安全工具-看雪-安全社区|安全招聘|kanxue.com</a></li></ul><h1 id="vs2022写汇编"><a href="#VS2022写汇编" class="headerlink" title="VS2022写汇编"></a>VS2022写汇编</h1><ul><li>由于要用到<code>vs2022</code>编写汇编程序所以先来简单介绍一下在<code>vs2022</code>中如何可以设置编译汇编。先新建一个项目</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181212392.png" alt="image-20250701181212392"></p><ul><li>然后选择新建这个类型的项目</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181246713.png" alt="image-20250701181246713"></p><ul><li>点击<code>Windows</code>桌面引导后就选择如图选项</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181352226.png" alt="image-20250701181352226"></p><ul><li>之后右键新创建的项目，选择<code>生成依赖项---&gt;生成自定义</code></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181501755.png" alt="image-20250701181501755"></p><ul><li>勾选<code>masm</code>选项</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181525445.png" alt="image-20250701181525445"></p><ul><li>现在就可以新建一个<code>.asm</code>后缀的文件，写入如下代码，注意下面这个汇编代码是在<code>i386</code>架构下的</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181557776.png" alt="image-20250701181557776"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">extern MessageBoxA@16:proc</span><br><span class="line">extern ExitProcess@4:proc</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">    msgTitle db &quot;PE&quot;, 0</span><br><span class="line">    msgText  db &quot;Hello world!&quot;, 0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main:</span><br><span class="line">    push 0</span><br><span class="line">    push offset msgTitle</span><br><span class="line">    push offset msgText</span><br><span class="line">    push 0</span><br><span class="line">    call MessageBoxA@16</span><br><span class="line"></span><br><span class="line">    push 0</span><br><span class="line">    call ExitProcess@4</span><br><span class="line">    ret</span><br><span class="line">end main</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>既然是<code>i386</code>架构下的汇编，我们就需要将这里设置为<code>x86</code>，建议<code>debug</code>模式</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181815141.png" alt="image-20250701181815141"></p><ul><li>之后查看编译器是<code>ml.exe</code>还是<code>ml64.exe</code>，因为<code>x86</code>和<code>x64</code>的汇编语法上会存在不同，使用<code>ml64</code>编译<code>i386</code>的程序会编译不通过。</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701181930556.png" alt="image-20250701181930556"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701182019631.png" alt="image-20250701182019631"></p><ul><li>如果是<code>release</code>模式，在编译的时候就会出现这个问题</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701182127025.png" alt="image-20250701182127025"></p><ul><li>这个也比较好解决，解决方法就是在下图的<code>命令行</code>这一栏添加这么一句<code>ml</code>的汇编命令<code>/SAFESEH:NO</code></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701182250518.png" alt="image-20250701182250518"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701182319450.png" alt="image-20250701182319450"></p><ul><li>这样就可以编译通过了</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701182409366.png" alt="image-20250701182409366"></p><h1 id="pe文件结构简述"><a href="#PE文件结构简述" class="headerlink" title="PE文件结构简述"></a>PE文件结构简述</h1><ul><li>每个成熟的带有后缀名的文件比如<code>.exe</code>、<code>.pdf</code>、<code>.jpg</code>等文件都会有属于自己特有的文件头和文件尾。当我们查看或者运行这些文件的时候，操作系统并不是根据后缀名来识别这些文件类型。操作系统是通过识别这些<strong>文件的文件头和文件尾</strong>来判断这些文件具体是属于哪一类型。</li><li><code>PE</code>，英文全称为<code>portable executable</code>是可移植可执行文件。</li><li>对于<code>PE</code>可执行文件即<code>.exe</code>后缀的文件也是如此，<code>PE</code>文件也有属于自己的文件结果（文件头和文件尾），在这些文件中隐藏着一些程序运行的信息，并且<strong>一些反调试技术也与PE文件格式相关</strong>，所以在学<code>Windows</code>用户程序逆向之前，先要具体详细地学习一下<code>PE</code>文件结构。</li><li><code>PE</code>文件头大概有如下结构：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DOS_HEADER;  <span class="comment">//DOS头</span></span><br><span class="line">IMAGE_NT_HEADERS;  <span class="comment">//NT头,NT头包含了两个子结构</span></span><br><span class="line">    IMAGE_FILE_HEADER;  <span class="comment">//NT的文件头</span></span><br><span class="line">IMAGE_OPTIONAL_HEADER;<span class="comment">//NT的选项头文件,为可执行文件指定选项</span></span><br><span class="line">IMAGE_SECTION_HEADER;<span class="comment">//段头,段头与段数据的风格就是类似于Pascal风格字符串.有几个段数据,就会出现段头,</span></span><br><span class="line">.....<span class="comment">//段头都被放在一起</span></span><br><span class="line">IMAGE_SECTION_HEADER;<span class="comment">//段头</span></span><br><span class="line">SECTION_DATA;<span class="comment">//段数据</span></span><br><span class="line">....</span><br><span class="line">SECTION_DATA;<span class="comment">//段数据</span></span><br><span class="line">user data;<span class="comment">//附加数据,属于自定义类型,不属于格式一类.</span></span><br></pre></td></tr></table></figure><ul><li><code>PE</code>文件处于内存中的时候通常称为<strong>映像</strong></li></ul><h1 id="pe文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h1><ul><li>上面我们已经使用<code>VS2022</code>汇编出了<code>exe</code>文件，先使用<code>010Editor</code>查看一下这个<code>exe</code>文件<code>PE</code>结构。</li></ul><h2 id="dos头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><ul><li><code>MZ</code>是一个DOS头的识别部分，当操作系统执行这个可执行文件的时候，并不是看拓展名，而是看这个文件的二进制形式，其实<code>DOS</code>头的<strong>标志性标识</strong>其实就是<code>0x4D 0x5A</code>也就是<code>MZ</code>，<code>MZ</code>其实是<code>DOS</code>最早期作者的名字缩写。</li><li>而这个<code>DOS头</code>中我们标注<code>CC</code>的这边实际上是<strong>可以任意修改的、可以使用的</strong>，修改后并不影响其执行。标注<code>CC</code>的地方其实是为<code>DOS</code>文件执行的时候提供环境信息，这个环境信息包括<strong>寄存器值、可选重定位表、中断向量表、文件句柄表等</strong></li><li>最后的<code>32</code>位其实标明了<strong>新结构的位置(NT头的位置)</strong>，其中<code>0xC8</code>其实就是<code>PE</code>结构标识符中<code>P</code>字母的位置。</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701190415703.png" alt="image-20250701190415703"></p><ul><li>在<code>PE</code>和<code>DOS</code>头这边还有一段数据，其实也就是这一段数据。这一部分被称为<code>Stub</code>数据，通常被叫做<strong>残留数据</strong>(包含二进制指令和数据)。</li><li>当该文件在DOS下执行时，其就会真正从<code>offset=0x40</code>这个位置开始执行，最先开始执行<code>0x0E</code></li><li>在<code>DOS</code>执行后就会出现这样的提示：<code>This program cannot be run in DOS mode.</code></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701190659291.png" alt="image-20250701190659291"></p><ul><li>使用<code>IDA</code>反汇编就能看到这一段的具体指令了</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701191610768.png" alt="image-20250701191610768"></p><ul><li>接下来为了更熟悉<code>DOS</code>文件结构，就将<code>DOS</code>结构体敲一遍抄下来</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> stuct _IMAGE_DOS_HEADER&#123;</span><br><span class="line">    WORD e_magic;<span class="comment">//0x00 魔数: 存储DOS头&quot;MZ&quot;(0x5A4D,小端序就变成0x4D5A)</span></span><br><span class="line">    WORD e_cblp;<span class="comment">//0x02 存储最后一页剩余的字节数</span></span><br><span class="line">    WORD e_cp;<span class="comment">//0x04 文件总页数(512字节为单位)</span></span><br><span class="line">    WORD e_crlc;<span class="comment">//0x06 重定位表项数</span></span><br><span class="line">    WORD e_cparhdr;<span class="comment">//0x08 头部大小(以16字节为单位)</span></span><br><span class="line">    WORD e_minalloc;<span class="comment">//0x0A 程序最小额外分配内存(段数)</span></span><br><span class="line">    WORD e_maxalloc;<span class="comment">//0x0C 程序最大额外分配内存(段数)</span></span><br><span class="line">    WORD e_ss;<span class="comment">//0x0E 初始栈段地址(相对加载地址)</span></span><br><span class="line">    WORD e_sp;<span class="comment">//0x10 初始栈指针</span></span><br><span class="line">    WORD e_csum;<span class="comment">//0x12 校验和(通常为0,未使用)</span></span><br><span class="line">    WORD e_ip;<span class="comment">//0x14 初始指令指针(寄存器IP的初始值)</span></span><br><span class="line">    WORD e_csl;<span class="comment">//0x16 初始代码段地址 (相对加载地址)</span></span><br><span class="line">    WORD e_lfarlc;<span class="comment">//0x18 重定位表偏移 (从文件头开始的偏移)</span></span><br><span class="line">    WORD e_ovno;<span class="comment">//0x1A overlay号 (从文件头开始的偏移)(用于老式 DOS 多阶段加载)</span></span><br><span class="line">    WORD e_res[<span class="number">4</span>];<span class="comment">//0x1C~0x24 保留字段</span></span><br><span class="line">    WORD e_oemid;<span class="comment">//0x24 OEM标识符(用户自定义)(系统厂商自定义)</span></span><br><span class="line">    WORD e_oemindfo;<span class="comment">//0x26 OEM信息(和e_oemid配对)</span></span><br><span class="line">    WORD e_res2[<span class="number">10</span>];<span class="comment">//0x28~0x3C 额外保留字段</span></span><br><span class="line">    LONG e_lfanew;<span class="comment">//0x3C 指向 PE 文件头 (NT头) 偏移</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><ul><li>其实这一段都是可以<code>人为修改</code>和<code>利用</code>的</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701193847234.png" alt="image-20250701193847234"></p><h2 id="nt头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h2><ul><li><code>NT</code>头有三个主要结构体。其中一个是NT标识即<code>IMAGE_NT_HEADERS</code>，还有俩个子结构<code>IMAGE_FILE_HEADER</code>、<code>IMAGE_OPTIONAL_HEADER</code>。</li></ul><h3 id="nt头_nt_headers"><a href="#NT头-NT-HEADERS" class="headerlink" title="NT头_NT_HEADERS"></a>NT头_NT_HEADERS</h3><ul><li>在<code>VS</code>中查看<code>NT</code>头，发现<code>NT</code>头定义有区分<code>32</code>位和<code>64</code>位</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701194501594.png" alt="image-20250701194501594"></p><ul><li>其结构体就是这样(以32位为例子，先介绍32位的)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">  DWORD Signature; <span class="comment">// NT头的标识4字节,&quot;PE\x00\x00&quot; (0x4550 小端序就是0x50 0x45 0x00 0x00)</span></span><br><span class="line">  IMAGE_FILE_HEADER FileHeader; <span class="comment">// NT文件头</span></span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader; <span class="comment">// NT的选项头文件,为可执行文件指定选项</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><ul><li>下面是<code>NT</code>文件头文件格式的<code>16</code>进制分布</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701195743221.png" alt="image-20250701195743221"></p><h3 id="nt的文件头_file_headers"><a href="#NT的文件头-FILE-HEADERS" class="headerlink" title="NT的文件头_FILE_HEADERS"></a>NT的文件头_FILE_HEADERS</h3><ul><li>依然是这张图片，其中标<code>CC</code>的就是可以利用的。</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701195743221.png" alt="image-20250701195743221"></p><ul><li>直接查看<code>vs</code>的<code>IMAGE_FILE_HEADER</code>的结构体</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701200007106.png" alt="image-20250701200007106"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span>&#123;</span></span><br><span class="line">    WORD Machine;<span class="comment">// 一个宏,表示该程序是什么架构的程序,包括MIPS小端序、Intel 386等不同架构的程序,之后会详细说明</span></span><br><span class="line">    WORD NumberOfSections;<span class="comment">// 描述节区总数也就是IMAGE_SECTION_HEADER个数</span></span><br><span class="line">    DWORD TimeDateStamp;<span class="comment">// 每个可执行文件产生的时间(可以参考,但是不可信,因为别人可以改)</span></span><br><span class="line">    DWORD PointerToSymbolTable;<span class="comment">// 指向COFF符号表的文件偏移(距离文件开头的字节数)</span></span><br><span class="line">    DWORD NumberOfSymbols;<span class="comment">// 符号表中包含的符号个数</span></span><br><span class="line">    WORD sizeOfOptionalHeader;<span class="comment">// 描述后面的IMAGE_OPTIONAL_HEADER32的大小</span></span><br><span class="line">    WORD Characteristics;<span class="comment">// 该可执行文件的属性,可以知道该程序是PE文件中的哪一种.exe、.dll、.sys</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><ul><li>注意如果合理修改了<code>sizeOfOptionalHeader</code>的值，其实程序是可以正常运行，但是程序可能不能进行动态调试，动态调试可能就会出现问题。</li></ul><h4 id="machin宏定义"><a href="#Machin宏定义" class="headerlink" title="Machin宏定义"></a>Machin宏定义</h4><ul><li>上面<code>FILE_HEADER</code>中的<code>Machine</code>宏定义也可以在<code>VS</code>中能看到，某些宏定义可以经过<code>与</code>操作组合在一起</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701200837227.png" alt="image-20250701200837227"></p><ul><li>在上图中又几个比较重要和常见的架构宏定义</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="comment">// Intel 386架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="comment">// ARM 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br></pre></td></tr></table></figure><ul><li>介绍一下这些宏定义在的架构和类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED           0x0001  <span class="comment">// 去掉了重定位信息（常见于绝对地址绑定的程序）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  <span class="comment">// 可执行映像(非obj)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  <span class="comment">// 去掉调试行号信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  <span class="comment">// 去掉局部符号表信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  <span class="comment">// 工作集裁剪标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  <span class="comment">// 程序能访问大于2GB的地址空间(主要在x64系统上)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO         0x0080  <span class="comment">// 用于老系统检测字节序(低位反转)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_32BIT_MACHINE             0x0100  <span class="comment">// 32位程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED            0x0200  <span class="comment">// 去除调试信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  <span class="comment">// 来自可移动设备时,复制到交换文件运行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  <span class="comment">// 来自网络运行时,复制到交换文件运行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_SYSTEM                    0x1000  <span class="comment">// 标识该文件是系统文件(NTDLL、KERNEL32等).</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_DLL                       0x2000  <span class="comment">// 标识该文件是DLL类型的PE文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  <span class="comment">// 只能在但处理器机器上运行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI         0x8000  <span class="comment">// 字节高位反转,比较少见,用于字节序检测</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_UNKNOWN           0 <span class="comment">// 表示未知架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_TARGET_HOST       0x0001  <span class="comment">// 用于宿主机而非虚拟化环境</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="comment">// Intel 386架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_R3000             0x0162  <span class="comment">// MIPS 小端序架构, 0x160为大端序架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_R4000             0x0166  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_R10000            0x0168  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  <span class="comment">// MIPS little-endian WCE v2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ALPHA             0x0184  <span class="comment">// Alpha_AXP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH3               0x01a2  <span class="comment">// SH3 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH3DSP            0x01a3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH3E              0x01a4  <span class="comment">// SH3E 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH4               0x01a6  <span class="comment">// SH4 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_SH5               0x01a8  <span class="comment">// SH5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="comment">// ARM 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_THUMB             0x01c2  <span class="comment">// ARM Thumb/Thumb-2 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ARMNT             0x01c4  <span class="comment">// ARM Thumb-2 小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_AM33              0x01d3 <span class="comment">// AM33 架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_POWERPC           0x01F0  <span class="comment">// IBM PowerPC Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_POWERPCFP         0x01f1 <span class="comment">// IBM PowerPC 架构</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_MIPS16            0x0266  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ALPHA64           0x0284  <span class="comment">// ALPHA64</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU           0x0366  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_TRICORE           0x0520  <span class="comment">// Infineon</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_CEF               0x0CEF <span class="comment">// Infineon TriCore 架构 (混合型 RISC 架构处理器)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_EBC               0x0EBC  <span class="comment">// EFI Byte Code</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_M32R              0x9041  <span class="comment">// M32R小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_ARM64             0xAA64  <span class="comment">// ARM64小端序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_MACHINE_CEE               0xC0EE <span class="comment">// CEE虚拟机生成的可执行文件</span></span></span><br></pre></td></tr></table></figure><h3 id="nt的选项头文件_optional_header"><a href="#NT的选项头文件-OPTIONAL-HEADER" class="headerlink" title="NT的选项头文件_OPTIONAL_HEADER"></a>NT的选项头文件_OPTIONAL_HEADER</h3><ul><li>选项头有三类<code>32位选项头</code>、<code>64位选项头</code>、<code>嵌入式选项头</code>。这里主要介绍<code>32位选项头</code>和<code>64</code>位选项头</li><li>从<code>FILE_HEADERS</code>倒数第<code>3、4</code>字节就可以得到<code>optional header</code>的大小，其实就是<code>0xE0</code>，从而得到<code>optional head</code>的那一块区域</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701210423532.png" alt="image-20250701210423532"></p><ul><li>先查看一下<code>IMAGE_OPTIONAL_HEADER32</code>的结构体</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701212448754.png" alt="image-20250701212448754"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个是32位的选项头重点介绍</span></span><br><span class="line"><span class="comment">// 其实32位的结构和64位头结构一样,只是关于地址描述部分WORD、DWORD和ULONGLONG(无符号长整型)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span>&#123;</span></span><br><span class="line">    WORD Magic;<span class="comment">//0x00类似于PE、MZ这样的识别,有三个宏定义.IMAGE_NT_OPTIONAL_HDR_MAGIC可执行文件,IMAGE_ROM_OPTIONAL_HDR_MAGIC在ROM的文件用作固件(一般是UEFI ROM、BIOS插件模块、或者是在嵌入式设备中的),IMAGE_NT_OPTIONAL_HDR64_MAGIC</span></span><br><span class="line">    BYTE MajorLinkerVersion; <span class="comment">// 链接器主版本号</span></span><br><span class="line">    BYTE MinorLinkerversion; <span class="comment">// 链接器次版本号</span></span><br><span class="line">    DWORD SizeOfCode;<span class="comment">// 当前可执行文件所包含代码的总大小</span></span><br><span class="line">    DWORD SizeOfInitializedData;<span class="comment">// 已初始化数据的总大小 .data 、.const已初始化</span></span><br><span class="line">    DWORD SizeOfUninitializedData;<span class="comment">// 未初始化数据的总大小 .data? 未初始化 (对应已初始化的数据程序编译的时候需要记录数据内容,对于未初始化的数据不要保留位置,只需要记录SizeOfUninitializedData即可)</span></span><br><span class="line">    <span class="comment">// 上面这3个sizeOf都是说明性的东西,可以任意修改不影响执行,但是可以干扰调试调试器(可以用于反调试)</span></span><br><span class="line">    DWORD AddressOfEntryPoint;<span class="comment">// 程序入口点地址,简称EP(当前入口点)。OEP(原始入口点),在加壳的时候这么称呼</span></span><br><span class="line">    DWORD BaseOfCode;<span class="comment">// 代码基地址,程序偏移多少字节到代码段地址开头</span></span><br><span class="line">    DWORD BaseOfData;<span class="comment">// 数据基地址,数据的起始地址</span></span><br><span class="line">    <span class="comment">//上面程序基地址和数据基地址都是可以被修改的,这种其实也是反调试的方法之一</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以上这个部分是三个可选头共同的</span></span><br><span class="line">    DWORD ImageBase;<span class="comment">// (建议装载地址)程序默认的加载地址,如0x400000,方便操作系统重定位</span></span><br><span class="line">    DWORD SectionAlignment;<span class="comment">// 映像(内存中)每个节(Section)的对齐大小,通常为0x1000 </span></span><br><span class="line">    DWORD FileAlignment;<span class="comment">// 文件中每个节的对齐大小,通常为0x200,不满足0x200大小的就会补0</span></span><br><span class="line">    WORD MajorOperatingSystemVersion;<span class="comment">// 要求的最低操作系统主版本</span></span><br><span class="line">    WORD MinorOperatingSystemVersion;<span class="comment">// 要求的最低操作系统次版本</span></span><br><span class="line">    WORD MajorImageVersion;<span class="comment">// 应用程序自身主版本号(开发者填写)</span></span><br><span class="line">    WORD MinorImageVersion;<span class="comment">// 应用程序自身次版本号</span></span><br><span class="line">    WORD MajorSubsystemVersion;<span class="comment">// 所需子系统主版本</span></span><br><span class="line">    WORD MinorSubsystemVersion;<span class="comment">// 所需子系统次版本</span></span><br><span class="line">    DWORD Win32VersionValue;<span class="comment">// 通常为0,保留字段</span></span><br><span class="line">    DWORD SizeOfImage;<span class="comment">// 映像整体大小(对齐到SectionAlignment),用于加载时分配内存,必须对齐于SectionAlignment中的数据</span></span><br><span class="line">    DWORD SizeOfHeaders;<span class="comment">// 所有头部大小之和(DOS头+PE头+节表+可选头)</span></span><br><span class="line">    DWORD CheckSum;<span class="comment">// 可执行文件的校验和,用户程序一般不用检查校验和,如果是系统文件驱动等就需要检查校验和,判断其是否被修改或者出错误(3环的时候能利用,0环不能)</span></span><br><span class="line">    WORD Subsystem;<span class="comment">// 表示运行环境,GUI、Console、Native</span></span><br><span class="line">    WORD DllCharacteristics;<span class="comment">// DLL特性标志,例如ASLR、DEP支持等,如0x40动态重定位、NX兼容等</span></span><br><span class="line">    DWORD SizeOfStackReserve;<span class="comment">// 初始保留的栈空间大小</span></span><br><span class="line">    DWORD SizeOfStackCommit;<span class="comment">// 初始提交(分配)的栈空间</span></span><br><span class="line">    DWORD SizeOfHeapReserve;<span class="comment">// 初始保留的堆大小</span></span><br><span class="line">    DWORD SizeOfHeapCommit;<span class="comment">// 初始提交的堆大小</span></span><br><span class="line">    DWORD LoaderFlags;<span class="comment">// 保留字段,一般为0,可以自己写个值,在程序运行的时候读这个值</span></span><br><span class="line">    DWORD NumberOfRvaAndSizes;<span class="comment">// DataDirectory中有效条目数量(通常为16)</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <span class="comment">//一个数组,每项是一个数据目录项,包括导入表、导出表、资源表、异常表</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br><span class="line"><span class="comment">// DataDirectory[0]位导出函数表DLL,DataDirectory[1]位导入函数表,DataDirectory[2]位资源</span></span><br><span class="line"><span class="comment">// DataDirectory[3]异常处理信息</span></span><br></pre></td></tr></table></figure><ul><li>对于<code>DWORD FileAlignment;</code>这个文件对齐，紫色框部分才是代码的部分，但是由于文件需要<code>0x200</code>字节对齐，所以剩余部分需要补充<code>\x00</code></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702012000846.png" alt="image-20250702012000846"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702200111516.png" alt="image-20250702200111516"></p><h4 id="sizeofheaders"><a href="#SizeOfHeaders" class="headerlink" title="SizeOfHeaders"></a>SizeOfHeaders</h4><ul><li><code>SizeOfHeaders</code>指的是可执行文件的头部大小，从<code>SizeOfHeaders</code>中可以看出来<code>PE文件头大小为0x400</code>，这个<code>0x400</code>需要与<code>File_aligment</code>这里面的数据对齐(也就是需要满足0x200的整数倍)，由于我们的<code>Headers</code>大于<code>0x200</code>所以需要对齐到<code>0x400</code>也就是<code>Headers</code>头结束后，填充<code>\x00</code><strong>当做无效数据</strong></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702200521803.png" alt="image-20250702200521803"></p><h4 id="subsystem"><a href="#Subsystem" class="headerlink" title="Subsystem"></a>Subsystem</h4><ul><li>主要介绍一下<code>Subsystem</code>中一些宏，这个字段可以改，但是需要合理的改。</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702201441763.png" alt="image-20250702201441763"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_UNKNOWN              0   <span class="comment">// Unknown subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_NATIVE               1   <span class="comment">// Image doesn&#x27;t require a subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_GUI          2   <span class="comment">// 主要接触：Windows图形用户界面.Image runs in the Windows GUI subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CUI          3   <span class="comment">// 主要接触：Windows控制台界面.Image runs in the Windows character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_OS2_CUI              5   <span class="comment">// image runs in the OS/2 character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_POSIX_CUI            7   <span class="comment">// image runs in the Posix character subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_NATIVE_WINDOWS       8   <span class="comment">// 主要接触：Windows内核驱动 image is a native Win9x driver.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CE_GUI       9   <span class="comment">// Image runs in the Windows CE subsystem.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_APPLICATION      10  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER  11   <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER   12  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_EFI_ROM              13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_XBOX                 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG    17</span></span><br></pre></td></tr></table></figure><h4 id="dllcharacteristics"><a href="#DllCharacteristics" class="headerlink" title="DllCharacteristics"></a>DllCharacteristics</h4><ul><li>关于<code>Dll</code>的属性描述</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0001</span> 保留字段</span><br><span class="line"><span class="number">0x0002</span>保留字段</span><br><span class="line"><span class="number">0x0004</span>保留字段</span><br><span class="line"><span class="number">0x0008</span>保留字段</span><br><span class="line"><span class="number">0x2000</span>A WDM driver 基于WDM的一个驱动程序</span><br></pre></td></tr></table></figure><h4 id="堆栈保留和提交"><a href="#堆栈保留和提交" class="headerlink" title="堆栈保留和提交"></a>堆栈保留和提交</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD SizeOfStackReserve;<span class="comment">// 初始保留的栈空间大小,程序能向操作系统申请的最大栈内存</span></span><br><span class="line">DWORD SizeOfStackCommit;<span class="comment">// 初始提交(分配)的栈空间,程序一开始运行时需要先申请的栈大小</span></span><br><span class="line">DWORD SizeOfHeapReserve;<span class="comment">// 初始保留的堆大小,程序能向操作系统申请的最大堆内存</span></span><br><span class="line">DWORD SizeOfHeapCommit;<span class="comment">// 初始提交的堆大小,程序一开始运行时需要先申请的堆大小</span></span><br><span class="line"><span class="comment">// 该字段可以修改,但是需要合理修改。保留需要大于提交的大小,保留需要不超过OS的内存限制</span></span><br></pre></td></tr></table></figure><h3 id="image_data_directory"><a href="#IMAGE-DATA-DIRECTORY" class="headerlink" title="IMAGE_DATA_DIRECTORY"></a>IMAGE_DATA_DIRECTORY</h3><ul><li><strong>数据目录</strong>是<code>PE</code>文件中的一个重要结构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMAGE_DATA_DIRECTORY的结构如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">// 表的虚拟地址</span></span><br><span class="line">    DWORD   Size;<span class="comment">// 表的大小</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><ul><li>数据目录数组对应的索引已经规定好了具体的数据表，下面就是具体数据表的宏定义</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// 重点:导出表Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// 重点:导入表Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// 重点:资源描述Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// 重点:重定位表Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// 重点:TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// 过时了:Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// 过时了:Bound Import Directory in headers</span></span></span><br><span class="line"><span class="comment">// 早期Window是为了装载常用API,就将API地址固定了,但是由于OS更新比较快,每次更新地址会变,就出现问题,所以之后该文件就废弃了</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// 重点:IAT表 Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703183738734.png" alt="image-20250703183738734"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703183922862.png" alt="image-20250703183922862"></p><h4 id="导入表image_directory_entry_import"><a href="#导入表-IMAGE-DIRECTORY-ENTRY-IMPORT" class="headerlink" title="导入表(IMAGE_DIRECTORY_ENTRY_IMPORT)"></a>导入表(IMAGE_DIRECTORY_ENTRY_IMPORT)</h4><ul><li>最复杂的一个数据目录。</li><li><p>导入表的作用如下：</p><ul><li>当程序运行的时候，有时需要调用外部接口，尤其是<code>操作系统API</code>。有点类似于<code>ELF</code>文件中的<code>got表</code>。</li><li>当操作系统装载我们的可执行文件时，操作系统首先会分析可执行文件需要哪些库。接着分析需要这些库的哪些函数，将需要调用的函数地址，填入到操作系统和编译器约定好的位置。</li><li>编译器在编译好代码的时候，运行该程序，该程序在调用操作系统的相关<code>API</code>的时候就会到约定好的地址对这个<code>API</code>进行间接的反问。</li><li>而操作系统与应用程序约定好填入<code>API</code>的位置被称为<strong>Import Address Table简称IAT</strong>，调用<code>API</code>的地址是不固定的。</li></ul></li><li><p>导入表需要记录俩个东西<code>函数对应的动态库</code>、<code>动态库中的具体函数</code>（这两者的关系就相当于学生和班级这一数据关系，<code>一个动态库对应多个班级</code>）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DIRECTORY_ENTRY_IMPORT; <span class="comment">//导入表</span></span><br><span class="line">IMAGE_IMPORY_DESCRIPTOR;  <span class="comment">//导入表子结构</span></span><br><span class="line">IMAGE_THUNK_DATA;    <span class="comment">//导入表子结构</span></span><br><span class="line">IMAGE_IMPORT_BY_NAME; <span class="comment">// 导入表子结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入表中其实最先是IMAGE_IMPORY_DESCRIPTOR这个结构</span></span><br><span class="line"><span class="comment">// 存放动态库的信息,也就相当于学生与班级这一数据关系中的班级信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// 不太重要RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 不太重要0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// 不太重要-1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">// 不太重要in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// 不太重要O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// 不太重要-1 if no forwarders</span></span><br><span class="line">    DWORD   Name;<span class="comment">// 重要:动态库的名称</span></span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// 重要:存放地址 RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><ul><li>在编译时，操作系统装载库函数的过程：<ul><li>首先遍历动态库信息，获得目标的库函数信息</li><li>然后读取函数信息表，将目标函数填入对应<code>IAT</code>结构体的中</li></ul></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703212813870.png" alt="image-20250703212813870"></p><ul><li>使用<code>xdbg</code>查看内存</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703213544177.png" alt="image-20250703213544177"></p><ul><li>通过<code>表的内存偏移</code>找到真实导入表</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703214019750.png" alt="image-20250703214019750"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703214044597.png" alt="image-20250703214044597"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703214109670.png" alt="image-20250703214109670"></p><ul><li>以下面张图片来将一下具体的过程：<ul><li>首先遍历第一个动态库的信息，先会找到库名称(图中阴影部分第一行最后<code>3A 22 00 00</code>就是存储库函数名称的地址)</li><li>接着操作系统就会<code>载入相应的库</code>，如果载入失败，就会弹出缺少<code>.dll</code>依赖</li></ul></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703221053131.png" alt="image-20250703221053131"></p><ul><li>接着会根据<code>24 22 00 00</code>找到<code>对应偏移为24 22 00 00</code>的这个地方其实是一个数组，存放着被引用函数的信息，但是这里由于我们只使用了<code>第一个库中的第一个函数</code>，所以这里的数组长度就为1。</li><li>如果多个的话，就会有很多项直到<code>00 00 00 00</code>结尾，之后<code>2c 22 00 00</code>就会定位到<code>_IMAGE_IMPORT_BY_NAME</code>结构体</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703220526477.png" alt="image-20250703220526477"></p><ul><li>之后就是这样的一个数据，该数据其实就是如下结构体<ul><li><code>WORD Hint</code>不是很重要，仅供参考</li><li><code>CHAR Name[1]</code>其实是一个可变长数组，存放的是函数的名称</li><li>这样我们就拿到了函数名称，拿到函数名就可以得到函数对应的地址，得到函数对应地址后</li></ul></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703215556833.png" alt="image-20250703215556833"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703215953330.png" alt="image-20250703215953330"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250703220229783.png" alt="image-20250703220229783"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><h4 id="导出表image_directoryt_entry_export"><a href="#导出表-IMAGE-DIRECTORYT-ENTRY-EXPORT" class="headerlink" title="导出表(IMAGE_DIRECTORYT_ENTRY_EXPORT)"></a>导出表(IMAGE_DIRECTORYT_ENTRY_EXPORT)</h4><h4 id="导入地址表import-address-table"><a href="#导入地址表-Import-Address-Table" class="headerlink" title="导入地址表(Import Address Table)"></a>导入地址表(Import Address Table)</h4><h3 id="nt_optional_hdr64"><a href="#NT-OPTIONAL-HDR64" class="headerlink" title="NT_OPTIONAL_HDR64"></a>NT_OPTIONAL_HDR64</h3><h3 id="rom_optional_hdr"><a href="#ROM-OPTIONAL-HDR" class="headerlink" title="ROM_OPTIONAL_HDR"></a>ROM_OPTIONAL_HDR</h3><h2 id="段头"><a href="#段头" class="headerlink" title="段头"></a>段头</h2><ul><li><code>PE</code>文件头的这个位置其实就是段头的位置，先来看一下每个段头的结构</li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702204723216.png" alt="image-20250702204723216"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要确定段头,需要先找数据目录</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">// 0x00段名如:.text 、.rdata、.data、.rsrc、.reloc,类似于注释,描述该节是做什么的(段名称可以重复,也可以乱写)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">DWORD PhysicalAddress;<span class="comment">// 仅用于某些平台，现在常使用 VirtualSize</span></span><br><span class="line">DWORD VirtualSize;<span class="comment">// 0x08 节的实际大小(而不是节头的大小)</span></span><br><span class="line"> &#125; Misc;</span><br><span class="line">DWORD VirtualAddress;<span class="comment">// 0xC 相对虚拟地址</span></span><br><span class="line">DWORD SizeOfRawData;<span class="comment">// 0x10 需要载入内存的数据总大小,文件描述与NT可选头中FileAlignment对应</span></span><br><span class="line">DWORD PointerToRawData;<span class="comment">// 0x14 节数据在文件中的偏移地址 </span></span><br><span class="line">DWORD PointerToRelocations;<span class="comment">// 0x18 重定位的信息 (为兼容其他系统所做)</span></span><br><span class="line">DWORD PointerToLinenumber;<span class="comment">// 0x1c 行信息(为兼容其他系统所做)</span></span><br><span class="line">WORD NumberOfRelocations;<span class="comment">// 0x20 重定位总数(为兼容其他系统所做)</span></span><br><span class="line">WORD NumberOfLinenumbers;<span class="comment">// 0x24 行总数(为兼容其他系统所做)</span></span><br><span class="line">DWORD Characteristics;<span class="comment">// 0x28 内存属性,可读、可写、可执行、可共享是位描述W、R、E、S</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><ul><li>使用<code>.text</code>段来分析一下这个结构体，结合着下面内存映射的来解读一下<code>.text</code>段载入内存<ul><li>首先是名为<code>.text</code>段的一个段，会从文件偏移<code>0x400</code>的位置将数据载入到内存<code>相对地址为0x1000</code>的位置，载入实际有效的数据为<code>0x27</code>个字节(实际上载入总数是0x200字节即<code>SizeOfRawData</code>的大小)</li><li>并且内存要满足与<code>NT可选头中的SectionAlignment对齐</code></li><li>而<code>VirtualSize</code>这里面的数据是半说明性质的（可以适当修改）</li><li>然后给该内存段<code>可执行、可读</code>的权限</li></ul></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702205544398.png" alt="image-20250702205544398"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702212827539.png" alt="image-20250702212827539"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250702210926335.png" alt="image-20250702210926335"></p><h3 id="virtualaddress"><a href="#VirtualAddress" class="headerlink" title="VirtualAddress"></a>VirtualAddress</h3><ul><li>存储着是文件中的<code>各个Section段</code>载入到内存后的起始偏移地址。所以在内存中的地址应该是这样计算。并且文件载入到内存中每一段的大小需要与<strong>NT可选头的</strong><code>SectionAlignment</code>里面的值对齐</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">绝对地址 = VirtualAddress + Image_Base(但是Image_Base不可信这里需要注意)</span><br></pre></td></tr></table></figure><h3 id="characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">R 可读   </span><br><span class="line">W 可写 </span><br><span class="line">E 可执行</span><br><span class="line">S 可共享</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_DISCARDABLE            0x02000000  <span class="comment">// Section can be discarded.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_NOT_CACHED             0x04000000  <span class="comment">// Section is not cachable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_NOT_PAGED              0x08000000  <span class="comment">// Section is not pageable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_SHARED                 0x10000000  <span class="comment">// Section is shareable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_EXECUTE                0x20000000  <span class="comment">// Section is executable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_READ                   0x40000000  <span class="comment">// Section is readable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_WRITE                  0x80000000  <span class="comment">// Section is writeable.</span></span></span><br><span class="line"><span class="comment">// 可读可写可执行不可共享其实就是将这些位坐或运算 0x20000000 | 0x40000000 | 0x80000000</span></span><br><span class="line"><span class="comment">// Characteristics字段可以改，但是需要适当的改</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//下面的是 Characteristic的其他宏定义,了解即可</span></span><br><span class="line"><span class="comment">// Section characteristics.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_TYPE_NO_PAD                0x00000008  <span class="comment">// Reserved.</span></span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_CNT_CODE                   0x00000020  <span class="comment">// Section contains code.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  <span class="comment">// Section contains initialized data.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  <span class="comment">// Section contains uninitialized data.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_OTHER                  0x00000100  <span class="comment">// Reserved.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_INFO                   0x00000200  <span class="comment">// Section contains comments or some other type of information.</span></span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_REMOVE                 0x00000800  <span class="comment">// Section contents will not become part of image.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_COMDAT                 0x00001000  <span class="comment">// Section contents comdat.</span></span></span><br><span class="line"><span class="comment">//                                           0x00002000  // Reserved.</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  <span class="comment">// Reset speculative exceptions handling bits in the TLB entries for this section.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_GPREL                      0x00008000  <span class="comment">// Section content can be accessed relative to GP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_FARDATA                0x00008000</span></span><br><span class="line"><span class="comment">//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_PURGEABLE              0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_16BIT                  0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_LOCKED                 0x00040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_PRELOAD                0x00080000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_1BYTES               0x00100000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_2BYTES               0x00200000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_4BYTES               0x00300000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_8BYTES               0x00400000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_16BYTES              0x00500000  <span class="comment">// Default alignment if no others are specified.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_32BYTES              0x00600000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_64BYTES              0x00700000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_128BYTES             0x00800000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_256BYTES             0x00900000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_512BYTES             0x00A00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_1024BYTES            0x00B00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_2048BYTES            0x00C00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_4096BYTES            0x00D00000  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_8192BYTES            0x00E00000  <span class="comment">//</span></span></span><br><span class="line"><span class="comment">// Unused                                    0x00F00000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_MASK                 0x00F00000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  <span class="comment">// Section contains extended relocations.</span></span></span><br></pre></td></tr></table></figure><h2 id="无效数据"><a href="#无效数据" class="headerlink" title="无效数据"></a>无效数据</h2><ul><li>无效数据是为了对齐，所以在<code>PE</code>文件头写完了<code>DOS头</code>、<code>NT头</code>和<code>段头</code>之后如果程序偏移还没有到<code>0x400</code>，此时就需要使用无效数据<code>\x00</code>进行偏移操作。</li><li>之后从<code>0x400</code>开始其实就是存放着<code>段数据</code></li></ul><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701210829931.png" alt="image-20250701210829931"></p><h2 id="段数据"><a href="#段数据" class="headerlink" title="段数据"></a>段数据</h2><h2 id="附加数据"><a href="#附加数据" class="headerlink" title="附加数据"></a>附加数据</h2><h2 id="vs2022查看pe结构体"><a href="#VS2022查看PE结构体" class="headerlink" title="VS2022查看PE结构体"></a>VS2022查看PE结构体</h2><ul><li>新建一个项目，编写如下代码，鼠标选中<code>IMAGE_DOS_HEADER</code>就可以跳转到对应结构体的定义中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">IMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701183153887.png" alt="image-20250701183153887"></p><p><img src="/2025/08/08/CTFblog/REVERSE%E7%B3%BB%E5%88%97blog/Windows%E9%80%86%E5%90%91/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20250701183329984.png" alt="image-20250701183329984"></p><h1 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h1><h1 id="玩转导入表"><a href="#玩转导入表" class="headerlink" title="玩转导入表"></a>玩转导入表</h1><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><ol><li>尝试自己编写一个小程序，试着修改一些无关值，查看程序能不能正常执行。</li><li>尝试编写一个像<code>CFF</code>这样的界面，可以读取查看<code>PE</code>文件头结构，还可以<code>修改</code>。</li><li>尝试修改<code>DOS</code>那边的<code>stub</code>部分，使得某个简单的程序能在<code>DOS</code>环境下也能实现功能。</li><li>尝试添加一个节头，该节用于注入操作(添加节头即可，注入的代码后面再说)<strong>三步走</strong><ul><li>第一步添加新节描述</li><li>第二步添加新节数据</li><li>修改NT可选头中的<code>SizeOfImage</code>、修改节表总数即修改NT头中的<code>NumberOfSections</code>的个数</li></ul></li><li>添加一个没有文件映射的节头即未初始化数据，对应高级语言中的未初始化的全局变量，以及汇编中的<code>.data?</code></li><li>添加一个变形的未初始化区，即在文件中的数据<code>小于等于0x200</code>，但是映射到内存映射<code>0x2000</code>字节大小</li><li>写一个类似<code>CFF</code>中能自动计算文件偏移，并且可以自动定位数据的程序，可以作为<code>2.</code>程序中的功能</li><li>尝试修改导入表，进行<code>.dll</code>hook操作</li></ol>]]></content>
    
    
    <summary type="html">前言：大三有逆向课，现在也学点吧</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="REVERSE" scheme="http://iyheart.github.io/categories/CTF/REVERSE/"/>
    
    
  </entry>
  
  <entry>
    <title>数论基础-原根与指标</title>
    <link href="http://iyheart.github.io/2025/08/05/%E6%95%B0%E5%AD%A6blog/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E5%8E%9F%E6%A0%B9%E4%B8%8E%E6%8C%87%E6%A0%87/"/>
    <id>http://iyheart.github.io/2025/08/05/%E6%95%B0%E5%AD%A6blog/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E5%8E%9F%E6%A0%B9%E4%B8%8E%E6%8C%87%E6%A0%87/</id>
    <published>2025-08-05T15:54:31.000Z</published>
    <updated>2025-08-21T07:35:12.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指数及其基本性质"><a href="#指数及其基本性质" class="headerlink" title="指数及其基本性质"></a>指数及其基本性质</h1><blockquote><p><strong>定义1</strong>：</p><p>若$m&gt;1,(a,m)=1$，则使得同余式$a^{\gamma}\equiv1~mod(~m)$，成立的最小正整数$\gamma$叫做a对模m的<strong>指数</strong>。若a对模m的指数等于$\phi(m)$，则a叫做模m的一个<strong>原根</strong></p><p>注意1：指数总是存在的，但原根可能不存在。因为由欧拉定理$\forall a\in Z,(a,m)=1$，有$a^{\phi(m)}\equiv 1~(mod~m)$，总是能找到一个数，但这个数不一定是原根，但一定是原根的整数倍</p><p>注意2：原根是底数对模数的概念，满足条件的最小正整数才叫指数，而不是放在头上的都叫指数。</p><p><strong>定理1</strong>：</p><p>若a对模m的指数是$\delta$，则$1=a^{0},a^{1},…,a^{\delta-1}$对模m两两不同余。</p><p><strong>定理2</strong>：</p><p>若a对模m的指数为$\delta$，则$a^{\gamma}\equiv a^{\gamma’}~(mod~m)$的充分必要条件是$r\equiv r’~(mod~\delta)$，特别地，当$a^{\delta}\equiv1~(mod~m)$的充分必要条件是$\delta\mid r$</p><p><strong>推论1</strong>：</p><p>若a对模m的指数是$\delta$，则$\delta \mid\phi(m)$</p><p><strong>推论2</strong>：</p><p>设$0&lt;a&lt;b,(a,b)=1,b=2^{\alpha}5^{\beta}b_1,(b_1,10)=1,b_1\not\equiv1$，若将有理数$\frac{a}{b}$化成循环小数，则此循环小数的循环节的长度$\delta \mid \phi(b_1)$</p><p><strong>定理3</strong>:</p><p>若x对模m的指数是ab，$a&gt;0,b&gt;0$，则$x^{a}$对模m的指数是b</p><p><strong>定理4</strong>：</p><p>若x对模m的指数是a，y对模m的指数是b，并且$(a,b)=1$，则xy对模m的指数是ab。</p></blockquote><h1 id="原根存在的条件"><a href="#原根存在的条件" class="headerlink" title="原根存在的条件"></a>原根存在的条件</h1><blockquote><p><strong>命题1</strong>：</p><p>设$a,m&gt;1$都是整数，$a=mq+r$，则a对模m的指数等于对模m的指数</p><p><strong>推论1</strong>：</p><p>若$a\equiv b(~mod~m)$，则a对模m的指数等于b对模m的指数</p><p><strong>推论2</strong>：</p><p>设$a,m&gt;1$都是整数，$a=mq+r$，则a是模m的原根当前仅当r是模m的原根。</p><p><strong>定理1</strong>：</p><p>若p是奇素数，则模p的原根是存在的</p><p><strong>定理2</strong>：</p><p>设g是模p的一个原根，则存在一个整数$t_0$，使得由等式$(g+pt_0)^{p-1}=1+pu_0$所确定的$u_0$不能被p整除，并且对应于这个$t_0$的$g+pt_0$就是模$p^{\alpha}$的原根，其中$\alpha$是大于1的任何整数，即对任意正整数$\alpha$来说，模$p^{\alpha}$的原根存在。</p></blockquote><h1 id="指标及n次剩余"><a href="#指标及n次剩余" class="headerlink" title="指标及n次剩余"></a>指标及n次剩余</h1><h1 id="模2alpha及合模数的指标组"><a href="#模-2-alpha-及合模数的指标组" class="headerlink" title="模$2^{\alpha}$及合模数的指标组"></a>模$2^{\alpha}$及合模数的指标组</h1><h1 id="特征函数"><a href="#特征函数" class="headerlink" title="特征函数"></a>特征函数</h1>]]></content>
    
    
    <summary type="html">前言：终于学完二次同余式了</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>IO利用之stdin任意写</title>
    <link href="http://iyheart.github.io/2025/07/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdin%E4%BB%BB%E6%84%8F%E5%86%99/"/>
    <id>http://iyheart.github.io/2025/07/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdin%E4%BB%BB%E6%84%8F%E5%86%99/</id>
    <published>2025-07-23T16:45:04.000Z</published>
    <updated>2025-07-23T16:57:16.405Z</updated>
    
    <content type="html"><![CDATA[<ul><li>虽然得了严重的感冒，好在差不多把<code>stdout</code>任意读学会了。没学新东西</li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1>]]></content>
    
    
    <summary type="html">前言：得了有点严重的感冒，这俩天摆了QAQ</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
</feed>
